require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 */
/*jshint unused:false */
module.exports = function naturalSort (a, b) {
	"use strict";
	var re = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,
		sre = /(^[ ]*|[ ]*$)/g,
		dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
		hre = /^0x[0-9a-f]+$/i,
		ore = /^0/,
		i = function(s) { return naturalSort.insensitive && ('' + s).toLowerCase() || '' + s; },
		// convert all to strings strip whitespace
		x = i(a).replace(sre, '') || '',
		y = i(b).replace(sre, '') || '',
		// chunk/tokenize
		xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
		yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
		// numeric, hex or date detection
		xD = parseInt(x.match(hre), 16) || (xN.length !== 1 && x.match(dre) && Date.parse(x)),
		yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null,
		oFxNcL, oFyNcL;
	// first try and sort Hex codes or Dates
	if (yD) {
		if ( xD < yD ) { return -1; }
		else if ( xD > yD ) { return 1; }
	}
	// natural sorting through split numeric strings and default strings
	for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
		// find floats not starting with '0', string or 0 if not defined (Clint Priest)
		oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
		oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
		// handle numeric vs string comparison - number < string - (Kyle Adams)
		if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
		// rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
		else if (typeof oFxNcL !== typeof oFyNcL) {
			oFxNcL += '';
			oFyNcL += '';
		}
		if (oFxNcL < oFyNcL) { return -1; }
		if (oFxNcL > oFyNcL) { return 1; }
	}
	return 0;
};

},{}],2:[function(require,module,exports){
/**
 * @license
 * Copyright(c) 2012-2014 National ICT Australia Limited (NICTA).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
module.exports = undefined;


},{}],3:[function(require,module,exports){
"use strict";

/*global require*/

var defined = require('../../third_party/cesium/Source/Core/defined');

var KnockoutSanitizedHtmlBinding = {
    register : function(knockout) {
        knockout.bindingHandlers.sanitizedHtml= {
            'init': function() {
                // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
                return { 'controlsDescendantBindings': true };
            },
            'update': function (element, valueAccessor) {
                knockout.utils.setHtml(element, sanitize(knockout.unwrap(valueAccessor())));
            }
        };
    }
};

// TODO: use a proper HTML sanitizer instead of this hackery.
function sanitize(html) {
    // Escape HTML
    var div = document.createElement('div');
    
    if (defined(div.textContent)) {
        div.textContent = html;
    } else {
        div.innerText = html;
    }

    // Replace Markdown style links (such as: [Link Text](http://link.url.com) ) with actual links.
    var escaped = div.innerHTML;
    var fixedLinks = escaped.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, function(match, name, href) {
        return '<a href="' + href + '" target="_blank">' + name + '</a>';
    });

    // Replace '<br/>' with actual an <br/> tag.
    return fixedLinks.replace(/&lt;br\/&gt;/g, '<br/>');
}

module.exports = KnockoutSanitizedHtmlBinding;
},{"../../third_party/cesium/Source/Core/defined":245}],4:[function(require,module,exports){
'use strict';

var defined = require('../../third_party/cesium/Source/Core/defined');

function arraysAreEqual(left, right) {
    if (left === right) {
        return true;
    }

    if (!defined(left) || !defined(right) || left.length !== right.length) {
        return false;
    }

    for (var i = 0; i < left.length; ++i) {
        if (left[i] !== right[i]) {
            return false;
        }
    }

    return true;
}

module.exports = arraysAreEqual;

},{"../../third_party/cesium/Source/Core/defined":245}],5:[function(require,module,exports){
"use strict";

/*global require,URI*/

var defined = require('../../third_party/cesium/Source/Core/defined');

var corsProxy = {
    getURL : function(resource, proxyFlag) {
        var flag = (proxyFlag === undefined) ? '' : '_' + proxyFlag + '/';
        return '/proxy/' + flag + resource;
    },
    proxyDomains : [],
    corsDomains : [],
    alwaysUseProxy : false
};

corsProxy.shouldUseProxy = function(url) {
    var uri = new URI(url);
    var host = uri.host();
    var proxyAvail = proxyAllowedHost(host, corsProxy.proxyDomains);
    var corsAvail = !corsProxy.alwaysUseProxy && proxyAllowedHost(host, corsProxy.corsDomains);

    if (proxyAvail && !corsAvail) {
//        console.log('PROXY:', host);
        return true;
    }
//    console.log('CORS:', host);
    return false;
};

//Non CORS hosts we proxy to
function proxyAllowedHost(host, domains) {
    if (!defined(domains)) {
        return false;
    }

    host = host.toLowerCase();
    //check that host is from one of these domains
    for (var i = 0; i < domains.length; i++) {
        if (host.indexOf(domains[i], host.length - domains[i].length) !== -1) {
            return true;
        }
    }
    return false;
}

module.exports = corsProxy;

},{"../../third_party/cesium/Source/Core/defined":245}],6:[function(require,module,exports){
'use strict';

var createFragmentFromTemplate = function(htmlString) {
    var holder = document.createElement('div');
    holder.innerHTML = htmlString;

    var fragment = document.createDocumentFragment();
    while (holder.firstChild) {
        fragment.appendChild(holder.firstChild);
    }

    return fragment;
};

module.exports = createFragmentFromTemplate;

},{}],7:[function(require,module,exports){
'use strict';

var inherit = function(base, derived) {
    function F() {}
    F.prototype = base.prototype;
    derived.prototype = new F();
    derived.prototype.constructor = derived;
};

module.exports = inherit;
},{}],8:[function(require,module,exports){
'use strict';

/*global require*/
var getElement = require('../../third_party/cesium/Source/Widgets/getElement');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var createFragmentFromTemplate = require('./createFragmentFromTemplate');

var loadView = function(htmlString, container, viewModel) {
    container = getElement(container);

    var fragment = createFragmentFromTemplate(htmlString);

    // Sadly, fragment.childNodes doesn't have a slice function.
    // This code could be replaced with Array.prototype.slice.call(fragment.childNodes)
    // but that seems slightly error prone.
    var nodes = [];

    var i;
    for (i = 0; i < fragment.childNodes.length; ++i) {
        nodes.push(fragment.childNodes[i]);
    }

    container.appendChild(fragment);

    for (i = 0; i < nodes.length; ++i) {
        var node = nodes[i];
        if (node.nodeType === 1 || node.nodeType === 8) {
            knockout.applyBindings(viewModel, node);
        }
    }

    return nodes;
};

module.exports = loadView;

},{"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/Widgets/getElement":628,"./createFragmentFromTemplate":6}],9:[function(require,module,exports){
"use strict";

/*global require*/
var readText = require('./readText');

var when = require('../../third_party/cesium/Source/ThirdParty/when');

function readJson(file) {
    return when(readText(file), function(result) {
        return JSON.parse(result);
    }, function(e) {
        throw e;
    });
}

module.exports = readJson;

},{"../../third_party/cesium/Source/ThirdParty/when":596,"./readText":10}],10:[function(require,module,exports){
"use strict";

/*global require*/
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

function readText(file) {
    if (typeof file === 'undefined') {
        throw new DeveloperError('file is required');
    }

    var reader = new FileReader();
    reader.readAsText(file);
    var deferred = when.defer();
    reader.onload = function (event) {
        var allText = event.target.result;
        deferred.resolve(allText);
    };
    reader.onerror = function (e) {
        deferred.reject(e);
    };
    return deferred.promise;
}

module.exports = readText;
},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/ThirdParty/when":596}],11:[function(require,module,exports){
"use strict";

/*global require*/
var readText = require('./readText');

var when = require('../../third_party/cesium/Source/ThirdParty/when');

var parser = new DOMParser();

function readXml(file) {
    return when(readText(file), function(result) {
        return parser.parseFromString(result, 'application/xml');
    }, function(e) {
        throw e;
    });
}

module.exports = readXml;

},{"../../third_party/cesium/Source/ThirdParty/when":596,"./readText":10}],12:[function(require,module,exports){
'use strict';

/*global require*/
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var SvgPathBindingHandler = require('../../third_party/cesium/Source/Widgets/SvgPathBindingHandler');

var KnockoutSanitizedHtmlBinding = require('./KnockoutSanitizedHtmlBinding');

var registerKnockoutBindings = function() {
    SvgPathBindingHandler.register(knockout);
    KnockoutSanitizedHtmlBinding.register(knockout);

    knockout.bindingHandlers.embeddedComponent = {
        init : function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var component = knockout.unwrap(valueAccessor());
            component.show(element);
            return { controlsDescendantBindings: true };
        },
        update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        }
    };
};

module.exports = registerKnockoutBindings;

},{"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/Widgets/SvgPathBindingHandler":621,"./KnockoutSanitizedHtmlBinding":3}],13:[function(require,module,exports){
'use strict';

/*global require*/

var when = require('../../third_party/cesium/Source/ThirdParty/when');

var runLater = function(functionToRunLater) {
    var deferred = when.defer();
    setTimeout(function() {
        try {
            deferred.resolve(functionToRunLater());
        } catch (e) {
            deferred.reject(e);
        }
    }, 0);
    return deferred.promise;
};

module.exports = runLater;

},{"../../third_party/cesium/Source/ThirdParty/when":596}],14:[function(require,module,exports){
/*global require,$,alert*/
"use strict";

var VarType = require('./VarType');
var Variable = require('./Variable');

var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var destroyObject = require('../../third_party/cesium/Source/Core/destroyObject');
var loadText = require('../../third_party/cesium/Source/Core/loadText');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');

/*!
 * Copyright(c) 2012-2013 National ICT Australia Limited (NICTA).  All rights reserved.
 */
 
/**
* Dataset is a container for table based datasets
*
* @alias Dataset
* @internalConstructor
* @constructor
*/
var Dataset = function() {
    this.noData = 1e-34;
    this.rowCount = 0;
    this.dataShape = undefined;
    this.varTypeSet = [];
    this.variables = undefined;
    this.loadingData = false;
};

Dataset.prototype.hasLocationData = function () {
    return (this.varTypeSet[VarType.LON] && this.varTypeSet[VarType.LAT]);
};

Dataset.prototype.hasTimeData = function () {
    return (this.varTypeSet[VarType.TIME]);
};

Dataset.prototype.getVarID = function (type) {
    return (this.varTypeSet[type]);
};

/**
* Return the geographic extent of the dataset
*
* @returns {Object} The extent of the data points
*/
Dataset.prototype.getExtent = function () {
    var minPos = [0, 0, 0];
    var maxPos = [0, 0, 0];
    var type = [VarType.LON, VarType.LAT, VarType.ALT];
    for (var p in type) {
        if (this.varTypeSet[type[p]]) {
            minPos[p] = this.variables[this.varTypeSet[type[p]]].minVal;
            maxPos[p] = this.variables[this.varTypeSet[type[p]]].maxVal;
        }
    }
    return Rectangle.fromDegrees(minPos[0], minPos[1], maxPos[0], maxPos[1]);
};

/**
* Return the minimum value
*
* @returns {Float} The minimum data value
*/
Dataset.prototype.getMinVal = function () {
    if (this.variables && this.varTypeSet[VarType.SCALAR]) {
        return this.variables[this.varTypeSet[VarType.SCALAR]].minVal;
    }
};

/**
* Return the maximum value
*
* @returns {Float} The maximum data value
*/
Dataset.prototype.getMaxVal = function () {
    if (this.variables && this.varTypeSet[VarType.SCALAR]) {
        return this.variables[this.varTypeSet[VarType.SCALAR]].maxVal;
    }
};

/**
* Return the minimum time
*
* @returns {Object} The minimum time value in Cesium JulianTime
*/
Dataset.prototype.getMinTime = function () {
    if (this.variables && this.varTypeSet[VarType.TIME]) {
        return this.variables[this.varTypeSet[VarType.TIME]].timeVar.minVal;
    }
};

/**
* Return the maximum time
*
* @returns {Object} The maximum time value in Cesium JulianTime
*/
Dataset.prototype.getMaxTime = function () {
    if (this.variables && this.varTypeSet[VarType.TIME]) {
        return this.variables[this.varTypeSet[VarType.TIME]].timeVar.maxVal;
    }
};


/**
* Get a list of available scalar and enum type variables
*
* @returns {Array} An array of variables
*/
Dataset.prototype.getVarList = function () {
    var ret = [];
    for (var v in this.variables) {
        if (this.variables[v].varType === VarType.SCALAR || this.variables[v].varType === VarType.ENUM) {
            ret.push(v);
        }
    }
    return ret;
};

// Determine the min, max, and type of each variable
Dataset.prototype._processVariables = function () {
    this.varTypeSet = [];

    for (var id in this.variables) {
        if (this.variables.hasOwnProperty(id)) {
            var variable = this.variables[id];
            //guess var type if not set
            if (variable.varType === undefined) {
                variable.guessVarType(id);
            }
            if (variable.varType === VarType.TIME) {
                variable.processTimeVar();            //calculate time variables
                //if failed then default type to scalar
                if (variable.timeVar === undefined) {
                    variable.varType = VarType.SCALAR;
                }
            }
            if (variable.varType !== VarType.TIME) {
                variable._calculateVarMinMax();            //calculate var min/max
            }
            //deal with enumerated variables
            if (variable.varType === VarType.SCALAR && variable.minVal > variable.maxVal) {
                variable.varType = VarType.ENUM;
                variable.processEnumVar();            //calculate enum variables
            }

            //set the varIDs
            for (var vt in VarType) {
                if (VarType.hasOwnProperty(vt)) {
                    if (this.varTypeSet[VarType[vt]] === undefined && variable.varType === VarType[vt]) {
                        this.varTypeSet[VarType[vt]] = id;
                    }
                }
            }
        }
    }

    //set variable if preset
    if (this.varName && this.varName.length && this.variables[this.varName]) {
        this.varTypeSet[VarType.SCALAR] = this.varName;
    }

    if (this.varTypeSet[VarType.SCALAR] === undefined) {
        this.varTypeSet[VarType.SCALAR] = this.varTypeSet[VarType.ENUM];
    }
    //set point count
    this.rowCount = this.variables[this.varTypeSet[VarType.SCALAR]].vals.length;

    //save the shape information
    if (this.dataShape === undefined) {
        this.dataShape = [this.rowCount];
    }
};


/**
* Load a JSON object into a dataset
*
* @param {Object} jsonTable Table data in JSON format.
*/
Dataset.prototype.loadJson = function (jsonTable) {

    this.dataShape = undefined;

    //create the variable set
    this.variables = {};
    var columnNames = jsonTable[0];
    for (var c = 0; c < columnNames.length; c++) {
        var name = columnNames[c];
        var variable = new Variable();
        for (var i = 1; i < jsonTable.length; ++i) {
            variable.vals.push(jsonTable[i][c]);
        }
        this.variables[name] = variable;
    }

    //calculate variable type and min/max vals
    this._processVariables();

    if (this.varName) {
        this.setCurrentVariable({ variable: this.varName });
    }

    console.log(this);

    this.loadingData = false;
};

/**
* Load text into a dataset
*
* @param {String} text Text to load as dataset
*
*/
Dataset.prototype.loadText = function (text) {
        //normalize line breaks
    text = text.replace(/\r\n|\r|\n/g, "\r\n");
    var jsonTable = $.csv.toArrays(text, {
            onParseValue: $.csv.hooks.castToScalar
        });
    this.loadJson(jsonTable);
};

/**
* Load a dataset
*
* @param {Object} description Object with the following properties:
* @param {String} [description.url] The url of the dataset
* @param {String} [description.variable] The initial variable to show
*
*/
Dataset.prototype.loadUrl = function (description) {
    description = defaultValue(description, {});

    this.dataUrl = defaultValue(description.url, this.dataUrl);
    this.varName = defaultValue(description.variable, '');

    if (!this.dataUrl) {
        return;
    }

    console.log('loading: ' + this.dataUrl);

    this.loadingData = true;
    var that = this;
    
    return loadText(this.dataUrl).then( function (text) { 
        that.loadText(text); 
    }, 
    function(err) { 
        alert('HTTP Error ' + err.statusCode + ' - ' + err.response);
    });
};

/**
* Set the current variable
*
* @param {Object} description Object with the following properties:
* @param {String} [description.variable] The initial variable to show
*
*/
Dataset.prototype.setCurrentVariable = function (description) {
    if (!this.variables[description.variable] || 
        this.variables[description.variable].vals.length === 0) {
        return;
    }
    this.varName = description.variable;
    if (this.varName.length && this.variables[this.varName]) {
        this.varTypeSet[VarType.SCALAR] = this.varName;
    }
};

function _float_equals(a, b) { return (Math.abs((a - b) / b) < 0.00001); }

/**
* Get the current variable name
*
* @returns {Object} the current variable name
*
*/
Dataset.prototype.getCurrentVariable = function () {
    return this.varTypeSet[VarType.SCALAR];
};

/**
* Get the current variable
*
* @returns {Object} the current variable
*
*/
Dataset.prototype.getVariable = function (varName) {
    return this.variables[varName];
};

/**
* Add a variable to a dataset
*
* @returns {Object} the current variable
*
*/
Dataset.prototype.addVariable = function (varName, variable) {
    this.variables[varName] = variable;
    if (variable.minVal === undefined || variable.maxVal === undefined) {
        this.variables[varName]._calculateVarMinMax();
    }
};


/**
* Remove a variable from the dataset
*
* @returns {Object} the current variable
*
*/
Dataset.prototype.removeVariable = function (varName) {
    if (this.variables[varName] !== undefined) {
        delete this.variables[varName];
    }
};

/**
* Get a data value
*
* @param {String} Variable name
* @param {Integer} Index in variable values
*
* @returns {Float} Value for the variable at that index
*/
Dataset.prototype.getDataValue = function (varName, idx) {
    var variable = this.variables[varName];
    if (variable === undefined || variable.vals === undefined) {
        return undefined;
    }
    if (variable.varType === VarType.ENUM) {
        return variable.enumList[variable.vals[idx]];
    }
    else if (variable.varType === VarType.TIME) {
        return variable.timeVar.vals[idx];
    }
     return variable.vals[idx];
};

/**
* Get a data row
*
* @param {Integer} Index of row
*
* @returns {Object} Object containing all row members
*/
Dataset.prototype.getDataRow = function (idx) {
    var rowObj = {};
    if (idx !== undefined) {
        for (var id in this.variables) {
            if (this.variables.hasOwnProperty(id)) {
                rowObj[id] = this.getDataValue(id, idx);
            }
        }
    }
    return rowObj;
};

/**
* Get all of the data values
*
* @param {String} Variable name
*
* @returns {Array} Array of values for the variable
*/
Dataset.prototype.getDataValues = function (varName) {
    if (this.variables[varName] === undefined || this.variables[varName].vals === undefined) {
        return undefined;
    }
    return this.variables[varName].vals;
};


/**
* Return a boolean as to whether this is a nodata item
*
* @param {Float} ptVal The value to check
*
* @returns {Boolean} True if this is NoData
*/
Dataset.prototype.isNoData = function (ptVal) {
    return _float_equals(this.noData, ptVal);
};

/**
* Get a set of data points and positions for the current variable
*
* @param {Integer} maxPts The maximum number of points to return
*
*/
Dataset.prototype.getPointList = function (maxPts) {

    var lon = this.varTypeSet[VarType.LON] ? this.variables[this.varTypeSet[VarType.LON]].vals : undefined;
    var lat = this.varTypeSet[VarType.LAT] ? this.variables[this.varTypeSet[VarType.LAT]].vals : undefined;
    var alt = this.varTypeSet[VarType.ALT] ? this.variables[this.varTypeSet[VarType.ALT]].vals : undefined;
    var vals = this.variables[this.varTypeSet[VarType.SCALAR]].vals;
    var time = this.varTypeSet[VarType.TIME] ? this.variables[this.varTypeSet[VarType.TIME]].timeVar.vals : undefined;
    if (maxPts === undefined) {
        maxPts = vals.length;
    }

    var ret = [];
    for (var i = 0; i < vals.length && i < maxPts; i++) {
        var rec = {val: vals[i]};
        rec.time =  time ? time[i] : undefined;
        rec.pos = [lon ? lon[i] : 0.0, lat ? lat[i] : 0.0, alt ? alt[i] : 0.0];
        rec.row = i;
        if (this.isNoData(rec.pos[0]) || this.isNoData(rec.pos[1])) {
            continue;
        }
        ret.push(rec);
    }
    return ret;
};


/**
* Destroy the object and release resources
*
*/
Dataset.prototype.destroy = function () {
    return destroyObject(this);
};

module.exports = Dataset;


},{"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/destroyObject":247,"../../third_party/cesium/Source/Core/loadText":262,"./VarType":17,"./Variable":18}],15:[function(require,module,exports){

"use strict";

/*global require,L*/
var AssociativeArray = require('../../third_party/cesium/Source/Core/AssociativeArray');
var Cartesian2 = require('../../third_party/cesium/Source/Core/Cartesian2');
var Color = require('../../third_party/cesium/Source/Core/Color');
var defined = require('../../third_party/cesium/Source/Core/defined');
var destroyObject = require('../../third_party/cesium/Source/Core/destroyObject');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var Property = require('../../third_party/cesium/Source/DataSources/Property');
var Ellipsoid = require('../../third_party/cesium/Source/Core/Ellipsoid');
var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var writeTextToCanvas = require('../../third_party/cesium/Source/Core/writeTextToCanvas');
 

var defaultColor = Color.WHITE;
var defaultOutlineColor = Color.BLACK;
var defaultOutlineWidth = 1.0;
var defaultPixelSize = 5.0;

var defaultWidth = 5.0;
var popupHeight = 520;

//NOT IMPLEMENTED
// Path primitive - no need identified
// Ellipse primitive - no need identified
// Ellipsoid primitive - 3d prim - no plans for this
// Model primitive - 3d prim - no plans for this

/**
 * A {@link Visualizer} which maps {@link Entity#point} to Leaflet primitives.
 * @alias LeafletGeomVisualizer
 * @constructor
 *
 * @param {Scene} map The map the primitives will be rendered in.
 * @param {EntityCollection} entityCollection The entityCollection to visualize.
 */
var LeafletGeomVisualizer = function(map, entityCollection) {
    if (!defined(map)) {
        throw new DeveloperError('map is required.');
    }
    if (!defined(entityCollection)) {
        throw new DeveloperError('entityCollection is required.');
    }

    var featureGroup = L.featureGroup().addTo(map);
    entityCollection.collectionChanged.addEventListener(LeafletGeomVisualizer.prototype._onCollectionChanged, this);

    this._map = map;
    this._featureGroup = featureGroup;
    this._entityCollection = entityCollection;
    this._entitiesToVisualize = new AssociativeArray();

    this._onCollectionChanged(entityCollection, entityCollection.entities, [], []);
};


LeafletGeomVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {
    var i;
    var entity;
    var featureGroup = this._featureGroup;
    var entities = this._entitiesToVisualize;

    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        if (((defined(entity._point) || defined(entity._billboard) || defined(entity._label)) && defined(entity._position))
            || defined(entity._polyline) || defined(entity._polygon)) {
            entities.set(entity.id, entity);
        }
    }

    for (i = changed.length - 1; i > -1; i--) {
        entity = changed[i];
        if (((defined(entity._point) || defined(entity._billboard) || defined(entity._label)) && defined(entity._position))
            || defined(entity._polyline) || defined(entity._polygon)) {
            entities.set(entity.id, entity);
        } else {
            cleanEntity(entity, featureGroup);
            entities.remove(entity.id);
        }
    }

    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        cleanEntity(entity, featureGroup);
        entities.remove(entity.id);
    }
};


function cleanEntity(entity, group) {
    if (defined(entity._geomPoint)) {
        group.removeLayer(entity._geomPoint);
        entity._geomPoint = undefined;
    }
    if (defined(entity._geomBillboard)) {
        group.removeLayer(entity._geomBillboard);
        entity._geomBillboard = undefined;
    }
    if (defined(entity._geomLabel)) {
        group.removeLayer(entity._geomLabel);
        entity._geomLabel = undefined;
    }
    if (defined(entity._geomPolyline)) {
        group.removeLayer(entity._geomPolyline);
        entity._geomPolyline = undefined;
    }
    if (defined(entity._geomPolygon)) {
        group.removeLayer(entity._geomPolygon);
        entity._geomPolygon = undefined;
    }
}


/**
 * Updates the primitives created by this visualizer to match their
 * Entity counterpart at the given time.
 *
 * @param {JulianDate} time The time to update to.
 * @returns {Boolean} This function always returns true.
 */
LeafletGeomVisualizer.prototype.update = function(time) {
    //>>includeStart('debug', pragmas.debug);
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    //>>includeEnd('debug');

    var entities = this._entitiesToVisualize.values;
    for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];
        if (defined(entity._point)) {
            this._updatePoint(entity, time);
        }
        if (defined(entity._billboard)) {
            this._updateBillboard(entity, time);
        }
        if (defined(entity._label)) {
            this._updateLabel(entity, time);
        }
        if (defined(entity._polyline)) {
            this._updatePolyline(entity, time);
        }
        if (defined(entity._polygon)) {
            this._updatePolygon(entity, time);
        }
    }
    return true;
};

LeafletGeomVisualizer.prototype._updatePoint = function(entity, time) {
    var pointGraphics = entity._point;
    var featureGroup = this._featureGroup;
    var geomLayer = entity._geomPoint;
    var position, point, description;
    var show = entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);
    if (show) {
        position = Property.getValueOrUndefined(entity._position, time);
        description = Property.getValueOrUndefined(entity._description, time);
        show = defined(position);
    }
    if (!show) {
        cleanEntity(entity, featureGroup);
        return;
    }

    var cart = Ellipsoid.WGS84.cartesianToCartographic(position);
    var latlng = L.latLng( CesiumMath.toDegrees(cart.latitude), CesiumMath.toDegrees(cart.longitude) );
    var pixelSize = Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize);
    var color = Property.getValueOrDefault(pointGraphics._color, time, defaultColor);
    var outlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor);
    var outlineWidth = Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth);

    var pointOptions = {
        radius: pixelSize / 2.0,
        fillColor: color.toCssColorString(),
        fillOpacity: color.alpha,
        color: outlineColor.toCssColorString(),
        weight: outlineWidth,
        opacity: outlineColor.alpha
    };

    if (!defined(geomLayer)) {
        point = L.circleMarker(latlng, pointOptions);
        point.bindPopup(description, {maxHeight: popupHeight});
        featureGroup.addLayer(point);
        entity._geomPoint = point;
    } else {
        point = geomLayer;
        if (!point._latlng.equals(latlng)) {
            point.setLatLng(latlng);
        }
        for (var prop in pointOptions) {
            if (pointOptions[prop] !== point.options[prop]) {
                point.setStyle(pointOptions);
                break;
            }
        }
    }
};

//Recolor an image using 2d canvas
function recolorBillboard(img, color) {
    var canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;

    // Copy the image contents to the canvas
    var context = canvas.getContext("2d");
    context.drawImage(img, 0, 0);
    var image = context.getImageData(0, 0, canvas.width, canvas.height);
    var normClr = [color.red, color.green, color.blue, color.alpha];

    var length = image.data.length;  //pixel count * 4
    for (var i = 0; i < length; i += 4) {
        for (var j = 0; j < 4; j++) {
            image.data[j+i] *= normClr[j];
        }
    }
    
    context.putImageData(image, 0, 0);
    return canvas.toDataURL();
//    return context.getImageData(0, 0, canvas.width, canvas.height);
}

//Single pixel black dot
var tmpImage = "data:image/gif;base64,R0lGODlhAQABAPAAAAAAAP///yH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==";

//NYI: currently skipping all the camera distance related properties
LeafletGeomVisualizer.prototype._updateBillboard = function(entity, time) {
    var markerGraphics = entity._billboard;
    var featureGroup = this._featureGroup;
    var geomLayer = entity._geomBillboard;
    var position, marker, description;
    var show = entity.isAvailable(time) && Property.getValueOrDefault(markerGraphics._show, time, true);
    if (show) {
        position = Property.getValueOrUndefined(entity._position, time);
        description = Property.getValueOrUndefined(entity._description, time);
        show = defined(position);
    }
    if (!show) {
        cleanEntity(entity, featureGroup);
        return;
    }

    var cart = Ellipsoid.WGS84.cartesianToCartographic(position);
    var latlng = L.latLng( CesiumMath.toDegrees(cart.latitude), CesiumMath.toDegrees(cart.longitude) );
    var image = Property.getValueOrDefault(markerGraphics._image, time, undefined);
    var height = Property.getValueOrDefault(markerGraphics._height, time, undefined);
    var width = Property.getValueOrDefault(markerGraphics._width, time, undefined);
    var color = Property.getValueOrDefault(markerGraphics._color, time, defaultColor);
    var scale = Property.getValueOrDefault(markerGraphics._scale, time, 1.0);
    var verticalOrigin = Property.getValueOrDefault(markerGraphics._verticalOrigin, time, 0);
    var horizontalOrigin = Property.getValueOrDefault(markerGraphics._horizontalOrigin, time, 0);
    var pixelOffset = Property.getValueOrDefault(markerGraphics._pixelOffset, time, Cartesian2.ZERO);

    var imageUrl;
    if (defined(image)) {
        if (typeof image === 'string') {
            imageUrl = image;
        } else if (defined(image.toDataURL)) {
            imageUrl = image.toDataURL();
        } else {
            imageUrl = image.src;
        }
    }

    var iconOptions = {
        color: color.toCssColorString(),
        origUrl: imageUrl,
        scale: scale,
        horizontalOrigin: horizontalOrigin,  //value: left, center, right
        verticalOrigin: verticalOrigin      //value: bottom, center, top
    };

    if (defined(height) || defined(width)) {
        iconOptions.iconSize = [width, height];
    }

    var redrawIcon = false;
    if (!defined(geomLayer)) {
        var markerOptions = {icon: L.icon({iconUrl: tmpImage})};
        marker = L.marker(latlng, markerOptions);
        marker.bindPopup(description, {maxHeight: popupHeight});
        featureGroup.addLayer(marker);
        entity._geomBillboard = marker;
        redrawIcon = true;
    } else {
        marker = geomLayer;
        if (!marker._latlng.equals(latlng)) {
            marker.setLatLng(latlng);
        }
        for (var prop in iconOptions) {
            if (iconOptions[prop] !== marker.options.icon.options[prop]) {
                redrawIcon = true;
                break;
            }
        }
    }

    if (redrawIcon) {
        var drawBillboard = function(image, dataurl) {
            iconOptions.iconUrl = dataurl || image;
            if (!defined(iconOptions.iconSize)) {
                iconOptions.iconSize = [image.width * scale, image.height * scale];
            }
            var w = iconOptions.iconSize[0], h = iconOptions.iconSize[1];
            var xOff = (w/2)*(1-horizontalOrigin) - pixelOffset.x;
            var yOff = (h/2)*(1+verticalOrigin) - pixelOffset.y;
            iconOptions.iconAnchor = [xOff, yOff];

            if (!color.equals(defaultColor)) {
                iconOptions.iconUrl = recolorBillboard(image, color);
            }
            marker.setIcon(L.icon(iconOptions));
        };
        var img = new Image();
        img.onload = function() {
            drawBillboard(img, imageUrl);
        };
        img.src = imageUrl;
    }
};


LeafletGeomVisualizer.prototype._updateLabel = function(entity, time) {
    var labelGraphics = entity._label;
    var featureGroup = this._featureGroup;
    var geomLayer = entity._geomLabel;
    var position, marker;
    var show = entity.isAvailable(time) && Property.getValueOrDefault(labelGraphics._show, time, true);
    if (show) {
        position = Property.getValueOrUndefined(entity._position, time);
        show = defined(position);
    }
    if (!show) {
        cleanEntity(entity, featureGroup);
        return;
    }

    var cart = Ellipsoid.WGS84.cartesianToCartographic(position);
    var latlng = L.latLng( CesiumMath.toDegrees(cart.latitude), CesiumMath.toDegrees(cart.longitude) );
    var text = Property.getValueOrDefault(labelGraphics._text, time, undefined);
    var font = Property.getValueOrDefault(labelGraphics._font, time, undefined);
    var scale = Property.getValueOrDefault(labelGraphics._scale, time, 1.0);
    var fillColor = Property.getValueOrDefault(labelGraphics._fillColor, time, defaultColor);
    var verticalOrigin = Property.getValueOrDefault(labelGraphics._verticalOrigin, time, 0);
    var horizontalOrigin = Property.getValueOrDefault(labelGraphics._horizontalOrigin, time, 0);
    var pixelOffset = Property.getValueOrDefault(labelGraphics._pixelOffset, time, Cartesian2.ZERO);

    var iconOptions = {
        text: text,
        font: font,
        color: fillColor.toCssColorString(),
        scale: scale,
        horizontalOrigin: horizontalOrigin,  //value: left, center, right
        verticalOrigin: verticalOrigin      //value: bottom, center, top
    };

    var redrawLabel = false;
    if (!defined(geomLayer)) {
        var markerOptions = {icon: L.icon({iconUrl: tmpImage})};
        marker = L.marker(latlng, markerOptions);
        featureGroup.addLayer(marker);
        entity._geomLabel = marker;
        redrawLabel = true;
    } else {
        marker = geomLayer;
        if (!marker._latlng.equals(latlng)) {
            marker.setLatLng(latlng);
        }
        for (var prop in iconOptions) {
            if (iconOptions[prop] !== marker.options.icon.options[prop]) {
                redrawLabel = true;
                break;
            }
        }
    }

    if (redrawLabel) {
        var drawBillboard = function(image, dataurl) {
            iconOptions.iconUrl = dataurl || image;
            if (!defined(iconOptions.iconSize)) {
                iconOptions.iconSize = [image.width * scale, image.height * scale];
            }
            var w = iconOptions.iconSize[0], h = iconOptions.iconSize[1];
            var xOff = (w/2)*(1-horizontalOrigin) - pixelOffset.x;
            var yOff = (h/2)*(1+verticalOrigin) - pixelOffset.y;
            iconOptions.iconAnchor = [xOff, yOff];
            marker.setIcon(L.icon(iconOptions));
        };

        var canvas = writeTextToCanvas(text, {fillColor: fillColor, font: font});
        var imageUrl = canvas.toDataURL();

        var img = new Image();
        img.onload = function() {
            drawBillboard(img, imageUrl);
        };
        img.src = imageUrl;
    }
};

LeafletGeomVisualizer.prototype._updatePolyline = function(entity, time) {
    var polylineGraphics = entity._polyline;
    var featureGroup = this._featureGroup;
    var geomLayer = entity._geomPolyline;
    var positions, polyline, description;
    var show = entity.isAvailable(time) && Property.getValueOrDefault(polylineGraphics._show, time, true);
    if (show) {
        positions = Property.getValueOrUndefined(polylineGraphics._positions, time);
        description = Property.getValueOrUndefined(entity._description, time);
        show = defined(positions);
    }
    if (!show) {
        cleanEntity(entity, featureGroup);
        return;
    }

    var carts = Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
    var latlngs = [];
    for (var p = 0; p < carts.length; p++) {
        latlngs.push(L.latLng( CesiumMath.toDegrees(carts[p].latitude), CesiumMath.toDegrees(carts[p].longitude)));
    }
    var color = Property.getValueOrDefault(polylineGraphics._material.color, time, defaultColor);
    var width = Property.getValueOrDefault(polylineGraphics._width, time, defaultWidth);

    var polylineOptions = {
        color: color.toCssColorString(),
        weight: width,
        opacity: color.alpha
    };

    if (!defined(geomLayer)) {
        polyline = L.polyline(latlngs, polylineOptions);
        polyline.bindPopup(description, {maxHeight: popupHeight});
        featureGroup.addLayer(polyline);
        entity._geomPolyline = polyline;
    } else {
        polyline = geomLayer;
        var curLatLngs = polyline.getLatLngs;
        for (var i = 0; i < curLatLngs.length; i++) {
            if (!curLatLngs[i].equals(latlngs[i])) {
                polyline.setLatLngs(latlngs);
                break;
            }
        }
        for (var prop in polylineOptions) {
            if (polylineOptions[prop] !== polyline.options[prop]) {
                polyline.setStyle(polylineOptions);
                break;
            }
        }
    }
};

LeafletGeomVisualizer.prototype._updatePolygon = function(entity, time) {
    var polygonGraphics = entity._polygon;
    var featureGroup = this._featureGroup;
    var geomLayer = entity._geomPolygon;
    var positions, polygon, description;
    var show = entity.isAvailable(time) && Property.getValueOrDefault(polygonGraphics._show, time, true);
    if (show) {
        var hierarchy = Property.getValueOrUndefined(polygonGraphics._hierarchy, time);
        positions = hierarchy ? hierarchy.positions : undefined;
        description = Property.getValueOrUndefined(entity._description, time);
        show = defined(positions);
    }
    if (!show) {
        cleanEntity(entity, featureGroup);
        return;
    }

    var carts = Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
    var latlngs = [];
    for (var p = 0; p < carts.length; p++) {
        latlngs.push(L.latLng( CesiumMath.toDegrees(carts[p].latitude), CesiumMath.toDegrees(carts[p].longitude)));
    }
    var color = Property.getValueOrDefault(polygonGraphics._material.color, time, defaultColor);
    var fill = Property.getValueOrDefault(polygonGraphics._fill, time, true);
    var outline = Property.getValueOrDefault(polygonGraphics._outline, time, true);
    var outlineColor = Property.getValueOrDefault(polygonGraphics._outlineColor, time, defaultOutlineColor);

    var polygonOptions = {
        fill: fill,
        fillColor: color.toCssColorString(),
        fillOpacity: color.alpha,
        weight: outline ? 1.0 : 0.0,
        color: outlineColor.toCssColorString(),
        opacity: outlineColor.alpha
     };

    if (!defined(geomLayer)) {
        polygon = L.polygon(latlngs, polygonOptions);
        polygon.bindPopup(description, {maxHeight: popupHeight});
        featureGroup.addLayer(polygon);
        entity._geomPolygon = polygon;
    } else {
        polygon = geomLayer;
        var curLatLngs = polygon.getLatLngs;
        for (var i = 0; i < curLatLngs.length; i++) {
            if (!curLatLngs[i].equals(latlngs[i])) {
                polygon.setLatLngs(latlngs);
                break;
            }
        }
        for (var prop in polygonOptions) {
            if (polygonOptions[prop] !== polygon.options[prop]) {
                polygon.setStyle(polygonOptions);
                break;
            }
        }
    }
};

/**
 * Returns true if this object was destroyed; otherwise, false.
 *
 * @returns {Boolean} True if this object was destroyed; otherwise, false.
 */
LeafletGeomVisualizer.prototype.isDestroyed = function() {
    return false;
};

/**
 * Removes and destroys all primitives created by this instance.
 */
LeafletGeomVisualizer.prototype.destroy = function() {
    var entities = this._entitiesToVisualize.values;
    for (var i = entities.length - 1; i > -1; i--) {
        entities[i]._geomPoint = undefined;
        entities[i]._geomBillboard = undefined;
        entities[i]._geomLabel = undefined;
        entities[i]._geomPolyline = undefined;
        entities[i]._geomPolygon = undefined;
    }
    this._entityCollection.collectionChanged.removeEventListener(LeafletGeomVisualizer.prototype._onCollectionChanged, this);
    this._map.removeLayer(this._featureGroup);
    return destroyObject(this);
};

/////////////////////////////////////////////////////////

var LeafletVisualizer = function() {
};

LeafletVisualizer.prototype.visualizersCallback = function(map, dataSource) {
    var entities = dataSource.entities;
    return [new LeafletGeomVisualizer(map, entities)];
};

module.exports = LeafletVisualizer;

},{"../../third_party/cesium/Source/Core/AssociativeArray":93,"../../third_party/cesium/Source/Core/Cartesian2":101,"../../third_party/cesium/Source/Core/Color":111,"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/Ellipsoid":130,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/destroyObject":247,"../../third_party/cesium/Source/Core/writeTextToCanvas":273,"../../third_party/cesium/Source/DataSources/Property":321}],16:[function(require,module,exports){
/*global require*/
"use strict";

var Dataset = require('./Dataset');

/*
TableDataSource object for displaying geo-located datasets
For the time being it acts as a layer on top of a CzmlDataSource
And writes a czml file for it to display
*/

//TODO: DOCUMENT using model in GeoJsonDataSource

var defined = require('../../third_party/cesium/Source/Core/defined');
var CzmlDataSource = require('../../third_party/cesium/Source/DataSources/CzmlDataSource');
var Color = require('../../third_party/cesium/Source/Core/Color');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var destroyObject = require('../../third_party/cesium/Source/Core/destroyObject');
var JulianDate = require('../../third_party/cesium/Source/Core/JulianDate');
var loadText = require('../../third_party/cesium/Source/Core/loadText');

/**
* @class TableDataSource is a cesium based datasource for table based geodata
* @name TableDataSource
*
* @alias TableDataSource
* @internalConstructor
* @constructor
*/
var TableDataSource = function () {

    //Create a czmlDataSource to piggyback on
    this.czmlDataSource = new CzmlDataSource();
    this.dataset = new Dataset();
    this.show = true;

    this.color = Color.RED;

    this.leadTimeMin = 0;
    this.trailTimeMin = 60;
    this.scale = 1.0;
    this.scaleValue = false;
    this.imageUrl = "./images/circle32.png";

    var rainbowGradient = [
        {offset: 0.0, color: 'rgba(0,0,200,1.00)'},
        {offset: 0.25, color: 'rgba(0,200,200,1.0)'},
        {offset: 0.25, color: 'rgba(0,200,200,1.0)'},
        {offset: 0.5, color: 'rgba(0,200,0,1.0)'},
        {offset: 0.5, color: 'rgba(0,200,0,1.0)'},
        {offset: 0.75, color: 'rgba(200,200,0,1.0)'},
        {offset: 0.75, color: 'rgba(200,200,0,1.0)'},
        {offset: 1.0, color: 'rgba(200,0,0,1.0)'}
    ];
    this.setColorGradient(rainbowGradient);
};

defineProperties(TableDataSource.prototype, {
        /**
         * Gets a human-readable name for this instance.
         * @memberof TableDataSource.prototype
         * @type {String}
         */
        name : {
            get : function() {
                return this.czmlDataSource.name;
            }
        },
         /**
         * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly
         * defined in the CZML, the combined availability of all objects is returned.  If
         * only static data exists, this value is undefined.
         * @memberof TableDataSource.prototype
         * @type {DataSourceClock}
         */
       clock : {
            get : function() {
                return this.czmlDataSource.clock;
            }
        },
         /**
         * Gets the collection of {@link Entity} instances.
         * @memberof TableDataSource.prototype
         * @type {EntityCollection}
         */
       entities : {
            get : function() {
                return this.czmlDataSource.entities;
            }
        },
         /**
         * Gets a value indicating if the data source is currently loading data.
         * @memberof TableDataSource.prototype
         * @type {Boolean}
         */
       isLoading : {
            get : function() {
                return this.czmlDataSource.isLoading;
            }
        },
         /**
         * Gets an event that will be raised when the underlying data changes.
         * @memberof TableDataSource.prototype
         * @type {Event}
         */
       changedEvent : {
            get : function() {
                return this.czmlDataSource.changedEvent;
            }
        },
         /**
         * Gets an event that will be raised if an error is encountered during processing.
         * @memberof TableDataSource.prototype
         * @type {Event}
         */
       errorEvent : {
            get : function() {
                return this.czmlDataSource.errorEvent;
            }
        },
        /**
         * Gets an event that will be raised when the data source either starts or stops loading.
         * @memberof TableDataSource.prototype
         * @type {Event}
         */
        loadingEvent : {
            get : function() {
                return this.czmlDataSource.loadingEvent;
            }
        }
});

/**
 * Asynchronously loads the Table at the provided url, replacing any existing data.
 *
 * @param {Object} url The url to be processed.
 *
 * @returns {Promise} a promise that will resolve when the CZML is processed.
 */
TableDataSource.prototype.loadUrl = function (url) {
    var that = this;
    return loadText(url).then(function(text) {
        return that.loadText(text);
    });
};

/**
 * Asynchronously loads the Table from text, replacing any existing data.
 *
 * @param {Object} text The text to be processed.
 *
 * @returns {Promise} a promise that will resolve when the CZML is processed.
 */
TableDataSource.prototype.loadText = function (text) {
    this.dataset.loadText(text);
    this.setLeadTimeByPercent(0.0);
    this.setTrailTimeByPercent(1.0);
    if (this.dataset.hasLocationData()) {
        this.czmlDataSource.load(this.getDataPointList(), 'TableDataSource');
    }
};

/**
* Load a variable
*
* @memberof TableDataSource
*
*/
TableDataSource.prototype.setCurrentVariable = function (varName) {
    this.dataset.setCurrentVariable({ variable: varName});
    if (this.dataset.hasLocationData()) {
        this.czmlDataSource.load(this.getDataPointList(), 'TableDataSource');
    }
};

var startScratch = new JulianDate();
var endScratch = new JulianDate();


TableDataSource.prototype.describe = function(properties) {
    var html = '<table class="cesium-infoBox-defaultTable">';
    for ( var key in properties) {
        if (properties.hasOwnProperty(key)) {
            var value = properties[key];
            if (defined(value)) {
                if (typeof value === 'object') {
                    html += '<tr><td>' + key + '</td><td>' + this.describe(value) + '</td></tr>';
                } else {
                    html += '<tr><td>' + key + '</td><td>' + value + '</td></tr>';
                }
            }
        }
    }
    html += '</table>';
    return html;
};


/**
* Replaceable visualizer function
*
* @memberof TableDataSource
*
*/
TableDataSource.prototype.czmlRecFromPoint = function (point) {

    var rec = {
        "name": "Site Data",
        "description": "empty",
        "billboard" : {
            "horizontalOrigin" : "CENTER",
            "verticalOrigin" : "BOTTOM",
            "image" : this.imageUrl,
            "scale" : this.scale,
            "color" : { "rgba" : [255, 0, 0, 255] },
            "show" : [{
                    "boolean" : false
                }, {
                "interval" : "2011-02-04T16:00:00Z/2011-04-04T18:00:00Z",
                "boolean" : true
            }]
        },
        "position" : {
            "cartographicDegrees" : [0, 0, 0]
        }
    };
    
    rec.billboard.color.rgba = this._mapValue2Color(point.val);
    rec.billboard.scale = this._mapValue2Scale(point.val);
    for (var p = 0; p < 3; p++) {
        rec.position.cartographicDegrees[p] = point.pos[p];
    }

    if (this.dataset.hasTimeData()) {
        var start = JulianDate.addMinutes(point.time, -this.leadTimeMin, startScratch);
        var finish = JulianDate.addMinutes(point.time, this.trailTimeMin, endScratch);
        rec.billboard.show[1].interval = JulianDate.toIso8601(start) + '/' + JulianDate.toIso8601(finish);
        rec.availability = rec.billboard.show[1].interval;
    }
    else {
        rec.billboard.show[0].boolean = true;
        rec.billboard.show[1].interval = undefined;
    }
    return rec;
};


/**
* Get a list of display records for the current point list.
*  Currently defaults to a czml based output
*
* @memberof TableDataSource
*
*/
TableDataSource.prototype.getDataPointList = function () {
    var data = this.dataset;
    if (data.loadingData) {
        return;
    }
    //update the datapoint collection
    var pointList = data.getPointList();
    
    var dispRecords = [{
        id : 'document',
        version : '1.0'
    }];
    
    for (var i = 0; i < pointList.length; i++) {
        //set position, scale, color, and display time
        var rec = this.czmlRecFromPoint(pointList[i]);
        rec.description = this.describe(data.getDataRow(pointList[i].row));
        dispRecords.push(rec);
    }
    return dispRecords;
};


TableDataSource.prototype._getNormalizedPoint = function (pntVal) {
    var data = this.dataset;
    if (data === undefined || data.isNoData(pntVal)) {
        return undefined;
    }
    var minVal = data.getMinVal();
    var maxVal = data.getMaxVal();
    var normPoint = (maxVal === minVal) ? 0 : (pntVal - minVal) / (maxVal - minVal);
    return normPoint;
};


TableDataSource.prototype._mapValue2Scale = function (pntVal) {
    var scale = this.scale;
    var normPoint = this._getNormalizedPoint(pntVal);
    if (defined(normPoint) && normPoint === normPoint) {
        scale *= (this.scaleValue ? 1.0 * normPoint + 0.5 : 1.0);
    }
    return scale;
};


TableDataSource.prototype._mapValue2Color = function (pntVal) {
    var colors = this.dataImage;
    if (colors === undefined) {
        return this.color;
    }
    var normPoint = this._getNormalizedPoint(pntVal);
    var color = [0, 0, 0, 0];
    if (normPoint !== undefined) {
        var colorIndex = Math.floor(normPoint * (colors.data.length / 4 - 1)) * 4;
        color[0] = colors.data[colorIndex];
        color[1] = colors.data[colorIndex + 1];
        color[2] = colors.data[colorIndex + 2];
        color[3] = colors.data[colorIndex + 3] * this.color.alpha;
    }
    return color;
};

/**
* Set the lead time by percent
*
* @memberof TableDataSource
*
*/
TableDataSource.prototype.setLeadTimeByPercent = function (pct) {
    if (this.dataset && this.dataset.hasTimeData()) {
        var data = this.dataset;
        this.leadTimeMin = JulianDate.secondsDifference(data.getMaxTime(), data.getMinTime()) * pct / (60.0 * 100.0);
    }
};

/**
* Set the trailing time by percent
*
* @memberof TableDataSource
*
*/
TableDataSource.prototype.setTrailTimeByPercent = function (pct) {
    if (this.dataset && this.dataset.hasTimeData()) {
        var data = this.dataset;
        this.trailTimeMin = JulianDate.secondsDifference(data.getMaxTime(), data.getMinTime()) * pct / (60.0 * 100.0);
    }
};


TableDataSource.prototype.getLegendGraphic = function () {
    var canvas = document.createElement("canvas");
    if (!defined(canvas)) {
        return;
    }
    var w = canvas.width = 210;
    var h = canvas.height = 160;
    var gradW = 40;
    var gradH = 128;
    var ctx = canvas.getContext('2d');

        // Create Linear Gradient
    var grad = this.colorGradient;
    var linGrad = ctx.createLinearGradient(0,0,0,gradH);
    for (var i = 0; i < grad.length; i++) {
        linGrad.addColorStop(grad[i].offset, grad[i].color);
    }
        //white background
    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0,0,w,h);
        //put 0 at bottom
    ctx.translate(gradW + 15, h-5);
    ctx.rotate(180 * Math.PI / 180);
    ctx.fillStyle = linGrad;
    ctx.fillRect(0,0,gradW,gradH);
    
        //text
    var val;
    var minText = (val = this.dataset.getMinVal()) === undefined ? 'und.' : val.toString();
    var maxText = (val = this.dataset.getMaxVal()) === undefined ? 'und.' : val.toString();
    var varText = this.dataset.getCurrentVariable();
    
    ctx.setTransform(1,0,0,1,0,0);
    ctx.font = "16px Arial Narrow";
    ctx.fillStyle = "#000000";
    ctx.fillText(varText, 5, 15);
    ctx.fillText(maxText, gradW + 25, 15+h-gradH-5);
    ctx.fillText(minText, gradW + 25, h-5);
    
    return canvas.toDataURL("image/png");
};


/**
* Set the gradient used to color the data points
*
* @memberof TableDataSource
*
*/
TableDataSource.prototype.setColorGradient = function (colorGradient) {
    if (colorGradient !== undefined) {
        this.colorGradient = colorGradient;
    }
    
    var canvas = document.createElement("canvas");
    if (!defined(canvas)) {
        return;
    }
    var w = canvas.width = 64;
    var h = canvas.height = 256;
    var ctx = canvas.getContext('2d');
    
    // Create Linear Gradient
    var grad = this.colorGradient;
    var linGrad = ctx.createLinearGradient(0,0,0,h);
    for (var i = 0; i < grad.length; i++) {
        linGrad.addColorStop(grad[i].offset, grad[i].color);
    }
    ctx.fillStyle = linGrad;
    ctx.fillRect(0,0,w,h);

    this.dataImage = ctx.getImageData(0, 0, 1, 256);
};

/**
* Set the image used to represent the data points
*
* @memberof TableDataSource
*
*/
TableDataSource.prototype.setImageUrl = function (imageUrl) {
    this.imageUrl = imageUrl;
};

/**
* Destroy the object and release resources
*
* @memberof TableDataSource
*
*/
TableDataSource.prototype.destroy = function () {
    return destroyObject(this);
};

module.exports = TableDataSource;

},{"../../third_party/cesium/Source/Core/Color":111,"../../third_party/cesium/Source/Core/JulianDate":168,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/destroyObject":247,"../../third_party/cesium/Source/Core/loadText":262,"../../third_party/cesium/Source/DataSources/CzmlDataSource":286,"./Dataset":14}],17:[function(require,module,exports){
'use strict';

var VarType = {LON: 0, LAT: 1, ALT: 2, TIME: 3, SCALAR: 4, ENUM: 5 };

module.exports = VarType;

},{}],18:[function(require,module,exports){
/*global require*/
"use strict";

/*!
 * Copyright(c) 2012-2013 National ICT Australia Limited (NICTA).  All rights reserved.
 */

var destroyObject = require('../../third_party/cesium/Source/Core/destroyObject');
var JulianDate = require('../../third_party/cesium/Source/Core/JulianDate');
var VarType = require('./VarType');

/**
* @class Variable contains a single variable from a table dataset
* @name Variable
*
* @alias Variable
* @internalConstructor
* @constructor
*/
var Variable = function () {
    this.vals = [];
    this.varType = undefined;
    this.noData = 1e-34;
    this.minVal = undefined;
    this.maxVal = undefined;
    this.timeVar = undefined;
    this.enumList = undefined;
};

Variable.prototype._calculateVarMinMax = function () {
    var vals = this.vals;
    var minVal = Number.MAX_VALUE;
    var maxVal = -Number.MAX_VALUE;
    for (var i = 0; i < vals.length; i++) {
        if (vals[i] === undefined || vals[i] === null) {
            vals[i] = this.noData;
        }
        else {
            if (minVal > vals[i]) {
                minVal = vals[i];
            }
            if (maxVal < vals[i]) {
                maxVal = vals[i];
            }
        }
    }
    this.minVal = minVal;
    this.maxVal = maxVal;
};

Variable.prototype._calculateTimeMinMax = function () {
    var vals = this.vals;
    var minVal = vals[0];
    var maxVal = vals[0];
    for (var i = 1; i < vals.length; i++) {
        if (JulianDate.greaterThan(minVal, vals[i])) {
            minVal = vals[i];
        }
        if (JulianDate.lessThan(maxVal, vals[i])) {
            maxVal = vals[i];
        }
    }
    this.minVal = minVal;
    this.maxVal = maxVal;
};

/**
* Convert input time variable to Cesium Time variable
*
*/
Variable.prototype.processTimeVar = function () {
    if (this.varType !== VarType.TIME) {
        return;
    }
    
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _swapDateFormat(v) {
        var part = v.split(/[/-]/);
        if (part.length === 3) {
            v = part[1] + '/' + part[0] + '/' + part[2];
        }
        return v;
    }

    //time parsing functions
    function timeString(v) { //  9/2/94 0:56
        return JulianDate.fromDate(new Date(v));
    }
    function timeExcel(v) {   // 40544.4533
        var date = JulianDate.fromDate(new Date('January 1, 1970 0:00:00'));
        date = JulianDate.addDays(date, Math.floor(v) - 25569.0, date); //account for offset to 1900
        date = JulianDate.addSeconds(date, (v - Math.floor(v)) * 60 * 60 * 24, date);
        return date;
    }
    function timeUtc(v) {   //12321231414434
        return JulianDate.fromDate(Date.setTime(v));
    }
    function timeSosus(v) {   //19912410952050
        var dateString = v.toString();
        var year = parseInt(dateString.substring(0, 4), 10);
        var dayofyear = parseInt(dateString.substring(4, 7), 10);
        if (dateString.length !== 14 || year < 1950 || year > 2050 || dayofyear > 366) {
            return new JulianDate(0.0, 0.0);
        }
        var d = new Date();
        d.setUTCFullYear(year);
        d.setUTCHours(dateString.substring(7, 9), dateString.substring(9, 11), dateString.substring(11, 13));
        var date = JulianDate.addDays(JulianDate.fromDate(d), dayofyear, new JulianDate());
        return date;
    }
    //create new Cessium time variable to attach to the variable
    var timeVar = new Variable();
    var vals = this.vals;
    //select time parsing function
    var parseFunc;
    if (parseInt(vals[0], 10) > 500000) {
        if (timeSosus(vals[0]).dayNumber !== 0) {
            parseFunc = timeSosus;
        }
        else {
            parseFunc = timeUtc;
        }
    }
    else if (_isNumber(vals[0])) {
        parseFunc = timeExcel;
    }
    else {
        parseFunc = timeString;
    }
    //parse the time values
    var bSuccess = false;
    try {
        for (var i = 0; i < vals.length; i++) {
            timeVar.vals[i] = parseFunc(vals[i]);
        }
        bSuccess = true;
    }
    catch (err) {
        if (parseFunc === timeString) {
            console.log('Trying swap of day and month in date strings');
            timeVar.vals = [];
            try {
                for (var i = 0; i < vals.length; i++) {
                    timeVar.vals[i] = parseFunc(_swapDateFormat(vals[i]));
                }
                bSuccess = true;
            }
            catch (err) {
            }
        }
    }
    if (bSuccess) {
        timeVar._calculateTimeMinMax();
        this.timeVar = timeVar;
    }
    else {
        this.varType = VarType.SCALAR;
        console.log('Unable to parse time variable');
    }
};


/**
* Convert input enum variable to values and enumList
*
*/
Variable.prototype.processEnumVar = function () {
    if (this.varType !== VarType.ENUM) {
        return;
    }
    //create new enum list for the variable
    var enumList = [];
    for (var i = 0; i < this.vals.length; i++) {
        if (this.vals[i] === this.noData) {
            this.vals[i] = 'undefined';
        }
        var n = enumList.indexOf(this.vals[i]);
        if (n === -1) {
            n = enumList.length;
            enumList.push(this.vals[i]);
        }
        this.vals[i] = parseFloat(n);
    }
    this.enumList = enumList;
    this._calculateVarMinMax();
};


/**
* Based on variable name, guess what the VarType should be
*
* @param {String} name Make an initial guess at the variable type based on its name
*
*/
Variable.prototype.guessVarType = function (name) {
    //functions to try to figure out position and time variables.
    function matchColumn(name, hints) {
        name = name.toLowerCase();
        for (var h in hints) {
            if (hints.hasOwnProperty(h)) {
                var hint = hints[h].toLowerCase();
                if (name.indexOf(hint) === 0 || name.indexOf(' ' + hint) !== -1 || name.indexOf('_' + hint) !== -1) {
                    return true;
                }
            }
        }
        return false;
    }

    var hintSet = [
        { hints: ['lon'], type: VarType.LON },
        { hints: ['lat'], type: VarType.LAT },
        { hints: ['depth', 'height', 'elevation'], type: VarType.ALT },
        { hints: ['time', 'date'], type: VarType.TIME }];

    for (var vt in hintSet) {
        if (matchColumn(name, hintSet[vt].hints)) {
            this.varType = hintSet[vt].type;
            return;
        }
    }
    this.varType = VarType.SCALAR;
};

/**
* Destroy the object and release resources
*
*/
Variable.prototype.destroy = function () {
    return destroyObject(this);
};

module.exports = Variable;




},{"../../third_party/cesium/Source/Core/JulianDate":168,"../../third_party/cesium/Source/Core/destroyObject":247,"./VarType":17}],19:[function(require,module,exports){
'use strict';

/*global $*/

function gmlToGeoJson(xml) {
    var json = $.xml2json(xml);

    var newObj = {type: "FeatureCollection", crs: {"type":"EPSG","properties":{"code":"4326"}}, features: []};

    function pointFilterFunction(obj, prop) {
        newObj.features.push(convertFeature(obj[prop], 'Point'));
    }

    function lineStringFilterFunction(obj, prop) {
        newObj.features.push(convertFeature(obj[prop], 'LineString'));
    }

    function polygonFilterFunction(obj, prop) {
        newObj.features.push(convertFeature(obj[prop], 'Polygon'));
    }

    for (var i = 0; i < json.featureMember.length; i++) {
           //TODO: get feature properties from non-SHAPE properties if present
        //feature.properties = feature.attributes;

        //Recursively find features and add to FeatureCollection
        filterValue(json.featureMember[i], 'Point', pointFilterFunction);
        filterValue(json.featureMember[i], 'LineString', lineStringFilterFunction);
        filterValue(json.featureMember[i], 'Polygon', polygonFilterFunction);
    }

    return newObj;
}

//Utility function to convert esri gml based feature to geojson
function convertFeature(feature, geom_type) {
    var newFeature = {type: "Feature"};
    var pts = (geom_type === 'Point') ? gml2coord(feature.pos)[0] : gml2coord(feature.posList);
    newFeature.geometry = { "type": geom_type, "coordinates": pts };
    return newFeature;
}  

// find a member by name in the gml
function filterValue(obj, prop, func) {
    for (var p in obj) {
        if (obj.hasOwnProperty(p) === false) {
            continue;
        }
        else if (p === prop) {
            if (func && (typeof func === 'function')) {
                (func)(obj, prop);
            }
        }
        else if (typeof obj[p] === 'object') {
            filterValue(obj[p], prop, func);
        }
    }
}

//Utility function to change esri gml positions to geojson positions
function gml2coord(posList) {
    var pnts = posList.split(/[ ,]+/);
    var coords = [];
    for (var i = 0; i < pnts.length; i+=2) {
        coords.push([parseFloat(pnts[i+1]), parseFloat(pnts[i])]);
    }
    return coords;
}

module.exports = gmlToGeoJson;
},{}],20:[function(require,module,exports){
'use strict';

/*global require,L*/

var CesiumMath = require('../../third_party/cesium/Source/Core/Math');

/**
 * Converts a Cesium Rectangle into a Leaflet LatLngBounds.
 * @param {Rectangle} rectangle The rectangle to convert.
 * @return {L.latLngBounds} The equivalent Leaflet latLngBounds.
 */
var rectangleToLatLngBounds = function(rectangle) {
    var west = CesiumMath.toDegrees(rectangle.west);
    var south = CesiumMath.toDegrees(rectangle.south);
    var east = CesiumMath.toDegrees(rectangle.east);
    var north = CesiumMath.toDegrees(rectangle.north);
    return L.latLngBounds([south, west], [north, east]);
};

module.exports = rectangleToLatLngBounds;

},{"../../third_party/cesium/Source/Core/Math":174}],21:[function(require,module,exports){
'use strict';

/*global require*/
var defined = require('../../third_party/cesium/Source/Core/defined');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');

/**
 * Computes the union of two rectangles.
 * @param {Rectangle} first The first rectangle to union.
 * @param {Rectangle} second The second rectangle to union.
 * @param {Rectangle} [result] The existing {@link Rectangle} to which to copy the result instead of creating and returning a new instance.
 * @return {Rectangle} The union of the two rectangles.
 */
var unionRectangles = function(first, second, result) {
    if (!defined(first)) {
        throw new DeveloperError('first is required');
    }
    if (!defined(second)) {
        throw new DeveloperError('second is required');
    }

    var west = Math.min(first.west, second.west);
    var south = Math.min(first.south, second.south);
    var east = Math.max(first.east, second.east);
    var north = Math.max(first.north, second.north);

    if (!defined(result)) {
        result = new Rectangle(west, south, east, north);
    } else {
        result.west = west;
        result.south = south;
        result.east = east;
        result.north = north;
    }

    return result;
};

module.exports = unionRectangles;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/defined":245}],22:[function(require,module,exports){
"use strict";

/*global require, URI*/
var CesiumEvent = require('../../third_party/cesium/Source/Core/Event');
var Clock = require('../../third_party/cesium/Source/Core/Clock');
var DataSourceCollection = require('../../third_party/cesium/Source/DataSources/DataSourceCollection');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var FeatureDetection = require('../../third_party/cesium/Source/Core/FeatureDetection');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadJson = require('../../third_party/cesium/Source/Core/loadJson');
var queryToObject = require('../../third_party/cesium/Source/Core/queryToObject');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var Catalog = require('./Catalog');
var corsProxy = require('../Core/corsProxy');
var NowViewing = require('./NowViewing');
var Services = require('./Services');
var ViewerMode = require('./ViewerMode');
var ModelError = require('./ModelError');

/**
 * The overall model for National Map.
 * @alias Application
 * @constructor
 */
var Application = function() {
    /**
     * An event that is raised when a user-facing error occurs.  This is especially useful for errors that happen asynchronously and so
     * cannot be raised as an exception because no one would be able to catch it.  Subscribers are passed the {@link ModelError}
     * that occurred as the only function parameter.
     * @type {CesiumEvent}
     */
    this.error = new CesiumEvent();

    /**
     * Gets or sets the map mode.
     * @type {ViewerMode}
     */
    this.viewerMode = ViewerMode.CesiumTerrain;

    /**
     * Gets or sets the current base map.
     * @type {ImageryLayerCatalogItem}
     */
    this.baseMap = undefined;

    /**
     * Gets or sets the event that is raised just before switching between Cesium and Leaflet.
     * @type {Event}
     */
    this.beforeViewerChanged = new CesiumEvent();

    /**
     * Gets or sets the event that is raised just after switching between Cesium and Leaflet.
     * @type {Event}
     */
    this.afterViewerChanged = new CesiumEvent();

    /**
     * Gets or sets the collection of Cesium-style data sources that are currently active on the map.
     * @type {DataSourceCollection}
     */
    this.dataSources = new DataSourceCollection();

    /**
     * Gets or sets the clock that controls how time-varying data items are displayed.
     * @type {Clock}
     */
    this.clock = new Clock();

    /**
     * Gets or sets the initial bounding box of the camera's view.
     * @type {Rectangle}
     */
    this.initialBoundingBox = Rectangle.MAX_VALUE;

    /**
     * Gets or sets the {@link corsProxy} used to determine if a URL needs to be proxied and to proxy it if necessary.
     * @type {corsProxy}
     */
    this.corsProxy = corsProxy;

    /**
     * Gets or sets properties related to the Cesium globe.  If the application is in 2D mode, this property will be
     * undefined and {@link Application#leaflet} will be set.
     * @type {Cesium}
     */
    this.cesium = undefined;

    /**
     * Gets or sets properties related to the Leaflet map.  If the application is in 3D mode, this property will be
     * undefined and {@link Application#cesium} will be set.
     * @type {Leaflet}
     */
    this.leaflet = undefined;

    /**
     * Gets or sets a reference to either {@link Application#cesium} or {@link Application#leaflet},
     * whichever is currently in use.
     * @type {Cesium|Leaflet}
     */
    this.currentViewer = undefined;

    /**
     * Gets or sets the collection of user properties.  User properties
     * can be set by specifying them in the hash portion of the URL.  For example, if the application URL is
     * `http://localhost:3001/#foo=bar&someproperty=true`, this object will contain a property named 'foo' with the
     * value 'bar' and a property named 'someproperty' with the value 'true'.
     * @type {Object}
     */
    this.userProperties = {};

    /**
     * Gets or sets the list of sources from which the catalog was populated.  A source may be a string, in which case it
     * is expected to be a URL of an init file (like init_nm.json), or it can be a JSON-style object literal which is
     * the init content itself.
     * @type {Array}
     */
    this.initSources = [];

    /**
     * Gets or sets the catalog of geospatial data.
     * @type {Catalog}
     */
    this.catalog = new Catalog(this);

    /**
     * Gets or sets the add-on services known to the application.
     * @type {Services}
     */
    this.services = new Services(this);

    /**
     * Gets or sets the collection of geospatial data that is currently enabled.
     * @type {NowViewing}
     */
    this.nowViewing = new NowViewing(this);

    knockout.track(this, ['viewerMode', 'baseMap', 'initialBoundingBox']);

    // IE versions prior to 10 don't support CORS, so always use the proxy.
    corsProxy.alwaysUseProxy = (FeatureDetection.isInternetExplorer() && FeatureDetection.internetExplorerVersion()[0] < 10);
};

/**
 * Starts the application.
 *
 * @param {Object} options Object with the following properties:
 * @param {String} [options.applicationUrl] The URL of the application.  Typically this is obtained from window.location.  This URL, if
 *                                          supplied, is parsed for startup parameters.
 * @param {String} [options.configUrl='config.json'] The URL of the file containing configuration information, such as the list of domains to proxy.
 * @param {Boolean} [options.useApplicationUrlHashAsInitSource=true] true to parse the applicationUrl as an init source.  The hash may be of the form
 *                                                                   'start=???', where ??? is a JSON-encoded initialization object, or it may be
 *                                                                   a simple string.  If it's a simple string, a file named 'init_' + hash + '.json'
 *                                                                   will be loaded as the init source.  For example, #vic will load init_vic.json.
 */
Application.prototype.start = function(options) {
    var applicationUrl = defaultValue(options.applicationUrl, '');

    var that = this;
    return loadJson(options.configUrl).then(function(config) {
        corsProxy.proxyDomains.push.apply(corsProxy.proxyDomains, config.proxyDomains);

        var initializationUrls = config.initializationUrls;

        if (defined(initializationUrls)) {
            for (var i = 0; i < initializationUrls.length; i++) {
                that.initSources.push(initializationUrls[i]);
            }
        }

        return that.updateApplicationUrl(applicationUrl);
    });
};

/**
 * Updates the state of the application based on the hash portion of a URL.
 * @param {String} newUrl The new URL of the application.
 * @return {Promise} A promise that resolves when any new init sources specified in the URL have been loaded.
 */
Application.prototype.updateApplicationUrl = function(newUrl) {
    var uri = new URI(newUrl);
    var hash = uri.fragment();
    var hashProperties = queryToObject(hash);

    var initSources = this.initSources.slice();
    interpretHash(hashProperties, this.userProperties, this.initSources, initSources);

    return loadInitSources(this, initSources);
};

/**
 * Gets the value of a user property.  If the property doesn't exist, it is created as an observable property with the 
 * value undefined.  This way, if it becomes defined in the future, anyone depending on the value will be notified.
 * @param {String} propertyName The name of the user property for which to get the value.
 * @return {Object} The value of the property, or undefined if the property does not exist.
 */
Application.prototype.getUserProperty = function(propertyName) {
    if (!knockout.getObservable(this.userProperties, propertyName)) {
        this.userProperties[propertyName] = undefined;
        knockout.track(this.userProperties, [propertyName]);
    }
    return this.userProperties[propertyName];
};

Application.prototype.addInitSource = function(initSource) {
    // Extract the list of CORS-ready domains.
    if (defined(initSource.corsDomains)) {
        corsProxy.corsDomains.push.apply(corsProxy.corsDomains, initSource.corsDomains);
    }

    // The last init source to specify a camera position wins.
    if (defined(initSource.camera)) {
        this.initialBoundingBox = Rectangle.fromDegrees(initSource.camera.west, initSource.camera.south, initSource.camera.east, initSource.camera.north);
    }

    // Populate the list of services.
    if (defined(initSource.services)) {
        this.services.services.push.apply(this.services, initSource.services);
    }

    // Populate the catalog
    if (defined(initSource.catalog)) {
        var isUserSupplied;
        if (initSource.isFromExternalFile) {
            isUserSupplied = false;
        } else if (initSource.catalogOnlyUpdatesExistingItems) {
            isUserSupplied = undefined;
        } else {
            isUserSupplied = true;
        }

        return this.catalog.updateFromJson(initSource.catalog, {
            onlyUpdateExistingItems: initSource.catalogOnlyUpdatesExistingItems,
            isUserSupplied: isUserSupplied
        });
    } else {
        return when();
    }
};

function interpretHash(hashProperties, userProperties, persistentInitSources, temporaryInitSources) {
    for (var property in hashProperties) {
        if (hashProperties.hasOwnProperty(property)) {
            var propertyValue = hashProperties[property];

            if (property === 'clean') {
                persistentInitSources.length = 0;
                temporaryInitSources.length = 0;
            }
            else if (property === 'start') {
                var startData = JSON.parse(propertyValue);

                // Include any initSources specified in the URL.
                if (defined(startData.initSources)) {
                    for (var i = 0; i < startData.initSources.length; ++i) {
                        var initSource = startData.initSources[i];
                        if (temporaryInitSources.indexOf(initSource) < 0) {
                            temporaryInitSources.push(initSource);

                            // Only add external files to the application's list of init sources.
                            if (typeof initSource === 'string' && persistentInitSources.indexOf(initSource) < 0) {
                                persistentInitSources.push(initSource);
                            }
                        }
                    }
                }
            } else if (defined(propertyValue) && propertyValue.length > 0) {
                userProperties[property] = propertyValue;
                knockout.track(userProperties, [property]);
            } else {
                var initSourceFile = 'init_' + property + '.json';
                persistentInitSources.push(initSourceFile);
                temporaryInitSources.push(initSourceFile);
            }
        }
    }
}

function loadInitSources(application, initSources) {
    return when.all(initSources.map(loadInitSource), function(initSources) {
        var promises = [];

        for (var i = 0; i < initSources.length; ++i) {
            var initSource = initSources[i];
            if (!defined(initSource)) {
                continue;
            }
            application.addInitSource(initSource);
        }

        return when.all(promises);
    });
}

function loadInitSource(source) {
    if (typeof source === 'string') {
        return loadJson(source).then(function(initSource) {
            initSource.isFromExternalFile = true;
            return initSource;
        }).otherwise(function() {
            throw new ModelError({
                title: 'Error loading initialization source',
                message: 'An error occurred while loading initialization information from ' + source + '.  This may indicate that you followed an invalid link or that there is a problem with your Internet connection.'
            });
        });
    } else {
        return source;
    }
}

module.exports = Application;

},{"../../third_party/cesium/Source/Core/Clock":108,"../../third_party/cesium/Source/Core/Event":138,"../../third_party/cesium/Source/Core/FeatureDetection":141,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/loadJson":261,"../../third_party/cesium/Source/Core/queryToObject":269,"../../third_party/cesium/Source/DataSources/DataSourceCollection":289,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/corsProxy":5,"./Catalog":25,"./ModelError":41,"./NowViewing":42,"./Services":44,"./ViewerMode":45}],23:[function(require,module,exports){
'use strict';

/*global require,L,URI*/

var ArcGisMapServerImageryProvider = require('../../third_party/cesium/Source/Scene/ArcGisMapServerImageryProvider');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var ImageryLayer = require('../../third_party/cesium/Source/Scene/ImageryLayer');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var ImageryLayerCatalogItem = require('./ImageryLayerCatalogItem');
var inherit = require('../Core/inherit');

/**
 * A {@link ImageryLayerCatalogItem} representing a layer from an Esri ArcGIS MapServer.
 *
 * @alias ArcGisMapServerCatalogItem
 * @constructor
 * @extends ImageryLayerCatalogItem
 * 
 * @param {Application} application The application.
 */
var ArcGisMapServerCatalogItem = function(application) {
    ImageryLayerCatalogItem.call(this, application);

    this._legendUrl = undefined;

    /**
     * Gets or sets the URL of the WMS server.  This property is observable.
     * @type {String}
     */
    this.url = '';

    knockout.track(this, ['url', '_legendUrl']);

    // dataUrl, metadataUrl, and legendUrl are derived from url if not explicitly specified.
    delete this.__knockoutObservables.legendUrl;
    knockout.defineProperty(this, 'legendUrl', {
        get : function() {
            if (defined(this._legendUrl)) {
                return this._legendUrl;
            }
            return cleanUrl(this.url) + '/legend';
        },
        set : function(value) {
            this._legendUrl = value;
        }
    });

};

inherit(ImageryLayerCatalogItem, ArcGisMapServerCatalogItem);

defineProperties(ArcGisMapServerCatalogItem.prototype, {
    /**
     * Gets the type of data item represented by this instance.
     * @memberOf ArcGisMapServerCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'esri-mapServer';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'Esri ArcGIS MapServer'.
     * @memberOf ArcGisMapServerCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Esri ArcGIS MapServer';
        }
    }
});


ArcGisMapServerCatalogItem.prototype._enableInCesium = function() {
    if (defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is already enabled.');
    }

    var scene = this.application.cesium.scene;

    var imageryProvider = new ArcGisMapServerImageryProvider({
        url : cleanAndProxyUrl(this.application, this.url)
    });

    this._imageryLayer = new ImageryLayer(imageryProvider, {
        show: false,
        alpha : this.opacity
        // Ideally we'd specify "rectangle : this.rectangle" here.
        // But lots of data sources get the extent wrong, and even the ones that get it right
        // specify the extent of the geometry itself, not the representation of the geometry.  So that means,
        // for example, that if we clip the layer at the given extent, then a point centered on the edge of the
        // extent will only be half visible.
    });

    scene.imageryLayers.add(this._imageryLayer);
};

ArcGisMapServerCatalogItem.prototype._disableInCesium = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var scene = this.application.cesium.scene;

    scene.imageryLayers.remove(this._imageryLayer);
    this._imageryLayer = undefined;
};

ArcGisMapServerCatalogItem.prototype._enableInLeaflet = function() {
    if (defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is already enabled.');
    }

    var options = {
        opacity : this.opacity
        // Ideally we'd specify "bounds : rectangleToLatLngBounds(this.rectangle)" here.
        // See comment in _enableInCesium for an explanation of why we don't.
    };

    this._imageryLayer = new L.esri.tiledMapLayer(cleanAndProxyUrl(this.application, this.url), options);
};

ArcGisMapServerCatalogItem.prototype._disableInLeaflet = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    this._imageryLayer = undefined;
};

function cleanAndProxyUrl(application, url) {
    return proxyUrl(application, cleanUrl(url));
}

function cleanUrl(url) {
    // Strip off the search portion of the URL
    var uri = new URI(url);
    uri.search('');
    return uri.toString();
}

function proxyUrl(application, url) {
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(url)) {
        return application.corsProxy.getURL(url);
    }

    return url;
}

module.exports = ArcGisMapServerCatalogItem;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Scene/ArcGisMapServerImageryProvider":367,"../../third_party/cesium/Source/Scene/ImageryLayer":396,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"./ImageryLayerCatalogItem":36}],24:[function(require,module,exports){
'use strict';

/*global require,L*/

var BingMapsApi = require('../../third_party/cesium/Source/Core/BingMapsApi');
var BingMapsImageryProvider = require('../../third_party/cesium/Source/Scene/BingMapsImageryProvider');
var BingMapsStyle = require('../../third_party/cesium/Source/Scene/BingMapsStyle');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var ImageryLayer = require('../../third_party/cesium/Source/Scene/ImageryLayer');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var ImageryLayerCatalogItem = require('./ImageryLayerCatalogItem');
var inherit = require('../Core/inherit');

/**
 * A {@link ImageryLayerCatalogItem} representing a layer from the Bing Maps server.
 *
 * @alias BingMapsCatalogItem
 * @constructor
 * @extends ImageryLayerCatalogItem
 * 
 * @param {Application} application The application.
 */
var BingMapsCatalogItem = function(application) {
    ImageryLayerCatalogItem.call(this, application);

    /**
     * Gets or sets the style of the Bing Maps map to use.
     * @type {BingMapsStyle}
     */
    this.mapStyle = BingMapsStyle.AERIAL;

    /**
     * Gets or sets the Bing Maps API key to use.  If this property is undefined,
     * {@link BingMapsApi.getKey} is used.
     * @type {String}
     */
    this.key = undefined;

    knockout.track(this, ['mapStyle', 'key']);
};

inherit(ImageryLayerCatalogItem, BingMapsCatalogItem);

defineProperties(BingMapsCatalogItem.prototype, {
    /**
     * Gets the type of data item represented by this instance.
     * @memberOf BingMapsCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'bing-maps';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'Bing Maps'.
     * @memberOf BingMapsCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Bing Maps';
        }
    }
});

BingMapsCatalogItem.prototype._enableInCesium = function() {
    if (defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is already enabled.');
    }

    var scene = this.application.cesium.scene;

    var imageryProvider = new BingMapsImageryProvider({
        url: '//dev.virtualearth.net',
        mapStyle: this.mapStyle,
        key: this.key
    });

    this._imageryLayer = new ImageryLayer(imageryProvider, {
        show: false,
        alpha : this.opacity
    });

    scene.imageryLayers.add(this._imageryLayer);
};

BingMapsCatalogItem.prototype._disableInCesium = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var scene = this.application.cesium.scene;

    scene.imageryLayers.remove(this._imageryLayer);
    this._imageryLayer = undefined;
};

BingMapsCatalogItem.prototype._enableInLeaflet = function() {
    if (defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is already enabled.');
    }

    var options = {
        type: this.mapStyle,
        opacity : this.opacity
    };

    var key = this.key;
    if (!defined(key)) {
        key = BingMapsApi.getKey();
    }

    this._imageryLayer = new L.BingLayer(key, options);
};

BingMapsCatalogItem.prototype._disableInLeaflet = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    this._imageryLayer = undefined;
};

module.exports = BingMapsCatalogItem;

},{"../../third_party/cesium/Source/Core/BingMapsApi":96,"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Scene/BingMapsImageryProvider":370,"../../third_party/cesium/Source/Scene/BingMapsStyle":371,"../../third_party/cesium/Source/Scene/ImageryLayer":396,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"./ImageryLayerCatalogItem":36}],25:[function(require,module,exports){
'use strict';

/*global require*/

var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var RuntimeError = require('../../third_party/cesium/Source/Core/RuntimeError');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var createCatalogMemberFromType = require('./createCatalogMemberFromType');
var CatalogGroup = require('./CatalogGroup');

/**
 * The view model for the geospatial data catalog.
 *
 * @param {Application} application The application.
 *
 * @alias Catalog
 * @constructor
 */
var Catalog = function(application) {
    if (!defined(application)) {
        throw new DeveloperError('application is required');
    }

    this._application = application;

    this._group = new CatalogGroup(application);
    this._group.name = 'Root Group';

    /**
     * Gets or sets a flag indicating whether the catalog is currently loading.
     * @type {Boolean}
     */
    this.isLoading = false;

    knockout.track(this, ['isLoading']);

    knockout.defineProperty(this, 'userAddedDataGroup', {
        get : function() {
            var group;

            var groups = this.group.items;
            for (var i = 0; i < groups.length; ++i) {
                group = groups[i];
                if (group.name === 'User-Added Data') {
                    return group;
                }
            }

            group = new CatalogGroup(this.application);
            group.name = 'User-Added Data';
            group.description = 'The group for data that was added by the user via the Add Data panel.';
            this.group.add(group);

            return group;
        }
    });
};

defineProperties(Catalog.prototype, {
    /**
     * Gets the application.
     * @memberOf Catalog.prototype
     * @type {Application}
     */
    application : {
        get : function() {
            return this._application;
        }
    },

    /**
     * Gets the catalog's top-level group.
     * @memberOf Catalog.prototype
     * @type {CatalogGroup}
     */
    group : {
        get : function() {
            return this._group;
        }
    }
});

/**
 * Updates the catalog from a JSON object-literal description of the available collections.
 * Existing collections with the same name as a collection in the JSON description are
 * updated.  If the description contains a collection with a name that does not yet exist,
 * it is created.  Because parts of the update may happen asynchronously, this method
 * returns at Promise that will resolve when the update is completely done.
 *
 * @param {Object} json The JSON description.  The JSON should be in the form of an object literal, not a string.
 * @param {Object} [options] Object with the following properties:
 * @param {Boolean} [options.onlyUpdateExistingItems] true to only update existing items and never create new ones, or false is new items
 *                                                    may be created by this update.
 * @param {Boolean} [options.isUserSupplied] If specified, sets the {@link CatalogMember#isUserSupplied} property of updated catalog members
 *                                           to the given value.  If not specified, the property is left unchanged.
 * @returns {Promise} A promise that resolves when the update is complete.
 */
Catalog.prototype.updateFromJson = function(json, options) {
    if (!(json instanceof Array)) {
        throw new DeveloperError('JSON catalog description must be an array of groups.');
    }

    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var onlyUpdateExistingItems = defaultValue(options.onlyUpdateExistingItems, false);

    var promises = [];

    for (var groupIndex = 0; groupIndex < json.length; ++groupIndex) {
        var group = json[groupIndex];

        if (!defined(group.name)) {
            throw new RuntimeError('A group must have a name.');
        }

        // Find an existing group with the same name, if any.
        var existingGroup = this.group.findFirstItemByName(group.name);
        if (!defined(existingGroup)) {
            // Skip this item entirely if we're not allowed to create it.
            if (onlyUpdateExistingItems) {
                continue;
            }

            if (!defined(group.type)) {
                throw new RuntimeError('A group must have a type.');
            }

            existingGroup = createCatalogMemberFromType(group.type, this.application);

            this.group.add(existingGroup);
        }

        promises.push(existingGroup.updateFromJson(group, options));
    }

    var that = this;
    return when.all(promises, function() {
        that.application.nowViewing.sortByNowViewingIndices();
    });
};

/**
 * Serializes the catalog to JSON.
 *
 * @param {Object} [options] Object with the following properties:
 * @param {Boolean} [options.enabledItemsOnly=false] true if only enabled data items (and their groups) should be serialized,
 *                  or false if all data items should be serialized.
 * @param {CatalogMember[]} [options.itemsSkippedBecauseTheyAreNotEnabled] An array that, if provided, is populated on return with
 *        all of the data items that were not serialized because they were not enabled.  The array will be empty if
 *        options.enabledItemsOnly is false.
 * @param {Boolean} [options.skipItemsWithLocalData=false] true if items with a serializable 'data' property should be skipped entirely.
 *                  This is useful to avoid creating a JSON data structure with potentially very large embedded data.
 * @param {CatalogMember[]} [options.itemsSkippedBecauseTheyHaveLocalData] An array that, if provided, is populated on return
 *        with all of the data items that were not serialized because they have a serializable 'data' property.  The array will be empty
 *        if options.skipItemsWithLocalData is false.
 * @param {Boolean} [options.serializeForSharing=false] true to only serialize properties that are typically necessary for sharing this member
 *                                                      with other users, such as {@link CatalogGroup#isOpen}, {@link CatalogItem#isEnabled},
 *                                                      {@link CatalogItem#isLegendVisible}, and {@link ImageryLayerCatalogItem#opacity},
 *                                                      rather than serializing all properties needed to completely recreate the catalog.
 * @param {Boolean} [options.userSuppliedOnly=false] true to only serialize catalog members (and their containing groups) that have been identified as having been
 *                  supplied by the user ({@link CatalogMember#isUserSupplied} is true); false to serialize all catalog members.
 * @return {Object} The serialized JSON object-literal.
 */
Catalog.prototype.serializeToJson = function(options) {
    this.application.nowViewing.recordNowViewingIndices();

    var json = {};
    CatalogGroup.defaultSerializers.items(this.group, json, 'items', options);
    return json.items;
};

module.exports = Catalog;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/RuntimeError":207,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"./CatalogGroup":26,"./createCatalogMemberFromType":53}],26:[function(require,module,exports){
'use strict';

/*global require*/

var clone = require('../../third_party/cesium/Source/Core/clone');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var RuntimeError = require('../../third_party/cesium/Source/Core/RuntimeError');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var arraysAreEqual = require('../Core/arraysAreEqual');
var createCatalogMemberFromType = require('./createCatalogMemberFromType');
var CatalogMember = require('./CatalogMember');
var inherit = require('../Core/inherit');
var raiseErrorOnRejectedPromise = require('./raiseErrorOnRejectedPromise');
var runLater = require('../Core/runLater');

var naturalSort = require('javascript-natural-sort');

/**
 * A group of data items and other groups in the {@link Catalog}.  A group can contain
 * {@link CatalogMember|CatalogMembers} or other
 * {@link CatalogGroup|CatalogGroups}.
 *
 * @alias CatalogGroup
 * @constructor
 * @extends CatalogMember
 * 
 * @param {Application} application The application.
 */
var CatalogGroup = function(application) {
    CatalogMember.call(this, application);

    this._loadingPromise = undefined;
    this._lastLoadInfluencingValues = undefined;

    /**
     * Gets or sets a value indicating whether the group is currently expanded and showing
     * its children.  This property is observable.
     * @type {Boolean}
     */
    this.isOpen = false;

    /**
     * Gets or sets a value indicating whether the group is currently loading.  This property
     * is observable.
     * @type {Boolean}
     */
    this.isLoading = false;

    /**
     * Gets the collection of items in this group.  This property is observable.
     * @type {CatalogMember[]}
     */
    this.items = [];

    knockout.track(this, ['isOpen', 'isLoading', 'items']);

    var that = this;

    knockout.getObservable(this, 'isOpen').subscribe(function(newValue) {
        // Load this group's items (if we haven't already) when it is opened.
        if (newValue) {
            raiseErrorOnRejectedPromise(that.application, that.load());
        }
    });

    knockout.getObservable(this, 'isLoading').subscribe(function(newValue) {
        // Call load() again immediately after finishing loading, if the group is still open.  Normally this will do nothing,
        // but if the URL has changed since we started, it will kick off loading the new URL.
        // If this spins you into a stack overflow, verify that your derived-class load method only
        // loads when it actually needs to do so!
        if (newValue === false && that.isOpen) {
            raiseErrorOnRejectedPromise(that.application, that.load());
        }
    });
};

inherit(CatalogMember, CatalogGroup);

defineProperties(CatalogGroup.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf CatalogGroup.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'group';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, such as 'Web Map Service (WMS)'.
     * @memberOf CatalogGroup.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Group';
        }
    },

    /**
     * Gets a value indicating whether the items in this group (and their sub-items, if any) should be sorted when
     * {@link CatalogGroup#load} is complete.
     * @memberOf CatalogGroup.prototype
     * @type {Boolean}
     */
    sortItemsOnLoad : {
        get : function() {
            return true;
        }
    },

    /**
     * Gets the set of functions used to update individual properties in {@link CatalogMember#updateFromJson}.
     * When a property name in the returned object literal matches the name of a property on this instance, the value
     * will be called as a function and passed a reference to this instance, a reference to the source JSON object
     * literal, and the name of the property.
     * @memberOf CatalogGroup.prototype
     * @type {Object}
     */
    updaters : {
        get : function() {
            return CatalogGroup.defaultUpdaters;
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf CatalogGroup.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return CatalogGroup.defaultSerializers;
        }
    },

    /**
     * Gets the set of names of the properties to be serialized for this object when {@link CatalogMember#serializeToJson} is called
     * and the `serializeForSharing` flag is set in the options.
     * @memberOf CatalogGroup.prototype
     * @type {String[]}
     */
    propertiesForSharing : {
        get : function() {
            return CatalogGroup.defaultPropertiesForSharing;
        }
    }
});

/**
 * Gets or sets the set of default updater functions to use in {@link CatalogMember#updateFromJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#updaters} property.
 * @type {Object}
 */
CatalogGroup.defaultUpdaters = clone(CatalogMember.defaultUpdaters);

CatalogGroup.defaultUpdaters.items = function(catalogGroup, json, propertyName, options) {
    // Let the group finish loading first.  Otherwise, these changes could get clobbered by the load.
    return when(catalogGroup.load(), function() {
        var promises = [];

        // TODO: allow JSON to update the order of items as well.

        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var onlyUpdateExistingItems = defaultValue(options.onlyUpdateExistingItems, false);

        var items = json.items;
        for (var itemIndex = 0; itemIndex < items.length; ++itemIndex) {
            var item = items[itemIndex];

            // Find an existing item with the same name
            var existingItem = catalogGroup.findFirstItemByName(item.name);
            if (!defined(existingItem)) {
                // Skip this item entirely if we're not allowed to create it.
                if (onlyUpdateExistingItems) {
                    continue;
                }

                if (!defined(item.type)) {
                    throw new RuntimeError('An item must have a type.');
                }

                existingItem = createCatalogMemberFromType(item.type, catalogGroup.application);
                catalogGroup.add(existingItem);
            }

            promises.push(existingItem.updateFromJson(item, options));
        }

        return when.all(promises, function() {
            if (defaultValue(json.sortItemsOnLoad, true)) {
                catalogGroup.sortItems();
            }
        });
    });
};

CatalogGroup.defaultUpdaters.isLoading = function(catalogGroup, json, propertyName) {};

freezeObject(CatalogGroup.defaultUpdaters);

/**
 * Gets or sets the set of default serializer functions to use in {@link CatalogMember#serializeToJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#serializers} property.
 * @type {Object}
 */
CatalogGroup.defaultSerializers = clone(CatalogMember.defaultSerializers);

CatalogGroup.defaultSerializers.items = function(catalogGroup, json, propertyName, options) {
    var items = json.items = [];

    for (var i = 0; i < catalogGroup.items.length; ++i) {
        var item = catalogGroup.items[i].serializeToJson(options);
        if (defined(item)) {
            items.push(item);
        }
    }
};

CatalogGroup.defaultSerializers.isLoading = function(catalogGroup, json, propertyName, options) {};

freezeObject(CatalogGroup.defaultSerializers);

/**
 * Gets or sets the default set of properties that are serialized when serializing a {@link CatalogItem}-derived object with the
 * `serializeForSharing` flag set in the options.
 * @type {String[]}
 */
CatalogGroup.defaultPropertiesForSharing = clone(CatalogMember.defaultPropertiesForSharing);
CatalogGroup.defaultPropertiesForSharing.push('items');
CatalogGroup.defaultPropertiesForSharing.push('isOpened');

freezeObject(CatalogGroup.defaultPropertiesForSharing);

/**
 * Loads the contents of this group, if the contents are not already loaded.  It is safe to
 * call this method multiple times.  The {@link CatalogGroup#isLoading} flag will be set while the load is in progress.
 * Derived classes should implement {@link CatalogGroup#_load} to perform the actual loading for the group.
 * Derived classes may optionally implement {@link CatalogGroup#_getValuesThatInfluenceLoad} to provide an array containing
 * the current value of all properties that influence this group's load process.  Each time that {@link CatalogGroup#load}
 * is invoked, these values are checked against the list of values returned last time, and {@link CatalogGroup#_load} is
 * invoked again if they are different.  If {@link CatalogGroup#_getValuesThatInfluenceLoad} is undefined or returns an
 * empty array, {@link CatalogGroup#_load} will only be invoked once, no matter how many times
 * {@link CatalogGroup#load} is invoked.
 *
 * @returns {Promise} A promise that resolves when the load is complete, or undefined if the group is already loaded.
 * 
 */
CatalogGroup.prototype.load = function() {
    if (defined(this._loadingPromise)) {
        // Load already in progress.
        return this._loadingPromise;
    }

    var loadInfluencingValues = [];
    if (defined(this._getValuesThatInfluenceLoad)) {
        loadInfluencingValues = this._getValuesThatInfluenceLoad();
    }

    if (arraysAreEqual(loadInfluencingValues, this._lastLoadInfluencingValues)) {
        // Already loaded, and nothing has changed to force a re-load.
        return undefined;
    }

    this.isLoading = true;

    var that = this;
    this._loadingPromise = runLater(function() {
        that._lastLoadInfluencingValues = [];
        if (defined(that._getValuesThatInfluenceLoad)) {
            that._lastLoadInfluencingValues = that._getValuesThatInfluenceLoad();
        }

        return that._load();
    }).then(function() {
        if (defaultValue(that.sortItemsOnLoad, true)) {
            that.sortItems(true);
        }
        that._loadingPromise = undefined;
        that.isLoading = false;
    }).otherwise(function(e) {
        that._lastLoadInfluencingValues = undefined;
        that._loadingPromise = undefined;
        that.isOpen = false;
        that.isLoading = false;
        throw e;
    });

    return this._loadingPromise;
};

/**
 * When implemented in a derived class, this method loads the group.  The base class implementation does nothing.
 * This method should not be called directly; call {@link CatalogGroup#load} instead.
 * @return {Promise} A promise that resolves when the load is complete.
 * @protected
 */
CatalogGroup.prototype._load = function() {
    return when();
};

var emptyArray = freezeObject([]);

/**
 * When implemented in a derived class, gets an array containing the current value of all properties that
 * influence this group's load process.  See {@link CatalogGroup#load} for more information on when and
 * how this is used.  The base class implementation returns an empty array.
 * @return {Array} The array of values that influence the load process.
 * @protected
 */
CatalogGroup.prototype._getValuesThatInfluenceLoad = function() {
    return emptyArray;
};

/**
 * Adds an item or group to this group.
 * 
 * @param {CatalogMember} item The item to add.
 */
CatalogGroup.prototype.add = function(item) {
    this.items.push(item);
};

/**
 * Removes an item or group from this group.
 * 
 * @param {CatalogMember} item The item to remove.
 */
CatalogGroup.prototype.remove = function(item) {
    this.items.remove(item);
};

/**
 * Toggles the {@link CatalogGroup#isOpen} property of this group.  If it is open, calling this method
 * will close it.  If it is closed, calling this method will open it.
 */
CatalogGroup.prototype.toggleOpen = function() {
    this.isOpen = !this.isOpen;
};

/**
 * Finds the first item in this group that has the given name.  The search is case-sensitive.
 * 
 * @param {String} name The name of the item to find.
 * @return {CatalogMember} The first item with the given name, or undefined if no item with that name exists.
 */
CatalogGroup.prototype.findFirstItemByName = function(name) {
    for (var i = 0; i < this.items.length; ++i) {
        if (this.items[i].name === name) {
            return this.items[i];
        }
    }

    return undefined;
};

/**
 * Sorts the items in this group.
 *
 * @param {Boolean} [sortRecursively=false] true to sort the items in sub-groups as well; false to sort only the items in this group.
 */
CatalogGroup.prototype.sortItems = function(sortRecursively) {
    naturalSort.insensitive = true;
    this.items.sort(function(a, b) {
        return naturalSort(a.name, b.name);
    });

    if (defaultValue(sortRecursively, false)) {
        for (var i = 0; i < this.items.length; ++i) {
            var item = this.items[i];
            if (defined(item.sortItems)) {
                item.sortItems(sortRecursively);
            }
        }
    }
};

module.exports = CatalogGroup;

},{"../../third_party/cesium/Source/Core/RuntimeError":207,"../../third_party/cesium/Source/Core/clone":240,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/arraysAreEqual":4,"../Core/inherit":7,"../Core/runLater":13,"./CatalogMember":28,"./createCatalogMemberFromType":53,"./raiseErrorOnRejectedPromise":54,"javascript-natural-sort":1}],27:[function(require,module,exports){
'use strict';

/*global require,ga,$*/

var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var clone = require('../../third_party/cesium/Source/Core/clone');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var arraysAreEqual = require('../Core/arraysAreEqual');
var Metadata = require('./Metadata');
var CatalogMember = require('./CatalogMember');
var inherit = require('../Core/inherit');
var raiseErrorOnRejectedPromise = require('./raiseErrorOnRejectedPromise');
var runLater = require('../Core/runLater');

/**
 * A data item in a {@link CatalogGroup}.
 *
 * @alias CatalogItem
 * @constructor
 * @extends CatalogMember
 * @abstract
 *
 * @param {Application} application The application.
 */
var CatalogItem = function(application) {
    CatalogMember.call(this, application);

    this._enabledDate = undefined;
    this._shownDate = undefined;
    this._loadForEnablePromise = undefined;
    this._loadingPromise = undefined;
    this._lastLoadInfluencingValues = undefined;

    /**
     * The index of the item in the Now Viewing list.  Setting this property does not automatically change the order.
     * This property is used intenally to save/restore the Now Viewing order and is not intended for general use.
     * @private
     * @type {Number}
     */
    this.nowViewingIndex = undefined;

    /**
     * Gets or sets the geographic rectangle (extent or bounding box) containing this data item.  This property is observable.
     * @type {Rectangle}
     */
    this.rectangle = Rectangle.MAX_VALUE;

    /**
     * Gets or sets the URL of the legend for this data item, or undefined if this data item does not have a legend.
     * This property is observable.
     * @type {String}
     */
    this.legendUrl = undefined;

    /**
     * Gets or sets the type of the {@link CatalogItem#dataUrl}, or undefined if raw data for this data
     * source is not available.  This property is observable.
     * Valid values are:
     *  * `direct` - A direct link to the data.
     *  * `wfs` - A Web Feature Service (WFS) base URL.  If {@link CatalogItem#dataUrl} is not
     *            specified, the base URL will be this data item's URL.
     *  * `wfs-complete` - A complete, ready-to-use link to download features from a WFS server.
     *  * `none` - There is no data link.
     * @type {String}
     */
    this.dataUrlType = undefined;

    /**
     * Gets or sets the URL from which this data item's raw data can be retrieved, or undefined if raw data for
     * this data item is not available.  This property is observable.
     * @type {String}
     */
    this.dataUrl = undefined;

    /**
     * Gets or sets a description of the custodian of this data item.
     * This property is an HTML string that must be sanitized before display to the user.
     * This property is observable.
     * @type {String}
     */
    this.dataCustodian = undefined;

    /**
     * Gets or sets the URL from which this data item's metadata description can be retrieved, or undefined if
     * metadata is not available for this data item.  The format of the metadata depends on the type of data item.
     * For example, Web Map Service (WMS) data items provide their metadata via their GetCapabilities document.
     * This property is observable.
     * @type {String}
     */
    this.metadataUrl = undefined;

    /**
     * Gets or sets a value indicating whether this data item is enabled.  An enabled data item appears in the
     * "Now Viewing" pane, but is not necessarily shown on the map.  This property is observable.
     * @type {Boolean}
     */
    this.isEnabled = false;

    /**
     * Gets or sets a value indicating whether this data item is currently shown on the map.  In order to be shown,
     * the item must also be enabled.  This property is observable.
     * @type {Boolean}
     */
    this.isShown = false;

    /**
     * Gets or sets a value indicating whether the legend for this data item is currently visible.
     * This property is observable.
     * @type {Boolean}
     */
    this.isLegendVisible = true;

    /**
     * Gets or sets the clock parameters for this data item.  If this property is undefined, this data item
     * does not have any time-varying data.  This property is observable.
     * @type {DataSourceClock}
     */
    this.clock = undefined;

    /**
     * Gets or sets a value indicating whether this data source is currently loading.  This property is observable.
     * @type {Boolean}
     */
    this.isLoading = false;

    knockout.track(this, ['rectangle', 'legendUrl', 'dataUrlType', 'dataUrl', 'dataCustodian',
                          'metadataUrl', 'isEnabled', 'isShown', 'isLegendVisible', 'clock',
                          'isLoading']);

    knockout.getObservable(this, 'isEnabled').subscribe(function(newValue) {
        isEnabledChanged(this);
    }, this);

    knockout.getObservable(this, 'isShown').subscribe(function(newValue) {
        isShownChanged(this);
    }, this);
};

inherit(CatalogMember, CatalogItem);

var imageUrlRegex = /[.\/](png|jpg|jpeg|gif)/i;

defineProperties(CatalogItem.prototype, {
    /**
     * Gets a value indicating whether this data item, when enabled, can be reordered with respect to other data items.
     * Data items that cannot be reordered are typically displayed above reorderable data items.
     * @memberOf CatalogItem.prototype
     * @type {Boolean}
     */
    supportsReordering : {
        get : function() {
            return false;
        }
    },

    /**
     * Gets a value indicating whether the opacity of this data item can be changed.
     * @memberOf CatalogItem.prototype
     * @type {Boolean}
     */
    supportsOpacity : {
        get : function() {
            return false;
        }
    },

    /**
     * Gets a value indicating whether this data item has a legend.
     * @memberOf CatalogItem.prototype
     * @type {Boolean}
     */
    hasLegend : {
        get : function() {
            return defined(this.legendUrl) && this.legendUrl.length > 0;
        }
    },

    /**
     * Gets a value indicating whether this data item's legend is an image in a
     * browser-supported format such as JPEG, PNG, or GIF.
     * @memberOf CatalogItem.prototype
     * @type {Boolean}
     */
    legendIsImage : {
        get : function() {
            if (!defined(this.legendUrl) || this.legendUrl.length === 0) {
                return false;
            }

            return this.legendUrl.match(imageUrlRegex);
        }
    },

    /**
     * Gets the metadata associated with this data item and the server that provided it, if applicable.
     * @memberOf CatalogItem.prototype
     * @type {Metadata}
     */
    metadata : {
        get : function() {
            return CatalogItem.defaultMetadata;
        }
    },

    /**
     * Gets the set of functions used to update individual properties in {@link CatalogMember#updateFromJson}.
     * When a property name in the returned object literal matches the name of a property on this instance, the value
     * will be called as a function and passed a reference to this instance, a reference to the source JSON object
     * literal, and the name of the property.
     * @memberOf CatalogItem.prototype
     * @type {Object}
     */
    updaters : {
        get : function() {
            return CatalogItem.defaultUpdaters;
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf CatalogItem.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return CatalogItem.defaultSerializers;
        }
    },

    /**
     * Gets the set of names of the properties to be serialized for this object when {@link CatalogMember#serializeToJson} is called
     * and the `serializeForSharing` flag is set in the options.
     * @memberOf CatalogItem.prototype
     * @type {String[]}
     */
    propertiesForSharing : {
        get : function() {
            return CatalogItem.defaultPropertiesForSharing;
        }
    }
});

/**
 * Gets or sets the default metadata to use for data items that don't provide anything better from their
 * {@link CatalogItem#metadata} property.  The default simply indicates that no metadata is available.
 * @type {Metadata}
 */
CatalogItem.defaultMetadata = new Metadata();
CatalogItem.defaultMetadata.isLoading = false;
CatalogItem.defaultMetadata.dataSourceErrorMessage = 'This data item does not have any details available.';
CatalogItem.defaultMetadata.serviceErrorMessage = 'This service does not have any details available.';

freezeObject(CatalogItem.defaultMetadata);

/**
 * Gets or sets the set of default updater functions to use in {@link CatalogMember#updateFromJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#updaters} property.
 * @type {Object}
 */
CatalogItem.defaultUpdaters = clone(CatalogMember.defaultUpdaters);
CatalogItem.defaultUpdaters.rectangle = function(catalogItem, json, propertyName) {
    if (defined(json.rectangle)) {
        catalogItem.rectangle = Rectangle.fromDegrees(json.rectangle[0], json.rectangle[1], json.rectangle[2], json.rectangle[3]);
    } else {
        catalogItem.rectangle = Rectangle.MAX_VALUE;
    }
};

freezeObject(CatalogItem.defaultUpdaters);

/**
 * Gets or sets the set of default serializer functions to use in {@link CatalogMember#serializeToJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#serializers} property.
 * @type {Object}
 */
CatalogItem.defaultSerializers = clone(CatalogMember.defaultSerializers);
CatalogItem.defaultSerializers.rectangle = function(catalogItem, json, propertyName) {
    if (defined(catalogItem.rectangle)) {
        json.rectangle = [
            CesiumMath.toDegrees(catalogItem.rectangle.west),
            CesiumMath.toDegrees(catalogItem.rectangle.south),
            CesiumMath.toDegrees(catalogItem.rectangle.east),
            CesiumMath.toDegrees(catalogItem.rectangle.north)
        ];
    }
};

freezeObject(CatalogItem.defaultSerializers);

/**
 * Gets or sets the default set of properties that are serialized when serializing a {@link CatalogItem}-derived object with the
 * `serializeForSharing` flag set in the options.
 * @type {String[]}
 */
CatalogItem.defaultPropertiesForSharing = clone(CatalogMember.defaultPropertiesForSharing);
CatalogItem.defaultPropertiesForSharing.push('isEnabled');
CatalogItem.defaultPropertiesForSharing.push('isShown');
CatalogItem.defaultPropertiesForSharing.push('isLegendVisible');
CatalogItem.defaultPropertiesForSharing.push('nowViewingIndex');

freezeObject(CatalogItem.defaultPropertiesForSharing);

/**
 * Loads this catalog item, if it's not already loaded.  It is safe to
 * call this method multiple times.  The {@link CatalogItem#isLoading} flag will be set while the load is in progress.
 * Derived classes should implement {@link CatalogItem#_load} to perform the actual loading for the item.
 * Derived classes may optionally implement {@link CatalogItem#_getValuesThatInfluenceLoad} to provide an array containing
 * the current value of all properties that influence this item's load process.  Each time that {@link CatalogItem#load}
 * is invoked, these values are checked against the list of values returned last time, and {@link CatalogItem#_load} is
 * invoked again if they are different.  If {@link CatalogItem#_getValuesThatInfluenceLoad} is undefined or returns an
 * empty array, {@link CatalogItem#_load} will only be invoked once, no matter how many times
 * {@link CatalogItem#load} is invoked.
 *
 * @returns {Promise} A promise that resolves when the load is complete, or undefined if the item is already loaded.
 * 
 */
CatalogItem.prototype.load = function() {
    if (defined(this._loadingPromise)) {
        // Load already in progress.
        return this._loadingPromise;
    }

    var loadInfluencingValues = [];
    if (defined(this._getValuesThatInfluenceLoad)) {
        loadInfluencingValues = this._getValuesThatInfluenceLoad();
    }

    if (arraysAreEqual(loadInfluencingValues, this._lastLoadInfluencingValues)) {
        // Already loaded, and nothing has changed to force a re-load.
        return undefined;
    }

    this.isLoading = true;

    var that = this;
    this._loadingPromise = runLater(function() {
        that._lastLoadInfluencingValues = [];
        if (defined(that._getValuesThatInfluenceLoad)) {
            that._lastLoadInfluencingValues = that._getValuesThatInfluenceLoad();
        }

        return that._load();
    }).then(function() {
        that._loadingPromise = undefined;
        that.isLoading = false;
    }).otherwise(function(e) {
        that._lastLoadInfluencingValues = undefined;
        that._loadingPromise = undefined;
        that.isEnabled = false;
        that.isLoading = false;
        throw e;
    });

    return this._loadingPromise;
};

/**
 * When implemented in a derived class, this method loads the item.  The base class implementation does nothing.
 * This method should not be called directly; call {@link CatalogItem#load} instead.
 * @return {Promise} A promise that resolves when the load is complete.
 * @protected
 */
CatalogItem.prototype._load = function() {
    return when();
};

var emptyArray = freezeObject([]);

/**
 * When implemented in a derived class, gets an array containing the current value of all properties that
 * influence this item's load process.  See {@link CatalogItem#load} for more information on when and
 * how this is used.  The base class implementation returns an empty array.
 * @return {Array} The array of values that influence the load process.
 * @protected
 */
CatalogItem.prototype._getValuesThatInfluenceLoad = function() {
    // In the future, we can implement auto-reloading when any of these properties change.  Just create a knockout
    // computed property that calls this method and subscribe to change notifications on that computed property.
    // (Will need to use the rateLimit extender, presumably).
    return emptyArray;
};

/**
 * Toggles the {@link CatalogItem#isEnabled} property of this item.  If it is enabled, calling this method
 * will disable it.  If it is disabled, calling this method will enable it.
 *
 * @returns {Boolean} true if the item is now enabled, false if it is now disabled.
 */
 CatalogItem.prototype.toggleEnabled = function() {
    this.isEnabled = !this.isEnabled;
    return this.isEnabled;
};

/**
 * Toggles the {@link CatalogItem#isShown} property of this item.  If it is shown, calling this method
 * will hide it.  If it is hidden, calling this method will show it.
 *
 * @returns {Boolean} true if the item is now shown, false if it is now hidden.
 */
 CatalogItem.prototype.toggleShown = function() {
    this.isShown = !this.isShown;
    return this.isShown;
};

/**
 * Toggles the {@link CatalogItem#isLegendVisible} property of this item.  If it is visible, calling this
 * method will hide it.  If it is hidden, calling this method will make it visible.
 * @return {Boolean} true if the legend is now visible, false if it is now hidden.
 */
CatalogItem.prototype.toggleLegendVisible = function() {
    this.isLegendVisible = !this.isLegendVisible;
    return this.isLegendVisible;
};

var scratchRectangle = new Rectangle();

/**
 * Moves the camera so that the item's bounding rectangle is visible.  If {@link CatalogItem#rectangle} is
 * undefined or covers more than about half the world in the longitude direction, or if the data item is not enabled
 * or not shown, this method does nothing.  Because the zoom may happen asynchronously (for example, if the item's
 * rectangle is not yet known), this method returns a Promise that resolves when the zoom animation starts.
 * @returns {Promise} A promise that resolves when the zoom animation starts.
 */
 CatalogItem.prototype.zoomTo = function() {
    var that = this;
    return when(this.load(), function() {
        if (!defined(that.rectangle)) {
            return;
        }

        if (that.rectangle.east - that.rectangle.west > 3.14) {
            console.log('Extent is wider than half the world.  Ignoring zoomto');
            return;
        }

        ga('send', 'event', 'dataSource', 'zoomTo', that.name);

        var epsilon = CesiumMath.EPSILON3;

        var rect = Rectangle.clone(that.rectangle, scratchRectangle);

        if (rect.east - rect.west < epsilon) {
            rect.east += epsilon;
            rect.west -= epsilon;
        }

        if (rect.north - rect.south < epsilon) {
            rect.north += epsilon;
            rect.south -= epsilon;
        }


        var application = that.application;
        application.currentViewer.zoomTo(rect);
    });
};

/**
 * Uses the {@link CatalogItem#clock} settings from this data item.  If this data item
 * has no clock settings, this method does nothing.  Because the clock update may happen asynchronously
 * (for example, if the item's clock parameters are not yet known), this method returns a Promise that
 * resolves when the clock has been updated.
 * @returns {Promise} A promise that resolves when the clock has been updated.
 */
CatalogItem.prototype.useClock = function() {
    var that = this;
    return when(this.load(), function() {
        if (!defined(that.clock)) {
            return;
        }

        $('.cesium-viewer-animationContainer').css('visibility', 'visible');
        $('.cesium-viewer-timelineContainer').css('visibility', 'visible');

        that.clock.getValue(that.application.clock);

        if (defined(that.application.cesium)) {
            that.application.cesium.viewer.timeline.zoomTo(that.application.clock.startTime, that.application.clock.stopTime);
            that.application.cesium.viewer.forceResize();
        }

        if (defined(that.application.leaflet)) {
            that.application.leaflet.map.timeline.zoomTo(that.application.clock.startTime, that.application.clock.stopTime);
        }
    });
};

/**
 * Moves the camera so that the data item's bounding rectangle is visible, and updates the application clock according to this
 * data item's clock settings.  This method simply calls {@link CatalogItem#zoomTo} and
 * {@link CatalogItem#useClock}.  Because the zoom and clock update may happen asynchronously (for example, if the item's
 * rectangle is not yet known), this method returns a Promise that resolves when the zoom animation starts and the clock
 * has been updated.
 * @returns {Promise} A promise that resolves when the clock has been updated and the zoom animation has started.
 */
CatalogItem.prototype.zoomToAndUseClock = function() {
    return when.all([this.zoomTo(), this.useClock()]);
};

/**
 * Enables this data item on the globe or map.  This method:
 * * Should not be called directly.  Instead, set the {@link CatalogItem#isEnabled} property to true.
 * * Will not necessarily be called immediately when {@link CatalogItem#isEnabled} is set to true; it will be deferred until
 *   {@link CatalogItem#isLoading} is false.
 * * Should NOT also show the data item on the globe/map (see {@link CatalogItem#_show}), so in some cases it may not do
 *   anything at all.
 * * Calls {@link CatalogItem#_enableInCesium} or {@link CatalogItem#_enableInLeaflet} in the base-class implementation,
 *   depending on which viewer is active.  Derived classes that have identical enable logic for both viewers may override
 *   this method instead of the viewer-specific ones.
 * @protected
 */
CatalogItem.prototype._enable = function() {
    var application = this.application;

    if (defined(application.cesium)) {
        this._enableInCesium();
    }

    if (defined(application.leaflet)) {
        this._enableInLeaflet();
    }
};

/**
 * Disables this data item on the globe or map.  This method:
 * * Should not be called directly.  Instead, set the {@link CatalogItem#isEnabled} property to false.
 * * Will not be called if {@link CatalogItem#_enable} was not called (for example, because the previous call was deferred
 *   while the data item loaded, and the user disabled the data item before the load completed).
 * * Will only be called after {@link CatalogItem#_hide} when a shown data item is disabled.
 * * Calls {@link CatalogItem#_disableInCesium} or {@link CatalogItem#_disableInLeaflet} in the base-class implementation,
 *   depending on which viewer is active.  Derived classes that have identical disable logic for both viewers may override
 *   this method instead of the viewer-specific ones.
 * @protected
 */
CatalogItem.prototype._disable = function() {
    var application = this.application;

    if (defined(application.cesium)) {
        this._disableInCesium();
    }

    if (defined(application.leaflet)) {
        this._disableInLeaflet();
    }
};

/**
 * Shows this data item on the globe or map.  This method:
 * * Should not be called directly.  Instead, set the {@link CatalogItem#isShown} property to true.
 * * Will only be called after {@link CatalogItem#_enable}; you can count on that method having been called first.
 * * Will not necessarily be called immediately when {@link CatalogItem#isShown} is set to true; it will be deferred until
 *   {@link CatalogItem#isLoading} is false.
 * * Calls {@link CatalogItem#_showInCesium} or {@link CatalogItem#_showInLeaflet} in the base-class implementation,
 *   depending on which viewer is active.  Derived classes that have identical show logic for both viewers
 *    may override this method instead of the viewer-specific ones.
 * @protected
 */
CatalogItem.prototype._show = function() {
    var application = this.application;

    if (defined(application.cesium)) {
        this._showInCesium();
    }

    if (defined(application.leaflet)) {
        this._showInLeaflet();
    }
};

/**
 * Hides this data item on the globe or map.  This method:
 * * Should not be called directly.  Instead, set the {@link CatalogItem#isShown} property to false.
 * * Will not be called if {@link CatalogItem#_show} was not called (for example, because the previous call was deferred
 *   while the data item loaded, and the user hid the data item before the load completed).
 * * Calls {@link CatalogItem#_hideInCesium} or {@link CatalogItem#_hideInLeaflet} in the base-class implementation,
 *   depending on which viewer is active.  Derived classes that have identical hide logic for both viewers may override
 *   this method instead of the viewer-specific ones.
 * @protected
 */
CatalogItem.prototype._hide = function() {
    var application = this.application;

    if (defined(application.cesium)) {
        this._hideInCesium();
    }

    if (defined(application.leaflet)) {
        this._hideInLeaflet();
    }
};

/**
 * When implemented in a derived class, enables this data item on the Cesium globe.  You should not call this
 * directly, but instead set the {@link CatalogItem#isEnabled} property to true.  See
 * {@link CatalogItem#_enable} for more information.
 * @abstract
 * @protected
 */
CatalogItem.prototype._enableInCesium = function() {
    throw new DeveloperError('_enableInCesium must be implemented in the derived class.');
};

/**
 * When implemented in a derived class, disables this data item on the Cesium globe.  You should not call this
 * directly, but instead set the {@link CatalogItem#isEnabled} property to false.  See
 * {@link CatalogItem#_disable} for more information.
 * @abstract
 * @protected
 */
CatalogItem.prototype._disableInCesium = function() {
    throw new DeveloperError('_disableInCesium must be implemented in the derived class.');
};

/**
 * When implemented in a derived class, shows this data item on the Cesium globe.  You should not call this
 * directly, but instead set the {@link CatalogItem#isShown} property to true.  See
 * {@link CatalogItem#_show} for more information.
 * @abstract
 * @protected
 */
CatalogItem.prototype._showInCesium = function() {
    throw new DeveloperError('_showInCesium must be implemented in the derived class.');
};

/**
 * When implemented in a derived class, hides this data item on the Cesium globe.  You should not call this
 * directly, but instead set the {@link CatalogItem#isShown} property to false.  See
 * {@link CatalogItem#_hide} for more information.
 * @abstract
 * @protected
 */
CatalogItem.prototype._hideInCesium = function() {
    throw new DeveloperError('_hideInCesium must be implemented in the derived class.');
};

/**
 * When implemented in a derived class, enables this data item on the Leaflet map.  You should not call this
 * directly, but instead set the {@link CatalogItem#isEnabled} property to true.  See
 * {@link CatalogItem#_enable} for more information.
 * @abstract
 * @protected
 */
CatalogItem.prototype._enableInLeaflet = function() {
    throw new DeveloperError('enableInLeaflet must be implemented in the derived class.');
};

/**
 * When implemented in a derived class, disables this data item on the Leaflet map.  You should not call this
 * directly, but instead set the {@link CatalogItem#isEnabled} property to false.  See
 * {@link CatalogItem#_disable} for more information.
 * @abstract
 * @protected
 */
CatalogItem.prototype._disableInLeaflet = function() {
    throw new DeveloperError('disableInLeaflet must be implemented in the derived class.');
};

/**
 * When implemented in a derived class, shows this data item on the Leaflet map.  You should not call this
 * directly, but instead set the {@link CatalogItem#isShown} property to true.  See
 * {@link CatalogItem#_show} for more information.
 * @abstract
 * @protected
 */
CatalogItem.prototype._showInLeaflet = function() {
    throw new DeveloperError('_showInLeaflet must be implemented in the derived class.');
};

/**
 * When implemented in a derived class, hides this data item on the Leaflet map.  You should not call this
 * directly, but instead set the {@link CatalogItem#isShown} property to false.  See
 * {@link CatalogItem#_hide} for more information.
 * @abstract
 * @protected
 */
CatalogItem.prototype._hideInLeaflet = function() {
    throw new DeveloperError('_hideInLeaflet must be implemented in the derived class.');
};

function isEnabledChanged(catalogItem) {
    var application = catalogItem.application;

    if (catalogItem.isEnabled) {
        application.nowViewing.add(catalogItem);

        // Load this catalog item's data (if we haven't already) when it is enabled.
        // Don't actually enable until the load finishes.
        // Be careful not to call _enable multiple times or to call _enable
        // after the item has already been disabled.
        if (!defined(catalogItem._loadForEnablePromise)) {
            var resolvedOrRejected = false;

            var loadPromise = when(catalogItem.load(), function() {
                if (catalogItem.isEnabled) {
                    catalogItem._enable();
                }
            });

            raiseErrorOnRejectedPromise(catalogItem.application, loadPromise);

            loadPromise.always(function() {
                resolvedOrRejected = true;
                catalogItem._loadForEnablePromise = undefined;
            });

            // Make sure we know about it when the promise already resolved/rejected.
            catalogItem._loadForEnablePromise = resolvedOrRejected ? undefined : loadPromise;
        }

        catalogItem.isShown = true;

        ga('send', 'event', 'dataSource', 'added', catalogItem.name);
        catalogItem._enabledDate = Date.now();
    } else {
        catalogItem.isShown = false;

        // Disable this data item on the map, but only if the previous request to enable it has
        // actually gone through.
        if (!defined(catalogItem._loadForEnablePromise)) {
            catalogItem._disable();
        }

        application.nowViewing.remove(catalogItem);

        var duration;
        if (catalogItem._enabledDate) {
            duration = ((Date.now() - catalogItem._enabledDate) / 1000.0) | 0;
        }
        ga('send', 'event', 'dataSource', 'removed', catalogItem.name, duration);
    }

    catalogItem.application.currentViewer.notifyRepaintRequired();
}

function isShownChanged(catalogItem) {
    if (catalogItem.isShown) {
        // If the item is not enabled, do that first.  This way things will work even if isShown is
        // deserialized before isEnabled.
        catalogItem.isEnabled = true;

        // If enabling is waiting on an async load, we need to wait on it, too.
        when(catalogItem._loadForEnablePromise, function() {
            if (catalogItem.isEnabled && catalogItem.isShown) {
                catalogItem._show();
            }
        });

        ga('send', 'event', 'dataSource', 'shown', catalogItem.name);
        catalogItem._shownDate = Date.now();
    } else {
        // Hide this data item on the map, but only if the previous request to show it has
        // actually gone through.
        if (!defined(catalogItem._loadForEnablePromise)) {
            catalogItem._hide();
        }

        var duration;
        if (defined(catalogItem._shownDate)) {
            duration = ((Date.now() - catalogItem._shownDate) / 1000.0) | 0;
        } else if (catalogItem._enabledDate) {
            duration = ((Date.now() - catalogItem._enabledDate) / 1000.0) | 0;
        }
        ga('send', 'event', 'dataSource', 'hidden', catalogItem.name, duration);
    }

    catalogItem.application.currentViewer.notifyRepaintRequired();
}

module.exports = CatalogItem;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/clone":240,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/arraysAreEqual":4,"../Core/inherit":7,"../Core/runLater":13,"./CatalogMember":28,"./Metadata":39,"./raiseErrorOnRejectedPromise":54}],28:[function(require,module,exports){
'use strict';

/*global require*/

var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

/**
 * A member of a {@link CatalogGroup}.  A member may be a {@link CatalogItem} or a
 * {@link CatalogGroup}.
 *
 * @alias CatalogMember
 * @constructor
 * @abstract
 *
 * @param {Application} application The application.
 */
var CatalogMember = function(application) {
    if (!defined(application)) {
        throw new DeveloperError('application is required');
    }

    this._application = application;

    /**
     * Gets or sets the name of the item.  This property is observable.
     * @type {String}
     */
    this.name = 'Unnamed Item';

    /**
     * Gets or sets the description of the item.  This property is observable.
     * @type {String}
     */
    this.description = '';

    /**
     * Gets or sets a value indicating whether this member was supplied by the user rather than loaded from one of the
     * {@link Application#initSources}.  User-supplied members must be serialized completely when, for example,
     * serializing enabled members for sharing.  This property is observable.
     * @type {Boolean}
     * @default true
     */
    this.isUserSupplied = true;

    knockout.track(this, ['name', 'description', 'isUserSupplied']);
};

defineProperties(CatalogMember.prototype, {
    /**
     * Gets the type of data item represented by this instance.
     * @memberOf CatalogMember.prototype
     * @type {String}
     */
    type : {
        get : function() {
            throw new DeveloperError('Types derived from CatalogMember must implement a "type" property.');
        }
    },

    /**
     * Gets a human-readable name for this type of data source, such as 'Web Map Service (WMS)'.
     * @memberOf CatalogMember.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            throw new DeveloperError('Types derived from CatalogMember must implement a "typeName" property.');
        }
    },

    /**
     * Gets the application.
     * @memberOf CatalogMember.prototype
     * @type {Application}
     */
    application : {
        get : function() {
            return this._application;
        }
    },

    /**
     * Gets the set of functions used to update individual properties in {@link CatalogMember#updateFromJson}.
     * When a property name in the returned object literal matches the name of a property on this instance, the value
     * will be called as a function and passed a reference to this instance, a reference to the source JSON object
     * literal, and the name of the property.  If part of the update happens asynchronously, the updater function should
     * return a Promise that resolves when it is complete.
     * @memberOf CatalogMember.prototype
     * @type {Object}
     */
    updaters : {
        get : function() {
            return CatalogMember.defaultUpdaters;
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf CatalogMember.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return CatalogMember.defaultSerializers;
        }
    },

    /**
     * Gets the set of names of the properties to be serialized for this object when {@link CatalogMember#serializeToJson} is called
     * and the `serializeForSharing` flag is set in the options.
     * @memberOf CatalogMember.prototype
     * @type {String[]}
     */
    propertiesForSharing : {
        get : function() {
            return CatalogMember.defaultPropertiesForSharing;
        }
    }
});

/**
 * Gets or sets the set of default updater functions to use in {@link CatalogMember#updateFromJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#updaters} property.
 * @type {Object}
 */
CatalogMember.defaultUpdaters = {
};

freezeObject(CatalogMember.defaultUpdaters);

/**
 * Gets or sets the set of default serializer functions to use in {@link CatalogMember#serializeToJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#serializers} property.
 * @type {Object}
 */
CatalogMember.defaultSerializers = {
};

freezeObject(CatalogMember.defaultSerializers);

/**
 * Gets or sets the default set of properties that are serialized when serializing a {@link CatalogMember}-derived object with the
 * `serializeForSharing` flag set in the options.
 * @type {String[]}
 */
CatalogMember.defaultPropertiesForSharing = [
    'name'
];

freezeObject(CatalogMember.defaultPropertiesForSharing);

/**
 * Updates the catalog member from a JSON object-literal description of it.
 * Existing collections with the same name as a collection in the JSON description are
 * updated.  If the description contains a collection with a name that does not yet exist,
 * it is created.  Because parts of the update may happen asynchronously, this method
 * returns at Promise that will resolve when the update is completely done.
 *
 * @param {Object} json The JSON description.  The JSON should be in the form of an object literal, not a string.
 * @param {Object} [options] Object with the following properties:
 * @param {Boolean} [options.onlyUpdateExistingItems] true to only update existing items and never create new ones, or false is new items
 *                                                    may be created by this update.
 * @param {Boolean} [options.isUserSupplied] If specified, sets the {@link CatalogMember#isUserSupplied} property of updated catalog members
 *                                           to the given value.  If not specified, the property is left unchanged.
  * @returns {Promise} A promise that resolves when the update is complete.
*/
CatalogMember.prototype.updateFromJson = function(json, options) {
    if (defined(options) && defined(options.isUserSupplied)) {
        this.isUserSupplied = options.isUserSupplied;
    }

    var promises = [];

    for (var propertyName in this) {
        if (this.hasOwnProperty(propertyName) && defined(json[propertyName]) && propertyName.length > 0 && propertyName[0] !== '_') {
            if (this.updaters && this.updaters[propertyName]) {
                promises.push(this.updaters[propertyName](this, json, propertyName, options));
            } else {
                this[propertyName] = json[propertyName];
            }
        }
    }

    return when.all(promises);
};

/**
 * Serializes the data item to JSON.
 *
 * @param {Object} [options] Object with the following properties:
 * @param {Boolean} [options.enabledItemsOnly=false] true if only enabled data items (and their groups) should be serialized,
 *                  or false if all data items should be serialized.
 * @param {CatalogMember[]} [options.itemsSkippedBecauseTheyAreNotEnabled] An array that, if provided, is populated on return with
 *        all of the data items that were not serialized because they were not enabled.  The array will be empty if
 *        options.enabledItemsOnly is false.
 * @param {Boolean} [options.skipItemsWithLocalData=false] true if items with a serializable 'data' property should be skipped entirely.
 *                  This is useful to avoid creating a JSON data structure with potentially very large embedded data.
 * @param {CatalogMember[]} [options.itemsSkippedBecauseTheyHaveLocalData] An array that, if provided, is populated on return
 *        with all of the data items that were not serialized because they have a serializable 'data' property.  The array will be empty
 *        if options.skipItemsWithLocalData is false.
 * @param {Boolean} [options.serializeForSharing=false] true to only serialize properties that are typically necessary for sharing this member
 *                                                      with other users, such as {@link CatalogGroup#isOpen}, {@link CatalogItem#isEnabled},
 *                                                      {@link CatalogItem#isLegendVisible}, and {@link ImageryLayerCatalogItem#opacity},
 *                                                      rather than serializing all properties needed to completely recreate the catalog.  The set of properties
 *                                                      that is serialized when this property is true is given by each model's
 *                                                      {@link CatalogMember#propertiesForSharing} property.
 * @param {Boolean} [options.userSuppliedOnly=false] true to only serialize catalog members (and their containing groups) that have been identified as having been
 *                  supplied by the user ({@link CatalogMember#isUserSupplied} is true); false to serialize all catalog members.
 * @return {Object} The serialized JSON object-literal.
 */
CatalogMember.prototype.serializeToJson = function(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);

    var enabledItemsOnly = defaultValue(options.enabledItemsOnly, false);

    if (defaultValue(options.userSuppliedOnly, false) && !this.isUserSupplied) {
        return undefined;
    }

    if (enabledItemsOnly && this.isEnabled === false) {
        if (defined(options.itemsSkippedBecauseTheyAreNotEnabled)) {
            options.itemsSkippedBecauseTheyAreNotEnabled.push(this);
        }
        return undefined;
    }

    if (defaultValue(options.skipItemsWithLocalData, false) && defined(this.data)) {
        if (defined(options.itemsSkippedBecauseTheyHaveLocalData)) {
            options.itemsSkippedBecauseTheyHaveLocalData.push(this);
        }
        return undefined;
    }

    var result = {};

    var filterFunction = function() { return true; };
    if (options.serializeForSharing) {
        var that = this;
        filterFunction = function(propertyName) {
            return that.propertiesForSharing.indexOf(propertyName) >= 0;
        };
    } else {
        result.type = this.type;
    }

    var promises = [];

    for (var propertyName in this) {
        if (this.hasOwnProperty(propertyName) && propertyName.length > 0 && propertyName[0] !== '_' && filterFunction(propertyName)) {
            if (this.serializers && this.serializers[propertyName]) {
                promises.push(this.serializers[propertyName](this, result, propertyName, options));
            } else {
                result[propertyName] = this[propertyName];
            }
        }
    }

    // Only serialize a group if the group has items in it.
    if (enabledItemsOnly && defined(this.items) && (!defined(result.items) || result.items.length === 0)) {
        return undefined;
    }

    return result;
};

module.exports = CatalogMember;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596}],29:[function(require,module,exports){
'use strict';

/*global require*/
var CameraFlightPath = require('../../third_party/cesium/Source/Scene/CameraFlightPath');
var Cartesian2 = require('../../third_party/cesium/Source/Core/Cartesian2');
var Cartesian3 = require('../../third_party/cesium/Source/Core/Cartesian3');
var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var destroyObject = require('../../third_party/cesium/Source/Core/destroyObject');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var Ellipsoid = require('../../third_party/cesium/Source/Core/Ellipsoid');
var getTimestamp = require('../../third_party/cesium/Source/Core/getTimestamp');
var JulianDate = require('../../third_party/cesium/Source/Core/JulianDate');
var Matrix4 = require('../../third_party/cesium/Source/Core/Matrix4');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var Cesium = function(application, viewer) {
    /**
     * Gets or sets the Cesium {@link Viewer} instance.
     * @type {Viewer}
     */
    this.viewer = viewer;

    /**
     * Gets or sets the Cesium {@link Scene} instance.
     * @type {Scene}
     */
    this.scene = viewer.scene;


    /**
     * Gets or sets whether the viewer has stopped rendering since startup or last set to false.
     * @type {Scene}
     */
    this.stoppedRendering = false;


    this._lastClockTime = new JulianDate(0, 0.0);
    this._lastCameraViewMatrix = new Matrix4();
    this._lastCameraMoveTime = 0;

    this._removePostRenderListener = this.scene.postRender.addEventListener(postRender.bind(undefined, this));
    this._removeInfoBoxCloseListener = undefined;
    this._boundNotifyRepaintRequired = this.notifyRepaintRequired.bind(this);

    // Force a repaint when the mouse moves or the window changes size.
    this.viewer.canvas.addEventListener('mousemove', this._boundNotifyRepaintRequired, false);
    this.viewer.canvas.addEventListener('mousedown', this._boundNotifyRepaintRequired, false);
    this.viewer.canvas.addEventListener('mouseup', this._boundNotifyRepaintRequired, false);
    window.addEventListener('resize', this._boundNotifyRepaintRequired, false);

    // Force a repaint when the feature info box is closed.  Cesium can't close its info box
    // when the clock is not ticking, for reasons that are not clear.
    if (defined(this.viewer.infoBox)) {
        this._removeInfoBoxCloseListener = this.viewer.infoBox.viewModel.closeClicked.addEventListener(this._boundNotifyRepaintRequired);
    }
};

Cesium.prototype.destroy = function() {
    if (defined(this._removePostRenderListener)) {
        this._removePostRenderListener();
        this._removePostRenderListener = undefined;
    }

    if (defined(this._removeInfoBoxCloseListener)) {
        this._removeInfoBoxCloseListener();
    }

    this.viewer.canvas.removeEventListener('mousemove', this._boundNotifyRepaintRequired, false);
    this.viewer.canvas.removeEventListener('mousedown', this._boundNotifyRepaintRequired, false);
    this.viewer.canvas.removeEventListener('mouseup', this._boundNotifyRepaintRequired, false);

    window.removeEventListener('resize', this._boundNotifyRepaintRequired, false);

    return destroyObject(this);
};

var cartesian3Scratch = new Cartesian3();

/**
 * Gets the current extent of the camera.  This may be approximate if the viewer does not have a strictly rectangular view.
 * @return {Rectangle} The current visible extent.
 */
Cesium.prototype.getCurrentExtent = function() {
    var scene = this.scene;

    var width = scene.canvas.clientWidth;
    var height = scene.canvas.clientHeight;

    var centerOfScreen = new Cartesian2(width / 2.0, height / 2.0);
    var pickRay = scene.camera.getPickRay(centerOfScreen);
    var focus = scene.globe.pick(pickRay, scene);

    var focusCartographic = Ellipsoid.WGS84.cartesianToCartographic(focus);

    var distance = Cartesian3.magnitude(Cartesian3.subtract(focus, scene.camera.position, cartesian3Scratch));
    var offset = CesiumMath.toRadians(distance * 2.5e-6);

    var longitude = focusCartographic.longitude;
    var latitude = focusCartographic.latitude;
    return new Rectangle(longitude - offset, latitude - offset, longitude + offset, latitude + offset);
};

/**
 * Zooms to a specified extent with a smooth flight animation.
 *
 * @param {Rectangle} extent The extent to which to zoom.
 * @param {Number} [flightDurationSeconds=3.0] The length of the flight animation in seconds.
 */
Cesium.prototype.zoomTo = function(extent, flightDurationSeconds) {
    if (!defined(extent)) {
        throw new DeveloperError('extent is required.');
    }

    var flight = CameraFlightPath.createTweenRectangle(this.scene, {
        destination : extent,
        duration : defaultValue(flightDurationSeconds, 3.0)
    });
    this.scene.tweens.add(flight);

    this.notifyRepaintRequired();
};

/**
 * Captures a screenshot of the map.
 * @return {Promise} A promise that resolves to a data URL when the screenshot is ready.
 */
Cesium.prototype.captureScreenshot = function() {
    var deferred = when.defer();

    var removeCallback = this.scene.postRender.addEventListener(function() {
        removeCallback();
        try {
            deferred.resolve(this.scene.canvas.toDataURL('image/jpeg'));
        } catch (e) {
            deferred.reject(e);
        }
    }, this);

    this.notifyRepaintRequired();

    return deferred.promise;
};

/**
 * Notifies the viewer that a repaint is required.
 */
Cesium.prototype.notifyRepaintRequired = function() {
    if (!this.viewer.useDefaultRenderLoop) {
        console.log('starting rendering @ ' + getTimestamp());
    }
    this._lastCameraMoveTime = getTimestamp();
    this.viewer.useDefaultRenderLoop = true;
};

function postRender(cesium, date) {
    // We can safely stop rendering when:
    //  - the camera position hasn't changed in over a second,
    //  - there are no tiles waiting to load, and
    //  - the clock is not animating

    var now = getTimestamp();

    var scene = cesium.scene;

    if (!Matrix4.equals(cesium._lastCameraViewMatrix, scene.camera.viewMatrix)) {
        cesium._lastCameraMoveTime = now;
    }

    var cameraMovedInLastSecond = now - cesium._lastCameraMoveTime < 1000;

    var surface = scene.globe._surface;
    var tilesWaiting = !surface._tileProvider.ready || surface._tileLoadQueue.length > 0 || surface._debug.tilesWaitingForChildren > 0;

    if (!cameraMovedInLastSecond && !tilesWaiting && !cesium.viewer.clock.shouldAnimate) {
        console.log('stopping rendering @ ' + getTimestamp());
        cesium.viewer.useDefaultRenderLoop = false;
        cesium.stoppedRendering = true;
    }

    Matrix4.clone(scene.camera.viewMatrix, cesium._lastCameraViewMatrix);
}

module.exports = Cesium;

},{"../../third_party/cesium/Source/Core/Cartesian2":101,"../../third_party/cesium/Source/Core/Cartesian3":102,"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/Ellipsoid":130,"../../third_party/cesium/Source/Core/JulianDate":168,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/Matrix4":177,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/destroyObject":247,"../../third_party/cesium/Source/Core/getTimestamp":252,"../../third_party/cesium/Source/Scene/CameraFlightPath":378,"../../third_party/cesium/Source/ThirdParty/when":596}],30:[function(require,module,exports){
'use strict';

/*global require,URI,$*/

var clone = require('../../third_party/cesium/Source/Core/clone');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadJson = require('../../third_party/cesium/Source/Core/loadJson');
var loadText = require('../../third_party/cesium/Source/Core/loadText');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var corsProxy = require('../Core/corsProxy');
var ModelError = require('./ModelError');
var CatalogGroup = require('./CatalogGroup');
var inherit = require('../Core/inherit');
var WebMapServiceCatalogItem = require('./WebMapServiceCatalogItem');
var ArcGisMapServerCatalogItem = require('./ArcGisMapServerCatalogItem');

/**
 * A {@link CatalogGroup} representing a collection of layers from a [CKAN](http://ckan.org) server.
 *
 * @alias CkanCatalogGroup
 * @constructor
 * @extends CatalogGroup
 * 
 * @param {Application} application The application.
 */
var CkanCatalogGroup = function(application) {
    CatalogGroup.call(this, application, 'ckan');

    /**
     * Gets or sets the URL of the CKAN server.  This property is observable.
     * @type {String}
     */
    this.url = '';

    /**
     * Gets or sets a description of the custodian of the data sources in this group.
     * This property is an HTML string that must be sanitized before display to the user.
     * This property is observable.
     * @type {String}
     */
    this.dataCustodian = undefined;

    /**
     * Gets or sets the filter query to pass to CKAN when querying the available data sources and their groups.  Each string in the 
     * array is passed to CKAN as an independent search string and the results are concatenated to create the complete list.  The
     * search string is equivlent to what would be in the parameters segment of the url calling the CKAN search api.
     * See the [Solr documentation](http://wiki.apache.org/solr/CommonQueryParameters#fq) for information about filter queries.
     *   To get all the datasets with wms resources the query array would be ['fq=res_format%3awms']
     *   To get all the datasets in the Surface Water group it would be ['q=groups%3dSurface%20Water&fq=res_format%3aWMS']
     *   And to get both wms and esri-mapService datasets it would be ['q=res_format:WMS', 'q=res_format:%22Esri%20REST%22' ]
     * This property is observable.
     * @type {String[]}
     */
    this.filterQuery = undefined;

    /**
     * Gets or sets a hash of names of blacklisted groups and data sources.  A group or data source that appears in this hash
     * will not be shown to the user.  In this hash, the keys should be the names of the groups and data sources to blacklist,
     * and the values should be "true".  This property is observable.
     * @type {Object}
     */
    this.blacklist = undefined;

    /**
     * Gets or sets a value indicating whether the CKAN datasets should be filtered by querying GetCapabilities from each
     * referenced WMS server and excluding datasets not found therein.  This property is observable.
     * @type {Boolean}
     */
    this.filterByWmsGetCapabilities = false;

    /**
     * Gets or sets the minimum MaxScaleDenominator that is allowed for a WMS dataset to be included in this CKAN group.
     * If this property is undefined or if {@link CkanCatalogGroup#filterByWmsGetCapabilities} is false, no
     * filtering based on MaxScaleDenominator is performed.  This property is observable.
     * @type {Number}
     */
    this.minimumMaxScaleDenominator = undefined;

    /**
     * Gets or sets any extra wms parameters that should be added to the wms query urls in this CKAN group.
     * If this property is undefined then no extra parameters are added.
     * This property is observable.
     * @type {Object}
     */
    this.wmsParameters = undefined;

    knockout.track(this, ['url', 'dataCustodian', 'filterQuery', 'blacklist', 'wmsParameters']);
};

inherit(CatalogGroup, CkanCatalogGroup);

defineProperties(CkanCatalogGroup.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf CkanCatalogGroup.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'ckan';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, such as 'Web Map Service (WMS)'.
     * @memberOf CkanCatalogGroup.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'CKAN Server';
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf CkanCatalogGroup.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return CkanCatalogGroup.defaultSerializers;
        }
    }
});

/**
 * Gets or sets the set of default serializer functions to use in {@link CatalogMember#serializeToJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#serializers} property.
 * @type {Object}
 */
CkanCatalogGroup.defaultSerializers = clone(CatalogGroup.defaultSerializers);

CkanCatalogGroup.defaultSerializers.items = function(ckanGroup, json, propertyName, options) {
    // Only serialize minimal properties in contained items, because other properties are loaded from CKAN.
    var previousSerializeForSharing = options.serializeForSharing;
    options.serializeForSharing = true;

    // Only serlize enabled items as well.  This isn't quite right - ideally we'd serialize any
    // property of any item if the property's value is changed from what was loaded from CKAN -
    // but this gives us reasonable results for sharing and is a lot less work than the ideal
    // solution.
    var previousEnabledItemsOnly = options.enabledItemsOnly;
    options.enabledItemsOnly = true;

    var result = CatalogGroup.defaultSerializers.items(ckanGroup, json, propertyName, options);

    options.enabledItemsOnly = previousEnabledItemsOnly;
    options.serializeForSharing = previousSerializeForSharing;

    return result;
};

CkanCatalogGroup.defaultSerializers.isLoading = function(ckanGroup, json, propertyName, options) {};

freezeObject(CkanCatalogGroup.defaultSerializers);

CkanCatalogGroup.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url, this.filterQuery, this.blacklist, this.filterByWmsGetCapabilities, this.minimumMaxScaleDenominator];
};

CkanCatalogGroup.prototype._load = function() {
    if (!defined(this.url) || this.url.length === 0) {
        return undefined;
    }

    var that = this;

    var promises = [];
    for (var i = 0; i < this.filterQuery.length; i++) {
        var url = cleanAndProxyUrl(this.application, this.url) + '/api/3/action/package_search?rows=100000&' + this.filterQuery[i];

        var promise = loadJson(url);

        promises.push(promise);
    }

    return when.all(promises).then( function(queryResults) {
        if (!defined(queryResults)) {
            return;
        }
        var allResults = queryResults[0];
        for (var p = 1; p < queryResults.length; p++) {
            allResults.result.results = allResults.result.results.concat(queryResults[p].result.results);
        }

        if (that.filterByWmsGetCapabilities) {
            return when(filterResultsByGetCapabilities(that, allResults), function() {
                populateGroupFromResults(that, allResults);
            });
        } else {
            populateGroupFromResults(that, allResults);
        }
    }).otherwise(function() {
        throw new ModelError({
            sender: that,
            title: 'Group is not available',
            message: '\
An error occurred while invoking package_search on the CKAN server.  \
<p>If you entered the link manually, please verify that the link is correct.</p>\
<p>This error may also indicate that the server does not support <a href="http://enable-cors.org/" target="_blank">CORS</a>.  If this is your \
server, verify that CORS is enabled and enable it if it is not.  If you do not control the server, \
please contact the administrator of the server and ask them to enable CORS.  Or, contact the National \
Map team by emailing <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a> \
and ask us to add this server to the list of non-CORS-supporting servers that may be proxied by \
National Map itself.</p>\
<p>If you did not enter this link manually, this error may indicate that the group you opened is temporarily unavailable or there is a \
problem with your internet connection.  Try opening the group again, and if the problem persists, please report it by \
sending an email to <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.</p>'
        });
    });
};

// The "format" field of CKAN resources must match this regular expression to be considered a WMS resource.
var wmsFormatRegex = /^wms$/i;
var esriRestFormatRegex = /^esri rest$/i;

function filterResultsByGetCapabilities(ckanGroup, json) {
    var wmsServers = {};

    var items = json.result.results;
    for (var itemIndex = 0; itemIndex < items.length; ++itemIndex) {
        var item = items[itemIndex];

        var resources = item.resources;
        for (var resourceIndex = 0; resourceIndex < resources.length; ++resourceIndex) {
            var resource = resources[resourceIndex];
            if (!resource.format.match(wmsFormatRegex)) {
                continue;
            }

            var wmsUrl = resource.wms_url;
            if (!defined(wmsUrl)) {
                wmsUrl = resource.url;
                if (!defined(wmsUrl)) {
                    continue;
                }
            }

            // Extract the layer name from the WMS URL.
            var uri = new URI(wmsUrl);
            var params = uri.search(true);
            var layerName = params.LAYERS;

            // Remove the query portion of the WMS URL.
            uri.search('');
            var url = uri.toString();

            if (!defined(wmsServers[url])) {
                wmsServers[url] = {};
            }

            wmsServers[url][layerName] = resource;
        }
    }

    var promises = [];

    for (var wmsServer in wmsServers) {
        if (wmsServers.hasOwnProperty(wmsServer)) {
            var getCapabilitiesUrl = wmsServer + '?service=WMS&request=GetCapabilities';
            if (corsProxy.shouldUseProxy(getCapabilitiesUrl)) {
                getCapabilitiesUrl = corsProxy.getURL(getCapabilitiesUrl, '1d');
            }

            promises.push(filterBasedOnGetCapabilities(ckanGroup, getCapabilitiesUrl, wmsServers[wmsServer]));
        }
    }

    return when.all(promises);
}

function filterBasedOnGetCapabilities(ckanGroup, getCapabilitiesUrl, resources) {
    // Initially assume all resources will be filtered.
    for (var name in resources) {
        if (resources.hasOwnProperty(name)) {
            resources[name].__filtered = true;
        }
    }

    return loadText(getCapabilitiesUrl).then(function(getCapabilitiesXml) {
        var getCapabilitiesJson = $.xml2json(getCapabilitiesXml);
        filterBasedOnGetCapabilitiesResponse(ckanGroup, getCapabilitiesJson.Capability.Layer, resources);
    }).otherwise(function() {
        // Do nothing - all resources will be filtered.
    });
}

function filterBasedOnGetCapabilitiesResponse(ckanGroup, wmsLayersSource, resources) {
    if (defined(wmsLayersSource) && !(wmsLayersSource instanceof Array)) {
        wmsLayersSource = [wmsLayersSource];
    }

    for (var i = 0; i < wmsLayersSource.length; ++i) {
        var layerSource = wmsLayersSource[i];

        if (layerSource.Name) {
            var resource = resources[layerSource.Name];
            if (resource) {
                if (!defined(ckanGroup.minimumMaxScaleDenominator) || !defined(layerSource.MaxScaleDenominator) || layerSource.MaxScaleDenominator >= ckanGroup.minimumMaxScaleDenominator) {
                    resource.__filtered = false;
                }
                else {
                    console.log('Provider Feedback: Filtering out ' + layerSource.Title + ' (' + layerSource.Name + ') because its MaxScaleDenominator is ' + layerSource.MaxScaleDenominator);
                }
            }
        }

        if (layerSource.Layer) {
            filterBasedOnGetCapabilitiesResponse(ckanGroup, layerSource.Layer, resources);
        }
    }
}

function populateGroupFromResults(ckanGroup, json) {
    var items = json.result.results;
    for (var itemIndex = 0; itemIndex < items.length; ++itemIndex) {
        var item = items[itemIndex];

        if (ckanGroup.blacklist && ckanGroup.blacklist[item.title]) {
            console.log('Provider Feedback: Filtering out ' + item.title + ' (' + item.name + ') because it is blacklisted.');
            continue;
        }

        var textDescription = '';

        if (item.notes) {
            textDescription = item.notes.replace(/\n/g, '<br/>');
        }

        if (item.license_url && (item.notes === null || item.notes.indexOf('[Licence]') === -1)) {
            textDescription += '<br/>[Licence](' + item.license_url + ')';
        }

        var extras = {};
        if (defined(item.extras)) {
            for (var idx = 0; idx < item.extras.length; idx++) {
                extras[item.extras[idx].key] = item.extras[idx].value;
            }
        }

        var dataUrl = extras.data_url;
        var dataUrlType = extras.data_url_type;

        var rectangle;
        var bboxString = item.geo_coverage || extras.geo_coverage;
        if (defined(bboxString)) {
            var parts = bboxString.split(',');
            if (parts.length === 4) {
                rectangle = Rectangle.fromDegrees(parts[0], parts[1], parts[2], parts[3]);
            }
        }

        // Currently, we support WMS and Esri REST layers.
        var resources = item.resources;
        for (var resourceIndex = 0; resourceIndex < resources.length; ++resourceIndex) {
            var resource = resources[resourceIndex];
            if (resource.__filtered || (!resource.format.match(wmsFormatRegex) && !resource.format.match(esriRestFormatRegex))) {
                continue;
            }

            var wmsUrl = resource.wms_url;
            if (!defined(wmsUrl)) {
                wmsUrl = resource.url;
                if (!defined(wmsUrl)) {
                    continue;
                }
            }

            // Extract the layer name from the WMS URL.
            var uri = new URI(wmsUrl);
            var params = uri.search(true);
            var layerName = params.LAYERS || params.layers;

            // Remove the query portion of the WMS URL.
            uri.search('');
            var url = uri.toString();

            var newItem;
            if (resource.format.match(esriRestFormatRegex)) {
                newItem = new ArcGisMapServerCatalogItem(ckanGroup.application);
            } else {
                newItem = new WebMapServiceCatalogItem(ckanGroup.application);
            }
            newItem.name = item.title;
            newItem.description = textDescription;
            newItem.url = url;
            newItem.layers = layerName;
            newItem.rectangle = rectangle;
            newItem.dataUrl = dataUrl;
            newItem.dataUrlType = dataUrlType;
              //This should be deprecated and done on a server by server basis when feasible
            newItem.parameters = ckanGroup.wmsParameters;

            if (defined(ckanGroup.dataCustodian)) {
                newItem.dataCustodian = ckanGroup.dataCustodian;
            } else if (item.organization && item.organization.title) {
                newItem.dataCustodian = item.organization.description || item.organization.title;
            }

            var groups = item.groups;
            for (var groupIndex = 0; groupIndex < groups.length; ++groupIndex) {
                var group = groups[groupIndex];

                if (ckanGroup.blacklist && ckanGroup.blacklist[group.display_name]) {
                    continue;
                }

                var existingGroup = ckanGroup.findFirstItemByName(group.display_name);
                if (!defined(existingGroup)) {
                    existingGroup = new CatalogGroup(ckanGroup.application);
                    existingGroup.name = group.display_name;
                    ckanGroup.add(existingGroup);
                }

                existingGroup.add(newItem);
            }
        }
    }

    function compareNames(a, b) {
        var aName = a.name.toLowerCase();
        var bName = b.name.toLowerCase();
        if (aName < bName) {
            return -1;
        } else if (aName > bName) {
            return 1;
        } else {
            return 0;
        }
    }

    ckanGroup.items.sort(compareNames);

    for (var i = 0; i < ckanGroup.items.length; ++i) {
        ckanGroup.items[i].items.sort(compareNames);
    }
}

function cleanAndProxyUrl(application, url) {
    // Strip off the search portion of the URL
    var uri = new URI(url);
    uri.search('');

    var cleanedUrl = uri.toString();
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(cleanedUrl)) {
        cleanedUrl = application.corsProxy.getURL(cleanedUrl, '1d');
    }

    return cleanedUrl;
}

module.exports = CkanCatalogGroup;

},{"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/clone":240,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/Core/loadJson":261,"../../third_party/cesium/Source/Core/loadText":262,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/corsProxy":5,"../Core/inherit":7,"./ArcGisMapServerCatalogItem":23,"./CatalogGroup":26,"./ModelError":41,"./WebMapServiceCatalogItem":49}],31:[function(require,module,exports){
'use strict';

/*global require*/
var defined = require('../../third_party/cesium/Source/Core/defined');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var CatalogItem = require('./CatalogItem');

/**
 * A {@link CatalogItem} composed of multiple other catalog items.  When this item is enabled or shown, the composed items are
 * enabled or shown as well.  Other properties, including {@link CatalogItem#rectangle},
 * {@link CatalogItem#clock}, and {@link CatalogItem#legendUrl}, are not composed in any way, so you should manually set those
 * properties on this object as appropriate.
 *
 * @alias CompositeCatalogItem
 * @constructor
 * @extends CatalogItem
 * 
 * @param {Application} application The application.
 * @param {CatalogItem[]} [items] The items to compose.
 */
var CompositeCatalogItem = function(application, items) {
	CatalogItem.call(this, application);

	this.items = defined(items) ? items.slice() : [];

	knockout.track(this, ['items']);

	knockout.getObservable(this, 'items').subscribe(function() {
		for (var i = 0; i < this.items.length; ++i) {
			this.items[i].showInNowViewingWhenEnabled = false;
		}
	}, this);
};

CompositeCatalogItem.prototype._load = function() {
	return when.all(this.items.map(function(item) { return item.load(); }));
};

CompositeCatalogItem.prototype._getValuesThatInfluenceLoad = function() {
	var result = [];

	for (var i = 0; i < this.items.length; ++i) {
		result.push.apply(result, this.items[i]._getValuesThatInfluenceLoad());
	}

	return result;
};

CompositeCatalogItem.prototype._enable = function() {
	for (var i = 0; i < this.items.length; ++i) {
		this.items[i]._enable();
	}
};

CompositeCatalogItem.prototype._disable = function() {
	for (var i = 0; i < this.items.length; ++i) {
		this.items[i]._disable();
	}
};

CompositeCatalogItem.prototype._show = function() {
	for (var i = 0; i < this.items.length; ++i) {
		this.items[i]._show();
	}
};

CompositeCatalogItem.prototype._hide = function() {
	for (var i = 0; i < this.items.length; ++i) {
		this.items[i]._hide();
	}
};

CompositeCatalogItem.prototype.lowerToBottom = function() {
	for (var i = this.items.length - 1; i >= 0; --i) {
		var item = this.items[i];
		if (defined(item.lowerToBottom)) {
			item.lowerToBottom();
		}
	}
};

module.exports = CompositeCatalogItem;

},{"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"./CatalogItem":27}],32:[function(require,module,exports){
'use strict';

/*global require,L,$*/

var combine = require('../../third_party/cesium/Source/Core/combine');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadText = require('../../third_party/cesium/Source/Core/loadText');
var when = require('../../third_party/cesium/Source/ThirdParty/when');
var corsProxy = require('../Core/corsProxy');

var TableDataSource = require('../Map/TableDataSource');
var VarType = require('../Map/VarType');

var Metadata = require('./Metadata');
var ModelError = require('./ModelError');
var CatalogItem = require('./CatalogItem');
var inherit = require('../Core/inherit');
var readText = require('../Core/readText');

var WebMapServiceImageryProvider = require('../../third_party/cesium/Source/Scene/WebMapServiceImageryProvider');
var WebMapServiceCatalogItem = require('./WebMapServiceCatalogItem');
var ImageryLayer = require('../../third_party/cesium/Source/Scene/ImageryLayer');

/**
 * A {@link CatalogItem} representing CSV data.
 *
 * @alias CsvCatalogItem
 * @constructor
 * @extends CatalogItem
 * 
 * @param {Application} application The application.
 * @param {String} [url] The URL from which to retrieve the CSV data.
 */
var CsvCatalogItem = function(application, url) {
    CatalogItem.call(this, application);

    this._tableDataSource = undefined;
    this._regionMapped = false;

    /**
     * Gets or sets the URL from which to retrieve CSV data.  This property is ignored if
     * {@link GeoJsonCatalogItem#data} is defined.  This property is observable.
     * @type {String}
     */
    this.url = url;

    /**
     * Gets or sets the CSV data, represented as a binary Blob, a string, or a Promise for one of those things.
     * This property is observable.
     * @type {Blob|String|Promise}
     */
    this.data = undefined;


    /**
     * Gets or sets the URL from which the {@link CsvCatalogItem#data} was obtained.
     * @type {String}
     */
    this.dataSourceUrl = undefined;

    knockout.track(this, ['url', 'data', 'dataSourceUrl']);
};

inherit(CatalogItem, CsvCatalogItem);

defineProperties(CsvCatalogItem.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf CsvCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'csv';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'CSV'.
     * @memberOf CsvCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Comma-Separated Values (CSV)';
        }
    },

    /**
     * Gets the metadata associated with this data source and the server that provided it, if applicable.
     * @memberOf CsvCatalogItem.prototype
     * @type {Metadata}
     */
    metadata : {  //TODO: return metadata if tableDataSource defined
        get : function() {
            var result = new Metadata();
            result.isLoading = false;
            result.dataSourceErrorMessage = 'This data source does not have any details available.';
            result.serviceErrorMessage = 'This service does not have any details available.';
            return result;
        }
    }
});

CsvCatalogItem.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url, this.data];
};

CsvCatalogItem.prototype._load = function() {
    if (defined(this._tableDataSource)) {
        this._tableDataSource.destroy();
    }

    this._tableDataSource = new TableDataSource();

    var that = this;

    if (defined(this.data)) {
        return when(that.data, function(data) {
            if (data instanceof Blob) {
                return readText(data).then(function(text) {
                    return loadTable(that, text);
                });
            } else if (data instanceof String) {
                return loadTable(that, data);
            } else {
                throw new ModelError({
                    sender: that,
                    title: 'Unexpected type of CSV data',
                    message: '\
CsvCatalogItem.data is expected to be a Blob, File, or String, but it was not any of these. \
This may indicate a bug in National Map or incorrect use of the National Map API. \
If you believe it is a bug in National Map, please report it by emailing \
<a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.'
                });
            }
        });
    } else if (defined(that.url)) {
        return loadText(proxyUrl(that.application, that.url)).then(function(text) {
            return loadTable(that, text);
        }).otherwise(function(e) {
            throw new ModelError({
                sender: that,
                title: 'Could not load CSV file',
                message: '\
An error occurred while retrieving CSV data from the provided link.'
            });
        });
    }
};

CsvCatalogItem.prototype._enableInCesium = function() {
};

CsvCatalogItem.prototype._disableInCesium = function() {
};

CsvCatalogItem.prototype._showInCesium = function() {

    if (!this._regionMapped) {
        var dataSources = this.application.dataSources;
        if (dataSources.contains(this._tableDataSource)) {
            throw new DeveloperError('This data source is already shown.');
        }

        dataSources.add(this._tableDataSource);
    }
    else {
        var scene = this.application.cesium.scene;

        var imageryProvider = new WebMapServiceImageryProvider({
            url : proxyUrl(this.application, this.url),
            layers : this.layers,
            parameters : WebMapServiceCatalogItem.defaultParameters
        });

        imageryProvider.base_requestImage = imageryProvider.requestImage;
        var that = this;
        imageryProvider.requestImage = function(x, y, level) {
            var imagePromise = imageryProvider.base_requestImage(x, y, level);
            if (!defined(imagePromise)) {
                return imagePromise;
            }
            
            return when(imagePromise, function(image) {
                if (defined(image)) {
                    image = recolorImageWithCanvas(image, that.colorFunc);
                }
                return image;
            });
        };
            //remap image layer featurePicking Func
        imageryProvider.base_pickFeatures = imageryProvider.pickFeatures;
        imageryProvider.pickFeatures = function(x, y, level, longitude, latitude) {
            var featurePromise = imageryProvider.base_pickFeatures(x, y, level, longitude, latitude);
            if (!defined(featurePromise)) {
                return featurePromise;
            }
            
            return when(featurePromise, function(results) {
                if (defined(results)) {
                    var id = results[0].data.properties[that.regionProp];
                    var properties = that.rowProperties(parseInt(id,10));
                    results[0].description = that._tableDataSource.describe(properties);
                }
                return results;
            });
        };

        this._imageryLayer = new ImageryLayer(imageryProvider, {alpha : 0.6} );

        scene.imageryLayers.add(this._imageryLayer);

    }
};

CsvCatalogItem.prototype._hideInCesium = function() {

    if (!this._regionMapped) {
        var dataSources = this.application.dataSources;
        if (!dataSources.contains(this._tableDataSource)) {
            throw new DeveloperError('This data source is not shown.');
        }
        
        dataSources.remove(this._tableDataSource, false);
    }
    else {
        if (!defined(this._imageryLayer)) {
            throw new DeveloperError('This data source is not enabled.');
        }
        
        var scene = this.application.cesium.scene;
        scene.imageryLayers.remove(this._imageryLayer);
        this._imageryLayer = undefined;
    }
};

CsvCatalogItem.prototype._enableInLeaflet = function() {
};

CsvCatalogItem.prototype._disableInLeaflet = function() {
};

CsvCatalogItem.prototype._showInLeaflet = function() {

    if (!this._regionMapped) {
        this._showInCesium();
    }
    else {
        if (defined(this._imageryLayer)) {
            throw new DeveloperError('This data source is already enabled.');
        }
        
        var map = this.application.leaflet.map;
        
        var options = {
            layers : this.layers,
            opacity : 0.6
        };
        options = combine(defaultValue(WebMapServiceCatalogItem.defaultParameters), options);

        this._imageryLayer = new L.tileLayer.wms(proxyUrl(this.application, this.url), options);

        var that = this;
        this._imageryLayer.setFilter(function () {
            new L.CanvasFilter(this, {
                channelFilter: function (image) {
                    return recolorImage(image, that.colorFunc);
                }
           }).render();
        });
        this.wmsFeatureInfoFilter = function(result) {
                if (defined(result)) {
                    var properties = result.features[0].properties;
                    var id = properties[that.regionProp];
                    properties = combine(properties, that.rowProperties(parseInt(id,10)));
                    properties.FID = undefined;
                    properties[that.regionProp] = undefined;
                    result.features[0].properties = properties;
                }
                return result;
            };

        map.addLayer(this._imageryLayer);
    }
};

CsvCatalogItem.prototype._hideInLeaflet = function() {
    if (!this._regionMapped) {
        this._hideInCesium();
    }
    else {
        if (!defined(this._imageryLayer)) {
            throw new DeveloperError('This data source is not enabled.');
        }

        var map = this.application.leaflet.map;
        map.removeLayer(this._imageryLayer);
        this._imageryLayer = undefined;
    }
};

CsvCatalogItem.prototype._rebuild = function() {
    if (defined(this.application.cesium)) {
        this._hideInCesium();
        this._showInCesium();
    }
    else {
        this._hideInLeaflet();
        this._showInLeaflet();
    }
};

function proxyUrl(application, url) {
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(url)) {
        return application.corsProxy.getURL(url);
    }

    return url;
}



//////////////////////////////////////////////////////////////////////////

function loadTable(csvItem, text) {
    csvItem._tableDataSource.loadText(text);

    if (!csvItem._tableDataSource.dataset.hasLocationData()) {
        console.log('No locaton date found in csv file - trying to match based on region');
        return when(addRegionMap(csvItem), function() {
            if (csvItem._regionMapped !== true) {
                throw new ModelError({
                    sender: csvItem,
                    title: 'Could not load CSV file',
                    message: '\
Could not find any location parameters for latitude and longitude and was not able to determine \
a region mapping column.'
                });
            }
            else {
                csvItem.legendUrl = csvItem._tableDataSource.getLegendGraphic();
            }
        });
    }
    else {
        csvItem.clock = csvItem._tableDataSource.clock;
        csvItem.rectangle = csvItem._tableDataSource.dataset.getExtent();
        csvItem.legendUrl = csvItem._tableDataSource.getLegendGraphic();
    }
}


//////////////////////////////////////////////////////////////////////////

//Recolor an image using a color function
function recolorImage(image, colorFunc) {
    var length = image.data.length;  //pixel count * 4
    for (var i = 0; i < length; i += 4) {
        if (image.data[i+3] < 255) {
            continue;
        }
        if (image.data[i] === 0) {
            var idx = image.data[i+1] * 0x100 + image.data[i+2];
            var clr = colorFunc(idx);
            if (defined(clr)) {
                for (var j = 0; j < 4; j++) {
                    image.data[i+j] = clr[j];
                }
            }
            else {
                image.data[i+3] = 0;
            }
        }
    }
    return image;
}

//Recolor an image using 2d canvas
function recolorImageWithCanvas(img, colorFunc) {
    var canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;

    // Copy the image contents to the canvas
    var context = canvas.getContext("2d");
    context.drawImage(img, 0, 0);
    var image = context.getImageData(0, 0, canvas.width, canvas.height);
    
    image = recolorImage(image, colorFunc);
    
    context.putImageData(image, 0, 0);
    return context.getImageData(0, 0, canvas.width, canvas.height);
}


var regionServer = 'http://geoserver-nm.nicta.com.au/region_map/ows';
var regionWmsMap = {
    'STE': {
        "name":"region_map:FID_STE_2011_AUST",
        "regionProp": "STE_CODE11",
        "aliases": ['state', 'ste']
    },
    'CED': {
        "name":"region_map:FID_CED_2011_AUST",
        "regionProp": "CED_CODE",
        "aliases": ['ced']
    },
    'SED': {
        "name":"region_map:FID_SED_2011_AUST",
        "regionProp": "SED_CODE",
        "aliases": ['sed']
    },
    'POA': {
        "name":"region_map:FID_POA_2011_AUST",
        "regionProp": "POA_CODE",
        "aliases": ['poa', 'postcode']
    },
    'LGA': {
        "name":"region_map:FID_LGA_2011_AUST",
        "regionProp": "LGA_CODE11",
        "aliases": ['lga']
    },
    'SCC': {
        "name":"region_map:FID_SCC_2011_AUST",
        "regionProp": "SCC_CODE",
        "aliases": ['scc', 'suburb']
    },
    'SA4': {
        "name":"region_map:FID_SA4_2011_AUST",
        "regionProp": "SA4_CODE11",
        "aliases": ['sa4']
    },
    'SA3': {
        "name":"region_map:FID_SA3_2011_AUST",
        "regionProp": "SA3_CODE11",
        "aliases": ['sa3']
    },
    'SA2': {
        "name":"region_map:FID_SA2_2011_AUST",
        "regionProp": "SA2_MAIN11",
        "aliases": ['sa2']
    },
// COMMENTING OUT SA1: it works, but server performance is just too slow to be widely usable
//    'SA1': {
//        "name":"region_map:FID_SA1_2011_AUST",
//        "regionProp": "SA1_7DIG11",
//        "aliases": ['sa1']
//    }
};

//TODO: if we add enum capability and then can work with any unique field
function loadRegionIDs(regionDescriptor) {
    if (defined(regionDescriptor.idMap)) {
        return;
    }

    var url = regionServer + '?service=wfs&version=2.0&request=getPropertyValue';
    url += '&typenames=' + regionDescriptor.name;
    url += '&valueReference=' + regionDescriptor.regionProp;
    url = corsProxy.getURL(url);
    return loadText(url).then(function (text) { 
        var obj = $.xml2json(text);

        if (!defined(obj.member)) {
            return;
        }

        var idMap = [];
            //this turns ids into numbers since they are that way in table data
        for (var i = 0; i < obj.member.length; i++) {
            idMap.push(parseInt(obj.member[i][regionDescriptor.regionProp],10));
        }
        regionDescriptor.idMap = idMap;
    }, function(err) {
        console.log(err);
    });
}

function determineRegionVar(vars, aliases) {
    for (var i = 0; i < vars.length; i++) {
        var varName = vars[i].toLowerCase();
        for (var j = 0; j < aliases.length; j++) {
            if (varName.substring(0,aliases[j].length) === aliases[j]) {
                return i;
            }
        }
    }
    return -1;
}

function determineRegionType(dataset) {
    var vars = dataset.getVarList();

    var regionType;
    var idx = -1;
    //try to figure out the region variable
    for (regionType in regionWmsMap) {
        if (regionWmsMap.hasOwnProperty(regionType)) {
            idx = determineRegionVar(vars, regionWmsMap[regionType].aliases);
            if (idx !== -1) {
                break;
            }
        }
    }
    
    //if no match, try to derive regionType from region_id to use native abs census files
    if (idx === -1) {
        var absRegion = 'region_id';
        idx = vars.indexOf(absRegion);
        if (idx === -1) {
            return;
        }
        var code = dataset.getDataValue(absRegion, 0);
        regionType = code.replace(/[0-9]/g, '');
        if (regionWmsMap[regionType] === undefined) {
            return;
        }
        var vals = dataset.getDataValues(absRegion);
        var new_vals = [];
        for (var i = 0; i < vals.length; i++) {
            var id = dataset.getDataValue(absRegion, vals[i]).replace( /^\D+/g, '');
            new_vals.push(parseInt(id,10));
        }

        dataset.variables[absRegion].vals = new_vals;
        dataset.variables[regionType] = dataset.variables[absRegion];
        delete dataset.variables[absRegion];
        vars = dataset.getVarList();
        idx = vars.indexOf(regionType);
    }
    return { idx: idx, regionType: regionType};
}

function createRegionLookupFunc(csvItem) {
    if (!defined(csvItem) || !defined(csvItem._tableDataSource) || !defined(csvItem._tableDataSource.dataset)) {
        return;
    }
    var dataSource = csvItem._tableDataSource;
    var dataset = dataSource.dataset;
    var regionDescriptor = regionWmsMap[csvItem.regionType];
 
    var codes = dataset.getDataValues(csvItem.regionVar);
    var vals = dataset.getDataValues(dataset.getCurrentVariable());
    var ids = regionDescriptor.idMap;
    var lookup = new Array(ids.length);
    // get value for each id
    for (var i = 0; i < codes.length; i++) {
        var id = ids.indexOf(codes[i]);
        lookup[id] = vals[i];
    }
    // set color for each code
    var colors = [];
    for (var idx = dataset.getMinVal(); idx <= dataset.getMaxVal(); idx++) {
        colors[idx] = dataSource._mapValue2Color(idx);
    }
    //   color lookup function used by the region mapper
    csvItem.colorFunc = function(id) {
        return colors[lookup[id]];
    };
    // used to get current variable data
    csvItem.valFunc = function(code) {
        var rowIndex = codes.indexOf(code);
        return vals[rowIndex];
    };
    // used to get all region data properties
    csvItem.rowProperties = function(code) {
        var rowIndex = codes.indexOf(code);
        return dataset.getDataRow(rowIndex);
    };
}

function setRegionVariable(csvItem, regionVar, regionType) {
    if (!(csvItem._tableDataSource instanceof TableDataSource)) {
        return;
    }

    csvItem.regionVar = regionVar;
    var regionDescriptor = regionWmsMap[regionType];
    if (csvItem.regionType !== regionType) {
        csvItem.regionType = regionType;

        csvItem.url = regionServer;
        csvItem.layers = regionDescriptor.name;

        csvItem.regionProp = regionDescriptor.regionProp;
    }
    console.log('Region type:', csvItem.regionType, ', Region var:', csvItem.regionVar);
        
    return when(loadRegionIDs(regionDescriptor), function() {
        createRegionLookupFunc(csvItem);
        csvItem._regionMapped = true;
    });
}


function setRegionDataVariable(csvItem, newVar) {
    if (!(csvItem._tableDataSource instanceof TableDataSource)) {
        return;
    }

    var dataSource = csvItem._tableDataSource;
    var dataset = dataSource.dataset;
    dataset.setCurrentVariable({ variable: newVar});
    createRegionLookupFunc(csvItem);
    
    console.log('Var set to:', newVar);

    csvItem._rebuild();
}

function setRegionColorMap(csvItem, dataColorMap) {
     if (!(csvItem._tableDataSource instanceof TableDataSource)) {
        return;
    }

    csvItem._tableDataSource.setColorGradient(dataColorMap);
    createRegionLookupFunc(csvItem);

    csvItem._rebuild();
}


function addRegionMap(csvItem) {
    if (!(csvItem._tableDataSource instanceof TableDataSource)) {
        return;
    }
    //see if we can do region mapping
    var dataSource = csvItem._tableDataSource;
    var dataset = dataSource.dataset;

    //if csvItem includes style/var info then use that
    if (!defined(csvItem.style) || !defined(csvItem.style.table)) {
        var regionObj = determineRegionType(dataset);
        if (regionObj === undefined) {
            return;
        }
        var idx = regionObj.idx;
        var regionType = regionObj.regionType;

            //change current var if necessary
        var dataVar = dataset.getCurrentVariable();
        var vars = dataset.getVarList();
        if (dataVar === vars[idx]) {
            dataVar = (idx === 0) ? vars[1] : vars[0];
        }
            //set default style if none set
        var style = {line: {}, point: {}, polygon: {}, table: {}};
        style.table.lat = undefined;
        style.table.lon = undefined;
        style.table.alt = undefined;
        style.table.region = vars[idx];
        style.table.regionType = regionType;
        style.table.time = dataset.getVarID(VarType.TIME);
        style.table.data = dataVar;
        style.table.colorMap = [
            {offset: 0.0, color: 'rgba(200,0,0,1.00)'},
            {offset: 0.5, color: 'rgba(200,200,200,1.0)'},
            {offset: 0.5, color: 'rgba(200,200,200,1.0)'},
            {offset: 1.0, color: 'rgba(0,0,200,1.0)'}
        ];
        csvItem.style = style;
    }

    if (defined(csvItem.style.table.colorMap)) {
        dataSource.setColorGradient(csvItem.style.table.colorMap);
    }
    dataSource.setCurrentVariable(csvItem.style.table.data);

    //to make lint happy
    if (false) {
        setRegionColorMap();
        setRegionDataVariable();
    }
    
    //TODO: figure out how sharing works or doesn't
    
    return setRegionVariable(csvItem, csvItem.style.table.region, csvItem.style.table.regionType);
}



module.exports = CsvCatalogItem;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/combine":241,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/loadText":262,"../../third_party/cesium/Source/Scene/ImageryLayer":396,"../../third_party/cesium/Source/Scene/WebMapServiceImageryProvider":455,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/corsProxy":5,"../Core/inherit":7,"../Core/readText":10,"../Map/TableDataSource":16,"../Map/VarType":17,"./CatalogItem":27,"./Metadata":39,"./ModelError":41,"./WebMapServiceCatalogItem":49}],33:[function(require,module,exports){
'use strict';

/*global require*/

var CzmlDataSource = require('../../third_party/cesium/Source/DataSources/CzmlDataSource');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var Metadata = require('./Metadata');
var ModelError = require('./ModelError');
var CatalogItem = require('./CatalogItem');
var inherit = require('../Core/inherit');
var readJson = require('../Core/readJson');

/**
 * A {@link CatalogItem} representing Cesium Language (CZML) data.
 *
 * @alias CzmlCatalogItem
 * @constructor
 * @extends CatalogItem
 * 
 * @param {Application} application The application.
 * @param {String} [url] The URL from which to retrieve the CZML data.
 */
var CzmlCatalogItem = function(application, url) {
    CatalogItem.call(this, application);

    this._czmlDataSource = undefined;

    /**
     * Gets or sets the URL from which to retrieve CZML data.  This property is ignored if
     * {@link CzmlCatalogItem#data} is defined.  This property is observable.
     * @type {String}
     */
    this.url = url;

    /**
     * Gets or sets the CZML data, represented as a binary Blob, JSON object literal, or a Promise for one of those things.
     * This property is observable.
     * @type {Blob|Object|Promise}
     */
    this.data = undefined;

    /**
     * Gets or sets the URL from which the {@link CzmlCatalogItem#data} was obtained.  This will be used
     * to resolve any resources linked in the CZML file, if any.
     * @type {String}
     */
    this.dataSourceUrl = undefined;

    knockout.track(this, ['url', 'data', 'dataSourceUrl']);
};

inherit(CatalogItem, CzmlCatalogItem);

defineProperties(CzmlCatalogItem.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf CzmlCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'czml';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'Cesium Language (CZML)'.
     * @memberOf CzmlCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Cesium Language (CZML)';
        }
    },

    /**
     * Gets the metadata associated with this data source and the server that provided it, if applicable.
     * @memberOf CzmlCatalogItem.prototype
     * @type {Metadata}
     */
    metadata : {
        get : function() {
            var result = new Metadata();
            result.isLoading = false;
            result.dataSourceErrorMessage = 'This data source does not have any details available.';
            result.serviceErrorMessage = 'This service does not have any details available.';
            return result;
        }
    }
});

CzmlCatalogItem.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url, this.data];
};

CzmlCatalogItem.prototype._load = function() {
    var dataSource = new CzmlDataSource();
    this._czmlDataSource = dataSource;

    var that = this;

    if (defined(that.data)) {
        return when(that.data, function(data) {
            if (data instanceof Blob) {
                return readJson(data).then(function(data) {
                    dataSource.load(data, proxyUrl(that, that.dataSourceUrl));
                    doneLoading(that);
                }).otherwise(function() {
                    errorLoading(that);
                });
            } else {
                dataSource.load(data, proxyUrl(that, that.dataSourceUrl));
                doneLoading(that);
            }
        }).otherwise(function() {
            errorLoading(that);
        });
    } else {
        return dataSource.loadUrl(proxyUrl(that, that.url)).then(function() {
            doneLoading(that);
        }).otherwise(function() {
            errorLoading(that);
        });
    }
};

CzmlCatalogItem.prototype._enable = function() {
};

CzmlCatalogItem.prototype._disable = function() {
};

CzmlCatalogItem.prototype._show = function() {
    if (!defined(this._czmlDataSource)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var dataSources = this.application.dataSources;
    if (dataSources.contains(this._czmlDataSource)) {
        throw new DeveloperError('This data source is already shown.');
    }

    dataSources.add(this._czmlDataSource);
};

CzmlCatalogItem.prototype._hide = function() {
    if (!defined(this._czmlDataSource)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var dataSources = this.application.dataSources;
    if (!dataSources.contains(this._czmlDataSource)) {
        throw new DeveloperError('This data source is not shown.');
    }

    dataSources.remove(this._czmlDataSource, false);
};

function proxyUrl(application, url) {
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(url)) {
        return application.corsProxy.getURL(url);
    }

    return url;
}

function doneLoading(czmlItem) {
    czmlItem.clock = czmlItem._czmlDataSource.clock;
}

function errorLoading(czmlItem) {
    throw new ModelError({
        sender: czmlItem,
        title: 'Error loading CZML',
        message: '\
An error occurred while loading a CZML file.  This may indicate that the file is invalid or that it \
is not supported by National Map.  If you would like assistance or further information, please email us \
at <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.'
    });
}

module.exports = CzmlCatalogItem;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/DataSources/CzmlDataSource":286,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/inherit":7,"../Core/readJson":9,"./CatalogItem":27,"./Metadata":39,"./ModelError":41}],34:[function(require,module,exports){
'use strict';

/*global require,proj4,proj4_epsg*/

var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var Color = require('../../third_party/cesium/Source/Core/Color');
var ColorMaterialProperty = require('../../third_party/cesium/Source/DataSources/ColorMaterialProperty');
var ConstantProperty = require('../../third_party/cesium/Source/DataSources/ConstantProperty');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var GeoJsonDataSource = require('../../third_party/cesium/Source/DataSources/GeoJsonDataSource');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadJson = require('../../third_party/cesium/Source/Core/loadJson');
var loadText = require('../../third_party/cesium/Source/Core/loadText');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var Metadata = require('./Metadata');
var ModelError = require('./ModelError');
var CatalogItem = require('./CatalogItem');
var inherit = require('../Core/inherit');
var readJson = require('../Core/readJson');

var lineAndFillPalette = {
    minimumRed : 0.4,
    minimumGreen : 0.4,
    minimumBlue : 0.4,
    maximumRed : 0.9,
    maximumGreen : 0.9,
    maximumBlue : 0.9,
    alpha : 1.0
};

var pointPalette = {
    minimumRed : 0.6,
    minimumGreen : 0.6,
    minimumBlue : 0.6,
    maximumRed : 1.0,
    maximumGreen : 1.0,
    maximumBlue : 1.0,
    alpha : 1.0
};

/**
 * A {@link CatalogItem} representing GeoJSON feature data.
 *
 * @alias GeoJsonCatalogItem
 * @constructor
 * @extends CatalogItem
 * 
 * @param {Application} application The application.
 * @param {String} [url] The URL from which to retrieve the GeoJSON data.
 */
var GeoJsonCatalogItem = function(application, url) {
    CatalogItem.call(this, application);

    this._geoJsonDataSource = undefined;
    this._readyData = undefined;

    /**
     * Gets or sets the URL from which to retrieve GeoJSON data.  This property is ignored if
     * {@link GeoJsonCatalogItem#data} is defined.  This property is observable.
     * @type {String}
     */
    this.url = url;

    /**
     * Gets or sets the GeoJSON data, represented as a binary blob, object literal, or a Promise for one of those things.
     * This property is observable.
     * @type {Blob|Object|Promise}
     */
    this.data = undefined;

    /**
     * Gets or sets the URL from which the {@link GeoJsonCatalogItem#data} was obtained.  This will be used
     * to resolve any resources linked in the GeoJSON file, if any.
     * @type {String}
     */
    this.dataSourceUrl = undefined;

    knockout.track(this, ['url', 'data', 'dataSourceUrl']);
};

inherit(CatalogItem, GeoJsonCatalogItem);

defineProperties(GeoJsonCatalogItem.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf GeoJsonCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'geojson';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'GeoJSON'.
     * @memberOf GeoJsonCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'GeoJSON';
        }
    },

    /**
     * Gets the metadata associated with this data source and the server that provided it, if applicable.
     * @memberOf GeoJsonCatalogItem.prototype
     * @type {Metadata}
     */
    metadata : {
        get : function() {
            // TODO: maybe return the FeatureCollection's properties?
            var result = new Metadata();
            result.isLoading = false;
            result.dataSourceErrorMessage = 'This data source does not have any details available.';
            result.serviceErrorMessage = 'This service does not have any details available.';
            return result;
        }
    }
});

GeoJsonCatalogItem.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url, this.data];
};

GeoJsonCatalogItem.prototype._load = function() {
    this._geoJsonDataSource = new GeoJsonDataSource(this.name);

    var that = this;

    if (defined(that.data)) {
        return when(that.data, function(data) {
            var promise;
            if (typeof Blob !== 'undefined' && data instanceof Blob) {
                promise = readJson(data);
            } else {
                promise = data;
            }

            return when(promise, function(json) {
                that.data = json;
                return updateModelFromData(that, json);
            });
        });
    } else {
        return loadJson(proxyUrl(that.application, that.url)).then(function(json) {
            return updateModelFromData(that, json);
        }).otherwise(function(e) {
            throw new ModelError({
                sender: that,
                title: 'Could not load JSON',
                message: '\
An error occurred while retrieving JSON data from the provided link.  \
<p>If you entered the link manually, please verify that the link is correct.</p>\
<p>This error may also indicate that the server does not support <a href="http://enable-cors.org/" target="_blank">CORS</a>.  If this is your \
server, verify that CORS is enabled and enable it if it is not.  If you do not control the server, \
please contact the administrator of the server and ask them to enable CORS.  Or, contact the National \
Map team by emailing <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a> \
and ask us to add this server to the list of non-CORS-supporting servers that may be proxied by \
National Map itself.</p>\
<p>If you did not enter this link manually, this error may indicate that the data source you\'re trying to add is temporarily unavailable or there is a \
problem with your internet connection.  Try adding the data source again, and if the problem persists, please report it by \
sending an email to <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.</p>'
            });
        });
    }
};

GeoJsonCatalogItem.prototype._enable = function() {
};

GeoJsonCatalogItem.prototype._disable = function() {
};

GeoJsonCatalogItem.prototype._show = function() {
    if (!defined(this._geoJsonDataSource)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var dataSources = this.application.dataSources;
    if (dataSources.contains(this._geoJsonDataSource)) {
        throw new DeveloperError('This data source is already shown.');
    }

    dataSources.add(this._geoJsonDataSource);
};

GeoJsonCatalogItem.prototype._hide = function() {
    if (!defined(this._geoJsonDataSource)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var dataSources = this.application.dataSources;
    if (!dataSources.contains(this._geoJsonDataSource)) {
        throw new DeveloperError('This data source is not shown.');
    }

    dataSources.remove(this._geoJsonDataSource, false);
};

function updateModelFromData(geoJsonItem, geoJson) {
    // If this GeoJSON data is an object literal with a single property, treat that
    // property as the name of the data source, and the property's value as the
    // actual GeoJSON.
    var numProperties = 0;
    var propertyName;
    for (propertyName in geoJson) {
        if (geoJson.hasOwnProperty(propertyName)) {
            ++numProperties;
            if (numProperties > 1) {
                break; // no need to count past 2 properties.
            }
        }
    }

    var name;
    if (numProperties === 1) {
        name = propertyName;
        geoJson = geoJson[propertyName];

        // If we don't already have a name, or our name is just derived from our URL, update the name.
        if (!defined(geoJsonItem.name) || geoJsonItem.name.length === 0 || nameIsDerivedFromUrl(geoJsonItem.name, geoJsonItem.url)) {
            geoJsonItem.name = name;
        }
    }

    // Reproject the features if they're not already EPSG:4326.
    var promise = reprojectToGeographic(geoJson);

    return when(promise, function() {
        // If we don't already have a rectangle, compute one.
        if (!defined(geoJsonItem.rectangle) || Rectangle.equals(geoJsonItem.rectangle, Rectangle.MAX_VALUE)) {
            geoJsonItem.rectangle = getGeoJsonExtent(geoJson);
        }

        geoJsonItem._readyData = geoJson;

        return loadGeoJson(geoJsonItem);
    });
}

function nameIsDerivedFromUrl(name, url) {
    if (name === url) {
        return true;
    }

    // Is the name just the end of the URL?
    var indexOfNameInUrl = url.lastIndexOf(name);
    if (indexOfNameInUrl >= 0 && indexOfNameInUrl === url.length - name.length) {
        return true;
    }

    return false;
}

function proxyUrl(application, url) {
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(url)) {
        return application.corsProxy.getURL(url);
    }

    return url;
}

function loadGeoJson(geoJsonItem) {
    var fillPolygons = false;
    var pointColor = getRandomColor(pointPalette, geoJsonItem.name);
    var lineColor = getRandomColor(lineAndFillPalette, geoJsonItem.name);
    var fillColor = Color.clone(lineColor);
    fillColor.alpha = 0.75;

    var pointSize = 10;
    var lineWidth = 2;

    var dataSource = geoJsonItem._geoJsonDataSource;
    return dataSource.load(geoJsonItem._readyData).then(function() {
        var entities = dataSource.entities.entities;

        for (var i = 0; i < entities.length; ++i) {
            var entity = entities[i];
            var material;

            // Update default point/line/polygon
            var point = entity.point;
            if (defined(point)) {
                point.color = new ConstantProperty(pointColor);
                point.pixelSize = new ConstantProperty(pointSize);
                point.outlineColor = new ConstantProperty(Color.BLACK);
                point.outlineWidth = new ConstantProperty(1);
            }

            var polyline = entity.polyline;
            if (defined(polyline)) {
                material = new ColorMaterialProperty();
                material.color = new ConstantProperty(lineColor);
                polyline.material = material;
                polyline.width = new ConstantProperty(lineWidth);
            }

            var polygon = entity.polygon;
            if (defined(polygon)) {
                polygon.fill = new ConstantProperty(fillPolygons);
                polygon.outline = new ConstantProperty(true);

                material = new ColorMaterialProperty();
                material.color = new ConstantProperty(fillColor);
                polygon.material = material;
            }
        }
    });
}

// Get a random color for the data based on the passed seed (usually dataset name)
function getRandomColor(palette, seed) {
    if (defined(seed)) {
        if (typeof seed === 'string') {
            var val = 0;
            for (var i = 0; i < seed.length; i++) {
                val += seed.charCodeAt(i);
            }
            seed = val;
        }
        CesiumMath.setRandomNumberSeed(seed);
    }
    return Color.fromRandom(palette);
}

// Set the Cesium Reproject func if not already set - return false if can't set
function checkProjection(code) {
    if (proj4_epsg.hasOwnProperty(code)) {
        return true;
    }

    var url = '/proj4def/' + code;
    return when(loadText(url), function (proj4Text) {
            proj4_epsg[code] = proj4Text;
            console.log('Added new string for', code, '=', proj4Text);
            return true;
        }, function(err) {
            return false;
        });
 }

function reprojectToGeographic(geoJson) {
    var code;

    if (!defined(geoJson.crs)) {
        code = undefined;
    } else if (geoJson.crs.type === 'EPSG') {
        code = 'EPSG:' + geoJson.crs.properties.code;
    } else if (geoJson.crs.type === 'name' &&
               defined(geoJson.crs.properties) &&
               defined(geoJson.crs.properties.name)) {
        if (geoJson.crs.properties.name.indexOf('EPSG:') === 0) {
            code = geoJson.crs.properties.name;
        } else if (geoJson.crs.properties.name.indexOf('CRS84') !== -1) {
            code = 'EPSG:4326';
        }
    }

    geoJson.crs = {
        type: 'EPSG',
        properties: {
            code: '4326'
        }
    };

    if (!defined(code) || code === 'EPSG:4326' || code === 'EPSG:4283') {
        return true;
    }

   return when(checkProjection(code), function(result) {
        if (result) {
            filterValue(
                geoJson,
                'coordinates',
                function(obj, prop) {
                    obj[prop] = filterArray(
                        obj[prop],
                        function(pts) {
                            return reprojectPointList(pts, code);
                        });
                });
        } else {
            throw new DeveloperError('The crs code for this datasource is unsupported.');
        }
    });
}

// Reproject a point list based on the supplied crs code
function reprojectPointList(pts, code) {
    if (!(pts[0] instanceof Array)) {
        return pntReproject(pts, code);  //point
    }
    var pts_out = [];
    for (var i = 0; i < pts.length; i++) {
        pts_out.push(pntReproject(pts[i], code));
    }
    return pts_out;
}

// find a member by name in the gml
function filterValue(obj, prop, func) {
    for (var p in obj) {
        if (obj.hasOwnProperty(p) === false) {
            continue;
        }
        else if (p === prop) {
            if (func && (typeof func === 'function')) {
                (func)(obj, prop);
            }
        }
        else if (typeof obj[p] === 'object') {
            filterValue(obj[p], prop, func);
        }
    }
}

// Filter a geojson coordinates array structure
function filterArray(pts, func) {
    if (!(pts[0] instanceof Array) || !((pts[0][0]) instanceof Array) ) {
        pts = func(pts);
        return pts;
    }
    for (var i = 0; i < pts.length; i++) {
        pts[i] = filterArray(pts[i], func);  //at array of arrays of points
    }
    return pts;
}

// Function to pass to reproject function
function pntReproject(coordinates, id) {
    var source = new proj4.Proj(proj4_epsg[id]);
    var dest = new proj4.Proj('EPSG:4326');
    var p = proj4.toPoint(coordinates);
    proj4(source, dest, p);      //do the transformation.  x and y are modified in place
    return [p.x, p.y];
}

// Get Extent of geojson
function getExtent(pts, ext) {
    if (!(pts[0] instanceof Array) ) {
        if (pts[0] < ext.west)  { ext.west = pts[0];  }
        if (pts[0] > ext.east)  { ext.east = pts[0];  } 
        if (pts[1] < ext.south) { ext.south = pts[1]; }
        if (pts[1] > ext.north) { ext.north = pts[1]; }
    }
    else if (!((pts[0][0]) instanceof Array) ) {
        for (var i = 0; i < pts.length; i++) {
            getExtent(pts[i], ext);
        }
    }
    else {
        for (var j = 0; j < pts.length; j++) {
            getExtent(pts[j], ext);  //at array of arrays of points
        }
    }
}

function getGeoJsonExtent(geoJson) {
    var ext = {west:180, east:-180, south:90, north: -90};
    filterValue(geoJson, 'coordinates', function(obj, prop) { getExtent(obj[prop], ext); });
    return Rectangle.fromDegrees(ext.west, ext.south, ext.east, ext.north);
}

module.exports = GeoJsonCatalogItem;

},{"../../third_party/cesium/Source/Core/Color":111,"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/loadJson":261,"../../third_party/cesium/Source/Core/loadText":262,"../../third_party/cesium/Source/DataSources/ColorMaterialProperty":278,"../../third_party/cesium/Source/DataSources/ConstantProperty":283,"../../third_party/cesium/Source/DataSources/GeoJsonDataSource":298,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/inherit":7,"../Core/readJson":9,"./CatalogItem":27,"./Metadata":39,"./ModelError":41}],35:[function(require,module,exports){
'use strict';

/*global require,toGeoJSON*/

var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var Metadata = require('./Metadata');
var ModelError = require('./ModelError');
var CatalogItem = require('./CatalogItem');
var inherit = require('../Core/inherit');

var GeoJsonCatalogItem = require('./GeoJsonCatalogItem');
var readText = require('../Core/readText');
var loadText = require('../../third_party/cesium/Source/Core/loadText');


/**
 * A {@link CatalogItem} representing GPX data.
 *
 * @alias GpxCatalogItem
 * @constructor
 * @extends GeoJsonCatalogItem
 * 
 * @param {Application} application The application.
 * @param {String} [url] The URL from which to retrieve the GPX data.
 */
var GpxCatalogItem = function(application, url) {
    CatalogItem.call(this, application);

    this._geoJsonItem = undefined;

    /**
     * Gets or sets the URL from which to retrieve GPX data.  This property is ignored if
     * {@link GpxCatalogItem#data} is defined.  This property is observable.
     * @type {String}
     */
    this.url = url;

    /**
     * Gets or sets the Gpx data, represented as a binary Blob, DOM Document, or a Promise for one of those things.
     * This property is observable.
     * @type {Blob|Document|Promise}
     */
    this.data = undefined;

    /**
     * Gets or sets the URL from which the {@link GpxCatalogItem#data} was obtained.  This may be used
     * to resolve any resources linked in the Gpx file, if any.
     * @type {String}
     */
    this.dataSourceUrl = undefined;

    knockout.track(this, ['url', 'data', 'dataSourceUrl']);
};

inherit(CatalogItem, GpxCatalogItem);

defineProperties(GpxCatalogItem.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf GpxCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'gpx';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'GPX'.
     * @memberOf GpxCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'GPX';
        }
    },

    /**
     * Gets the metadata associated with this data source and the server that provided it, if applicable.
     * @memberOf GpxCatalogItem.prototype
     * @type {Metadata}
     */
    metadata : {
        get : function() {
            var result = new Metadata();
            result.isLoading = false;
            result.dataSourceErrorMessage = 'This data source does not have any details available.';
            result.serviceErrorMessage = 'This service does not have any details available.';
            return result;
        }
    }
});

GpxCatalogItem.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url, this.data];
};

GpxCatalogItem.prototype._load = function() {
    this._geoJsonItem = new GeoJsonCatalogItem(this.application);

    var that = this;

    if (defined(that.data)) {
        return when(that.data, function(data) {
            var promise;
            if (data instanceof Blob) {
                promise = readText(data);
            } else {
                promise = data;
            }

            return when(promise, function(text) {
                return loadGpxText(that, text);
            });
        });
    } else {
        return loadText(proxyUrl(that, that.url)).then(function(text) {
            return loadGpxText(that, text);
        }).otherwise(function() {
            errorLoading(that);
        });
    }
};

GpxCatalogItem.prototype._enable = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._enable();
    }
};

GpxCatalogItem.prototype._disable = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._disable();
    }
};

GpxCatalogItem.prototype._show = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._show();
    }
};

GpxCatalogItem.prototype._hide = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._hide();
    }
};


function proxyUrl(application, url) {
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(url)) {
        return application.corsProxy.getURL(url);
    }

    return url;
}

function loadGpxText(gpxItem, text) {

    var dom = (new DOMParser()).parseFromString(text, 'text/xml');    
    var geojson = toGeoJSON.gpx(dom);

    gpxItem._geoJsonItem.data = geojson;

    return gpxItem._geoJsonItem.load().then(function() {
        gpxItem.rectangle = gpxItem._geoJsonItem.rectangle;
        gpxItem.clock = gpxItem._geoJsonItem.clock;
    });
}

function errorLoading(gpxItem) {
    throw new ModelError({
        sender: gpxItem,
        title: 'Error loading GPX',
        message: '\
An error occurred while loading a GPX file.  This may indicate that the file is invalid or that it \
is not supported by National Map.  If you would like assistance or further information, please email us \
at <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.'
    });
}

module.exports = GpxCatalogItem;

},{"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/loadText":262,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/inherit":7,"../Core/readText":10,"./CatalogItem":27,"./GeoJsonCatalogItem":34,"./Metadata":39,"./ModelError":41}],36:[function(require,module,exports){
'use strict';

/*global require*/

var clone = require('../../third_party/cesium/Source/Core/clone');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');

var CatalogItem = require('./CatalogItem');
var inherit = require('../Core/inherit');
var ModelError = require('./ModelError');

/**
 * A {@link CatalogItem} that is added to the map as a rasterized imagery layer.
 *
 * @alias ImageryLayerCatalogItem
 * @constructor
 * @extends CatalogItem
 * @abstract
 * 
 * @param {Application} application The application.
 */
var ImageryLayerCatalogItem = function(application) {
    CatalogItem.call(this, application);

    this._imageryLayer = undefined;
    this._errorEventUnsubscribe = undefined;

    /**
     * Gets or sets the opacity (alpha) of the data item, where 0.0 is fully transparent and 1.0 is
     * fully opaque.  This property is observable.
     * @type {Number}
     */
    this.opacity = 0.6;

    knockout.track(this, ['opacity']);

    knockout.getObservable(this, 'opacity').subscribe(function(newValue) {
        updateOpacity(this);
    }, this);
};

inherit(CatalogItem, ImageryLayerCatalogItem);

defineProperties(ImageryLayerCatalogItem.prototype, {
    /**
     * Gets the Cesium or Leaflet imagery layer object associated with this data source.
     * This property is undefined if the data source is not enabled.
     * @memberOf ImageryLayerCatalogItem.prototype
     * @type {Object}
     */
    imageryLayer : {
        get : function() {
            return this._imageryLayer;
        }
    },

    /**
     * Gets a value indicating whether this data source, when enabled, can be reordered with respect to other data sources.
     * Data sources that cannot be reordered are typically displayed above reorderable data sources.
     * @memberOf ImageryLayerCatalogItem.prototype
     * @type {Boolean}
     */
    supportsReordering : {
        get : function() {
            return true;
        }
    },

    /**
     * Gets a value indicating whether the opacity of this data source can be changed.
     * @memberOf ImageryLayerCatalogItem.prototype
     * @type {Boolean}
     */
    supportsOpacity : {
        get : function() {
            return true;
        }
    },

    /**
     * Gets the set of functions used to update individual properties in {@link CatalogMember#updateFromJson}.
     * When a property name in the returned object literal matches the name of a property on this instance, the value
     * will be called as a function and passed a reference to this instance, a reference to the source JSON object
     * literal, and the name of the property.
     * @memberOf ImageryLayerCatalogItem.prototype
     * @type {Object}
     */
    updaters : {
        get : function() {
            return ImageryLayerCatalogItem.defaultUpdaters;
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf ImageryLayerCatalogItem.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return ImageryLayerCatalogItem.defaultSerializers;
        }
    },

    /**
     * Gets the set of names of the properties to be serialized for this object when {@link CatalogMember#serializeToJson} is called
     * and the `serializeForSharing` flag is set in the options.
     * @memberOf ImageryLayerCatalogItem.prototype
     * @type {String[]}
     */
    propertiesForSharing : {
        get : function() {
            return ImageryLayerCatalogItem.defaultPropertiesForSharing;
        }
    }
});

ImageryLayerCatalogItem.defaultUpdaters = clone(CatalogItem.defaultUpdaters);
freezeObject(ImageryLayerCatalogItem.defaultUpdaters);

ImageryLayerCatalogItem.defaultSerializers = clone(CatalogItem.defaultSerializers);
freezeObject(ImageryLayerCatalogItem.defaultSerializers);

/**
 * Gets or sets the default set of properties that are serialized when serializing a {@link CatalogItem}-derived object with the
 * `serializeForSharing` flag set in the options.
 * @type {String[]}
 */
ImageryLayerCatalogItem.defaultPropertiesForSharing = clone(CatalogItem.defaultPropertiesForSharing);
ImageryLayerCatalogItem.defaultPropertiesForSharing.push('opacity');

freezeObject(ImageryLayerCatalogItem.defaultPropertiesForSharing);

/**
 * Lowers this imagery layer to the bottom, underneath all other layers.  If this item is not enabled or not shown,
 * this method does nothing.
  */
ImageryLayerCatalogItem.prototype.lowerToBottom = function() {
    if (!defined(this._imageryLayer)) {
        return;
    }

    if (defined(this.application.cesium)) {
        this.application.cesium.scene.imageryLayers.lowerToBottom(this._imageryLayer);
    }

    if (defined(this.application.leaflet)) {
        this._imageryLayer.setZIndex(0);
    }
};

ImageryLayerCatalogItem.prototype._showInCesium = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var imageryProvider = this._imageryLayer.imageryProvider;
    var errorEvent = imageryProvider.errorEvent;

    if (defined(errorEvent)) {
        var that = this;
        this._errorEventUnsubscribe = errorEvent.addEventListener(function(tileProviderError) {
            // We're only concerned about failures for tiles that actually overlap this item's extent.
            if (defined(that.extent)) {
                var tilingScheme = imageryProvider.tilingScheme;
                var tileExtent = tilingScheme.tileXYToRectangle(tileProviderError.x, tileProviderError.y, tileProviderError.level);
                var intersection = Rectangle.intersectWith(tileExtent, that.extent);
                if (Rectangle.isEmpty(intersection)) {
                    return;
                }
            }

            // Retry 3 times.
            if (tileProviderError.timesRetried < 3) {
                tileProviderError.retry = true;
                return;
            }

            // After two failures, advise the user that something is wrong and disable the catalog item.
            that.application.error.raiseEvent(new ModelError({
                sender: that,
                title: 'Error accessing catalogue item',
                message: '\
An error occurred while attempting to download tiles for catalogue item ' + that.name + '.  This may indicate that there is a \
problem with your internet connection, that the catalogue item is temporarily unavailable, or that the catalogue item \
is invalid.  The catalogue item has been hidden from the map.  You may re-show it in the Now Viewing panel to try again.'
            }));

            that.isShown = false;
        });
    }

    this._imageryLayer.show = true;
};

ImageryLayerCatalogItem.prototype._hideInCesium = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    this._imageryLayer.show = false;

    if (defined(this._errorEventUnsubscribe)) {
        this._errorEventUnsubscribe();
    }
};

ImageryLayerCatalogItem.prototype._showInLeaflet = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var map = this.application.leaflet.map;
    map.addLayer(this._imageryLayer);
    this.application.nowViewing.updateLeafletLayerOrder();
};

ImageryLayerCatalogItem.prototype._hideInLeaflet = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var map = this.application.leaflet.map;
    map.removeLayer(this._imageryLayer);
};

function updateOpacity(imageryLayerItem) {
    if (defined(imageryLayerItem._imageryLayer) && imageryLayerItem.isEnabled && imageryLayerItem.isShown) {
        if (defined(imageryLayerItem._imageryLayer.alpha)) {
            imageryLayerItem._imageryLayer.alpha = imageryLayerItem.opacity;
        }

        if (defined(imageryLayerItem._imageryLayer.setOpacity)) {
            imageryLayerItem._imageryLayer.setOpacity(imageryLayerItem.opacity);
        }

        imageryLayerItem.application.currentViewer.notifyRepaintRequired();
    }
}

module.exports = ImageryLayerCatalogItem;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/clone":240,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"./CatalogItem":27,"./ModelError":41}],37:[function(require,module,exports){
'use strict';

/*global require,Document*/

var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var KmlDataSource = require('../../third_party/cesium/Source/DataSources/KmlDataSource');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var Metadata = require('./Metadata');
var ModelError = require('./ModelError');
var CatalogItem = require('./CatalogItem');
var inherit = require('../Core/inherit');
var readXml = require('../Core/readXml');

/**
 * A {@link CatalogItem} representing KML or KMZ feature data.
 *
 * @alias KmlCatalogItem
 * @constructor
 * @extends CatalogItem
 * 
 * @param {Application} application The application.
 * @param {String} [url] The URL from which to retrieve the KML or KMZ data.
 */
var KmlCatalogItem = function(application, url) {
    CatalogItem.call(this, application);

    this._kmlDataSource = undefined;

    /**
     * Gets or sets the URL from which to retrieve KML or KMZ data.  This property is ignored if
     * {@link KmlCatalogItem#data} is defined.  This property is observable.
     * @type {String}
     */
    this.url = url;

    /**
     * Gets or sets the KML or KMZ data, represented as a binary Blob, DOM Document, or a Promise for one of those things.
     * This property is observable.
     * @type {Blob|Document|Promise}
     */
    this.data = undefined;

    /**
     * Gets or sets the URL from which the {@link KmlCatalogItem#data} was obtained.  This will be used
     * to resolve any resources linked in the KML file, if any.
     * @type {String}
     */
    this.dataSourceUrl = undefined;

    knockout.track(this, ['url', 'data', 'dataSourceUrl']);
};

inherit(CatalogItem, KmlCatalogItem);

defineProperties(KmlCatalogItem.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf KmlCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'kml';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'KML'.
     * @memberOf KmlCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'KML or KMZ';
        }
    },

    /**
     * Gets the metadata associated with this data source and the server that provided it, if applicable.
     * @memberOf KmlCatalogItem.prototype
     * @type {Metadata}
     */
    metadata : {
        get : function() {
            var result = new Metadata();
            result.isLoading = false;
            result.dataSourceErrorMessage = 'This data source does not have any details available.';
            result.serviceErrorMessage = 'This service does not have any details available.';
            return result;
        }
    }
});

KmlCatalogItem.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url, this.data];
};

var kmzRegex = /\.kmz$/i;

KmlCatalogItem.prototype._load = function() {
    var dataSource = new KmlDataSource();
    this._kmlDataSource = dataSource;

    var that = this;

    if (defined(that.data)) {
        return when(that.data, function(data) {
            if (data instanceof Document) {
                return dataSource.load(data, proxyUrl(that, that.dataSourceUrl)).then(function() {
                    doneLoading(that);
                }).otherwise(function() {
                    errorLoading(that);
                });
            } else if (data instanceof Blob) {
                if (that.dataSourceUrl && that.dataSourceUrl.match(kmzRegex)) {
                    return dataSource.loadKmz(data, proxyUrl(that, that.dataSourceUrl)).then(function() {
                        doneLoading(that);
                    }).otherwise(function() {
                        errorLoading(that);
                    });
                } else {
                    return readXml(data).then(function(xml) {
                        return dataSource.load(xml, proxyUrl(that, that.dataSourceUrl)).then(function() {
                            doneLoading(that);
                        }).otherwise(function() {
                            errorLoading(that);
                        });
                    });
                }
            } else {
                throw new ModelError({
                    sender: that,
                    title: 'Unexpected type of KML data',
                    message: '\
KmlCatalogItem.data is expected to be an XML Document, Blob, or File, but it was none of these. \
This may indicate a bug in National Map or incorrect use of the National Map API. \
If you believe it is a bug in National Map, please report it by emailing \
<a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.'
                });
            }
        });
    } else {
        return dataSource.loadUrl(proxyUrl(that, that.url)).then(function() {
            doneLoading(that);
        }).otherwise(function() {
            errorLoading(that);
        });
    }
};

KmlCatalogItem.prototype._enable = function() {
};

KmlCatalogItem.prototype._disable = function() {
};

KmlCatalogItem.prototype._show = function() {
    if (!defined(this._kmlDataSource)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var dataSources = this.application.dataSources;
    if (dataSources.contains(this._kmlDataSource)) {
        throw new DeveloperError('This data source is already shown.');
    }

    dataSources.add(this._kmlDataSource);
};

KmlCatalogItem.prototype._hide = function() {
    if (!defined(this._kmlDataSource)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var dataSources = this.application.dataSources;
    if (!dataSources.contains(this._kmlDataSource)) {
        throw new DeveloperError('This data source is not shown.');
    }

    dataSources.remove(this._kmlDataSource, false);
};

function proxyUrl(application, url) {
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(url)) {
        return application.corsProxy.getURL(url);
    }

    return url;
}

function doneLoading(kmlItem) {
    kmlItem.clock = kmlItem._kmlDataSource.clock;
}

function errorLoading(kmlItem) {
    throw new ModelError({
        sender: kmlItem,
        title: 'Error loading KML or KMZ',
        message: '\
An error occurred while loading a KML or KMZ file.  This may indicate that the file is invalid or that it \
is not supported by National Map.  If you would like assistance or further information, please email us \
at <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.'
    });
}

module.exports = KmlCatalogItem;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/DataSources/KmlDataSource":302,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/inherit":7,"../Core/readXml":11,"./CatalogItem":27,"./Metadata":39,"./ModelError":41}],38:[function(require,module,exports){
'use strict';

/*global require,html2canvas*/
var destroyObject = require('../../third_party/cesium/Source/Core/destroyObject');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var rectangleToLatLngBounds = require('../Map/rectangleToLatLngBounds');

var Leaflet = function(application, map) {
    /**
     * Gets or sets the Leaflet {@link Map} instance.
     * @type {Map}
     */
    this.map = map;
};

Leaflet.prototype.destroy = function() {
    return destroyObject(this);
};

/**
 * Gets the current extent of the camera.  This may be approximate if the viewer does not have a strictly rectangular view.
 * @return {Rectangle} The current visible extent.
 */
Leaflet.prototype.getCurrentExtent = function() {
    var bounds = this.map.getBounds();
    return Rectangle.fromDegrees(bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth());
};

/**
 * Zooms to a specified extent.
 *
 * @param {Rectangle} extent The extent to which to zoom.
 */
Leaflet.prototype.zoomTo = function(extent) {
    this.map.fitBounds(rectangleToLatLngBounds(extent));
};

/**
 * Captures a screenshot of the map.
 * @return {Promise} A promise that resolves to a data URL when the screenshot is ready.
 */
Leaflet.prototype.captureScreenshot = function() {
    var deferred = when.defer();

    // Temporarily hide the map credits.
    this.map.attributionControl.removeFrom(this.map);

    var that = this;

    try {
        html2canvas(this.map.getContainer(), {
            useCORS: true,
            onrendered: function(canvas) {
                var dataUrl;

                try {
                    dataUrl = canvas.toDataURL("image/jpeg");
                } catch (e) {
                    deferred.reject(e);
                }

                that.map.attributionControl.addTo(that.map);

                deferred.resolve(dataUrl);
            }
        });
    } catch (e) {
        that.map.attributionControl.addTo(that.map);
        deferred.reject(e);
    }

    return deferred.promise;
};

/**
 * Notifies the viewer that a repaint is required.
 */
Leaflet.prototype.notifyRepaintRequired = function() {
    // Leaflet doesn't need to do anything with this notification.
};

module.exports = Leaflet;

},{"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/destroyObject":247,"../../third_party/cesium/Source/ThirdParty/when":596,"../Map/rectangleToLatLngBounds":20}],39:[function(require,module,exports){
"use strict";

/*global require*/

var MetadataItem = require('./MetadataItem');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

/**
 * Represents the metadata associated with a data source.
 *
 * @alias Metadata
 * @function
 */
var Metadata = function() {
    /**
     * Gets or sets the metadata group for the data source itself.
     * @type {MetadataItem}
     */
    this.dataSourceMetadata = new MetadataItem();

    /**
     * Gets or sets the metadata group for the service 
     * @type {MetadataItem}
     */
    this.serviceMetadata = new MetadataItem();

    /**
     * Gets or sets a promise that, when resolved, indicates that the metadata groups are
     * fully populated.
     * @type {Promise}
     */
    this.promise = undefined;

    /**
     * Gets or sets an error message resulting from attempting to get the data source metadata, or undefined
     * if no has error occurred.
     * @type {String}
     */
    this.dataSourceErrorMessage = undefined;

    /**
     * Gets or sets an error message resulting from attempting to get the service metadata, or undefined
     * if no has error occurred.
     * @type {String}
     */
    this.serviceErrorMessage = undefined;

    /**
     * Gets or sets a value indicating whether the metadata is currently loading.
     * @type {Boolean}
     */
    this.isLoading = true;

    knockout.track(this, ['dataSourceMetadata', 'serviceMetadata', 'dataSourceErrorMessage', 'serviceErrorMessage', 'isLoading']);
};

module.exports = Metadata;

},{"../../third_party/cesium/Source/ThirdParty/knockout":591,"./MetadataItem":40}],40:[function(require,module,exports){
"use strict";

/*global require*/

var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var MetadataItem = function(name, value) {
    /**
     * Gets or sets the name of the metadata item.  This property is observable.
     * @type {String}
     */
    this.name = name;

    /**
     * Gets or sets the value of the metadata item.
     * @type {Object}
     */
    this.value = value;

    /**
     * Gets the list of metadata items contained in this group.  This property is observable.
     * @type {MetadataItem[]}
     */
    this.items = [];

    /**
     * Gets or sets a value indicating whether this metadata item is currently open.  When an
     * item is open, its child items (if any) are visible.  This property is observable.
     * @type {Boolean}
     */
    this.isOpen = true;

    knockout.track(this, ['name', 'value', 'items', 'isOpen']);
};

defineProperties(MetadataItem.prototype, {
    /**
     * Gets a value indicating whether this item has child items.
     * @type {Boolean}
     */
    hasChildren : {
        get : function() {
            return this.items.length > 0;
        }
    },

    valueIsArray : {
        get : function() {
            return this.value instanceof Array;
        }
    }
});

/**
 * Toggles the {@link MetadataItem#isOpen} property.  If this item's list of children is open,
 * calling this method will close it.  If the list is closed, calling this method will open it.
 */
MetadataItem.prototype.toggleOpen = function() {
    this.isOpen = !this.isOpen;
};

module.exports = MetadataItem;

},{"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/ThirdParty/knockout":591}],41:[function(require,module,exports){
'use strict';

/*global require*/

var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');

/**
 * Represents an error that occurred in a model, especially an asynchronous one that cannot be raised
 * by throwing an exception because no one would be able to catch it.
 *
 * @alias ModelError
 * @constructor
 * 
 * @param {Object} options Object with the following properties:
 * @param {Object} [options.sender] The object raising the error.
 * @param {String} [options.title='An error occurred'] A short title describing the error.
 * @param {String} options.message A detailed message describing the error.  This message may be HTML and it should be sanitized before display to the user.
 */
var ModelError = function(options) {
    /**
     * Gets or sets the object that raised the error.
     * @type {Object}
     */
    this.sender = options.sender;

    /**
     * Gets or sets a short title describing the error.
     * @type {String}
     */
    this.title = defaultValue(options.title, 'An error occurred');

    /**
     * Gets or sets a metailed message describing the error.  This message may be HTML and it should be sanitized before display to the user.
     * @type {String}
     */
    this.message = options.message;
};

module.exports = ModelError;

},{"../../third_party/cesium/Source/Core/defaultValue":243}],42:[function(require,module,exports){
'use strict';

/*global require*/

var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var EventHelper = require('../../third_party/cesium/Source/Core/EventHelper');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

/**
 * The model for the "Now Viewing" pane.
 */
var NowViewing = function(application) {
    this._application = application;
    this._eventSubscriptions = new EventHelper();

    /**
     * Gets the list of items that we are "now viewing".  It is recommended that you use
     * the methods on this instance instead of manipulating the list of items directly.
     * This property is observable.
     * @type {CatalogItem[]}
     */
    this.items = [];

    /**
     * Gets or sets a value indicating whether the Now Viewing list is currently open and visible.
     * @type {Boolean}
     */
    this.isOpen = true;

    knockout.track(this, ['items', 'isOpen']);

    this._eventSubscriptions.add(this.application.beforeViewerChanged, function() {
        beforeViewerChanged(this);
    }, this);

    this._eventSubscriptions.add(this.application.afterViewerChanged, function() {
        afterViewerChanged(this);
    }, this);
};

defineProperties(NowViewing.prototype, {
    /**
     * Gets the application.
     * @memberOf NowViewing.prototype
     * @type {Application}
     */
    application : {
        get : function() {
            return this._application;
        }
    },

    /**
     * Gets a value indicating whether the "Now Viewing" pane has one or more items.
     * @memberOf NowViewing.prototype
     * @type {Boolean}
     */
    hasItems : {
        get : function() {
            return this.items.length > 0;
        }
    },

    /**
     * Gets a value indicating whether the "Now Viewing" pane has at list own data
     * source that is currently shown.
     * @memberOf NowViewing.prototype
     * @type {Boolean}
     */
    hasShownItems : {
        get : function() {
            for (var i = 0; i < this.items.length; ++i) {
                if (this.items[i].isShown) {
                    return true;
                }
            }
            return false;
        }
    }
});

/**
 * Destroys this instance, including unsubscribing it from any events.
 */
NowViewing.prototype.destroy = function() {
    this._eventSubscriptions.removeAll();
};

/**
 * Adds an item to the "Now Viewing" pane.
 *
 * @param {CatalogMember} item The item to add.
 */
NowViewing.prototype.add = function(item) {
    // Keep reorderable data sources (ie: imagery layers) below non-orderable ones (ie: GeoJSON).
    if (item.supportsReordering) {
        var index = 0;

        while (index < this.items.length && !this.items[index].supportsReordering) {
            ++index;
        }

        this.items.splice(index, 0, item);
    } else {
        this.items.unshift(item);
    }
};

/**
 * Removes an item from the "Now Viewing" pane and from the map.
 *
 * @param {CatalogMember} item The item to remove.
 */
NowViewing.prototype.remove = function(item) {
    item.isEnabled = false;
    this.items.remove(item);
};

/**
 * Removes all data sources from the "Now Viewing" pane and from the map.
 */
NowViewing.prototype.removeAll = function() {
    // Work backwards through the list of items because setting isEnabled=false
    // will usually remove the item from the list.
    for (var i = this.items.length - 1; i >= 0; --i) {
        this.items[i].isEnabled = false;
    }

    this.items.removeAll();
};

/**
 * Raises an item, making it displayed on top of the item that is currently above it.  If it
 * is nonsensical to move this item up (e.g. it is already at the top), this method does nothing.
 *
 * @param {CatalogMember} item The item to raise.
 * @param {Number} [index] The index of the item of the list, if it is already known.
 */
NowViewing.prototype.raise = function(item, index) {
    if (defined(index)) {
        if (this.items[index] !== item) {
            throw new DeveloperError('The provided index is not correct.');
        }
    } else {
        index = this.items.indexOf(item);
        if (index < 0) {
            return;
        }
    }

    if (index === 0) {
        return;
    }

    // Don't allow reorderable data sources to move above non-reorderable ones.
    if (item.supportsReordering && !this.items[index - 1].supportsReordering) {
        return;
    }

    var application = this.application;

    if (defined(application.cesium)) {
        raiseInCesium(this, item, this.items[index - 1]);
    }

    if (defined(application.leaflet)) {
        raiseInLeaflet(this, item, this.items[index - 1]);
    }

    this.items.splice(index, 1);
    this.items.splice(index - 1, 0, item);

    this.application.currentViewer.notifyRepaintRequired();
};

/**
 * Lowers an item, making it displayed below the item that is currently below it.  If it
 * is nonsensical to move this item down (e.g. it is already at the bottom), this method does nothing.
 *
 * @param {CatalogMember} item The item to lower.
 * @param {Number} [index] The index of the item of the list, if it is already known.
 */
NowViewing.prototype.lower = function(item, index) {
    if (defined(index)) {
        if (this.items[index] !== item) {
            throw new DeveloperError('The provided index is not correct.');
        }
    } else {
        index = this.items.indexOf(item);
        if (index < 0) {
            return;
        }
    }

    if (index === this.items.length - 1) {
        return;
    }

    var itemBelow = this.items[index + 1];

    // Don't allow non-reorderable data sources to move below reorderable ones.
    if (!item.supportsReordering && itemBelow.supportsReordering) {
        return;
    }

    var application = this.application;

    if (defined(application.cesium)) {
        lowerInCesium(this, item, itemBelow);
    }

    if (defined(application.leaflet)) {
        lowerInLeaflet(this, item, itemBelow);
    }

    this.items.splice(index, 1);
    this.items.splice(index + 1, 0, item);

    this.application.currentViewer.notifyRepaintRequired();
};

/**
 * Toggles the {@link NowViewing#isOpen} flag.  If it's open, it is closed.  If it's closed, it is opened.
 */
NowViewing.prototype.toggleOpen = function() {
    this.isOpen = !this.isOpen;
};

/**
 * Records the the index of each data source in the Now Viewing list in a {@link CatalogItem#nowViewingIndex} property
 * on the data source.  This is used to save the state of the Now Viewing list and is not intended for general
 * use.
 * @private
 */
NowViewing.prototype.recordNowViewingIndices = function() {
    for (var i = 0; i < this.items.length; ++i) {
        this.items[i].nowViewingIndex = i;
    }
};

/**
 * Sorts the data sources in the Now Viewing list by their {@link CatalogItem#nowViewingIndex} properties.  This is used
 * to restore the state of the Now Viewing list and is not intended for general use.
 * @private
 */
NowViewing.prototype.sortByNowViewingIndices = function() {
    var sortedItems = this.items.slice();
    sortedItems.sort(function(a, b) {
        return a.nowViewingIndex - b.nowViewingIndex;
    });

    for (var i = 0; i < sortedItems.length; ++i) {
        var item = sortedItems[i];

        var existingIndex = this.items.indexOf(item);

        while (existingIndex > i) {
            this.raise(item, existingIndex);
            --existingIndex;
        }
    }

    if (defined(this.application.currentViewer)) {
        this.application.currentViewer.notifyRepaintRequired();
    }
};

/**
 * Updates the order of layers on the Leaflet map to match the order in the Now Viewing pane.
 * @private
 */
NowViewing.prototype.updateLeafletLayerOrder = function() {
    // Set the current z-index of all layers.
    var items = this.items;

    var reorderableZIndex = 100; // an arbitrary place to start
    var fixedZIndex = 1000000; // fixed layers go on top of reorderable ones.

    for (var i = items.length - 1; i >= 0; --i) {
        var currentItem = items[i];
        if (defined(currentItem.imageryLayer)) {
            if (currentItem.supportsReordering) {
                currentItem.imageryLayer.setZIndex(reorderableZIndex++);
            } else {
                currentItem.imageryLayer.setZIndex(fixedZIndex++);
            }
        }
    }
};

// Raise and lower functions for the two maps.  Currently we can only raise and lower imagery layers.

function raiseInCesium(nowViewing, item, itemAbove) {
    if (!defined(item.imageryLayer) || !defined(itemAbove.imageryLayer)) {
        return;
    }

    var scene = nowViewing.application.cesium.scene;
    scene.imageryLayers.raise(item.imageryLayer);
}

function lowerInCesium(nowViewing, item, itemBelow) {
    if (!defined(item.imageryLayer) || !defined(itemBelow.imageryLayer)) {
        return;
    }

    var scene = nowViewing.application.cesium.scene;
    scene.imageryLayers.lower(item.imageryLayer);
}

function raiseInLeaflet(nowViewing, item, itemAbove) {
    swapLeafletZIndices(nowViewing, item, itemAbove);
}

function lowerInLeaflet(nowViewing, item, itemBelow) {
    swapLeafletZIndices(nowViewing, item, itemBelow);
}

function swapLeafletZIndices(nowViewing, item, otherItem) {
    if (!defined(item.imageryLayer) || !defined(otherItem.imageryLayer)) {
        return;
    }

    if (!defined(item.imageryLayer.options.zIndex) || !defined(item.imageryLayer.options.zIndex)) {
        nowViewing.updateLeafletLayerOrder();
    }

    // Swap the z-indices of the two layers.
    var itemIndex = item.imageryLayer.options.zIndex;
    var otherIndex = otherItem.imageryLayer.options.zIndex;

    item.imageryLayer.setZIndex(otherIndex);
    otherItem.imageryLayer.setZIndex(itemIndex);
}

function beforeViewerChanged(nowViewing) {
    // Hide and disable all data sources, without actually changing
    // their isEnabled and isShown flags.

    var dataSources = nowViewing.items;

    for (var i = 0; i < dataSources.length; ++i) {
        var dataSource = dataSources[i];
        if (defined(dataSource._loadForEnablePromise)) {
            continue;
        }

        if (dataSource.isShown) {
            dataSource._hide();
        }

        if (dataSource.isEnabled) {
            dataSource._disable();
        }
    }
}

function afterViewerChanged(nowViewing) {
    // Re-enable and re-show all data sources that were previously enabled or shown.
    // Work from the bottom data source up so that the correct order is created.

    var dataSources = nowViewing.items;

    for (var i = dataSources.length - 1; i >= 0; --i) {
        var dataSource = dataSources[i];
        if (defined(dataSource._loadForEnablePromise)) {
            continue;
        }

        if (dataSource.isEnabled) {
            dataSource._enable();
        }

        if (dataSource.isShown) {
            dataSource._show();
        }
    }
}

module.exports = NowViewing;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/EventHelper":139,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591}],43:[function(require,module,exports){
'use strict';

/*global require*/

var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadWithXhr = require('../../third_party/cesium/Source/Core/loadWithXhr');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var CatalogItem = require('./CatalogItem');
var GeoJsonCatalogItem = require('./GeoJsonCatalogItem');
var inherit = require('../Core/inherit');
var Metadata = require('./Metadata');
var ModelError = require('./ModelError');

/**
 * A {@link CatalogItem} representing ogr2ogr supported data formats.
 *
 * @alias OgrCatalogItem
 * @constructor
 * @extends GeoJsonCatalogItem
 * 
 * @param {Application} application The application.
 * @param {String} [url] The URL from which to retrieve the OGR data.
 */
var OgrCatalogItem = function(application, url) {
    CatalogItem.call(this, application);

    this._geoJsonItem = undefined;

    /**
     * Gets or sets the URL from which to retrieve OGR data.  This property is ignored if
     * {@link OgrCatalogItem#data} is defined.  This property is observable.
     * @type {String}
     */
    this.url = url;

    /**
     * Gets or sets the Ogr data, represented as a binary Blob, DOM Document, or a Promise for one of those things.
     * This property is observable.
     * @type {Blob|Document|Promise}
     */
    this.data = undefined;

    /**
     * Gets or sets the URL from which the {@link OgrCatalogItem#data} was obtained.  This may be used
     * to resolve any resources linked in the Ogr file, if any.
     * @type {String}
     */
    this.dataSourceUrl = undefined;

    knockout.track(this, ['url', 'data', 'dataSourceUrl']);
};

inherit(CatalogItem, OgrCatalogItem);

defineProperties(OgrCatalogItem.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf OgrCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'ogr';
        }
    },

    /**
     * Gets a human-readable name for this type of data source.
     * @memberOf OgrCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Unknown / Converted to GeoJSON';
        }
    },

    /**
     * Gets the metadata associated with this data source and the server that provided it, if applicable.
     * @memberOf OgrCatalogItem.prototype
     * @type {Metadata}
     */
    metadata : {
        get : function() {
            var result = new Metadata();
            result.isLoading = false;
            result.dataSourceErrorMessage = 'This data source does not have any details available.';
            result.serviceErrorMessage = 'This service does not have any details available.';
            return result;
        }
    }
});

OgrCatalogItem.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url, this.data];
};

OgrCatalogItem.prototype._load = function() {
    if (typeof FormData === 'undefined') {
        throw new ModelError({
            sender: this,
            title: 'Legacy browser not supported',
            message: '\
Your web browser does not support the "FormData" type, which is required by the National Map conversion service.  \
We recommend you upgrade to the latest version of <a href="http://www.google.com/chrome" target="_blank">Google Chrome</a>, \
<a href="http://www.mozilla.org/firefox" target="_blank">Mozilla Firefox</a>, \
<a href="https://www.apple.com/au/osx/how-to-upgrade/" target="_blank">Apple Safari</a>, or \
<a href="http://www.microsoft.com/ie" target="_blank">Microsoft Internet Explorer</a>.'
        });
    }

    this._geoJsonItem = new GeoJsonCatalogItem(this.application);

    var that = this;

    if (defined(that.data)) {
        return when(that.data, function(data) {
            if (!(data instanceof Blob)) {
                //create a file blob
                data = new Blob([data], {
                    type : 'application/octet-stream', 
                    name: that.dataSourceUrl, 
                    lastModifiedDate: new Date()
                });
            }
            return loadOgrData(that, data);
        });
    } else {
        return loadOgrData(that, undefined, that.url);
    }
};

OgrCatalogItem.prototype._enable = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._enable();
    }
};

OgrCatalogItem.prototype._disable = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._disable();
    }
};

OgrCatalogItem.prototype._show = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._show();
    }
};

OgrCatalogItem.prototype._hide = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._hide();
    }
};

function loadOgrData(ogrItem, file, url) {

    // generate form to submit file for conversion
    var formData = new FormData();
    if (defined(file)) {
        if (file.size > 1000000) {
            errorLoading(ogrItem, 'The file size is greater than the 1Mb limit of the National Map conversion service.');
            return;
        }
        formData.append('input_file', file);
    } else if (defined(url)) {
        // fix up url to server if relative
        if (url.indexOf('http') !== 0) {
            url = 'http://'+document.location.host+'/'+url;
        }
        formData.append('input_url', url);
    }

    console.log('Attempting to convert file via the NM ogr2ogr web service');

    return loadWithXhr({
        url : '/convert',
        method : 'POST',
        data : formData
    }).then(function(response) {
        ogrItem._geoJsonItem.data = JSON.parse(response);

        return ogrItem._geoJsonItem.load().then(function() {
            ogrItem.rectangle = ogrItem._geoJsonItem.rectangle;
            ogrItem.clock = ogrItem._geoJsonItem.clock;
        });
    }).otherwise(function() {
        errorLoading(ogrItem);
    });
}


function errorLoading(ogrItem, msg) {
    if (!defined(msg)) {
        msg = 'This may indicate that the file is invalid or that it is not supported by the National Map conversion service.';
    }
    throw new ModelError({
        sender: ogrItem,
        title: 'Error converting file to GeoJson',
        message: '\
An error occurred while attempting to convert this file to GeoJson.  ' + msg + '  If you would like assistance or further information, please email us \
at <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.'
    });
}

module.exports = OgrCatalogItem;

},{"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/loadWithXhr":263,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/inherit":7,"./CatalogItem":27,"./GeoJsonCatalogItem":34,"./Metadata":39,"./ModelError":41}],44:[function(require,module,exports){
'use strict';

var Services = function(application) {
    this.services = [];
};

module.exports = Services;

},{}],45:[function(require,module,exports){
'use strict';

/**
 * Identifies the map viewer mode to use.
 * @alias ViewerMode
 */
var ViewerMode = {
    /**
     * Cesium is used for a 3D view with terrain.
     * @type {Number}
     * @constant
     */
    CesiumTerrain : 0,

    /**
     * Cesium is used for a 3D view, but the globe surface is a smooth ellipsoid.
     * @type {Number}
     * @constant
     */
    CesiumEllipsoid : 1,

    /**
     * Leaflet is used for a 2D map.
     * @type {Number}
     */
    Leaflet : 2
};

module.exports = ViewerMode;

},{}],46:[function(require,module,exports){
'use strict';

/*global require,URI,$*/

var clone = require('../../third_party/cesium/Source/Core/clone');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadXML = require('../../third_party/cesium/Source/Core/loadXML');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');

var ModelError = require('./ModelError');
var CatalogGroup = require('./CatalogGroup');
var inherit = require('../Core/inherit');
var unionRectangles = require('../Map/unionRectangles');
var WebFeatureServiceCatalogItem = require('./WebFeatureServiceCatalogItem');

/**
 * A {@link CatalogGroup} representing a collection of feature types from a Web Feature Service (WFS) server.
 *
 * @alias WebFeatureServiceCatalogGroup
 * @constructor
 * @extends CatalogGroup
 * 
 * @param {Application} application The application.
 */
var WebFeatureServiceCatalogGroup = function(application) {
    CatalogGroup.call(this, application, 'wfs-getCapabilities');

    /**
     * Gets or sets the URL of the WFS server.  This property is observable.
     * @type {String}
     */
    this.url = '';

    /**
     * Gets or sets a description of the custodian of the data sources in this group.
     * This property is an HTML string that must be sanitized before display to the user.
     * This property is observable.
     * @type {String}
     */
    this.dataCustodian = undefined;

    knockout.track(this, ['url', 'dataCustodian']);
};

inherit(CatalogGroup, WebFeatureServiceCatalogGroup);

defineProperties(WebFeatureServiceCatalogGroup.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf WebFeatureServiceCatalogGroup.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'wfs-getCapabilities';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, such as 'Web Feature Service (WFS)'.
     * @memberOf WebFeatureServiceCatalogGroup.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Web Feature Service (WFS) Server';
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf WebFeatureServiceCatalogGroup.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return WebFeatureServiceCatalogGroup.defaultSerializers;
        }
    }
});

/**
 * Gets or sets the set of default serializer functions to use in {@link CatalogMember#serializeToJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#serializers} property.
 * @type {Object}
 */
WebFeatureServiceCatalogGroup.defaultSerializers = clone(CatalogGroup.defaultSerializers);

WebFeatureServiceCatalogGroup.defaultSerializers.items = function(wfsGroup, json, propertyName, options) {
    // Only serialize minimal properties in contained items, because other properties are loaded from GetCapabilities.
    var previousSerializeForSharing = options.serializeForSharing;
    options.serializeForSharing = true;

    // Only serlize enabled items as well.  This isn't quite right - ideally we'd serialize any
    // property of any item if the property's value is changed from what was loaded from GetCapabilities -
    // but this gives us reasonable results for sharing and is a lot less work than the ideal
    // solution.
    var previousEnabledItemsOnly = options.enabledItemsOnly;
    options.enabledItemsOnly = true;

    CatalogGroup.defaultSerializers.items(wfsGroup, json, propertyName, options);

    options.enabledItemsOnly = previousEnabledItemsOnly;
    options.serializeForSharing = previousSerializeForSharing;
};

WebFeatureServiceCatalogGroup.defaultSerializers.isLoading = function(wfsGroup, json, propertyName, options) {};

freezeObject(WebFeatureServiceCatalogGroup.defaultSerializers);

WebFeatureServiceCatalogGroup.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url];
};

WebFeatureServiceCatalogGroup.prototype._load = function() {
    var url = cleanAndProxyUrl(this.application, this.url) + '?service=WFS&version=1.1.0&request=GetCapabilities';

    var that = this;
    return loadXML(url).then(function(xml) {
        if (typeof xml === 'string') {
            xml = $.parseXML(xml);
        }

        // Is this really a GetCapabilities response?
        if (!xml || !xml.documentElement || xml.documentElement.localName !== 'WFS_Capabilities') {
            throw new ModelError({
                title: 'Invalid WFS server',
                message: '\
An error occurred while invoking GetCapabilities on the WFS server.  The server\'s response does not appear to be a valid GetCapabilities document.  \
<p>If you entered the link manually, please verify that the link is correct.</p>\
<p>If you did not enter this link manually, this error may indicate that the group you opened is temporarily unavailable or there is a \
problem with your internet connection.  Try opening the group again, and if the problem persists, please report it by \
sending an email to <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.</p>'
            });
        }

        var json = $.xml2json(xml);

        var supportsJsonGetFeature = false;

        if (defined(json.OperationsMetadata)) {
            var getFeatureOperation = findElementByName(json.OperationsMetadata.Operation, 'GetFeature');
            if (defined(getFeatureOperation)) {
                var outputFormatParameter = findElementByName(getFeatureOperation.Parameter, 'outputFormat');
                if (defined(outputFormatParameter) && defined(outputFormatParameter.Value)) {
                    supportsJsonGetFeature = outputFormatParameter.Value.indexOf('json') >= 0 ||
                                             outputFormatParameter.Value.indexOf('JSON') >= 0 ||
                                             outputFormatParameter.Value.indexOf('application/json') >= 0;
                }
            }
        }

        var dataCustodian = that.dataCustodian;
        if (!defined(dataCustodian) && defined(json.ServiceProvider) && defined(json.ServiceProvider.ProviderName)) {
            dataCustodian = json.ServiceProvider.ProviderName;

            if (defined(json.ServiceProvider.ProviderSite) && defined(json.ServiceProvider.ProviderSite.href)) {
                dataCustodian = '[' + dataCustodian + '](' + json.ServiceProvider.ProviderSite.href + ')';
            }

            if (defined(json.ServiceProvider.ServiceContact) && defined(json.ServiceProvider.ServiceContact.Address) && defined(json.ServiceProvider.ServiceContact.Address.ElectronicMailAddress)) {
                dataCustodian += '<br/>';
                dataCustodian += '[' + json.ServiceProvider.ServiceContact.Address.ElectronicMailAddress + '](mailto:' + json.ServiceProvider.ServiceContact.Address.ElectronicMailAddress + ')<br/>'; 
            }
        }

        if (defined(json.FeatureTypeList)) {
            addFeatureTypes(that, json.FeatureTypeList.FeatureType, that.items, undefined, supportsJsonGetFeature, dataCustodian);
        }
    }).otherwise(function(e) {
        throw new ModelError({
            title: 'Group is not available',
            message: '\
An error occurred while invoking GetCapabilities on the WFS server.  \
<p>If you entered the link manually, please verify that the link is correct.</p>\
<p>This error may also indicate that the server does not support <a href="http://enable-cors.org/" target="_blank">CORS</a>.  If this is your \
server, verify that CORS is enabled and enable it if it is not.  If you do not control the server, \
please contact the administrator of the server and ask them to enable CORS.  Or, contact the National \
Map team by emailing <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a> \
and ask us to add this server to the list of non-CORS-supporting servers that may be proxied by \
National Map itself.</p>\
<p>If you did not enter this link manually, this error may indicate that the group you opened is temporarily unavailable or there is a \
problem with your internet connection.  Try opening the group again, and if the problem persists, please report it by \
sending an email to <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.</p>'
        });
    });
};

function findElementByName(list, name) {
    if (!defined(list)) {
        return undefined;
    }

    for (var i = 0; i < list.length; ++i) {
        if (list[i].name === name) {
            return list[i];
        }
    }

    return undefined;
}

function cleanAndProxyUrl(application, url) {
    // Strip off the search portion of the URL
    var uri = new URI(url);
    uri.search('');

    var cleanedUrl = uri.toString();
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(cleanedUrl)) {
        cleanedUrl = application.corsProxy.getURL(cleanedUrl, '1d');
    }

    return cleanedUrl;
}

function addFeatureTypes(wfsGroup, featureTypes, items, parent, supportsJsonGetFeature, dataCustodian) {
    if (!(featureTypes instanceof Array)) {
        featureTypes = [featureTypes];
    }

    for (var i = 0; i < featureTypes.length; ++i) {
        var featureType = featureTypes[i];
        items.push(createWfsDataSource(wfsGroup, featureType, supportsJsonGetFeature, dataCustodian));
    }
}

function createWfsDataSource(wfsGroup, featureType, supportsJsonGetFeature, dataCustodian) {
    var result = new WebFeatureServiceCatalogItem(wfsGroup.application);

    result.name = featureType.Title;
    result.description = defined(featureType.Abstract) && featureType.Abstract.length > 0 ? featureType.Abstract : wfsGroup.description;
    result.dataCustodian = dataCustodian;
    result.url = wfsGroup.url;
    result.typeNames = featureType.Name;

    result.description = '';

    var wfsGroupHasDescription = defined(wfsGroup.description) && wfsGroup.description.length > 0;
    var layerHasAbstract = defined(featureType.Abstract) && featureType.Abstract.length > 0;

    if (wfsGroupHasDescription) {
        result.description += wfsGroup.description;
    }

    if (wfsGroupHasDescription && layerHasAbstract) {
        result.description += '<br/>';
    }

    if (layerHasAbstract) {
        result.description += featureType.Abstract;
    }

    result.requestGeoJson = supportsJsonGetFeature;
    result.requestGml = true;

    var boundingBoxes = featureType.WGS84BoundingBox;

    var rectangle;
    if (boundingBoxes instanceof Array) {
        rectangle = wgs84BoundingBoxToRectangle(boundingBoxes[0]);
        for (var i = 1; i < boundingBoxes.length; ++i) {
            rectangle = unionRectangles(rectangle, wgs84BoundingBoxToRectangle(boundingBoxes[i]));
        }
    } else if (defined(boundingBoxes)) {
        rectangle = wgs84BoundingBoxToRectangle(boundingBoxes);
    } else {
        rectangle = Rectangle.MAX_VALUE;
    }

    result.rectangle = rectangle;

    return result;
}

function wgs84BoundingBoxToRectangle(boundingBox) {
    if (!defined(boundingBox)) {
        return Rectangle.MAX_VALUE;
    }

    var lowerCorner = boundingBox.LowerCorner;
    var upperCorner = boundingBox.UpperCorner;
    if (!defined(lowerCorner) || !defined(upperCorner)) {
        return Rectangle.MAX_VALUE;
    }

    var lowerCoordinates = lowerCorner.split(' ');
    var upperCoordinates = upperCorner.split(' ');
    if (lowerCoordinates.length !== 2 || upperCoordinates.length !== 2) {
        return Rectangle.MAX_VALUE;
    }

    return Rectangle.fromDegrees(lowerCoordinates[0], lowerCoordinates[1], upperCoordinates[0], upperCoordinates[1]);
}


module.exports = WebFeatureServiceCatalogGroup;

},{"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/clone":240,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/Core/loadXML":264,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"../Map/unionRectangles":21,"./CatalogGroup":26,"./ModelError":41,"./WebFeatureServiceCatalogItem":47}],47:[function(require,module,exports){
'use strict';

/*global require,URI*/

var clone = require('../../third_party/cesium/Source/Core/clone');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadJson = require('../../third_party/cesium/Source/Core/loadJson');
var loadXML = require('../../third_party/cesium/Source/Core/loadXML');
var objectToQuery = require('../../third_party/cesium/Source/Core/objectToQuery');

var GeoJsonCatalogItem = require('./GeoJsonCatalogItem');
var CatalogItem = require('./CatalogItem');
var inherit = require('../Core/inherit');
var gmlToGeoJson = require('../Map/gmlToGeoJson');

/**
 * A {@link ImageryLayerCatalogItem} representing a layer from a Web Map Service (WMS) server.
 *
 * @alias WebFeatureServiceCatalogItem
 * @constructor
 * @extends CatalogItem
 * 
 * @param {Application} application The application for the group.
 */
var WebFeatureServiceCatalogItem = function(application) {
    CatalogItem.call(this, application);

    this._dataUrl = undefined;
    this._dataUrlType = undefined;
    this._metadataUrl = undefined;
    this._geoJsonItem = undefined;

    /**
     * Gets or sets the URL of the WFS server.  This property is observable.
     * @type {String}
     */
    this.url = '';

    /**
     * Gets or sets the WFS feature type names.
     * @type {String}
     */
    this.typeNames = '';

    /**
     * Gets or sets a value indicating whether we should request GeoJSON from the WFS server.  If this property
     * and {@link WebFeatureServiceCatalogItem#requestGeoJson} are both true, we'll request GeoJSON first and
     * only fall back on trying GML if the GeoJSON request fails.
     * @type {Boolean}
     * @default true
     */
    this.requestGeoJson = true;

    /**
     * Gets or sets a value indicating whether we should request GML from the WFS server.  If this property
     * and {@link WebFeatureServiceCatalogItem#requestGeoJson} are both true, we'll request GeoJSON first and
     * only fall back on trying GML if the GeoJSON request fails.
     * @type {Boolean}
     * @default true
     */
    this.requestGml = true;

    knockout.track(this, ['_dataUrl', '_dataUrlType', '_metadataUrl', 'url', 'typeNames', 'requestGeoJson', 'requestGml']);

    // dataUrl, metadataUrl, and legendUrl are derived from url if not explicitly specified.
    delete this.__knockoutObservables.dataUrl;
    knockout.defineProperty(this, 'dataUrl', {
        get : function() {
            var url = this._dataUrl;
            if (!defined(url)) {
                url = this.url;
            }

            if (this.dataUrlType === 'wfs') {
                url = cleanUrl(url) + '?service=WFS&version=1.1.0&request=GetFeature&typeName=' + this.typeNames + '&srsName=EPSG%3A4326&maxFeatures=1000';
            }

            return url;
        },
        set : function(value) {
            this._dataUrl = value;
        }
    });

    delete this.__knockoutObservables.dataUrlType;
    knockout.defineProperty(this, 'dataUrlType', {
        get : function() {
            if (defined(this._dataUrlType)) {
                return this._dataUrlType;
            } else {
                return 'wfs';
            }
        },
        set : function(value) {
            this._dataUrlType = value;
        }
    });

    delete this.__knockoutObservables.metadataUrl;
    knockout.defineProperty(this, 'metadataUrl', {
        get : function() {
            if (defined(this._metadataUrl)) {
                return this._metadataUrl;
            }

            return cleanUrl(this.url) + '?service=WFS&version=1.1.0&request=GetCapabilities';
        },
        set : function(value) {
            this._metadataUrl = value;
        }
    });
};

inherit(CatalogItem, WebFeatureServiceCatalogItem);

defineProperties(WebFeatureServiceCatalogItem.prototype, {
    /**
     * Gets the type of data item represented by this instance.
     * @memberOf WebFeatureServiceCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'wfs';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'Web Feature Service (WFS)'.
     * @memberOf WebFeatureServiceCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Web Feature Service (WFS)';
        }
    },

    /**
     * Gets the set of functions used to update individual properties in {@link CatalogMember#updateFromJson}.
     * When a property name in the returned object literal matches the name of a property on this instance, the value
     * will be called as a function and passed a reference to this instance, a reference to the source JSON object
     * literal, and the name of the property.
     * @memberOf WebFeatureServiceCatalogItem.prototype
     * @type {Object}
     */
    updaters : {
        get : function() {
            return WebFeatureServiceCatalogItem.defaultUpdaters;
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf WebFeatureServiceCatalogItem.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return WebFeatureServiceCatalogItem.defaultSerializers;
        }
    }
});

WebFeatureServiceCatalogItem.defaultUpdaters = clone(CatalogItem.defaultUpdaters);
freezeObject(WebFeatureServiceCatalogItem.defaultUpdaters);

WebFeatureServiceCatalogItem.defaultSerializers = clone(CatalogItem.defaultSerializers);

// Serialize the underlying properties instead of the public views of them.
WebFeatureServiceCatalogItem.defaultSerializers.dataUrl = function(wfsItem, json, propertyName) {
    json.dataUrl = wfsItem._dataUrl;
};
WebFeatureServiceCatalogItem.defaultSerializers.dataUrlType = function(wfsItem, json, propertyName) {
    json.dataUrlType = wfsItem._dataUrlType;
};
WebFeatureServiceCatalogItem.defaultSerializers.metadataUrl = function(wfsItem, json, propertyName) {
    json.metadataUrl = wfsItem._metadataUrl;
};
freezeObject(WebFeatureServiceCatalogItem.defaultSerializers);

WebFeatureServiceCatalogItem.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url, this.typeNames, this.requestGeoJson, this.requestGml];
};

WebFeatureServiceCatalogItem.prototype._load = function() {
    this._geoJsonItem = new GeoJsonCatalogItem(this.application);


    var promise;
    if (this.requestGeoJson) {
        promise = loadGeoJson(this);
    } else if (this.requestGml) {
        promise = loadGml(this);
    } else {
        return;
    }

    this._geoJsonItem.data = promise;

    var that = this;
    return that._geoJsonItem.load().then(function() {
        that.rectangle = that._geoJsonItem.rectangle;
    });
};

WebFeatureServiceCatalogItem.prototype._enable = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._enable();
    }
};

WebFeatureServiceCatalogItem.prototype._disable = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._disable();
    }
};

WebFeatureServiceCatalogItem.prototype._show = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._show();
    }
};

WebFeatureServiceCatalogItem.prototype._hide = function() {
    if (defined(this._geoJsonItem)) {
        this._geoJsonItem._hide();
    }
};

function loadGeoJson(wfsItem) {
    var promise = loadJson(buildGeoJsonUrl(wfsItem)).then(function(json) {
        return json;
    });

    if (wfsItem.requestGml) {
        promise = promise.otherwise(function() {
            return loadGml(wfsItem);
        });
    }

    return promise;
}

function loadGml(wfsItem) {
    return loadXML(buildGmlUrl(wfsItem)).then(function(xml) {
        return gmlToGeoJson(xml);
    });
}

function buildGeoJsonUrl(wfsItem) {
    var url = cleanAndProxyUrl(wfsItem.application, wfsItem.url);
    return url + '?' + objectToQuery({
        service: 'WFS',
        request: 'GetFeature',
        typeName: wfsItem.typeNames,
        version: '1.1.0',
        outputFormat: 'JSON',
        srsName: 'EPSG:4326'
    });
}

function buildGmlUrl(wfsItem) {
    var url = cleanAndProxyUrl(wfsItem.application, wfsItem.url);
    return url + '?' + objectToQuery({
        service: 'WFS',
        request: 'GetFeature',
        typeName: wfsItem.typeNames,
        version: '1.1.0',
        srsName: 'EPSG:4326'
    });
}

function cleanAndProxyUrl(application, url) {
    return proxyUrl(application, cleanUrl(url));
}

function cleanUrl(url) {
    // Strip off the search portion of the URL
    var uri = new URI(url);
    uri.search('');
    return uri.toString();
}

function proxyUrl(application, url) {
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(url)) {
        return application.corsProxy.getURL(url);
    }

    return url;
}

module.exports = WebFeatureServiceCatalogItem;

},{"../../third_party/cesium/Source/Core/clone":240,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/Core/loadJson":261,"../../third_party/cesium/Source/Core/loadXML":264,"../../third_party/cesium/Source/Core/objectToQuery":266,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"../Map/gmlToGeoJson":19,"./CatalogItem":27,"./GeoJsonCatalogItem":34}],48:[function(require,module,exports){
'use strict';

/*global require,URI,$*/

var clone = require('../../third_party/cesium/Source/Core/clone');
var combine = require('../../third_party/cesium/Source/Core/combine');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadXML = require('../../third_party/cesium/Source/Core/loadXML');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var GeographicTilingScheme = require('../../third_party/cesium/Source/Core/GeographicTilingScheme');

var ModelError = require('./ModelError');
var CatalogGroup = require('./CatalogGroup');
var inherit = require('../Core/inherit');
var WebMapServiceCatalogItem = require('./WebMapServiceCatalogItem');

/**
 * A {@link CatalogGroup} representing a collection of layers from a Web Map Service (WMS) server.
 *
 * @alias WebMapServiceCatalogGroup
 * @constructor
 * @extends CatalogGroup
 * 
 * @param {Application} application The application.
 */
var WebMapServiceCatalogGroup = function(application) {
    CatalogGroup.call(this, application, 'wms-getCapabilities');

    /**
     * Gets or sets the URL of the WMS server.  This property is observable.
     * @type {String}
     */
    this.url = '';

    /**
     * Gets or sets a description of the custodian of the data sources in this group.
     * This property is an HTML string that must be sanitized before display to the user.
     * This property is observable.
     * @type {String}
     */
    this.dataCustodian = undefined;

    /**
     * Gets or sets the additional parameters to pass to the WMS server when requesting images.
     * If this property is undefiend, {@link WebMapServiceCatalogItem.defaultParameters} is used.
     * @type {Object}
     */
    this.parameters = undefined;

    knockout.track(this, ['url', 'dataCustodian', 'parameters']);
};

inherit(CatalogGroup, WebMapServiceCatalogGroup);

defineProperties(WebMapServiceCatalogGroup.prototype, {
    /**
     * Gets the type of data member represented by this instance.
     * @memberOf WebMapServiceCatalogGroup.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'wms-getCapabilities';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, such as 'Web Map Service (WMS)'.
     * @memberOf WebMapServiceCatalogGroup.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Web Map Service (WMS) Server';
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf WebMapServiceCatalogGroup.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return WebMapServiceCatalogGroup.defaultSerializers;
        }
    }
});

/**
 * Gets or sets the set of default serializer functions to use in {@link CatalogMember#serializeToJson}.  Types derived from this type
 * should expose this instance - cloned and modified if necesary - through their {@link CatalogMember#serializers} property.
 * @type {Object}
 */
WebMapServiceCatalogGroup.defaultSerializers = clone(CatalogGroup.defaultSerializers);

WebMapServiceCatalogGroup.defaultSerializers.items = function(wmsGroup, json, propertyName, options) {
    // Only serialize minimal properties in contained items, because other properties are loaded from GetCapabilities.
    var previousSerializeForSharing = options.serializeForSharing;
    options.serializeForSharing = true;

    // Only serlize enabled items as well.  This isn't quite right - ideally we'd serialize any
    // property of any item if the property's value is changed from what was loaded from GetCapabilities -
    // but this gives us reasonable results for sharing and is a lot less work than the ideal
    // solution.
    var previousEnabledItemsOnly = options.enabledItemsOnly;
    options.enabledItemsOnly = true;

    var result = CatalogGroup.defaultSerializers.items(wmsGroup, json, propertyName, options);

    options.enabledItemsOnly = previousEnabledItemsOnly;
    options.serializeForSharing = previousSerializeForSharing;

    return result;
};

WebMapServiceCatalogGroup.defaultSerializers.isLoading = function(wmsGroup, json, propertyName, options) {};

freezeObject(WebMapServiceCatalogGroup.defaultSerializers);

WebMapServiceCatalogGroup.prototype._getValuesThatInfluenceLoad = function() {
    return [this.url];
};

WebMapServiceCatalogGroup.prototype._load = function() {
    var url = cleanAndProxyUrl(this.application, this.url) + '?service=WMS&request=GetCapabilities&version=1.1.1&tiled=true';

    var that = this;
    return loadXML(url).then(function(xml) {
        if (typeof xml === 'string') {
            xml = $.parseXML(xml);
        }

        // Is this really a GetCapabilities response?
        if (!xml || !xml.documentElement || (xml.documentElement.localName !== 'WMS_Capabilities' && xml.documentElement.localName !== 'WMT_MS_Capabilities')) {
            throw new ModelError({
                title: 'Invalid WMS server',
                message: '\
An error occurred while invoking GetCapabilities on the WMS server.  The server\'s response does not appear to be a valid GetCapabilities document.  \
<p>If you entered the link manually, please verify that the link is correct.</p>\
<p>If you did not enter this link manually, this error may indicate that the group you opened is temporarily unavailable or there is a \
problem with your internet connection.  Try opening the group again, and if the problem persists, please report it by \
sending an email to <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.</p>'
            });
        }

        var json = $.xml2json(xml);

        var supportsJsonGetFeatureInfo = false;

        if (defined(json.Capability.Request) &&
            defined(json.Capability.Request.GetFeatureInfo) &&
            defined(json.Capability.Request.GetFeatureInfo.Format)) {

            var format = json.Capability.Request.GetFeatureInfo.Format;
            if (format === 'application/json') {
                supportsJsonGetFeatureInfo = true;
            } else if (defined(format.indexOf) && format.indexOf('application/json') >= 0) {
                supportsJsonGetFeatureInfo = true;
            }
        }

        if (defined(json.Capability.VendorSpecificCapabilities) &&
            defined(json.Capability.VendorSpecificCapabilities.TileSet)) {

            var tileSet = json.Capability.VendorSpecificCapabilities.TileSet;
            for (var i = 0; i < tileSet.length; i++) {
                if (tileSet[i].SRS ===  "EPSG:3857") {
                    that.parameters = combine(that.parameters, {'tiled': true});
                    break;
                }
            }
        }

        var dataCustodian = that.dataCustodian;
        if (!defined(dataCustodian) && defined(json.Service.ContactInformation)) {
            var contactInfo = json.Service.ContactInformation;

            var text = '';

            var primary = contactInfo.ContactPersonPrimary;
            if (defined(primary)) {
                if (defined(primary.ContactOrganization) && primary.ContactOrganization.length > 0) {
                    text += primary.ContactOrganization + '<br/>';
                }
            }

            if (defined(contactInfo.ContactElectronicMailAddress) && contactInfo.ContactElectronicMailAddress.length > 0) {
                text += '[' + contactInfo.ContactElectronicMailAddress + '](mailto:' + contactInfo.ContactElectronicMailAddress + ')<br/>'; 
            }

            dataCustodian = text;
        }

        addLayersRecursively(that, json.Capability.Layer, that.items, undefined, supportsJsonGetFeatureInfo, dataCustodian);
    }).otherwise(function(e) {
        throw new ModelError({
            sender: that,
            title: 'Group is not available',
            message: '\
An error occurred while invoking GetCapabilities on the WMS server.  \
<p>If you entered the link manually, please verify that the link is correct.</p>\
<p>This error may also indicate that the server does not support <a href="http://enable-cors.org/" target="_blank">CORS</a>.  If this is your \
server, verify that CORS is enabled and enable it if it is not.  If you do not control the server, \
please contact the administrator of the server and ask them to enable CORS.  Or, contact the National \
Map team by emailing <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a> \
and ask us to add this server to the list of non-CORS-supporting servers that may be proxied by \
National Map itself.</p>\
<p>If you did not enter this link manually, this error may indicate that the group you opened is temporarily unavailable or there is a \
problem with your internet connection.  Try opening the group again, and if the problem persists, please report it by \
sending an email to <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.</p>'
        });
    });
};

function cleanAndProxyUrl(application, url) {
    // Strip off the search portion of the URL
    var uri = new URI(url);
    uri.search('');

    var cleanedUrl = uri.toString();
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(cleanedUrl)) {
        cleanedUrl = application.corsProxy.getURL(cleanedUrl, '1d');
    }

    return cleanedUrl;
}

function addLayersRecursively(wmsGroup, layers, items, parent, supportsJsonGetFeatureInfo, dataCustodian) {
    if (!(layers instanceof Array)) {
        layers = [layers];
    }

    for (var i = 0; i < layers.length; ++i) {
        var layer = layers[i];

        // Record this layer's parent, so we can walk up the layer hierarchy looking for inherited properties.
        layer.parent = parent;

        if (defined(layer.Layer)) {
            // WMS 1.1.1 spec section 7.1.4.5.2 says any layer with a Name property can be used
            // in the 'layers' parameter of a GetMap request.  This is true in 1.0.0 and 1.3.0 as well.
            if (defined(layer.Name) && layer.Name.length > 0) {
                items.push(createWmsDataSource(wmsGroup, layer, supportsJsonGetFeatureInfo, dataCustodian));
            }
            addLayersRecursively(wmsGroup, layer.Layer, items, layer, supportsJsonGetFeatureInfo, dataCustodian);
        }
        else {
            items.push(createWmsDataSource(wmsGroup, layer, supportsJsonGetFeatureInfo, dataCustodian));
        }
    }
}

function createWmsDataSource(wmsGroup, layer, supportsJsonGetFeatureInfo, dataCustodian) {
    var result = new WebMapServiceCatalogItem(wmsGroup.application);

    result.name = layer.Title;
    result.description = defined(layer.Abstract) && layer.Abstract.length > 0 ? layer.Abstract : wmsGroup.description;
    result.dataCustodian = dataCustodian;
    result.url = wmsGroup.url;
    result.layers = layer.Name;
    result.parameters = wmsGroup.parameters;

    result.description = '';

    var wmsGroupHasDescription = defined(wmsGroup.description) && wmsGroup.description.length > 0;
    var layerHasAbstract = defined(layer.Abstract) && layer.Abstract.length > 0;

    if (wmsGroupHasDescription) {
        result.description += wmsGroup.description;
    }

    if (wmsGroupHasDescription && layerHasAbstract) {
        result.description += '<br/>';
    }

    if (layerHasAbstract) {
        result.description += layer.Abstract;
    }


    var queryable = defaultValue(getInheritableProperty(layer, 'queryable'), false);

    result.getFeatureInfoAsGeoJson = queryable && supportsJsonGetFeatureInfo;
    result.getFeatureInfoAsXml = queryable;

    var egbb = getInheritableProperty(layer, 'EX_GeographicBoundingBox'); // required in WMS 1.3.0
    if (defined(egbb)) {
        result.rectangle = Rectangle.fromDegrees(egbb.westBoundLongitude, egbb.southBoundLatitude, egbb.eastBoundLongitude, egbb.northBoundLatitude);
    } else {
        var llbb = getInheritableProperty(layer, 'LatLonBoundingBox'); // required in WMS 1.0.0 through 1.1.1
        if (defined(llbb)) {
            result.rectangle = Rectangle.fromDegrees(llbb.minx, llbb.miny, llbb.maxx, llbb.maxy);
        }
    }

    var crs;
    if (defined(layer.CRS)) {
        crs = getInheritableProperty(layer, 'CRS', true);
    } else {
        crs = getInheritableProperty(layer, 'SRS', true);
    }

    if (defined(crs)) {
        if (crsIsMatch(crs, 'EPSG:3857')) {
            // Standard Web Mercator
        } else if (crsIsMatch(crs, 'EPSG:900913')) {
            // Older code for Web Mercator
            result.parameters = combine(result.parameters, {srs: 'EPSG:900913'});
        } else if (crsIsMatch(crs, 'EPSG:4326')) {
            // Standard Geographic
            result.tilingScheme = new GeographicTilingScheme();
        } else if (crsIsMatch(crs, 'CRS:84')) {
            // Another name for EPSG:4326
            result.tilingScheme = new GeographicTilingScheme();
            result.parameters = combine(result.parameters, {srs: 'CRS:84'});
        } else if (crsIsMatch(crs, 'EPSG:4283')) {
            // Australian system that is equivalent to EPSG:4326.
            result.tilingScheme = new GeographicTilingScheme();
            result.parameters = combine(result.parameters, {srs: 'EPSG:4283'});
        } else {
            // No known supported CRS listed.  Try the default, EPSG:3857, and hope for the best.
        }
    }


    return result;
}

function crsIsMatch(crs, matchValue) {
    if (crs === matchValue) {
        return true;
    }

    if (crs instanceof Array && crs.indexOf(matchValue) >= 0) {
        return true;
    }

     return false;
}

function getInheritableProperty(layer, name, appendValues) {
    var value = [];
    while (defined(layer)) {
        if (defined(layer[name])) {
            if (appendValues) {
                value = value.concat((layer[name] instanceof Array) ? layer[name] : [layer[name]]);
            } else {
                return layer[name];
            }
        }
        layer = layer.parent;
    }

    return value.length > 0 ? value : undefined;
}

module.exports = WebMapServiceCatalogGroup;

},{"../../third_party/cesium/Source/Core/GeographicTilingScheme":144,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/clone":240,"../../third_party/cesium/Source/Core/combine":241,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/Core/loadXML":264,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"./CatalogGroup":26,"./ModelError":41,"./WebMapServiceCatalogItem":49}],49:[function(require,module,exports){
'use strict';

/*global require,L,URI,$*/

var clone = require('../../third_party/cesium/Source/Core/clone');
var combine = require('../../third_party/cesium/Source/Core/combine');
var defined = require('../../third_party/cesium/Source/Core/defined');
var defineProperties = require('../../third_party/cesium/Source/Core/defineProperties');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var freezeObject = require('../../third_party/cesium/Source/Core/freezeObject');
var GeographicTilingScheme = require('../../third_party/cesium/Source/Core/GeographicTilingScheme');
var ImageryLayer = require('../../third_party/cesium/Source/Scene/ImageryLayer');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var loadXML = require('../../third_party/cesium/Source/Core/loadXML');
var WebMapServiceImageryProvider = require('../../third_party/cesium/Source/Scene/WebMapServiceImageryProvider');
var WebMercatorTilingScheme = require('../../third_party/cesium/Source/Core/WebMercatorTilingScheme');

var Metadata = require('./Metadata');
var MetadataItem = require('./MetadataItem');
var ImageryLayerCatalogItem = require('./ImageryLayerCatalogItem');
var inherit = require('../Core/inherit');

/**
 * A {@link ImageryLayerCatalogItem} representing a layer from a Web Map Service (WMS) server.
 *
 * @alias WebMapServiceCatalogItem
 * @constructor
 * @extends ImageryLayerCatalogItem
 * 
 * @param {Application} application The application for the group.
 */
var WebMapServiceCatalogItem = function(application) {
    ImageryLayerCatalogItem.call(this, application);

    this._metadata = undefined;
    this._dataUrl = undefined;
    this._dataUrlType = undefined;
    this._metadataUrl = undefined;
    this._legendUrl = undefined;

    /**
     * Gets or sets the URL of the WMS server.  This property is observable.
     * @type {String}
     */
    this.url = '';

    /**
     * Gets or sets the WMS layers to include.  To specify multiple layers, separate them
     * with a commas.  This property is observable.
     * @type {String}
     */
    this.layers = '';

    /**
     * Gets or sets the additional parameters to pass to the WMS server when requesting images.
     * If this property is undefiend, {@link WebMapServiceCatalogItem.defaultParameters} is used.
     * @type {Object}
     */
    this.parameters = undefined;

    /**
     * Gets or sets the tiling scheme to pass to the WMS server when requesting images.
     * If this property is undefiend, the default tiling scheme of the provider is used.
     * @type {Object}
     */

    this.tilingScheme = undefined;
    /**
     * Gets or sets a value indicating whether we should request information about individual features on click
     * as GeoJSON.  If getFeatureInfoAsXml is true as well, feature information will be requested first as GeoJSON,
     * and then as XML if the GeoJSON request fails.  If both are false, this data item will not support feature picking at all.
     * @type {Boolean}
     * @default true
     */
    this.getFeatureInfoAsGeoJson = true;

    /**
     * Gets or sets a value indicating whether we should request information about individual features on click
     * as XML.  If getFeatureInfoAsGeoJson is true as well, feature information will be requested first as GeoJSON,
     * and then as XML if the GeoJSON request fails.  If both are false, this data item will not support feature picking at all.
     * @type {Boolean}
     * @default true
     */
    this.getFeatureInfoAsXml = true;

    knockout.track(this, ['_dataUrl', '_dataUrlType', '_metadataUrl', '_legendUrl', 'url', 'layers', 'parameters', 'getFeatureInfoAsGeoJson', 'getFeatureInfoAsXml', 'tilingScheme']);

    // dataUrl, metadataUrl, and legendUrl are derived from url if not explicitly specified.
    delete this.__knockoutObservables.dataUrl;
    knockout.defineProperty(this, 'dataUrl', {
        get : function() {
            var url = this._dataUrl;
            if (!defined(url)) {
                url = this.url;
            }

            if (this.dataUrlType === 'wfs') {
                url = cleanUrl(url) + '?service=WFS&version=1.1.0&request=GetFeature&typeName=' + this.layers + '&srsName=EPSG%3A4326&maxFeatures=1000';
            }

            return url;
        },
        set : function(value) {
            this._dataUrl = value;
        }
    });

    delete this.__knockoutObservables.dataUrlType;
    knockout.defineProperty(this, 'dataUrlType', {
        get : function() {
            if (defined(this._dataUrlType)) {
                return this._dataUrlType;
            } else {
                return 'wfs';
            }
        },
        set : function(value) {
            this._dataUrlType = value;
        }
    });

    delete this.__knockoutObservables.metadataUrl;
    knockout.defineProperty(this, 'metadataUrl', {
        get : function() {
            if (defined(this._metadataUrl)) {
                return this._metadataUrl;
            }

            return cleanUrl(this.url) + '?service=WMS&version=1.3.0&request=GetCapabilities';
        },
        set : function(value) {
            this._metadataUrl = value;
        }
    });

    delete this.__knockoutObservables.legendUrl;
    knockout.defineProperty(this, 'legendUrl', {
        get : function() {
            if (defined(this._legendUrl)) {
                return this._legendUrl;
            }
            var layer = this.layers.split(',')[0];
            return cleanUrl(this.url) + '?service=WMS&version=1.3.0&request=GetLegendGraphic&format=image/png&layer=' + layer;
        },
        set : function(value) {
            this._legendUrl = value;
        }
    });
};

inherit(ImageryLayerCatalogItem, WebMapServiceCatalogItem);

defineProperties(WebMapServiceCatalogItem.prototype, {
    /**
     * Gets the type of data item represented by this instance.
     * @memberOf WebMapServiceCatalogItem.prototype
     * @type {String}
     */
    type : {
        get : function() {
            return 'wms';
        }
    },

    /**
     * Gets a human-readable name for this type of data source, 'Web Map Service (WMS)'.
     * @memberOf WebMapServiceCatalogItem.prototype
     * @type {String}
     */
    typeName : {
        get : function() {
            return 'Web Map Service (WMS)';
        }
    },

    /**
     * Gets the metadata associated with this data source and the server that provided it, if applicable.
     * @memberOf WebMapServiceCatalogItem.prototype
     * @type {Metadata}
     */
    metadata : {
        get : function() {
            if (!defined(this._metadata)) {
                this._metadata = requestMetadata(this);
            }
            return this._metadata;
        }
    },

    /**
     * Gets the set of functions used to update individual properties in {@link CatalogMember#updateFromJson}.
     * When a property name in the returned object literal matches the name of a property on this instance, the value
     * will be called as a function and passed a reference to this instance, a reference to the source JSON object
     * literal, and the name of the property.
     * @memberOf WebMapServiceCatalogItem.prototype
     * @type {Object}
     */
    updaters : {
        get : function() {
            return WebMapServiceCatalogItem.defaultUpdaters;
        }
    },

    /**
     * Gets the set of functions used to serialize individual properties in {@link CatalogMember#serializeToJson}.
     * When a property name on the model matches the name of a property in the serializers object lieral,
     * the value will be called as a function and passed a reference to the model, a reference to the destination
     * JSON object literal, and the name of the property.
     * @memberOf WebMapServiceCatalogItem.prototype
     * @type {Object}
     */
    serializers : {
        get : function() {
            return WebMapServiceCatalogItem.defaultSerializers;
        }
    }
});

WebMapServiceCatalogItem.defaultUpdaters = clone(ImageryLayerCatalogItem.defaultUpdaters);

WebMapServiceCatalogItem.defaultUpdaters.tilingScheme = function(wmsItem, json, propertyName, options) {
    if (json.tilingScheme === 'geographic') {
        wmsItem.tilingScheme = new GeographicTilingScheme();
    } else if (json.tilingScheme === 'web-mercator') {
        wmsItem.tilingScheme = new WebMercatorTilingScheme();
    } else {
        wmsItem.tilingScheme = json.tilingScheme;
    }
};

freezeObject(WebMapServiceCatalogItem.defaultUpdaters);

WebMapServiceCatalogItem.defaultSerializers = clone(ImageryLayerCatalogItem.defaultSerializers);

// Serialize the underlying properties instead of the public views of them.
WebMapServiceCatalogItem.defaultSerializers.dataUrl = function(wmsItem, json, propertyName) {
    json.dataUrl = wmsItem._dataUrl;
};
WebMapServiceCatalogItem.defaultSerializers.dataUrlType = function(wmsItem, json, propertyName) {
    json.dataUrlType = wmsItem._dataUrlType;
};
WebMapServiceCatalogItem.defaultSerializers.metadataUrl = function(wmsItem, json, propertyName) {
    json.metadataUrl = wmsItem._metadataUrl;
};
WebMapServiceCatalogItem.defaultSerializers.legendUrl = function(wmsItem, json, propertyName) {
    json.legendUrl = wmsItem._legendUrl;
};
WebMapServiceCatalogItem.defaultSerializers.tilingScheme = function(wmsItem, json, propertyName) {
    if (wmsItem.tilingScheme instanceof GeographicTilingScheme) {
        json.tilingScheme = 'geographic';
    } else if (wmsItem.tilingScheme instanceof WebMercatorTilingScheme) {
        json.tilingScheme = 'web-mercator';
    } else {
        json.tilingScheme = wmsItem.tilingScheme;
    }
};
freezeObject(WebMapServiceCatalogItem.defaultSerializers);

WebMapServiceCatalogItem.prototype._enableInCesium = function() {
    if (defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is already enabled.');
    }

    var scene = this.application.cesium.scene;

    var imageryProvider = new WebMapServiceImageryProvider({
        url : cleanAndProxyUrl(this.application, this.url),
        layers : this.layers,
        getFeatureInfoAsGeoJson : this.getFeatureInfoAsGeoJson,
        getFeatureInfoAsXml : this.getFeatureInfoAsXml,
        parameters : combine(this.parameters, WebMapServiceCatalogItem.defaultParameters),
        tilingScheme : defined(this.tilingScheme) ? this.tilingScheme : new WebMercatorTilingScheme()
    });

    this._imageryLayer = new ImageryLayer(imageryProvider, {
        show : false,
        alpha : this.opacity
        // Ideally we'd specify "rectangle : this.rectangle" here.
        // But lots of WMS data sources get the extent wrong, and even the ones that get it right
        // specify the extent of the geometry itself, not the representation of the geometry.  So that means,
        // for example, that if we clip the layer at the given extent, then a point centered on the edge of the
        // extent will only be half visible.
    });

    scene.imageryLayers.add(this._imageryLayer);
};

WebMapServiceCatalogItem.prototype._disableInCesium = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    var scene = this.application.cesium.scene;
    scene.imageryLayers.remove(this._imageryLayer);
    this._imageryLayer = undefined;
};

WebMapServiceCatalogItem.prototype._enableInLeaflet = function() {
    if (defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is already enabled.');
    }

    var options = {
        layers : this.layers,
        opacity : this.opacity
        // Ideally we'd specify "bounds : rectangleToLatLngBounds(this.rectangle)" here.
        // See comment in _enableInCesium for an explanation of why we don't.
    };

    options = combine(combine(this.parameters, WebMapServiceCatalogItem.defaultParameters), options);

    this._imageryLayer = new L.tileLayer.wms(cleanAndProxyUrl(this.application, this.url), options);
};

WebMapServiceCatalogItem.prototype._disableInLeaflet = function() {
    if (!defined(this._imageryLayer)) {
        throw new DeveloperError('This data source is not enabled.');
    }

    this._imageryLayer = undefined;
};

WebMapServiceCatalogItem.defaultParameters = {
    transparent: true,
    format: 'image/png',
    exceptions: 'application/vnd.ogc.se_xml',
    styles: '',
    tiled: true
};

function cleanAndProxyUrl(application, url) {
    return proxyUrl(application, cleanUrl(url));
}

function cleanUrl(url) {
    // Strip off the search portion of the URL
    var uri = new URI(url);
    uri.search('');
    return uri.toString();
}

function proxyUrl(application, url) {
    if (defined(application.corsProxy) && application.corsProxy.shouldUseProxy(url)) {
        return application.corsProxy.getURL(url);
    }

    return url;
}

function requestMetadata(wmsItem) {
    var result = new Metadata();

    result.isLoading = true;

    result.promise = loadXML(proxyUrl(wmsItem.application, wmsItem.metadataUrl)).then(function(capabilities) {
        var json = $.xml2json(capabilities);

        if (json.Service) {
            populateMetadataGroup(result.serviceMetadata, json.Service);
        } else {
            result.serviceErrorMessage = 'Service information not found in GetCapabilities operation response.';
        }

        var layer;
        if (defined(json.Capability)) {
            layer = findLayer(json.Capability.Layer, wmsItem.layers);
        }
        if (layer) {
            populateMetadataGroup(result.dataSourceMetadata, layer);
        } else {
            result.dataSourceErrorMessage = 'Layer information not found in GetCapabilities operation response.';
        }

        result.isLoading = false;
    }).otherwise(function() {
        result.dataSourceErrorMessage = 'An error occurred while invoking the GetCapabilities service.';
        result.serviceErrorMessage = 'An error occurred while invoking the GetCapabilities service.';
        result.isLoading = false;
    });

    return result;
}

function findLayer(startLayer, name) {
    if (startLayer.Name === name || startLayer.Title === name) {
        return startLayer;
    }

    var layers = startLayer.Layer;
    if (!defined(layers)) {
        return undefined;
    }

    var found = findLayer(layers, name);
    for (var i = 0; !found && i < layers.length; ++i) {
        var layer = layers[i];
        found = findLayer(layer, name);
    }

    return found;
}

function populateMetadataGroup(metadataGroup, sourceMetadata) {
    if (typeof sourceMetadata === 'string' || sourceMetadata instanceof Array) {
        return;
    }

    for (var name in sourceMetadata) {
        if (sourceMetadata.hasOwnProperty(name)) {
            var value = sourceMetadata[name];

            var dest;
            if (name === 'BoundingBox' && value instanceof Array) {
                for (var i = 0; i < value.length; ++i) {
                    var subValue = value[i];

                    dest = new MetadataItem();
                    dest.name = name + ' (' + subValue.CRS + ')';
                    dest.value = subValue;

                    populateMetadataGroup(dest, subValue);

                    metadataGroup.items.push(dest);
                }
            } else {
                dest = new MetadataItem();
                dest.name = name;
                dest.value = value;

                populateMetadataGroup(dest, value);

                metadataGroup.items.push(dest);
            }
        }
    }
}

module.exports = WebMapServiceCatalogItem;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/GeographicTilingScheme":144,"../../third_party/cesium/Source/Core/WebMercatorTilingScheme":234,"../../third_party/cesium/Source/Core/clone":240,"../../third_party/cesium/Source/Core/combine":241,"../../third_party/cesium/Source/Core/defineProperties":244,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/freezeObject":249,"../../third_party/cesium/Source/Core/loadXML":264,"../../third_party/cesium/Source/Scene/ImageryLayer":396,"../../third_party/cesium/Source/Scene/WebMapServiceImageryProvider":455,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"./ImageryLayerCatalogItem":36,"./Metadata":39,"./MetadataItem":40}],50:[function(require,module,exports){
'use strict';

/*global require*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var ModelError = require('./ModelError');

/**
 * Adds a user's catalog item or group to the catalog.
 * 
 * @param {Application} application The application containing the catalog member.
 * @param {CatalogItem|Promise} newCatalogItemOrPromise The catalog member to add, or a promise for a catalog member.
 * @param {Object} [options] An object with the following members:
 * @param {Boolean} [options.enable=true] True to enable the newly-added member if it is an item; otherwise, false.
 * @param {Boolean} [options.open=true] True to open the newly-added member if it is a group; otherwise, false.
 * @param {Boolean} [options.zoomTo=true] True to zoom and use the clock of the newly-added member if it is an item; otherwise, false.
 * @return {Promise} A promise that resolves when the catalog member has been added successfully.
 */
var addUserCatalogMember = function(application, newCatalogMemberOrPromise, options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);

    return when(newCatalogMemberOrPromise, function(newCatalogItem) {
        if (!defined(newCatalogItem)) {
            return;
        }

        application.catalog.userAddedDataGroup.items.push(newCatalogItem);

        if (defaultValue(options.open, true) && defined(newCatalogItem.isOpen)) {
            newCatalogItem.isOpen = true;
        }

        if (defaultValue(options.enable, true) && defined(newCatalogItem.isEnabled)) {
            newCatalogItem.isEnabled = true;
        }

        if (defaultValue(options.zoomTo, true) && defined(newCatalogItem.zoomToAndUseClock)) {
            newCatalogItem.zoomToAndUseClock();
        }

        application.catalog.userAddedDataGroup.isOpen = true;
    }).otherwise(function(e) {
        if (!(e instanceof ModelError)) {
            e = new ModelError({
                title: 'Data could not be added',
                message: 'The specified data could not be added because it is invalid or does not have the expected format.'
            });
        }

        application.error.raiseEvent(e);

        return when.reject(e);
    });
};

module.exports = addUserCatalogMember;

},{"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/when":596,"./ModelError":41}],51:[function(require,module,exports){
'use strict';

/*global require,confirm*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var createCatalogItemFromUrl = require('./createCatalogItemFromUrl');
var createCatalogMemberFromType = require('./createCatalogMemberFromType');

/**
 * Asynchronously creates and loads a catalog item for a given file.  The returned promise does not resolve until
 * the catalog item is successfully loaded, and it rejects if the file is not in the expected format or
 * another error occurs during loading.  If the OGR-based conversion service needs to be invoked to convert the file or URL
 * to a compatible format, the user 
 * 
 * @param {Application} application The application in which to create the item.
 * @param {File|String} fileOrUrl The file or URL for which to create a catalog item.
 * @param {String} [dataType='auto'] The type of catalog item to create.  If 'auto', the type is deduced from the URL or filename.
 *                                   If 'other', the OGR-based conversion service is used.  This can also be any valid catalog item
 *                                   {@link CatalogItem#type}.
 * @param {Boolean} [confirmConversion=true] If true, and the OGR-based conversion service needs to be invoked, the user will first
 *                                           be asked for permission to upload the file to the conversion service.  If false, the
 *                                           user will not be asked for permission.  If the user denies the request, the promise
 *                                           will be rejected with the string 'The user declined to use the conversion service.'.
 * @return {Promise} A promise that resolves to the created catalog item.
 */
var createCatalogItemFromFileOrUrl = function(application, fileOrUrl, dataType, confirmConversion) {
    var isUrl = typeof fileOrUrl === 'string';
    dataType = defaultValue(dataType, 'auto');

    var name = isUrl ? fileOrUrl : fileOrUrl.name;

    var newCatalogItem;
    if (dataType === 'auto') {
        newCatalogItem = createCatalogItemFromUrl(name, application);

        if (newCatalogItem.type === 'ogr' && defaultValue(confirmConversion, true) && !confirm('\
This file type is not directly supported by National Map.  However, it may be possible to convert it to a known \
format using the National Map conversion service.  Click OK to upload the file to the National Map conversion service now.  Or, click Cancel \
and the file will not be uploaded or added to the map.')) {
            return when.reject('The user declined to use the conversion service.');
        }

    } else if (dataType === 'other') {
        if (defaultValue(confirmConversion, true) && !confirm('\
In order to convert this file to a format supported by National Map, it must be uploaded to the National Map conversion service. \
Click OK to upload the file to the National Map conversion service now.  Or, click Cancel \
and the file will not be uploaded or added to the map.')) {
            return when.reject('The user declined to use the conversion service.');
        }

        newCatalogItem = createCatalogMemberFromType('ogr', application);
    } else {
        newCatalogItem = createCatalogMemberFromType(dataType, application);
    }

    var lastSlashIndex = name.lastIndexOf('/');
    if (lastSlashIndex >= 0) {
        name = name.substring(lastSlashIndex + 1);
    }

    newCatalogItem.name = name;

    if (isUrl) {
        newCatalogItem.url = fileOrUrl;
    } else {
        newCatalogItem.data = fileOrUrl;
        newCatalogItem.dataSourceUrl = fileOrUrl.name;
    }

    return newCatalogItem.load().then(function() {
        return newCatalogItem;
    });
};

module.exports = createCatalogItemFromFileOrUrl;

},{"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/ThirdParty/when":596,"./createCatalogItemFromUrl":52,"./createCatalogMemberFromType":53}],52:[function(require,module,exports){
'use strict';

var mapping = [];

/**
 * Creates a type derived from {@link CatalogMember} based on a given URL.
 *
 * @param {String} url The derived type name.
 * @param {Application} application The application.
 * @returns {CatalogMember} The constructed data item, or undefined if the URL is not supported.
 */
var createCatalogItemFromUrl = function(url, application) {
    for (var i = 0; i < mapping.length; ++i) {
        var matcher = mapping[i];
        if (matcher.matcher(url)) {
            return new matcher.constructor(application, url);
        }
    }
    return undefined;
};

/**
 * Registers a constructor for a given type of {@link CatalogMember}.
 * 
 * @param {createCatalogItemFromUrl~Matcher} matcher A function that is given a URL to match as its only parameter.  If the function returns true, The type name for which to register a constructor.
 * @param {createCatalogItemFromUrl~Constructor} constructor The constructor for data items that match the given matcher.
 */
 createCatalogItemFromUrl.register = function(matcher, constructor) {
    mapping.push({
        matcher: matcher,
        constructor: constructor
    });
};

/**
 * Function interface for matching a URL to a {@link CatalogMember} constructor
 * for that URL.
 * @callback createCatalogItemFromUrl~Matcher
 * @param {String} url The URL to match.
 * @returns {Boolean} True if the constructor can be used with this URL; otherwise, false.
 *
 * @example
 * var czmlExtensionRegex = /\.czml$/i;
 * function isCzml(url) {
 *     return url.match(czmlExtensionRegex);
 * }
 */

 /**
  * Function interface for matching a URL to a {@link CatalogMember} constructor
  * for that URL.
  * @callback createCatalogItemFromUrl~Constructor
  * @param {Application} application The application.
  * @param {String} url The URL from which to obtain the data.
  * @returns {CatalogMember} The created data item.
  */

module.exports = createCatalogItemFromUrl;
},{}],53:[function(require,module,exports){
'use strict';

/*global require*/

var defined = require('../../third_party/cesium/Source/Core/defined');

var ModelError = require('./ModelError');

var mapping = {};

/**
 * Creates a type derived from {@link CatalogMember} based on a given type string.
 * 
 * @param {String} type The derived type name.
 * @param {Application} application The application.
 */
var createCatalogMemberFromType = function(type, application) {
    var Constructor = mapping[type];
    if (!defined(Constructor)) {
        throw new ModelError({
            title: 'Unsupported catalogue item type',
            message: '\
Unknown catalogue item type: ' + type + '.  If you are loading your own catalogue, please verify that it is correct. \
This error may also indicate an attempt to load a newer catalogue file in an older version of National Map.'
        });
    }

    return new Constructor(application);
};

/**
 * Registers a constructor for a given type of {@link CatalogMember}.
 * 
 * @param {String} type The type name for which to register a constructor.
 * @param {Function} constructor The constructor for data items of this type.  The constructor is expected to take a
 *                               {@link Application} as its first and only required parameter.
 */
createCatalogMemberFromType.register = function(type, constructor) {
    mapping[type] = constructor;
};

module.exports = createCatalogMemberFromType;
},{"../../third_party/cesium/Source/Core/defined":245,"./ModelError":41}],54:[function(require,module,exports){
'use strict';

/*global require*/

var defined = require('../../third_party/cesium/Source/Core/defined');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');

var raiseErrorToUser = require('./raiseErrorToUser');

var raiseErrorOnRejectedPromise = function(application, promise) {
    if (!defined(application)) {
        throw new DeveloperError('application is required.');
    }

    if (defined(promise)) {
        return promise.otherwise(function(e) {
            raiseErrorToUser(application, e);
        });
    }
};

module.exports = raiseErrorOnRejectedPromise;
},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defined":245,"./raiseErrorToUser":55}],55:[function(require,module,exports){
'use strict';

/*global require*/

var ModelError = require('../Models/ModelError');

var raiseErrorToUser = function(application, error) {
    if (error instanceof ModelError) {
        application.error.raiseEvent(error);
    } else {
        application.error.raiseEvent(new ModelError({
            sender: undefined,
            title: 'An error occurred',
            message: '\
<p>National Map experienced an error.  Please report this by emailing <a href="mailto:nationalmap@lists.nicta.com.au">nationalmap@lists.nicta.com.au</a>.  \
Details of the error are below.</p>\
<p><pre>' + error.toString() + '</pre></p>'
        }));
    }
};

module.exports = raiseErrorToUser;
},{"../Models/ModelError":41}],56:[function(require,module,exports){
'use strict';

/*global require*/

var ArcGisMapServerCatalogItem = require('./ArcGisMapServerCatalogItem');
var CkanCatalogGroup = require('./CkanCatalogGroup');
var createCatalogMemberFromType = require('./createCatalogMemberFromType');
var createCatalogItemFromUrl = require('./createCatalogItemFromUrl');
var CzmlCatalogItem = require('./CzmlCatalogItem');
var CatalogGroup = require('./CatalogGroup');
var GeoJsonCatalogItem = require('./GeoJsonCatalogItem');
var KmlCatalogItem = require('./KmlCatalogItem');
var WebFeatureServiceCatalogGroup = require('./WebFeatureServiceCatalogGroup');
var WebFeatureServiceCatalogItem = require('./WebFeatureServiceCatalogItem');
var WebMapServiceCatalogGroup = require('./WebMapServiceCatalogGroup');
var WebMapServiceCatalogItem = require('./WebMapServiceCatalogItem');
var CsvCatalogItem = require('./CsvCatalogItem');
var GpxCatalogItem = require('./GpxCatalogItem');
var OgrCatalogItem = require('./OgrCatalogItem');

var registerCatalogMembers = function() {
    createCatalogMemberFromType.register('ckan', CkanCatalogGroup);
    createCatalogMemberFromType.register('csv', CsvCatalogItem);
    createCatalogMemberFromType.register('czml', CzmlCatalogItem);
    createCatalogMemberFromType.register('esri-mapServer', ArcGisMapServerCatalogItem);
    createCatalogMemberFromType.register('geojson', GeoJsonCatalogItem);
    createCatalogMemberFromType.register('gpx', GpxCatalogItem);
    createCatalogMemberFromType.register('group', CatalogGroup);
    createCatalogMemberFromType.register('kml', KmlCatalogItem);
    createCatalogMemberFromType.register('ogr', OgrCatalogItem);
    createCatalogMemberFromType.register('wfs', WebFeatureServiceCatalogItem);
    createCatalogMemberFromType.register('wfs-getCapabilities', WebFeatureServiceCatalogGroup);
    createCatalogMemberFromType.register('wms', WebMapServiceCatalogItem);
    createCatalogMemberFromType.register('wms-getCapabilities', WebMapServiceCatalogGroup);

    createCatalogItemFromUrl.register(matchesExtension('csv'), CsvCatalogItem);
    createCatalogItemFromUrl.register(matchesExtension('czm'), CzmlCatalogItem);
    createCatalogItemFromUrl.register(matchesExtension('czml'), CzmlCatalogItem);
    createCatalogItemFromUrl.register(matchesExtension('geojson'), GeoJsonCatalogItem);
    createCatalogItemFromUrl.register(matchesExtension('gpx'), GpxCatalogItem);
    createCatalogItemFromUrl.register(matchesExtension('json'), GeoJsonCatalogItem);
    createCatalogItemFromUrl.register(matchesExtension('kml'), KmlCatalogItem);
    createCatalogItemFromUrl.register(matchesExtension('kmz'), KmlCatalogItem);
    createCatalogItemFromUrl.register(matchesExtension('topojson'), GeoJsonCatalogItem);
    createCatalogItemFromUrl.register(matchAll, OgrCatalogItem);
};

function matchesExtension(extension) {
    var regex = new RegExp('\\.' + extension + '$', 'i');
    return function(url) {
        return url.match(regex);
    };
}

function matchAll() {
    return true;
}

module.exports = registerCatalogMembers;

},{"./ArcGisMapServerCatalogItem":23,"./CatalogGroup":26,"./CkanCatalogGroup":30,"./CsvCatalogItem":32,"./CzmlCatalogItem":33,"./GeoJsonCatalogItem":34,"./GpxCatalogItem":35,"./KmlCatalogItem":37,"./OgrCatalogItem":43,"./WebFeatureServiceCatalogGroup":46,"./WebFeatureServiceCatalogItem":47,"./WebMapServiceCatalogGroup":48,"./WebMapServiceCatalogItem":49,"./createCatalogItemFromUrl":52,"./createCatalogMemberFromType":53}],57:[function(require,module,exports){
module.exports = 'M8.037,11.166L14.5,22.359c0.825,1.43,2.175,1.43,3,0l6.463-11.194c0.826-1.429,0.15-2.598-1.5-2.598H9.537C7.886,8.568,7.211,9.737,8.037,11.166z';
},{}],58:[function(require,module,exports){
module.exports = 'M11.166,23.963L22.359,17.5c1.43-0.824,1.43-2.175,0-3L11.166,8.037c-1.429-0.826-2.598-0.15-2.598,1.5v12.926C8.568,24.113,9.737,24.789,11.166,23.963z';
},{}],59:[function(require,module,exports){
module.exports = 'M29.548,3.043c-1.081-0.859-2.651-0.679-3.513,0.401L16,16.066l-3.508-4.414c-0.859-1.081-2.431-1.26-3.513-0.401c-1.081,0.859-1.261,2.432-0.401,3.513l5.465,6.875c0.474,0.598,1.195,0.944,1.957,0.944c0.762,0,1.482-0.349,1.957-0.944L29.949,6.556C30.809,5.475,30.629,3.902,29.548,3.043zM24.5,24.5h-17v-17h12.756l2.385-3H6C5.171,4.5,4.5,5.171,4.5,6v20c0,0.828,0.671,1.5,1.5,1.5h20c0.828,0,1.5-0.672,1.5-1.5V12.851l-3,3.773V24.5z';

},{}],60:[function(require,module,exports){
module.exports = 'M26,27.5H6c-0.829,0-1.5-0.672-1.5-1.5V6c0-0.829,0.671-1.5,1.5-1.5h20c0.828,0,1.5,0.671,1.5,1.5v20C27.5,26.828,26.828,27.5,26,27.5zM7.5,24.5h17v-17h-17V24.5z';

},{}],61:[function(require,module,exports){
module.exports = 'm 4.8125,-0.15625 -4,4.3125 -0.15625,0.1875 0.1875,0.1875 4,3.65625 0.3125,-0.375 -3.8125,-3.46875 3.84375,-4.1875 -0.375,-0.3125 z';

},{}],62:[function(require,module,exports){
module.exports = 'm 8.28,13.32 0,-6.12 1.44,0 0,6.12 0.72,0 0,0.36 -2.88,0 0,-0.36 0.72,0 0,0 z M 9,18 c 4.97056,0 9,-4.029437 9,-9 C 18,4.029437 13.97056,0 9,0 4.02944,0 0,4.029437 0,9 c 0,4.970563 4.02944,9 9,9 z m 0,-0.72 c 4.57292,0 8.28,-3.707082 8.28,-8.28 C 17.28,4.427082 13.57292,0.72 9,0.72 4.42708,0.72 0.72,4.427082 0.72,9 c 0,4.572918 3.70708,8.28 8.28,8.28 z M 7.56,7.2 l 0,0.36 0.72,0 0,-0.36 -0.72,0 z M 9,6.48 C 9.59647,6.48 10.08,5.996468 10.08,5.4 10.08,4.8035324 9.59647,4.32 9,4.32 8.40353,4.32 7.92,4.8035324 7.92,5.4 7.92,5.996468 8.40353,6.48 9,6.48 z';
},{}],63:[function(require,module,exports){
module.exports = 'm 1.0625,0.84375 a 0.80661934,0.80661934 0 0 0 0.25,1.59375 l 19.375,0 a 0.80008001,0.80008001 0 1 0 0,-1.59375 l -19.375,0 a 0.80008001,0.80008001 0 0 0 -0.15625,0 0.8006955,0.8006955 0 0 0 -0.09375,0 z M 1.125,7.1875 a 0.81789077,0.81789077 0 0 0 0.1875,1.625 l 19.375,0 a 0.8125,0.8125 0 0 0 0,-1.625 l -19.375,0 a 0.80008001,0.80008001 0 0 0 -0.09375,0 0.81385104,0.81385104 0 0 0 -0.09375,0 z m -0.0625,6.375 a 0.80661934,0.80661934 0 0 0 0.25,1.59375 l 19.375,0 a 0.80008001,0.80008001 0 1 0 0,-1.59375 l -19.375,0 a 0.80008001,0.80008001 0 0 0 -0.15625,0 0.8006955,0.8006955 0 0 0 -0.09375,0 z';
},{}],64:[function(require,module,exports){
module.exports = 'M 7.5,0 C 3.375,0 0,3.375 0,7.5 0,11.625 3.375,15 7.5,15 c 3.46875,0 6.375,-2.4375 7.21875,-5.625 l -1.96875,0 C 12,11.53125 9.9375,13.125 7.5,13.125 4.40625,13.125 1.875,10.59375 1.875,7.5 1.875,4.40625 4.40625,1.875 7.5,1.875 c 1.59375,0 2.90625,0.65625 3.9375,1.6875 l -3,3 6.5625,0 L 15,0 12.75,2.25 C 11.4375,0.84375 9.5625,0 7.5,0 z';
},{}],65:[function(require,module,exports){
module.exports = 'm 24.369658,18.483707 c -0.07919,-0.08743 -3.345079,-3.906533 -8.714362,-3.906533 -4.254073,0 -7.875754,3.876287 -7.9549405,3.963722 L 5.8328745,16.797144 4.7330624,23.060575 11.089976,21.959662 9.3275276,20.190614 c 0.077536,-0.08029 3.4484614,-2.737982 6.3360174,-2.737982 4.191933,0 6.85238,2.691791 6.929916,2.772077 l -1.664565,1.734404 6.350865,1.100912 -1.099812,-6.263431 -1.810291,1.687113 z m -7.538113,-9.2340238 2.640099,0 -3.656325,-5.8499009 -3.657425,5.8499009 2.474028,0 0,4.3992488 2.199623,0 z m -2.199623,13.7476528 -2.472928,0 3.656875,5.8499 3.656875,-5.8499 -2.641199,0 0,-4.399249 -2.199623,0 z';
},{}],66:[function(require,module,exports){
module.exports = 'm 8.5,0.5 c -4.4123557,0 -8,3.5876443 -8,8 0,4.412356 3.5876444,8 8,8 1.804654,0 3.472798,-0.613745 4.8125,-1.625 l 0.46875,0.46875 5.09375,5.125 0.8125,0.8125 1.59375,-1.59375 -0.8125,-0.8125 -5.125,-5.09375 L 14.875,13.3125 C 15.886255,11.972798 16.5,10.304654 16.5,8.5 c 0,-4.4123556 -3.587644,-8 -8,-8 z m 0,1 c 3.871916,0 7,3.1280844 7,7 0,3.871916 -3.128084,7 -7,7 -3.8719156,0 -7,-3.128084 -7,-7 0,-3.8719155 3.1280845,-7 7,-7 z m -1,3 0,0.5 0,0.5 0,2 -2,0 -0.5,0 -0.5,0 0,0.5 0,1 0,0.5 0.5,0 0.5,0 2,0 0,2 0,0.5 0,0.5 0.5,0 1,0 0.5,0 0,-0.5 0,-0.5 0,-2 2,0 0.5,0 0.5,0 0,-0.5 0,-1 0,-0.5 -0.5,0 -0.5,0 -2,0 0,-2 0,-0.5 0,-0.5 -0.5,0 -1,0 -0.5,0 z';
},{}],67:[function(require,module,exports){
module.exports = 'm 8.5,0.4375 c -4.4461332,0 -8.0625,3.6163668 -8.0625,8.0625 0,4.446134 3.6163669,8.0625 8.0625,8.0625 1.818469,0 3.493543,-0.605755 4.84375,-1.625 l 0.4375,0.40625 5.09375,5.125 0.8125,0.8125 1.59375,-1.59375 -0.8125,-0.8125 -5.125,-5.09375 -0.40625,-0.4375 C 15.956745,11.993543 16.5625,10.318469 16.5625,8.5 16.5625,4.0538669 12.946134,0.4375 8.5,0.4375 z m 0,1.125 c 3.838138,0 6.9375,3.0993619 6.9375,6.9375 0,3.838138 -3.099362,6.9375 -6.9375,6.9375 -3.8381381,0 -6.9375,-3.099362 -6.9375,-6.9375 0,-3.838138 3.099362,-6.9375 6.9375,-6.9375 z m -4,6.9375 0,1 0.5,0 7,0 0.5,0 0,-1 -0.5,0 -7,0 -0.5,0 z';
},{}],68:[function(require,module,exports){
'use strict';

/*global require,ga*/
var addUserCatalogMember = require('../Models/addUserCatalogMember');
var createCatalogItemFromFileOrUrl = require('../Models/createCatalogItemFromFileOrUrl');
var loadView = require('../Core/loadView');
var ModelError = require('../Models/ModelError');
var WebFeatureServiceCatalogGroup = require('../Models/WebFeatureServiceCatalogGroup');
var WebMapServiceCatalogGroup = require('../Models/WebMapServiceCatalogGroup');

var defined = require('../../third_party/cesium/Source/Core/defined');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var AddDataPanelViewModel = function(options) {
    if (!defined(options) || !defined(options.application)) {
        throw new DeveloperError('options.application is required.');
    }

    this.application = options.application;
    this.destinationGroup = options.destinationGroup;

    this._domNodes = undefined;

    this.url = '';
    this.dataType ='auto';

    knockout.track(this, ['url', 'dataType']);
};

AddDataPanelViewModel.prototype.show = function(container) {
    this._domNodes = loadView("<div class=\"modal-background\" data-bind=\"click: closeIfClickOnBackground\">\n    <div class=\"add-data-panel\">\n        <div class=\"add-data-header\">\n            <div class=\"add-data-close-button\" data-bind=\"click: close\">&times;</div>\n            <h1>Add data</h1>\n        </div>\n        <div class=\"add-data-content\">\n            <p>\n                Use this panel to add data to the map from your local system or from elsewhere on the web.\n            </p>\n            <p>\n                Data added in this way is not saved or made visible to others unless you explicitly share it by using the Share panel.\n            </p>\n            <form class=\"add-data-form\" data-bind=\"submit: addUrl\">\n                <h2>Step 1</h2>\n                <label class=\"add-data-content-type\">\n                    Select the type of file or web service to add:\n                    <select class=\"add-data-content-type-select\" data-bind=\"value: dataType\">\n                        <option value=\"auto\">Auto-detect (recommended)</option>\n                        <option value=\"wms-getCapabilities\">Web Map Service (WMS) Server</option>\n                        <option value=\"wfs-getCapabilities\">Web Feature Service (WFS) Server</option>\n                        <option value=\"geojson\">GeoJSON</option>\n                        <option value=\"kml\">KML or KMZ</option>\n                        <option value=\"csv\">CSV</option>\n                        <option value=\"czml\">CZML</option>\n                        <option value=\"gpx\">GPX</option>\n                        <option value=\"other\">Other (use conversion service)</option>\n                    </select>\n                </label>\n\n                <h2>Step 2</h2>\n                <div class=\"add-data-select-file-button\" data-bind=\"click: selectFileToUpload\">Browse to select a local data file to upload</div>\n                <input type=\"file\" style=\"display: none;\" id=\"add-data-panel-upload-file\" data-bind=\"event: { change: addUploadedFile }\" />\n\n                <div class=\"add-data-or\">-or-</div>\n\n                Enter the URL of the data file or web service:\n                <div class=\"add-data-url-input-outer-holder\">\n                    <div class=\"add-data-url-input-inner-holder\">\n                        <input class=\"add-data-url-input\" type=\"text\" placeholder=\"e.g. http://data.gov.au/geoserver/wms\" data-bind=\"value: url\" />\n                    </div>\n                    <input class=\"add-data-url-add-button\" type=\"submit\" value=\"Add\" />\n                </div>\n\n                <div class=\"add-data-tip\">\n                    <strong>TIP:</strong> you can also drag data files directly onto the map.\n                </div>\n            </form>\n        </div>\n    </div>\n</div>\n", container, this);
};

AddDataPanelViewModel.prototype.close = function() {
    for (var i = 0; i < this._domNodes.length; ++i) {
        var node = this._domNodes[i];
        if (defined(node.parentElement)) {
            node.parentElement.removeChild(node);
        }
    }
};

AddDataPanelViewModel.prototype.closeIfClickOnBackground = function(viewModel, e) {
    if (e.target.className === 'modal-background') {
        this.close();
    }
    return true;
};

AddDataPanelViewModel.prototype.selectFileToUpload = function() {
    // If the browser doesn't have the FileReader type, this is an old browser (like IE9) that can't ready a user-selected
    // file from JavaScript without an ugly hack like bouncing it off a server first.  So tell the user this is not supported.
    if (typeof FileReader === 'undefined') {
        this.application.error.raiseEvent(new ModelError({
            title: 'File API not supported',
            message: '\
Sorry, your web browser does not support the File API, which National Map requires in order to \
add data from a file on your system.  Please upgrade your web browser.  For the best experience, we recommend \
<a href="http://www.microsoft.com/ie" target="_blank">Internet Explorer 11</a> or the latest version of \
<a href="http://www.google.com/chrome" target="_blank">Google Chrome</a> or \
<a href="http://www.mozilla.org/firefox" target="_blank">Mozilla Firefox</a>.'
        }));
        return;
    }

    // We can't add a WMS or WFS server from a file.
    if (this.dataType === 'wms-getCapabilities' || this.dataType === 'wfs-getCapabilities') {
        this.application.error.raiseEvent(new ModelError({
            title: 'A service cannot be added from a local file',
            message: 'Sorry, a WMS or WFS server can only be added by providing a URL to the server.  Please select a different type of file, or choose "Auto-detect".'
        }));
        return;
    }

    var element = document.getElementById('add-data-panel-upload-file');
    element.click();
};

AddDataPanelViewModel.prototype.addUploadedFile = function() {
    var uploadFileElement = document.getElementById('add-data-panel-upload-file');
    var files = uploadFileElement.files;

    if (!defined(files)) {
        this.application.error.raiseEvent(new ModelError({
            title: 'File API not supported',
            message: '\
Sorry, your web browser does not support the File API, which National Map requires in order to \
add data from a file on your system.  Please upgrade your web browser.  For the best experience, we recommend \
<a href="http://www.microsoft.com/ie" target="_blank">Internet Explorer 11</a> or the latest version of \
<a href="http://www.google.com/chrome" target="_blank">Google Chrome</a> or \
<a href="http://www.mozilla.org/firefox" target="_blank">Mozilla Firefox</a>.'
        }));
        return;
    }

    if (files.length > 0) {
        var promises = [];

        for (var i = 0; i < files.length; ++i) {
            var file = files[i];
            ga('send', 'event', 'uploadFile', 'browse', file.name);

            promises.push(addUserCatalogMember(this.application, createCatalogItemFromFileOrUrl(this.application, file, this.dataType, true)));
        }

        // Attempt to clear the selected file, so the onchange event is fired even if the user selects
        // the same file again.  This may not work in all browsers.
        try { uploadFileElement.value = ''; } catch(e) {}
        try { uploadFileElement.value = null; } catch(e) {}

        var that = this;
        when.all(promises, function() {
            that.close();
        });
    }
};

var wfsUrlRegex = /\bwfs\b/i;

AddDataPanelViewModel.prototype.addUrl = function() {
    ga('send', 'event', 'addDataUrl', this.url);

    var that = this;

    var promise;
    if (this.dataType === 'auto') {
        // Does this look like a WFS URL?  If so, try that first (before WMS).
        // This accounts for the fact that a single URL often works as both WMS and WFS.
        if (wfsUrlRegex.test(this.url)) {
            promise = loadWfs(that).otherwise(function() {
                return loadWms(that).otherwise(function() {
                    return loadFile(that);
                });
            });
        } else {
            promise = loadWms(that).otherwise(function() {
                return loadWfs(that).otherwise(function() {
                    return loadFile(that);
                });
            });
        }
    } else if (this.dataType === 'wms-getCapabilities') {
        promise = loadWms(this);
    } else if (this.dataType === 'wfs-getCapabilities') {
        promise = loadWfs(this);
    } else {
        promise = loadFile(this);
    }

    addUserCatalogMember(this.application, promise).then(function() {
        that.close();
    });
};

AddDataPanelViewModel.open = function(container, options) {
    var viewModel = new AddDataPanelViewModel(options);
    viewModel.show(container);
    return viewModel;
};

function loadWms(viewModel) {
    var wms = new WebMapServiceCatalogGroup(viewModel.application);
    wms.name = viewModel.url;
    wms.url = viewModel.url;

    return wms.load().then(function() {
        return wms;
    });
}

function loadWfs(viewModel) {
    var wfs = new WebFeatureServiceCatalogGroup(viewModel.application);
    wfs.name = viewModel.url;
    wfs.url = viewModel.url;

    return wfs.load().then(function() {
        return wfs;
    });
}

function loadFile(viewModel) {
    return createCatalogItemFromFileOrUrl(viewModel.application, viewModel.url, viewModel.dataType, true);
}

module.exports = AddDataPanelViewModel;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/loadView":8,"../Models/ModelError":41,"../Models/WebFeatureServiceCatalogGroup":46,"../Models/WebMapServiceCatalogGroup":48,"../Models/addUserCatalogMember":50,"../Models/createCatalogItemFromFileOrUrl":51}],69:[function(require,module,exports){
'use strict';

var BaseMapViewModel = function(options) {
    this.image = options.image;
    this.catalogItem = options.catalogItem;
};

BaseMapViewModel.prototype.activate = function() {
};

module.exports = BaseMapViewModel;

},{}],70:[function(require,module,exports){
'use strict';

/*global require,ga*/
var inherit = require('../Core/inherit');
var SearchProviderViewModel = require('./SearchProviderViewModel');
var SearchResultViewModel = require('./SearchResultViewModel');

var BingMapsApi = require('../../third_party/cesium/Source/Core/BingMapsApi');
var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var Ellipsoid = require('../../third_party/cesium/Source/Core/Ellipsoid');
var jsonp = require('../../third_party/cesium/Source/Core/jsonp');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');

var BingMapsSearchProviderViewModel = function(options) {
    SearchProviderViewModel.call(this);

    options = defaultValue(options, defaultValue.EMPTY_OBJECT);

    this.application = options.application;
    this._geocodeInProgress = undefined;

    this.name = 'Locations';
    this.url = defaultValue(options.url, '//dev.virtualearth.net/');
    if (this.url.length > 0 && this.url[this.url.length - 1] !== '/') {
        this.url += '/';
    }
    this.key = BingMapsApi.getKey(options.key);
    this.flightDurationSeconds = defaultValue(options.flightDurationSeconds, 1.5);
    this.primaryCountry = defaultValue(options.primaryCountry, 'Australia');
    this.culture = defaultValue(options.culture, 'en-au');
};

inherit(SearchProviderViewModel, BingMapsSearchProviderViewModel);

BingMapsSearchProviderViewModel.prototype.search = function(searchText) {
    if (!defined(searchText) || /^\s*$/.test(searchText)) {
        this.isSearching = false;
        this.searchResults.removeAll();
        return;
    }

    this.isSearching = true;
    this.searchResults.removeAll();
    this.searchMessage = undefined;

    ga('send', 'event', 'search', 'bing', searchText);

    // If there is already a search in progress, cancel it.
    if (defined(this._geocodeInProgress)) {
        this._geocodeInProgress.cancel = true;
        this._geocodeInProgress = undefined;
    }

    var longitudeDegrees;
    var latitudeDegrees;

    if (defined(this.application.cesium)) {
        var scene = this.application.cesium.scene;
        var cameraPosition = scene.camera.positionWC;
        var cameraPositionCartographic = Ellipsoid.WGS84.cartesianToCartographic(cameraPosition);
        longitudeDegrees = CesiumMath.toDegrees(cameraPositionCartographic.longitude);
        latitudeDegrees = CesiumMath.toDegrees(cameraPositionCartographic.latitude);
    } else if (defined(this.application.leaflet)) {
        var center = this.application.leaflet.map.getCenter();
        longitudeDegrees = center.lng;
        latitudeDegrees = center.lat;
    }

    var promise = jsonp(this.url + 'REST/v1/Locations?culture=' + this.culture + '&userLocation=' + latitudeDegrees + ',' + longitudeDegrees , {
        parameters : {
            query : searchText,
            key : this.key
        },
        callbackParameterName : 'jsonp'
    });

    var that = this;
    var geocodeInProgress = this._geocodeInProgress = promise.then(function(result) {
        if (geocodeInProgress.cancel) {
            return;
        }
        that.isSearching = false;

        if (result.resourceSets.length === 0) {
            that.searchMessage = 'Sorry, no locations match your search query.';
            return;
        }

        var resourceSet = result.resourceSets[0];
        if (resourceSet.resources.length === 0) {
            that.searchMessage = 'Sorry, no locations match your search query.';
            return;
        }

        var primaryCountryLocations = [];
        var otherLocations = [];

        // Locations in the primary country go on top, locations elsewhere go undernearth and we add
        // the country name to them.
        for (var i = 0; i < resourceSet.resources.length; ++i) {
            var resource = resourceSet.resources[i];

            var name = resource.name;
            if (!defined(name)) {
                continue;
            }

            var list = primaryCountryLocations;
            var isImportant = true;

            var country = resource.address ? resource.address.countryRegion : undefined;
            if (defined(that.primaryCountry) && country !== that.primaryCountry) {
                // Add this location to the list of other locations.
                list = otherLocations;
                isImportant = false;

                // Add the country to the name, if it's not already there.
                if (defined(country) && name.lastIndexOf(country) !== name.length - country.length) {
                    name += ', ' + country;
                }
            }

            list.push(new SearchResultViewModel({
                name: name,
                isImportant: isImportant,
                clickAction: createZoomToFunction(that, resource)
            }));
        }

        that.searchResults.push.apply(that.searchResults, primaryCountryLocations);
        that.searchResults.push.apply(that.searchResults, otherLocations);

        if (that.searchResults.length === 0) {
            that.searchMessage = 'Sorry, no locations match your search query.';
        }
    }).otherwise(function() {
        if (geocodeInProgress.cancel) {
            return;
        }

        that.isSearching = false;
        that.searchMessage = 'An error occurred while searching.  Please check your internet connection or try again later.';
    });
};

function createZoomToFunction(viewModel, resource) {
    var bbox = resource.bbox;
    var south = bbox[0];
    var west = bbox[1];
    var north = bbox[2];
    var east = bbox[3];

    var rectangle = Rectangle.fromDegrees(west, south, east, north);

    return function() {
        var application = viewModel.application;
        application.currentViewer.zoomTo(rectangle, viewModel.flightDurationSeconds);
    };
}

module.exports = BingMapsSearchProviderViewModel;

},{"../../third_party/cesium/Source/Core/BingMapsApi":96,"../../third_party/cesium/Source/Core/Ellipsoid":130,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/jsonp":256,"../Core/inherit":7,"./SearchProviderViewModel":86,"./SearchResultViewModel":87}],71:[function(require,module,exports){
'use strict';

/*global require*/


var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var createFragmentFromTemplate = require('../Core/createFragmentFromTemplate');
var svgMenu = require('../SvgPaths/svgMenu');

var html = "<div class=\"brand-bar\">\n    <div class=\"brand-bar-main\">\n        <div class=\"brand-bar-element\">\n            <img data-bind=\"attr: { src: leftLogo }\" height=\"52\" />\n        </div>\n        <div class=\"brand-bar-element\">\n            <div class=\"brand-bar-name\" data-bind=\"html: name\"></div>\n        </div>\n        <div class=\"brand-bar-element\">\n            <img src=\"images/nicta.png\" height=\"52\" />\n        </div>\n    </div>\n</div>\n";

var BrandBarViewModel = function(options) {
    this.svgMenu = svgMenu;

    this.name = options.name;
    this.leftLogo = options.leftLogo;
    this.explorerPanelIsOpen = true;

    knockout.track(this, ['name', 'leftLogo', 'explorerPanelIsOpen']);
};

BrandBarViewModel.create = function(container, options) {
    container = defaultValue(container, document.body);

    var fragment = createFragmentFromTemplate(html);
    var element = fragment.childNodes[0];
    container.appendChild(element);

    var viewModel = new BrandBarViewModel(options);
    knockout.applyBindings(viewModel, element);

    return viewModel;
};

BrandBarViewModel.prototype.toggleExplorerPanelOpen = function() {
    this.explorerPanelIsOpen = !this.explorerPanelIsOpen;
};

module.exports = BrandBarViewModel;
},{"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/createFragmentFromTemplate":6,"../SvgPaths/svgMenu":63}],72:[function(require,module,exports){
'use strict';

/*global require*/
var defined = require('../../third_party/cesium/Source/Core/defined');

var loadView = require('../Core/loadView');

var svgArrowDown = require('../SvgPaths/svgArrowDown');
var svgArrowRight = require('../SvgPaths/svgArrowRight');

var CatalogItemInfoViewModel = function(catalogItem) {
    this.catalogItem = catalogItem;
    this.svgArrowDown = svgArrowDown;
    this.svgArrowRight = svgArrowRight;

    this._domNodes = undefined;
};

CatalogItemInfoViewModel.prototype.show = function(container) {
    this._domNodes = loadView("<script type=\"text/html\" id=\"catalog-item-info-item-template\">\n    <tr>\n        <td class=\"catalog-item-info-properties-name-cell\" data-bind=\"click: toggleOpen, css: 'catalog-item-info-properties-level' + $parents.length + (hasChildren ? ' catalog-item-info-properties-parent' : '')\">\n            <!-- ko if: hasChildren && isOpen -->\n            <div class=\"catalog-item-info-properties-arrow\" data-bind=\"cesiumSvgPath: { path: $root.svgArrowDown, width: 32, height: 32 }\"></div>\n            <!-- /ko -->\n            <!-- ko if: hasChildren && !isOpen -->\n            <div class=\"catalog-item-info-properties-arrow\" data-bind=\"cesiumSvgPath: { path: $root.svgArrowRight, width: 32, height: 32 }\"></div>\n            <!-- /ko -->\n            <!-- ko if: !hasChildren -->\n            <div class=\"catalog-item-info-properties-arrow\"></div>\n            <!-- /ko -->\n            <div class=\"catalog-item-info-properties-name\" data-bind=\"text: name\"></div>\n        </td>\n        <!-- ko if: hasChildren -->\n            <td></td>\n        <!-- /ko -->\n        <!-- ko if: valueIsArray -->\n            <td data-bind=\"foreach: value\">\n                <span data-bind=\"if: $index() !== 0\">; </span>\n                <span data-bind=\"text: $data\"></span>\n            </td>\n        <!-- /ko -->\n        <!-- ko ifnot: hasChildren || valueIsArray -->\n            <td data-bind=\"text: value\"></td>\n        <!-- /ko -->\n    </tr>\n    <!-- ko if: hasChildren && isOpen -->\n        <!-- ko template: { name: 'catalog-item-info-item-template', foreach: items } -->\n        <!-- /ko -->\n    <!-- /ko -->\n</script>\n\n<div class=\"modal-background\" data-bind=\"click: closeIfClickOnBackground\">\n    <div class=\"catalog-item-info\" data-bind=\"css : { loadingIndicator : catalogItem.metadata.isLoading }\">\n        <div class=\"catalog-item-info-header\">\n            <div class=\"catalog-item-info-close-button\" data-bind=\"click: close\">&times;</div>\n            <h1 data-bind=\"text: catalogItem.name\"></h1>\n        </div>\n        <div class=\"catalog-item-info-content\">\n            <div class=\"catalog-item-info-section\">\n                <!-- ko if: catalogItem.description -->\n                <div class=\"catalog-item-info-description\" data-bind=\"sanitizedHtml: catalogItem.description\"></div>\n                <!-- /ko -->\n                <!-- ko if: !catalogItem.description -->\n                <div class=\"catalog-item-info-description\">Please contact the provider of this data for more information, including information about usage rights and constraints.</div>\n                <!-- /ko -->\n            </div>\n            <div class=\"catalog-item-info-section\">\n                <h2>Data Custodian</h2>\n                <div class=\"catalog-item-info-description\" data-bind=\"sanitizedHtml: catalogItem.dataCustodian\"></div>\n            </div>\n            <div class=\"catalog-item-info-section\" data-bind=\"if: catalogItem.url\">\n                <h2><span data-bind=\"text: catalogItem.typeName\"></span> URL</h2>\n                <input class=\"catalog-item-info-baseUrl\" readonly type=\"text\" data-bind=\"value: catalogItem.url\" size=\"80\" onclick=\"this.select();\" />\n            </div>\n            <div class=\"catalog-item-info-section\" data-bind=\"if: catalogItem.metadataUrl\">\n                <h2>Metadata URL</h2>\n                <a class=\"catalog-item-info-description\" data-bind=\"attr: { href: catalogItem.metadataUrl }, text: catalogItem.metadataUrl\" target=\"_blank\"></a>\n            </div>\n            <div class=\"catalog-item-info-section\" data-bind=\"if: catalogItem.dataUrlType === 'wfs' || catalogItem.dataUrlType === 'wfs-complete'\">\n                <h2>Data URL</h2>\n                <div class=\"catalog-item-info-description\">\n                    Use the link below to download GeoJSON data.  See the\n                    <a href=\"http://docs.geoserver.org/latest/en/user/services/wfs/reference.html\" target=\"_blank\">Web Feature Service (WFS) documentation</a>\n                    for more information on customising URL query parameters.\n                    <div><a data-bind=\"attr: { href: catalogItem.dataUrl }, text: catalogItem.dataUrl\" target=\"_blank\"></a></div>\n                </div>\n            </div>\n            <div class=\"catalog-item-info-section\" data-bind=\"if: catalogItem.dataUrlType === 'direct'\">\n                <h2>Data URL</h2>\n                <div class=\"catalog-item-info-description\">\n                    Use the link below to download data directly.\n                    <div><a data-bind=\"attr: { href: catalogItem.dataUrl }, text: catalogItem.dataUrl\" target=\"_blank\"></a></div>\n                </div>\n            </div>\n            <div class=\"catalog-item-info-section\">\n                <h2>Data Details</h2>\n                <div class=\"catalog-item-info-table\">\n                    <!-- ko if: catalogItem.metadata.dataSourceMetadata.hasChildren -->\n                    <table data-bind=\"template: { name: 'catalog-item-info-item-template', foreach: catalogItem.metadata.dataSourceMetadata.items }\">\n                    </table>\n                    <!-- /ko -->\n                    <!-- ko if: catalogItem.metadata.catalogItemErrorMessage -->\n                    <table>\n                        <tr>\n                            <td class=\"catalog-item-info-properties-name-cell catalog-item-info-properties-level1\">\n                                <div class=\"catalog-item-info-properties-arrow\"></div>\n                                <div class=\"catalog-item-info-properties-name\" data-bind=\"text: catalogItem.metadata.catalogItemErrorMessage\"></div>\n                            </td>\n                        </tr>\n                    </table>\n                    <!-- /ko -->\n                </div>\n            </div>\n            <div class=\"catalog-item-info-section\">\n                <h2>Service Details</h2>\n                <div class=\"catalog-item-info-table\">\n                    <!-- ko if: catalogItem.metadata.serviceMetadata.hasChildren -->\n                    <table data-bind=\"template: { name: 'catalog-item-info-item-template', foreach: catalogItem.metadata.serviceMetadata.items }\">\n                    </table>\n                    <!-- /ko -->\n                    <!-- ko if: catalogItem.metadata.serviceErrorMessage -->\n                    <table>\n                        <tr>\n                            <td class=\"catalog-item-info-properties-name-cell catalog-item-info-properties-level1\">\n                                <div class=\"catalog-item-info-properties-arrow\"></div>\n                                <div class=\"catalog-item-info-properties-name\" data-bind=\"text: catalogItem.metadata.serviceErrorMessage\"></div>\n                            </td>\n                        </tr>\n                    </table>\n                    <!-- /ko -->\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n", container, this);
};

CatalogItemInfoViewModel.prototype.close = function() {
    for (var i = 0; i < this._domNodes.length; ++i) {
        var node = this._domNodes[i];
        if (defined(node.parentElement)) {
            node.parentElement.removeChild(node);
        }
    }
};

CatalogItemInfoViewModel.prototype.closeIfClickOnBackground = function(viewModel, e) {
    if (e.target.className === 'modal-background') {
        this.close();
    }
    return true;
};

CatalogItemInfoViewModel.open = function(container, catalogItem) {
    var viewModel = new CatalogItemInfoViewModel(catalogItem);
    viewModel.show(container);
    return viewModel;
};

module.exports = CatalogItemInfoViewModel;

},{"../../third_party/cesium/Source/Core/defined":245,"../Core/loadView":8,"../SvgPaths/svgArrowDown":57,"../SvgPaths/svgArrowRight":58}],73:[function(require,module,exports){
'use strict';

/*global require,ga*/
var inherit = require('../Core/inherit');
var SearchProviderViewModel = require('./SearchProviderViewModel');
var SearchResultViewModel = require('./SearchResultViewModel');

var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');

var CatalogItemNameSearchProviderViewModel = function(options) {
    SearchProviderViewModel.call(this);

    options = defaultValue(options, defaultValue.EMPTY_OBJECT);

    this.application = options.application;
    this._geocodeInProgress = undefined;

    this.name = 'Catalogue Items';
    this.maxResults = defaultValue(options.maxResults, 10);
};

inherit(SearchProviderViewModel, CatalogItemNameSearchProviderViewModel);

CatalogItemNameSearchProviderViewModel.prototype.search = function(searchText) {
    if (!defined(searchText) || /^\s*$/.test(searchText)) {
        this.isSearching = false;
        this.searchResults.removeAll();
        return;
    }

    this.isSearching = true;
    this.searchResults.removeAll();
    this.searchMessage = undefined;

    ga('send', 'event', 'search', 'catalogue', searchText);

    var path = [];
    var topLevelGroup = this.application.catalog.group;
    findMatchingItemsRecursively(this, new RegExp(searchText, 'i'), topLevelGroup, path);

    if (this.searchResults.length === 0) {
        this.searchMessage = 'Sorry, no catalogue items match your search query.';
    }

    this.isSearching = false;
};

function findMatchingItemsRecursively(viewModel, searchExpression, group, path) {
    path.push(group);

    var items = group.items;
    for (var i = 0; viewModel.searchResults.length < viewModel.maxResults && i < items.length; ++i) {
        var item = items[i];

        // Match non-top-level items whose name contain the search text.
        if (path.length > 1 && searchExpression.test(item.name)) {
            viewModel.searchResults.push(new SearchResultViewModel({
                name: item.name,
                isImportant: true,
                catalogItem: item,
                tooltip: pathToTooltip(path)
            }));
        }

        if (defined(item.items)) {
            findMatchingItemsRecursively(viewModel, searchExpression, item, path);
        }
    }

    path.pop();
}

function pathToTooltip(path) {
    var result = 'In Data Catalogue';

    // Start at 1 to skip "Root Group"
    for (var i = 1; i < path.length; ++i) {
        result += ' -> ' + path[i].name;
    }

    return result;
}

module.exports = CatalogItemNameSearchProviderViewModel;

},{"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../Core/inherit":7,"./SearchProviderViewModel":86,"./SearchResultViewModel":87}],74:[function(require,module,exports){
'use strict';

/*global require,ga*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');

var CatalogItemInfoViewModel = require('./CatalogItemInfoViewModel');
var ExplorerTabViewModel = require('./ExplorerTabViewModel');
var inherit = require('../Core/inherit');
var loadView = require('../Core/loadView');

var svgCheckboxChecked = require('../SvgPaths/svgCheckboxChecked');
var svgCheckboxUnchecked = require('../SvgPaths/svgCheckboxUnchecked');
var svgArrowDown = require('../SvgPaths/svgArrowDown');
var svgArrowRight = require('../SvgPaths/svgArrowRight');
var svgInfo = require('../SvgPaths/svgInfo');

var DataCatalogTabViewModel = function(options) {
    ExplorerTabViewModel.call(this);

    this.name = 'Data Catalogue';
    this.catalog = options.catalog;

    this.svgCheckboxChecked = defaultValue(options.svgCheckboxChecked, svgCheckboxChecked);
    this.svgCheckboxUnchecked = defaultValue(options.svgCheckboxUnchecked, svgCheckboxUnchecked);
    this.svgArrowDown = defaultValue(options.svgArrowDown, svgArrowDown);
    this.svgArrowRight = defaultValue(options.svgArrowRight, svgArrowRight);
    this.svgInfo = defaultValue(options.svgInfo, svgInfo);
};

inherit(ExplorerTabViewModel, DataCatalogTabViewModel);

DataCatalogTabViewModel.prototype.show = function(container) {
    loadView("<script type=\"text/html\" id=\"data-catalog-item-template\">\n    <!-- ko if: typeof items === 'undefined' -->\n        <div class=\"data-catalog-member\" data-bind=\"css: 'data-catalog-indent' + ($parents.length - 2)\">\n            <div class=\"data-catalog-member-top-row\">\n                <div class=\"data-catalog-icon-holder\">\n                    <div class=\"data-catalog-icon clickable\" data-bind=\"click: toggleEnabled, cesiumSvgPath: { path: isEnabled ? $root.svgCheckboxChecked : $root.svgCheckboxUnchecked, width: 32, height: 32 }, css: { 'data-catalog-enabled-item': isEnabled }\"></div>\n                </div>\n                <div class=\"data-catalog-item-label data-catalog-enabled-item clickable\" data-bind=\"visible: isEnabled, text: name, click: zoomToAndUseClock\"></div>\n                <div class=\"data-catalog-item-label\" data-bind=\"visible: !isEnabled, text: name\"></div>\n                <div class=\"data-catalog-item-info\">\n                    <div class=\"data-catalog-info-icon clickable\" data-bind=\"click: $root.showInfo.bind($root), cesiumSvgPath: { path: $root.svgInfo, width: 18, height: 18, 'fill-rule': 'evenodd' }\"></div>\n                </div>\n            </div>\n        </div>\n    <!-- /ko -->\n\n    <!-- ko if: typeof items !== 'undefined' -->\n        <div class=\"data-catalog-member\" data-bind=\"css: 'data-catalog-indent' + ($parents.length - 2)\">\n            <div class=\"data-catalog-member-top-row\">\n                <div class=\"data-catalog-icon-holder\">\n                    <div class=\"data-catalog-icon clickable\" data-bind=\"click: toggleOpen, cesiumSvgPath: { path: isOpen ? $root.svgArrowDown : $root.svgArrowRight, width: 32, height: 32 }, css: { 'data-catalog-opened-group': isOpen }\"></div>\n                </div>\n                <div class=\"data-catalog-group-label clickable\" data-bind=\"click: toggleOpen, text: name, css: { 'data-catalog-opened-group': isOpen }\"></div>\n            </div>\n\n            <!-- ko if: isOpen && (isLoading || items.length === 0) -->\n                <div class=\"data-catalog-group-contents\">\n                    <div class=\"data-catalog-member\" data-bind=\"css: 'data-catalog-indent' + ($parents.length - 1)\">\n                        <div class=\"data-catalog-item-label\" data-bind=\"if: isLoading\">Loading...</div>\n                        <div class=\"data-catalog-item-label\" data-bind=\"if: !isLoading\">This group does not contain any data items.</div>\n                    </div>\n                </div>\n            <!-- /ko -->\n\n            <!-- ko if: isOpen -->\n                <div class=\"data-catalog-group-contents\" data-bind=\"template: { name: 'data-catalog-item-template', foreach: items }\"></div>\n            <!-- /ko -->\n        </div>\n    <!-- /ko -->\n</script>\n\n<div class=\"data-catalog-top-group\" data-bind=\"foreach: catalog.group.items\">\n    <div class=\"data-catalog-top-group-header\" data-bind=\"click: toggleOpen\">\n        <div class=\"data-catalog-top-group-label\" data-bind=\"text: name\"></div>\n        <div class=\"data-catalog-icon-holder\">\n            <div class=\"data-catalog-top-group-icon\" data-bind=\"cesiumSvgPath: { path: isOpen ? $root.svgArrowDown : $root.svgArrowRight, width: 32, height: 32 }\"></div>\n        </div>\n    </div>\n    <!-- ko if: isLoading -->\n        <div class=\"data-catalog-top-group-contents\">\n            <div class=\"data-catalog-member\">\n                <div class=\"data-catalog-member-top-row\">\n                    <div class=\"data-catalog-item-label\">Loading...</div>\n                </div>\n            </div>\n        </div>\n    <!-- /ko -->\n    <!-- ko if: typeof items !== 'undefined' && isOpen -->\n        <div class=\"data-catalog-top-group-contents\" data-bind=\"template: { name: 'data-catalog-item-template', foreach: items }\"></div>\n    <!-- /ko -->\n</div>\n", container, this);
};

DataCatalogTabViewModel.prototype.showInfo = function(item) {
    ga('send', 'event', 'dataSource', 'info', item.name);
    CatalogItemInfoViewModel.open('ui', item);
};

module.exports = DataCatalogTabViewModel;

},{"../../third_party/cesium/Source/Core/defaultValue":243,"../Core/inherit":7,"../Core/loadView":8,"../SvgPaths/svgArrowDown":57,"../SvgPaths/svgArrowRight":58,"../SvgPaths/svgCheckboxChecked":59,"../SvgPaths/svgCheckboxUnchecked":60,"../SvgPaths/svgInfo":62,"./CatalogItemInfoViewModel":72,"./ExplorerTabViewModel":78}],75:[function(require,module,exports){
'use strict';

/*global require,L*/
var Cartesian2 = require('../../third_party/cesium/Source/Core/Cartesian2');
var defined = require('../../third_party/cesium/Source/Core/defined');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var EllipsoidGeodesic = require('../../third_party/cesium/Source/Core/EllipsoidGeodesic');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var loadView = require('../Core/loadView');

var DistanceLegendViewModel = function(application) {
    if (!defined(application)) {
        throw new DeveloperError('application is required.');
    }

    this.application = application;
    this.removeSubscription = undefined;

    this.distanceLabel = undefined;
    this.barWidth = undefined;

    knockout.track(this, ['distanceLabel', 'barWidth']);

    this.application.beforeViewerChanged.addEventListener(function() {
        if (defined(this.removeSubscription)) {
            this.removeSubscription();
            this.removeSubscription = undefined;
        }
    }, this);

    var that = this;

    function addUpdateSubscription() {
        if (defined(that.application.cesium)) {
            var scene = that.application.cesium.scene;
            that.removeSubscription = scene.postRender.addEventListener(function() {
                updateDistanceLegendCesium(this, scene);
            }, that);
        } else if (defined(that.application.leaflet)) {
            var map = that.application.leaflet.map;

            var potentialChangeCallback = function potentialChangeCallback() {
                updateDistanceLegendLeaflet(that, map);
            };

            that.removeSubscription = function() {
                map.off('zoomend', potentialChangeCallback);
                map.off('moveend', potentialChangeCallback);
            };

            map.on('zoomend', potentialChangeCallback);
            map.on('moveend', potentialChangeCallback);

            updateDistanceLegendLeaflet(that, map);
        }
    }

    addUpdateSubscription();

    this.application.afterViewerChanged.addEventListener(function() {
        addUpdateSubscription();
    }, this);
};

DistanceLegendViewModel.prototype.show = function(container) {
    loadView("<div class=\"distance-legend\" data-bind=\"visible: distanceLabel && barWidth\">\n    <div class=\"distance-legend-label\" data-bind=\"text: distanceLabel\"></div>\n    <div class=\"distance-legend-scale-bar\" data-bind=\"style: { width: barWidth + 'px', left: (5 + (125 - barWidth) / 2) + 'px' }\"></div>\n</div>\n", container, this);
};

var geodesic = new EllipsoidGeodesic();

var distances = [
    1, 2, 3, 5,
    10, 20, 30, 50,
    100, 200, 300, 500,
    1000, 2000, 3000, 5000,
    10000, 20000, 30000, 50000,
    100000, 200000, 300000, 500000,
    1000000, 2000000, 3000000, 5000000,
    10000000, 20000000, 30000000, 50000000];

function updateDistanceLegendCesium(viewModel, scene) {
    // Find the distance between two pixels at the bottom center of the screen.
    var width = scene.canvas.clientWidth;
    var height = scene.canvas.clientHeight;

    var left = scene.camera.getPickRay(new Cartesian2((width / 2) | 0, height - 1));
    var right = scene.camera.getPickRay(new Cartesian2(1 + (width / 2) | 0, height - 1));

    var globe = scene.globe;
    var leftPosition = globe.pick(left, scene);
    var rightPosition = globe.pick(right, scene);

    if (!defined(leftPosition) || !defined(rightPosition)) {
        viewModel.barWidth = undefined;
        viewModel.distanceLabel = undefined;
        return;
    }

    var leftCartographic = globe.ellipsoid.cartesianToCartographic(leftPosition);
    var rightCartographic = globe.ellipsoid.cartesianToCartographic(rightPosition);

    geodesic.setEndPoints(leftCartographic, rightCartographic);
    var pixelDistance = geodesic.surfaceDistance;

    // Find the first distance that makes the scale bar less than 100 pixels.
    var maxBarWidth = 100;
    var distance;
    for (var i = distances.length - 1; !defined(distance) && i >= 0; --i) {
        if (distances[i] / pixelDistance < maxBarWidth) {
            distance = distances[i];
        }
    }

    if (defined(distance)) {
        var label;
        if (distance >= 1000) {
            label = (distance / 1000).toString() + ' km';
        } else {
            label = distance.toString() + ' m';
        }

        viewModel.barWidth = (distance / pixelDistance) | 0;
        viewModel.distanceLabel = label;
    } else {
        viewModel.barWidth = undefined;
        viewModel.distanceLabel = undefined;
    }
}

function updateDistanceLegendLeaflet(viewModel, map) {
    var halfHeight = map.getSize().y / 2;
    var maxPixelWidth = 100;
    var maxMeters = map.containerPointToLatLng([0, halfHeight]).distanceTo(
        map.containerPointToLatLng([maxPixelWidth, halfHeight]));

    var meters = L.control.scale()._getRoundNum(maxMeters);
    var label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

    viewModel.barWidth = (meters / maxMeters) * maxPixelWidth;
    viewModel.distanceLabel = label;
}

module.exports = DistanceLegendViewModel;
},{"../../third_party/cesium/Source/Core/Cartesian2":101,"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/EllipsoidGeodesic":131,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/loadView":8}],76:[function(require,module,exports){
'use strict';

/*global require,ga*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var getElement = require('../../third_party/cesium/Source/Widgets/getElement');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var addUserCatalogMember = require('../Models/addUserCatalogMember');
var createCatalogItemFromFileOrUrl = require('../Models/createCatalogItemFromFileOrUrl');
var loadView = require('../Core/loadView');
var raiseErrorOnRejectedPromise = require('../Models/raiseErrorOnRejectedPromise');
var readJson = require('../Core/readJson');

var DragDropViewModel = function(options) {
    if (!defined(options) || !defined(options.application)) {
        throw new DeveloperError('options.application is required.');
    }

    this.application = options.application;

    this.dropTarget = undefined;
    if (defined(options.dropTarget)) {
        this.dropTarget = getElement(options.dropTarget);
    } else {
        this.dropTarget = document;
    }

    this.showDropMessage = false;
    this.allowDropDataFiles = defaultValue(options.allowDropDataFiles, true);
    this.allowDropInitFiles = defaultValue(options.allowDropInitFiles, true);

    knockout.track(this, ['showDropMessage', 'allowDropDataFiles', 'allowDropInitFiles']);

    var that = this;

    // Chrome and Firefox can't agree on how to check if a string is included in the list of data transfer types.
    // Firefox has 'includes' and 'contains' but not 'indexOf', while Chrome only has 'indexOf'.
    // So we do this the hard way.
    function arrayContains(array, value) {
        for (var i = 0; i < array.length; ++i) {
            if (array[i] === value) {
                return true;
            }
        }

        return false;
    }

    this.dropTarget.addEventListener("dragenter", function(evt) {
        if (!evt.dataTransfer.types || !arrayContains(evt.dataTransfer.types, 'Files')) {
            return;
        }

        evt.preventDefault();
        that.showDropMessage = true;
    }, false);

    this.dropTarget.addEventListener("dragover", function(evt) {
        if (!evt.dataTransfer.types || !arrayContains(evt.dataTransfer.types, 'Files')) {
            return;
        }

        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy';
    }, false);

    this.dropTarget.addEventListener("dragleave", function(evt) {
        if (!evt.dataTransfer.types || !arrayContains(evt.dataTransfer.types, 'Files')) {
            return;
        }

        evt.preventDefault();

        if (evt.target.className === 'drag-drop') {
            that.showDropMessage = false;
        }
    }, false);

    this.dropTarget.addEventListener("drop", function(evt) {
        if (!evt.dataTransfer.types || !arrayContains(evt.dataTransfer.types, 'Files')) {
            return;
        }

        evt.preventDefault();

        that.showDropMessage = false;

        var files = evt.dataTransfer.files;
        for (var i = 0; i < files.length; ++i) {
            var file = files[i];
            ga('send', 'event', 'uploadFile', 'dragDrop', file.name);

            if (file.name.toUpperCase().indexOf('.JSON') !== -1) {
                readAndHandleJsonFile(that, file);
            } else {
                addFile(that, file);
            }
        }
    }, false);
};

DragDropViewModel.prototype.show = function(container) {
    loadView("<div class=\"drag-drop\" data-bind=\"visible: showDropMessage\">\n    <div class=\"drag-drop-message\">\n        Drop a data file anywhere to add it to the map!\n    </div>\n</div>\n", container, this);
};

DragDropViewModel.create = function(container, options) {
    var viewModel = new DragDropViewModel(options);
    viewModel.show(container);
    return viewModel;
};

function readAndHandleJsonFile(viewModel, file) {
    raiseErrorOnRejectedPromise(viewModel.application, readJson(file).then(function(json) {
        if (viewModel.allowDropInitFiles && (json.catalog || json.services)) {
            // This is an init file.
            return viewModel.application.addInitSource(json);
        } else {
            // This is some other type of data file.
            return addFile(viewModel, file);
        }
    }));
}

function addFile(viewModel, file) {
    if (!viewModel.allowDropDataFiles) {
        return;
    }

    return addUserCatalogMember(viewModel.application, createCatalogItemFromFileOrUrl(viewModel.application, file, 'auto', true));
}

module.exports = DragDropViewModel;
},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/Widgets/getElement":628,"../Core/loadView":8,"../Core/readJson":9,"../Models/addUserCatalogMember":50,"../Models/createCatalogItemFromFileOrUrl":51,"../Models/raiseErrorOnRejectedPromise":54}],77:[function(require,module,exports){
'use strict';

/*global require*/


var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var svgMenu = require('../SvgPaths/svgMenu.js');
var svgCollapse = require('../SvgPaths/svgCollapse');

var createFragmentFromTemplate = require('../Core/createFragmentFromTemplate');

var html = "<div class=\"explorer-panel\" data-bind=\"css: { 'explorer-panel-collapsed': !isOpen }\">\n    <div class=\"explorer-panel-header\"> \n        <div class=\"explorer-panel-tab-area\" data-bind=\"foreach: tabs\">\n          <div class=\"explorer-panel-tab\"\n              data-bind=\"visible: isVisible,\n                         css: { 'explorer-panel-tab-active': isActive },\n                         click: activate\">\n            <div class=\"explorer-panel-tab-content\">\n              <div data-bind=\"text: name\"></div>\n              <div class=\"explorer-panel-tab-badge\" data-bind=\"text: badgeText, visible: typeof badgeText !== 'undefined', css: { 'explorer-panel-tab-badge-pop': badgeIsPopped }, event: { transitionend: unpopBadge }\"></div>\n            </div>\n          </div>\n        </div>\n        <div class=\"explorer-panel-collapse-button clickable\" data-bind=\"click: toggleOpen\">\n            <div class=\"explorer-panel-collapse-button-icon\" data-bind=\"cesiumSvgPath: { path: svgCollapse, width: 6, height: 9 }, css: { 'brand-bar-menu-icon-highlighted': isOpen }\"></div>\n        </div>\n    </div>\n    <div class=\"explorer-panel-body\" data-bind=\"isOpen, foreach: tabs, css: { 'explorer-panel-body-collapsed': !$root.isOpen }\">\n      <div class=\"explorer-panel-frame\" data-bind=\"css: { 'explorer-panel-frame-inactive-left': !isActive && $index() < $root.activeTabIndex, 'explorer-panel-frame-inactive-right': !isActive && $index() > $root.activeTabIndex }\">\n        <div class=\"explorer-panel-body-pane\" data-bind=\"embeddedComponent: $data\">\n        </div>\n      </div>\n    </div>\n</div>\n";

var ExplorerPanelViewModel = function(options) {
    this.isOpen = true;
    this.tabs = [];
    this.activeTabIndex = 0;

    knockout.track(this, ['isOpen', 'tabs', 'activeTabIndex']);

    this.svgClose = 'M 6.937799,8.0450206 1.6369862,13.186666 C 1.3832705,13.432763 0.97809202,13.426587 0.73199467,13.172871 0.48589732,12.919156 0.4920732,12.513977 0.74578889,12.26788 L 6.0185862,7.1534091 0.74578889,2.0389383 C 0.4920732,1.792841 0.48589732,1.3876625 0.73199467,1.1339468 0.97809202,0.88023108 1.3832705,0.8740552 1.6369862,1.1201525 l 5.3008128,5.141645 5.300813,-5.141645 c 0.253716,-0.2460973 0.658894,-0.23992142 0.904991,0.013794 0.246098,0.2537157 0.239922,0.6588942 -0.01379,0.9049915 L 7.8570118,7.1534091 13.129809,12.26788 c 0.253716,0.246097 0.259892,0.651276 0.01379,0.904991 -0.246097,0.253716 -0.651275,0.259892 -0.904991,0.0138 L 6.937799,8.0450206 z';
    this.svgMenu = svgMenu;
    this.svgCollapse = svgCollapse;
};

/**
 * Shows this panel by adding it to the DOM inside a given container element.
 * @param {DOMNode} container The DOM node to which to add this panel.
 */
ExplorerPanelViewModel.prototype.show = function(container) {
    var fragment = createFragmentFromTemplate(html);
    var element = fragment.childNodes[0];
    container.appendChild(element);

    knockout.applyBindings(this, element);
};

ExplorerPanelViewModel.prototype.addTab = function(tabViewModel) {
    this.tabs.push(tabViewModel);

    tabViewModel.panel = this;

    if (this.tabs.length === 1) {
        this.activateTab(tabViewModel);
    }

    return tabViewModel;
};

ExplorerPanelViewModel.prototype.activateTab = function(tab) {
    for (var i = 0; i < this.tabs.length; ++i) {
        this.tabs[i].isActive = false;
    }

    tab.isActive = true;

    this.isOpen = true;

    this.activeTabIndex = this.tabs.indexOf(tab);
};

ExplorerPanelViewModel.prototype.toggleOpen = function() {
    this.isOpen = !this.isOpen;
};

module.exports = ExplorerPanelViewModel;
},{"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/createFragmentFromTemplate":6,"../SvgPaths/svgCollapse":61,"../SvgPaths/svgMenu.js":63}],78:[function(require,module,exports){
'use strict';

/*global require*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var ExplorerTabViewModel = function(name) {
    this.panel = undefined;

    this.name = defaultValue(name, 'Unknown');
    this.badgeText = undefined;
    this.badgeIsPopped = false;
    this.isVisible = true;
    this.isActive = false;

    this._popTimeoutID = undefined;

    knockout.track(this, ['name', 'badgeText', 'badgeIsPopped', 'isVisible', 'isActive']);
};

ExplorerTabViewModel.prototype.activate = function() {
    if (!defined(this.panel)) {
        throw new DeveloperError('This tab must be added to the explorer panel before it can be activated.');
    }

    this.panel.activateTab(this);
};

ExplorerTabViewModel.prototype.popBadge = function() {
    // Reset the popped state.  It might still be true if the pop was previously aborted.
    this.badgeIsPopped = false;

    // Delay the pop slightly, in case the badge just appeared.
    if (!defined(this._popTimeoutID)) {
        var that = this;
        this._popTimeoutID = setTimeout(function() {
            that._popTimeoutID = undefined;
            that.badgeIsPopped = true;
        }, 50);
    }
};

ExplorerTabViewModel.prototype.unpopBadge = function() {
    if (defined(this._popTimeoutID)) {
        clearTimeout(this._popTimeoutID);
        this._popTimeoutID = undefined;
    }
    this.badgeIsPopped = false;
};

module.exports = ExplorerTabViewModel;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591}],79:[function(require,module,exports){
'use strict';

/*global require,ga*/
var corsProxy = require('../Core/corsProxy');
var inherit = require('../Core/inherit');
var SearchProviderViewModel = require('./SearchProviderViewModel');
var SearchResultViewModel = require('./SearchResultViewModel');

var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var Ellipsoid = require('../../third_party/cesium/Source/Core/Ellipsoid');
var loadJson = require('../../third_party/cesium/Source/Core/loadJson');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');

var GazetteerSearchProviderViewModel = function(options) {
    SearchProviderViewModel.call(this);

    options = defaultValue(options, defaultValue.EMPTY_OBJECT);

    this.application = options.application;
    this._geocodeInProgress = undefined;

    this.name = 'Official Place Names';
    this.url = defaultValue(options.url, 'http://www.ga.gov.au/gazetteer-search/gazetteer2012/select/');
    this.forceUseOfProxy = defaultValue(options.forceUseOfProxy, true);
    this.flightDurationSeconds = defaultValue(options.flightDurationSeconds, 1.5);
};

inherit(SearchProviderViewModel, GazetteerSearchProviderViewModel);

GazetteerSearchProviderViewModel.prototype.search = function(searchText) {
    if (!defined(searchText) || /^\s*$/.test(searchText)) {
        this.isSearching = false;
        this.searchResults.removeAll();
        return;
    }

    this.isSearching = true;
    this.searchResults.removeAll();
    this.searchMessage = undefined;

    ga('send', 'event', 'search', 'gazetteer', searchText);

    // If there is already a search in progress, cancel it.
    if (defined(this._geocodeInProgress)) {
        this._geocodeInProgress.cancel = true;
        this._geocodeInProgress = undefined;
    }

    var longitudeDegrees;
    var latitudeDegrees;

    if (defined(this.application.cesium)) {
        var scene = this.application.cesium.scene;
        var cameraPosition = scene.camera.positionWC;
        var cameraPositionCartographic = Ellipsoid.WGS84.cartesianToCartographic(cameraPosition);
        longitudeDegrees = CesiumMath.toDegrees(cameraPositionCartographic.longitude);
        latitudeDegrees = CesiumMath.toDegrees(cameraPositionCartographic.latitude);
    } else if (defined(this.application.leaflet)) {
        var center = this.application.leaflet.map.getCenter();
        longitudeDegrees = center.lng;
        latitudeDegrees = center.lat;
    }

    var url = this.url + '?q=name:*' + searchText + '*';

    if (this.forceUseOfProxy || corsProxy.shouldUseProxy(url)) {
        url = corsProxy.getURL(url);
    }

    var promise = loadJson(url);

    var that = this;
    var geocodeInProgress = this._geocodeInProgress = promise.then(function(solarQueryResponse) {
        if (geocodeInProgress.cancel) {
            return;
        }
        that.isSearching = false;

        if (defined(solarQueryResponse.response) && solarQueryResponse.response.numFound > 0) {
            solarQueryResponse.response.docs.forEach(function(result) {
                that.searchResults.push(new SearchResultViewModel({
                    name: result.name,
                    isImportant: true,
                    clickAction: createZoomToFunction(that, result)
                }));
            });
        } else {
            that.searchMessage = 'Sorry, no official place names match your search query';
        }

        that.isSearching = false;
    }).otherwise(function() {
        if (geocodeInProgress.cancel) {
            return;
        }

        that.isSearching = false;
        that.searchMessage = 'An error occurred while searching.  Please check your internet connection or try again later.';
    });
};

function createZoomToFunction(viewModel, resource) {
    // Server does not return information of a bounding box, just a location.
    // bboxSize is used to expand a point
    var bboxSize = 0.2;
    var locLat = resource.location.split(',')[0];
    var locLng = resource.location.split(',')[1];
    var south = parseFloat(locLat) + bboxSize / 2;
    var west = parseFloat(locLng) - bboxSize / 2;
    var north = parseFloat(locLat) - bboxSize / 2;
    var east = parseFloat(locLng) + bboxSize / 2;
    var rectangle = Rectangle.fromDegrees(west, south, east, north);

    return function() {
        var application = viewModel.application;
        application.currentViewer.zoomTo(rectangle, viewModel.flightDurationSeconds);
    };
}

module.exports = GazetteerSearchProviderViewModel;

},{"../../third_party/cesium/Source/Core/Ellipsoid":130,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/loadJson":261,"../Core/corsProxy":5,"../Core/inherit":7,"./SearchProviderViewModel":86,"./SearchResultViewModel":87}],80:[function(require,module,exports){
'use strict';

/*global require*/
var Cartesian2 = require('../../third_party/cesium/Source/Core/Cartesian2');
var Cartographic = require('../../third_party/cesium/Source/Core/Cartographic');
var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var CesiumTerrainProvider = require('../../third_party/cesium/Source/Core/CesiumTerrainProvider');
var defined = require('../../third_party/cesium/Source/Core/defined');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var Intersections2D = require('../../third_party/cesium/Source/Core/Intersections2D');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var loadView = require('../Core/loadView');

var LocationBarViewModel = function(application, mapElement) {
    if (!defined(application)) {
        throw new DeveloperError('application is required.');
    }
    if (!defined(mapElement)) {
        throw new DeveloperError('mapElement is required.');
    }

    this.application = application;
    this.mapElement = mapElement;

    this.latitude = '43.199S';
    this.longitude = '154.461E';
    this.elevation = '28m';

    knockout.track(this, ['latitude', 'longitude', 'elevation']);

    var that = this;
    mapElement.addEventListener('mousemove', function(e) {
        var rect = mapElement.getBoundingClientRect();
        var position = new Cartesian2(e.clientX - rect.left, e.clientY - rect.top);

        if (defined(application.cesium)) {
            updateCoordinatesFromCesium(that, position);
        } else if (defined(application.leaflet)) {
            updateCoordinatesFromLeaflet(that, position);
        }
    }, false);
};

LocationBarViewModel.prototype.show = function(container) {
    loadView("<div class=\"location-bar\" data-bind=\"visible: latitude && longitude\">\n    <div class=\"location-bar-label\">LAT</div>\n    <div class=\"location-bar-value\" data-bind=\"text: latitude\"></div>\n    <div class=\"location-bar-label\">LON</div>\n    <div class=\"location-bar-value\" data-bind=\"text: longitude\"></div>\n\n    <!-- ko if: elevation -->\n    <div class=\"location-bar-label\">ELEV</div>\n    <div class=\"location-bar-value\" data-bind=\"text: elevation\"></div>\n    <!-- /ko -->\n</div>\n", container, this);
};

function updateCoordinatesFromCesium(viewModel, position) {
    var scene = viewModel.application.cesium.scene;

    var camera = scene.camera;
    var pickRay = camera.getPickRay(position);

    var globe = scene.globe;
    var pickedTriangle = globe.pickTriangle(pickRay, scene);
    if (defined(pickedTriangle)) {
        // Get a fast, accurate-ish height every time the mouse moves.
        var ellipsoid = globe.ellipsoid;
        
        var v0 = ellipsoid.cartesianToCartographic(pickedTriangle.v0);
        var v1 = ellipsoid.cartesianToCartographic(pickedTriangle.v1);
        var v2 = ellipsoid.cartesianToCartographic(pickedTriangle.v2);
        var intersection = ellipsoid.cartesianToCartographic(pickedTriangle.intersection);

        var barycentric = Intersections2D.computeBarycentricCoordinates(
            intersection.longitude, intersection.latitude,
            v0.longitude, v0.latitude,
            v1.longitude, v1.latitude,
            v2.longitude, v2.latitude);

        if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {
            var height = barycentric.x * v0.height +
                         barycentric.y * v1.height +
                         barycentric.z * v2.height;
            intersection.height = height;
        }

        var errorBar = globe.terrainProvider.getLevelMaximumGeometricError(pickedTriangle.tile.level);
        var approximateHeight = intersection.height;
        var minHeight = pickedTriangle.tile.data.minimumHeight;
        var maxHeight = pickedTriangle.tile.data.maximumHeight;
        var maxDiff = Math.max(approximateHeight - minHeight, maxHeight - approximateHeight);
        errorBar = Math.min(errorBar, maxDiff);

        cartographicToFields(viewModel, intersection, errorBar);

        debounceSampleAccurateHeight(viewModel, globe, intersection);
    } else {
        viewModel.latitude = undefined;
        viewModel.longitude = undefined;
        viewModel.elevation = undefined;
    }
}

function updateCoordinatesFromLeaflet(viewModel, position) {
    // TODO: correctly calculate these for Leaflet.
    viewModel.latitude = undefined;
    viewModel.longitude = undefined;
    viewModel.elevation = undefined;
}

function cartographicToFields(viewModel, coordinates, errorBar) {
    viewModel.latitude = Math.abs(CesiumMath.toDegrees(coordinates.latitude)).toFixed(3) + '' + (coordinates.latitude < 0.0 ? 'S' : 'N');
    viewModel.longitude = Math.abs(CesiumMath.toDegrees(coordinates.longitude)).toFixed(3) + '' + (coordinates.longitude < 0.0 ? 'W' : 'E');
    viewModel.elevation = Math.round(coordinates.height) + (defined(errorBar) ? '' + Math.round(errorBar) : '') + 'm';
}

var lastHeightSamplePosition = new Cartographic();
var accurateHeightTimer;
var tileRequestInFlight;
var accurateSamplingDebounceTime = 250;

function debounceSampleAccurateHeight(viewModel, globe, position) {
    // After a delay with no mouse movement, get a more accurate height.
    Cartographic.clone(position, lastHeightSamplePosition);

    var terrainProvider = globe.terrainProvider;
    if (terrainProvider instanceof CesiumTerrainProvider) {
        clearTimeout(accurateHeightTimer);
        accurateHeightTimer = setTimeout(function() {
            sampleAccurateHeight(viewModel, terrainProvider, position);
        }, accurateSamplingDebounceTime);
    }
}

function sampleAccurateHeight(viewModel, terrainProvider, position) {
    accurateHeightTimer = undefined;
    if (tileRequestInFlight) {
        // A tile request is already in flight, so reschedule for later.
        accurateHeightTimer = setTimeout(function() {
            sampleAccurateHeight(viewModel, terrainProvider, position);
        }, accurateSamplingDebounceTime);
        return;
    }

    // Find the most detailed available tile at the last mouse position.
    var tilingScheme = terrainProvider.tilingScheme;
    var tiles = terrainProvider._availableTiles;
    var foundTileID;
    var foundLevel;

    for (var level = tiles.length - 1; !foundTileID && level >= 0; --level) {
        var levelTiles = tiles[level];
        var tileID = tilingScheme.positionToTileXY(position, level);
        var yTiles = tilingScheme.getNumberOfYTilesAtLevel(level);
        var tmsY = yTiles - tileID.y - 1;

        // Is this tile ID available from the terrain provider?
        for (var i = 0, len = levelTiles.length; !foundTileID && i < len; ++i) {
            var range = levelTiles[i];
            if (tileID.x >= range.startX && tileID.x <= range.endX && tmsY >= range.startY && tmsY <= range.endY) {
                foundLevel = level;
                foundTileID = tileID;
            }
        }
    }

    if (foundTileID) {
        // This tile has our most accurate available height, so go get it.
        tileRequestInFlight = when(terrainProvider.requestTileGeometry(foundTileID.x, foundTileID.y, foundLevel, false), function(terrainData) {
            tileRequestInFlight = undefined;
            if (Cartographic.equals(position, lastHeightSamplePosition)) {
                position.height = terrainData.interpolateHeight(tilingScheme.tileXYToRectangle(foundTileID.x, foundTileID.y, foundLevel), position.longitude, position.latitude);
                cartographicToFields(viewModel, position);
            } else {
                // Mouse moved since we started this request, so the result isn't useful.  Try again next time.
            }
        }, function() {
            tileRequestInFlight = undefined;
        });
    }
}

module.exports = LocationBarViewModel;

},{"../../third_party/cesium/Source/Core/Cartesian2":101,"../../third_party/cesium/Source/Core/Cartographic":104,"../../third_party/cesium/Source/Core/CesiumTerrainProvider":105,"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/Intersections2D":165,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../Core/loadView":8}],81:[function(require,module,exports){
'use strict';

/*global require*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var MenuBarItemViewModel = function(options) {
    this.label = options.label;
    this.image = options.image;
    this.imageWidth = options.imageWidth;
    this.imageHeight = options.imageHeight;
    this.tooltip = options.tooltip;
    this.callback = options.callback;
    this.href = options.href;
    this.observableToToggle = options.observableToToggle;
    this.visible = defaultValue(options.visible, true);

    knockout.track(this, ['label', 'image', 'imageWidth', 'imageHeight', 'tooltip', 'href', 'isToggle', 'observableToToggle', 'visible']);
};

MenuBarItemViewModel.prototype.execute = function() {
    if (defined(this.callback)) {
        this.callback(this);
    }

    if (defined(this.observableToToggle)) {
        this.observableToToggle = !this.observableToToggle;
    }
};

module.exports = MenuBarItemViewModel;

},{"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591}],82:[function(require,module,exports){
'use strict';

/*global require*/
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var loadView = require('../Core/loadView');

var MenuBarViewModel = function() {
    this.items = [];

    knockout.track(this, ['items']);
};

MenuBarViewModel.prototype.show = function(container) {
    loadView("<div class=\"menu-bar\" data-bind=\"foreach: items\">\n    <!-- ko if: href -->\n    <a class=\"menu-bar-item\" data-bind=\"attr: { href: href, title: tooltip }\" target=\"_blank\">\n        <!-- ko if: image -->\n        <img class=\"menu-bar-item-image\" data-bind=\"attr: { src: image, width: imageWidth, height: imageHeight }\" />\n        <!-- /ko -->\n        <!-- ko if: label -->\n        <div class=\"menu-bar-item-label\" data-bind=\"text: label\"></div>\n        <!-- /ko -->\n    </a>\n    <!-- /ko -->\n\n    <!-- ko if: !href -->\n    <div class=\"menu-bar-item\" data-bind=\"click: execute, attr: { title: tooltip }, css: { 'menu-bar-item-enabled': observableToToggle }\">\n        <!-- ko if: image -->\n        <img class=\"menu-bar-item-image\" data-bind=\"attr: { src: image, width: imageWidth, height: imageHeight }\" />\n        <!-- /ko -->\n        <!-- ko if: label -->\n        <div class=\"menu-bar-item-label\" data-bind=\"text: label\"></div>\n        <!-- /ko -->\n    </div>\n    <!-- /ko -->\n</div>\n", container, this);
};

module.exports = MenuBarViewModel;

},{"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/loadView":8}],83:[function(require,module,exports){
'use strict';

/*global require,ga*/
var Cartesian3 = require('../../third_party/cesium/Source/Core/Cartesian3');
var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var Ellipsoid = require('../../third_party/cesium/Source/Core/Ellipsoid');
var IntersectionTests = require('../../third_party/cesium/Source/Core/IntersectionTests');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');
var Matrix4 = require('../../third_party/cesium/Source/Core/Matrix4');
var Ray = require('../../third_party/cesium/Source/Core/Ray');
var Tween = require('../../third_party/cesium/Source/ThirdParty/Tween');

var loadView = require('../Core/loadView');
var rectangleToLatLngBounds = require('../Map/rectangleToLatLngBounds');

var svgZoomIn = require('../SvgPaths/svgZoomIn');
var svgZoomOut = require('../SvgPaths/svgZoomOut');
var svgReset = require('../SvgPaths/svgReset');
var svgTilt = require('../SvgPaths/svgTilt');

var NavigationViewModel = function(application) {
    this.application = application;

    this.svgZoomIn = svgZoomIn;
    this.svgZoomOut = svgZoomOut;
    this.svgReset = svgReset;
    this.svgTilt = svgTilt;

    this._tiltInProgress = false;
    this._nextTilt = undefined;

    this.showTilt = defined(this.application.cesium);
    this.currentTilt = 0;

    knockout.track(this, ['showTilt', 'currentTilt']);

    application.afterViewerChanged.addEventListener(function() {
        if (defined(this.application.cesium)) {
            this.showTilt = true;
        } else {
            this.showTilt = false;
        }
    }, this);
};

NavigationViewModel.prototype.show = function(container) {
    loadView("<div class=\"navigation-controls\">\n    <div class=\"navigation-control\" data-bind=\"click: zoomIn\" title=\"Zoom In\">\n        <div class=\"navigation-control-icon-zoom-in\" data-bind=\"cesiumSvgPath: { path: svgZoomIn, width: 22, height: 22 }\"></div>\n    </div>\n    <div class=\"navigation-control\" data-bind=\"click: resetView\" title=\"Reset View\">\n        <div class=\"navigation-control-icon-reset\" data-bind=\"cesiumSvgPath: { path: svgReset, width: 15, height: 15 }\"></div>\n    </div>\n    <div class=\"navigation-control\" data-bind=\"click: zoomOut, css: { 'navigation-control-last': !showTilt }\" title=\"Zoom Out\">\n        <div class=\"navigation-control-icon-zoom-out\" data-bind=\"cesiumSvgPath: { path: svgZoomOut, width: 22, height: 22 }\"></div>\n    </div>\n    <div class=\"navigation-control-last\" data-bind=\"click: tilt, visible: showTilt\" title=\"Change Tilt\">\n        <div class=\"navigation-control-icon-tilt\" data-bind=\"cesiumSvgPath: { path: svgTilt, width: 32, height: 32 }\"></div>\n    </div>\n</div>\n", container, this);
};

var cartesian3Scratch = new Cartesian3();

NavigationViewModel.prototype.zoomIn = function() {
    ga('send', 'event', 'navigation', 'click', 'zoomIn');

    if (defined(this.application.leaflet)) {
        this.application.leaflet.map.zoomIn(1);
    }

    if (defined(this.application.cesium)) {
        var scene = this.application.cesium.scene;
        var camera = scene.camera;
        var focus = getCameraFocus(scene);
        var direction = Cartesian3.subtract(focus, camera.position, cartesian3Scratch);
        var movementVector = Cartesian3.multiplyByScalar(direction, 2.0 / 3.0, cartesian3Scratch);
        var endPosition = Cartesian3.add(camera.position, movementVector, cartesian3Scratch);

        flyToPosition(scene, endPosition);
    }

    this.application.currentViewer.notifyRepaintRequired();
};

NavigationViewModel.prototype.zoomOut = function() {
    ga('send', 'event', 'navigation', 'click', 'zoomOut');

    if (defined(this.application.leaflet)) {
        this.application.leaflet.map.zoomOut(1);
    }

    if (defined(this.application.cesium)) {
        var scene = this.application.cesium.scene;
        var camera = scene.camera;
        var focus = getCameraFocus(scene);
        var direction = Cartesian3.subtract(focus, camera.position, cartesian3Scratch);
        var movementVector = Cartesian3.multiplyByScalar(direction, -2.0, cartesian3Scratch);
        var endPosition = Cartesian3.add(camera.position, movementVector, cartesian3Scratch);

        flyToPosition(scene, endPosition);
    }

    this.application.currentViewer.notifyRepaintRequired();
};

NavigationViewModel.prototype.resetView = function() {
    ga('send', 'event', 'navigation', 'click', 'reset');

    var bbox = this.application.initialBoundingBox;

    if (defined(this.application.leaflet)) {
        this.application.leaflet.map.fitBounds(rectangleToLatLngBounds(bbox));
    }

    if (defined(this.application.cesium)) {
        var scene = this.application.cesium.scene;
        var camera = scene.camera;
        camera.flyToRectangle({
            destination: bbox,
            duration: 1.5
        });
    }

    this.application.currentViewer.notifyRepaintRequired();
};

var tilts = [0, 40, 80];

NavigationViewModel.prototype.tilt = function() {
    ga('send', 'event', 'navigation', 'click', 'tilt');

    if (defined(this.application.cesium)) {
        var scene = this.application.cesium.scene;

        var currentTilt = this.currentTilt;
        var index;
        for (index = 0; index < tilts.length && tilts[index] <= currentTilt; ++index) {
        }

        if (index >= tilts.length) {
            index = 0;
        }

        this.currentTilt = tilts[index];
        animateToTilt(this, scene, this.currentTilt);
    }

    this.application.currentViewer.notifyRepaintRequired();
};

function getCameraFocus(scene) {
    var ray = new Ray(scene.camera.positionWC, scene.camera.directionWC);
    var intersections = IntersectionTests.rayEllipsoid(ray, Ellipsoid.WGS84);
    if (defined(intersections)) {
        return Ray.getPoint(ray, intersections.start);
    } else {
        // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
        // the focal point.
        return IntersectionTests.grazingAltitudeLocation(ray, Ellipsoid.WGS84);
    }
}

function flyToPosition(scene, position, durationMilliseconds) {
    var camera = scene.camera;
    var startPosition = camera.position;
    var endPosition = position;

    durationMilliseconds = defaultValue(durationMilliseconds, 200);

    var controller = scene.screenSpaceCameraController;
    controller.enableInputs = false;

    scene.tweens.add({
        duration : durationMilliseconds / 1000.0,
        easingFunction : Tween.Easing.Sinusoidal.InOut,
        startObject : {
            time: 0.0
        },
        stopObject : {
            time : 1.0
        },
        update : function(value) {
            if (scene.isDestroyed()) {
                return;
            }
            scene.camera.position.x = CesiumMath.lerp(startPosition.x, endPosition.x, value.time);
            scene.camera.position.y = CesiumMath.lerp(startPosition.y, endPosition.y, value.time);
            scene.camera.position.z = CesiumMath.lerp(startPosition.z, endPosition.z, value.time);
        },
        complete : function() {
            if (controller.isDestroyed()) {
                return;
            }
            controller.enableInputs = true;
        },
        cancel: function() {
            if (controller.isDestroyed()) {
                return;
            }
            controller.enableInputs = true;
        }
    });
}

function animateToTilt(viewModel, scene, targetTiltDegrees, durationMilliseconds) {
    if (viewModel._tiltInProgress) {
        viewModel._nextTilt = targetTiltDegrees;
        return;
    }

    durationMilliseconds = defaultValue(durationMilliseconds, 500);

    // Get focus and camera position
    var focus = getCameraFocus(scene);
    if (!defined(focus)) {
        return;
    }

    var campos = Cartesian3.subtract(scene.camera.position, focus, cartesian3Scratch);

    // Get tilt
    var startTilt = Cartesian3.angleBetween(campos, focus);
    var endTilt = CesiumMath.toRadians(targetTiltDegrees);
    var curTilt = 0;

    // Translate camera reference to focus
    var trans = Matrix4.fromTranslation(focus);
    var oldTrans = scene.camera.transform;
    scene.camera.transform = trans;

    Cartesian3.clone(campos, scene.camera.position);

    // Translate camera in reference to current pos
    var controller = scene.screenSpaceCameraController;
    controller.enableInputs = false;

    viewModel._tiltInProgress = true;

    scene.tweens.add({
        duration : durationMilliseconds / 1000.0,
        easingFunction : Tween.Easing.Sinusoidal.InOut,
        startObject : {
            time: 0.0
        },
        stopObject : {
            time : 1.0
        },
        update : function(value) {
            if (scene.isDestroyed()) {
                return;
            }
            var amount = CesiumMath.lerp(startTilt, endTilt, value.time) - (startTilt + curTilt);
            scene.camera.rotate(scene.camera.right, -amount);
            curTilt += amount;
       },
        complete : function() {
            if (controller.isDestroyed()) {
                return;
            }
            controller.enableInputs = true;
            scene.camera.position = Cartesian3.add(scene.camera.position, focus, scene.camera.position);
            scene.camera.transform = oldTrans;
            viewModel._tiltInProgress = false;

            if (defined(viewModel._nextTilt)) {
                var nextTilt = viewModel._nextTilt;
                viewModel._nextTilt = undefined;
                animateToTilt(viewModel, scene, nextTilt, durationMilliseconds);
            }
        },
        cancel: function() {
            if (controller.isDestroyed()) {
                return;
            }
            controller.enableInputs = true;
            scene.camera.position = Cartesian3.add(scene.camera.position, focus, scene.camera.position);
            scene.camera.transform = oldTrans;
            viewModel._tiltInProgress = false;
        }
    });
}

module.exports = NavigationViewModel;

},{"../../third_party/cesium/Source/Core/Cartesian3":102,"../../third_party/cesium/Source/Core/Ellipsoid":130,"../../third_party/cesium/Source/Core/IntersectionTests":164,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/Matrix4":177,"../../third_party/cesium/Source/Core/Ray":200,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/Tween":586,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/loadView":8,"../Map/rectangleToLatLngBounds":20,"../SvgPaths/svgReset":64,"../SvgPaths/svgTilt":65,"../SvgPaths/svgZoomIn":66,"../SvgPaths/svgZoomOut":67}],84:[function(require,module,exports){
'use strict';

/*global require,ga*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var CatalogItemInfoViewModel = require('./CatalogItemInfoViewModel');
var ExplorerTabViewModel = require('./ExplorerTabViewModel');
var inherit = require('../Core/inherit');
var loadView = require('../Core/loadView');

var svgCheckboxChecked = require('../SvgPaths/svgCheckboxChecked');
var svgCheckboxUnchecked = require('../SvgPaths/svgCheckboxUnchecked');
var svgArrowDown = require('../SvgPaths/svgArrowDown');
var svgArrowRight = require('../SvgPaths/svgArrowRight');
var svgInfo = require('../SvgPaths/svgInfo');

var NowViewingTabViewModel = function(options) {
    ExplorerTabViewModel.call(this);

    this.name = 'Now Viewing';
    this.nowViewing = options.nowViewing;
    this.badgeText = this.nowViewing.items.length === 0 ? undefined : this.nowViewing.items.length;

    this.svgCheckboxChecked = defaultValue(options.svgCheckboxChecked, svgCheckboxChecked);
    this.svgCheckboxUnchecked = defaultValue(options.svgCheckboxUnchecked, svgCheckboxUnchecked);
    this.svgArrowDown = defaultValue(options.svgArrowDown, svgArrowDown);
    this.svgArrowRight = defaultValue(options.svgArrowRight, svgArrowRight);
    this.svgInfo = defaultValue(options.svgInfo, svgInfo);

    this._draggedItem = undefined;
    this._itemDropped = false;
    this._dragPlaceholder = undefined;

    this._lastNumberOfItems = -1;

    var that = this;
    knockout.getObservable(this, 'isActive').subscribe(function(newValue) {
        // Make sure that at least one item is showing its legend when this tab is activated.
        if (newValue) {
            var nowViewingItems = that.nowViewing.items;

            var oneIsOpen = false;
            for (var i = 0; !oneIsOpen && i < nowViewingItems.length; ++i) {
                oneIsOpen = nowViewingItems[i].isLegendVisible;
            }

            if (!oneIsOpen && nowViewingItems.length > 0) {
                nowViewingItems[0].isLegendVisible = true;
            }
        }
    });

    knockout.getObservable(this.nowViewing, 'items').subscribe(function() {
        this.badgeText = this.nowViewing.items.length === 0 ? undefined : this.nowViewing.items.length;

        if (this.nowViewing.items.length > this._lastNumberOfItems) {
            this.popBadge();
        }

        this._lastNumberOfItems = this.nowViewing.items.length;
    }, this);
};

inherit(ExplorerTabViewModel, NowViewingTabViewModel);

NowViewingTabViewModel.prototype.show = function(container) {
    loadView("<div class=\"now-viewing\">\n    <div class=\"now-viewing-toolbar\">\n        <span class=\"now-viewing-clear-all clickable\" data-bind=\"click: nowViewing.removeAll.bind(nowViewing)\">Remove All</span>\n    </div>\n\n    <div class=\"now-viewing-list\" data-bind=\"foreach: nowViewing.items\">\n        <div class=\"now-viewing-item\" data-bind=\"attr: { nowViewingIndex: $index }, event : { dragenter: $root.dragEnter.bind($root), dragover: $root.dragEnter.bind($root) }\">\n            <div class=\"now-viewing-item-top-row\" data-bind=\"attr: { draggable: supportsReordering, nowViewingIndex: $index }, event : { dragstart: $root.dragStart.bind($root), dragend: $root.dragEnd.bind($root), selectstart: $root.selectStart.bind($root) }\">\n                <div class=\"now-viewing-item-drag-handle-holder\">\n                    <img class=\"now-viewing-item-drag-handle\" data-bind=\"visible: supportsReordering\" draggable=\"false\" src=\"images/Reorder.svg\" width=\"12\" height=\"24\" alt=\"Drag to reorder data sources.\" title=\"Drag to reorder data sources.\" />\n                </div>\n                <div class=\"now-viewing-item-icon-holder\">\n                    <div class=\"now-viewing-item-icon clickable\" data-bind=\"click: toggleShown, cesiumSvgPath: { path: isShown ? $root.svgCheckboxChecked : $root.svgCheckboxUnchecked, width: 32, height: 32 }, css: { 'now-viewing-shown-item': isShown }\"></div>\n                </div>\n                <div class=\"now-viewing-item-label clickable\" data-bind=\"text: name, click: toggleLegendVisible, css { 'now-viewing-shown-item': isShown }\"></div>\n\n                <div class=\"now-viewing-item-arrow-holder\">\n                    <div class=\"now-viewing-item-arrow\" data-bind=\"click: toggleLegendVisible, cesiumSvgPath: { path: isLegendVisible ? $root.svgArrowDown : $root.svgArrowRight, width: 32, height: 32 }\"></div>\n                </div>\n            </div>\n            <div class=\"now-viewing-item-details\" data-bind=\"visible: isLegendVisible\">\n                <div class=\"now-viewing-action-menu\">\n                    <div class=\"now-viewing-action clickable\" data-bind=\"click: zoomToAndUseClock\" title=\"Change the map view to show the full extent of this data item.\">Zoom To</div>\n                    <div class=\"now-viewing-action clickable\" data-bind=\"click: $root.showInfo.bind($root)\" title=\"Display information about this data item.\">Info</div>\n                    <div class=\"now-viewing-action clickable\" data-bind=\"click: toggleEnabled\" title=\"Remove this data item from the Now Viewing panel and from the map.\">Remove</div>\n                </div>\n\n                <div class=\"now-viewing-item-opacity\" data-bind=\"if: supportsOpacity\">\n                    OPACITY: <span data-bind=\"text: Math.round(opacity * 100) + '%'\"></span>\n                    <input class=\"now-viewing-opacity-slider\" type=\"range\" min=\"0\" max=\"1\" step=\"0.01\" data-bind=\"value: opacity, valueUpdate: 'input'\" />\n                </div>\n\n                <!-- ko if: legendIsImage -->\n                <a data-bind=\"attr: { href: legendUrl }\" target=\"_blank\">\n                    <img class=\"now-viewing-legend-image\" data-bind=\"attr: { src: legendUrl }\" />\n                </a>\n                <!-- /ko -->\n                <!-- ko if: hasLegend && !legendIsImage -->\n                <a class=\"now-viewing-legend-text\" data-bind=\"attr: { href: legendUrl }\" target=\"_blank\">Open legend in a separate tab</a>\n                <!-- /ko -->\n                <!-- ko if: !hasLegend -->\n                <div class=\"now-viewing-legend-text\">No legend available for this data item.</div>\n                <!-- /ko -->\n            </div>\n        </div>\n    </div>\n\n    <div class=\"now-viewing-list\" data-bind=\"visible: nowViewing.items.length === 0\">\n        <div class=\"now-viewing-no-items\">\n            Add data using the Data Catalogue tab.\n        </div>\n    </div>\n</div>\n\n", container, this);
};

NowViewingTabViewModel.prototype.showInfo = function(item) {
    ga('send', 'event', 'dataSource', 'info', item.name);
    CatalogItemInfoViewModel.open('ui', item);
};

NowViewingTabViewModel.prototype.dragStart = function(viewModel, e) {
    ga('send', 'event', 'dataSource', 'reorder', viewModel.name);

    // The user drags .now-viewing-item-top-row, but really we want to drag the entire .now-viewing-item, its parent.
    if (!e.target || !e.target.parentElement) {
        return;
    }
    
    this._draggedItem = e.target.parentElement;
    this._itemDropped = false;

    // If the item's legend is open, close it before starting the drag.
    viewModel.isLegendVisible = false;

    this._dragPlaceholder = document.createElement('div');
    this._dragPlaceholder.className = 'now-viewing-drop-target';
    this._dragPlaceholder.style.height = this._draggedItem.clientHeight + 'px';

    var that = this;
    this._dragPlaceholder.addEventListener('drop', function(e) {
        that._itemDropped = true;
        e.preventDefault();
    }, false);

    this._dragPlaceholder.addEventListener('dragenter', function(e) {
        e.preventDefault();
    }, false);

    this._dragPlaceholder.addEventListener('dragover', function(e) {
        e.preventDefault();
    }, false);

    e.originalEvent.dataTransfer.setData('text', 'Dragging a Now Viewing item.');

    return true;
};

NowViewingTabViewModel.prototype.dragEnd = function(viewModel, e) {
    if (this._itemDropped) {
        var draggedItemIndex = this._draggedItem.getAttribute('nowViewingIndex') | 0;
        var placeholderIndex = this._dragPlaceholder.getAttribute('nowViewingIndex') | 0;

        if (placeholderIndex >= draggedItemIndex) {
            --placeholderIndex;
        }

        while (draggedItemIndex > placeholderIndex) {
            this.nowViewing.raise(viewModel);
            --draggedItemIndex;
        }
        while (draggedItemIndex < placeholderIndex) {
            this.nowViewing.lower(viewModel);
            ++draggedItemIndex;
        }

        // Reordering will trigger a badge pop because we remove/re-add items.
        // Cancel the pop.
        this.unpopBadge();
    }

    if (defined(this._draggedItem)) {
        this._draggedItem.style.display = 'block';
    }

    if (defined(this._dragPlaceholder)) {
        if (this._dragPlaceholder.parentElement) {
            this._dragPlaceholder.parentElement.removeChild(this._dragPlaceholder);
        }
        this._dragPlaceholder = undefined;
    }
};

NowViewingTabViewModel.prototype.dragEnter = function(viewModel, e) {
    if (!defined(this._draggedItem)) {
        return;
    }

    e.originalEvent.dataTransfer.dropEffect = 'move';

    this._draggedItem.style.display = 'none';

    // Add the placeholder above the entered element.
    // If the placeholder is already above the entered element, move it below.
    // TODO: this logic is imperfect, but good enough for now.
    var placeholderIndex;
    var targetIndex;

    var parent = e.currentTarget.parentElement;
    var siblings = parent.childNodes;
    for (var i = 0; i < siblings.length; ++i) {
        if (siblings[i] === this._dragPlaceholder) {
            placeholderIndex = i;
        }
        if (siblings[i] === e.currentTarget) {
            targetIndex = i;
        }
    }

    var insertBefore = true;
    if (placeholderIndex === targetIndex - 1) {
        var placeholderRect = this._dragPlaceholder.getBoundingClientRect();
        var placeholderHeight = placeholderRect.bottom - placeholderRect.top;

        var targetRect = e.currentTarget.getBoundingClientRect();
        var currentY = e.originalEvent.clientY;

        if (currentY > targetRect.bottom - placeholderHeight) {
            insertBefore = false;
        }
    }

    var doInsert = false;
    var nodeToInsertBefore;
    if (insertBefore && placeholderIndex !== targetIndex - 1) {
        nodeToInsertBefore = e.currentTarget;
        this._dragPlaceholder.setAttribute('nowViewingIndex', nodeToInsertBefore.getAttribute('nowViewingIndex'));
        doInsert = true;
    } else if (!insertBefore && placeholderIndex !== targetIndex + 1) {
        nodeToInsertBefore = siblings[targetIndex + 1];

        // IE doesn't like to insert before undefined, but null is fine.
        if (!nodeToInsertBefore || !defined(nodeToInsertBefore.getAttribute)) {
            nodeToInsertBefore = null;
            this._dragPlaceholder.setAttribute('nowViewingIndex', this.nowViewing.items.length);
        } else {
            this._dragPlaceholder.setAttribute('nowViewingIndex', nodeToInsertBefore.getAttribute('nowViewingIndex'));
        }
        doInsert = true;
    }

    if (doInsert) {
        if (this._dragPlaceholder.parentElement) {
            this._dragPlaceholder.parentElement.removeChild(this._dragPlaceholder);
        }

        e.currentTarget.parentElement.insertBefore(this._dragPlaceholder, nodeToInsertBefore);
    }

    e.originalEvent.preventDefault();
};

NowViewingTabViewModel.prototype.selectStart = function(viewModel, e) {
    // This function works around problems in IE9 where block divs are not draggable even when draggable="true".
    if (!viewModel.supportsReordering || !e || !e.currentTarget || !e.currentTarget.dragDrop) {
        return;
    }

    e.currentTarget.dragDrop();
    return false;
};

module.exports = NowViewingTabViewModel;

},{"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"../Core/loadView":8,"../SvgPaths/svgArrowDown":57,"../SvgPaths/svgArrowRight":58,"../SvgPaths/svgCheckboxChecked":59,"../SvgPaths/svgCheckboxUnchecked":60,"../SvgPaths/svgInfo":62,"./CatalogItemInfoViewModel":72,"./ExplorerTabViewModel":78}],85:[function(require,module,exports){
'use strict';

/*global require*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var loadView = require('../Core/loadView');

var PopupMessageViewModel = function(options) {
    this._domNodes = undefined;

    this.title = defaultValue(options.title, 'Information');
    this.message = options.message;

    // On really old browsers (IE8 for example), knockout.track will throw because
    // the browser doesn't support ES5 properties.  If that happens, we just continue
    // as if nothing happened so that we can still show the message.
    try {
        knockout.track(this, ['title', 'message']);
    } catch (e) {
    }
};

PopupMessageViewModel.prototype.show = function(container) {
    this._domNodes = loadView("<div class=\"modal-background\" data-bind=\"click: closeIfClickOnBackground\">\n    <div class=\"popup-message\">\n        <div class=\"popup-message-header\">\n            <div class=\"popup-message-close-button\" data-bind=\"click: close\">&times;</div>\n            <h1 data-bind=\"text: title\"></h1>\n        </div>\n        <div class=\"popup-message-content\">\n            <div class=\"popup-message-label\" data-bind=\"html: message\"></div>\n        </div>\n    </div>\n</div>\n", container, this);
};

PopupMessageViewModel.prototype.close = function() {
    for (var i = 0; i < this._domNodes.length; ++i) {
        var node = this._domNodes[i];
        if (defined(node.parentElement)) {
            node.parentElement.removeChild(node);
        }
    }
};

PopupMessageViewModel.prototype.closeIfClickOnBackground = function(viewModel, e) {
    if (e.target.className === 'modal-background') {
        this.close();
    }
    return true;
};

PopupMessageViewModel.open = function(container, options) {
    var viewModel = new PopupMessageViewModel(options);
    viewModel.show(container);
    return viewModel;
};

module.exports = PopupMessageViewModel;

},{"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/loadView":8}],86:[function(require,module,exports){
'use strict';

/*global require*/
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var SearchProviderViewModel = function() {
    this.name = 'Unknown';
    this.isOpen = true;
    this.searchResults = [];
    this.searchMessage = undefined;
    this.isSearching = false;

    knockout.track(this, ['name', 'isOpen', 'searchResults', 'searchMessage', 'isSearching']);
};

SearchProviderViewModel.prototype.toggleOpen = function() {
    this.isOpen = !this.isOpen;
};

SearchProviderViewModel.prototype.search = function(searchText) {
    throw new DeveloperError('search must be implemented in the derived class.');
};

module.exports = SearchProviderViewModel;

},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/ThirdParty/knockout":591}],87:[function(require,module,exports){
'use strict';

/*global require*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var raiseErrorOnRejectedPromise = require('../Models/raiseErrorOnRejectedPromise');

var SearchResultViewModel = function(options) {
    this.name = defaultValue(options.name, 'Unknown');
    this.tooltip = options.tooltip;
    this.isImportant = defaultValue(options.isImportant, false);
    this.clickAction = options.clickAction;
    this.catalogItem = options.catalogItem;
    this.isOpen = false;

    knockout.track(this, ['name', 'tooltip', 'isImportant', 'clickAction', 'catalogItem', 'isOpen']);
};

SearchResultViewModel.prototype.toggleOpen = function() {
    if (!defined(this.catalogItem)) {
        return;
    }

    this.isOpen = !this.isOpen;

    // Load this group's items (if we haven't already) when it is opened.
    if (this.isOpen) {
        raiseErrorOnRejectedPromise(this.catalogItem.application, this.catalogItem.load());
    }

};

module.exports = SearchResultViewModel;

},{"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Models/raiseErrorOnRejectedPromise":54}],88:[function(require,module,exports){
'use strict';

/*global require,ga*/
var defined = require('../../third_party/cesium/Source/Core/defined');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var CatalogItemInfoViewModel = require('./CatalogItemInfoViewModel');
var ExplorerTabViewModel = require('./ExplorerTabViewModel');
var inherit = require('../Core/inherit');
var loadView = require('../Core/loadView');

var svgArrowDown = require('../SvgPaths/svgArrowDown');
var svgArrowRight = require('../SvgPaths/svgArrowRight');
var svgCheckboxChecked = require('../SvgPaths/svgCheckboxChecked');
var svgCheckboxUnchecked = require('../SvgPaths/svgCheckboxUnchecked');
var svgInfo = require('../SvgPaths/svgInfo');

var SearchTabViewModel = function(application) {
    ExplorerTabViewModel.call(this);

    this.application = application;

    this.name = 'Search';
    this.searchText = '';
    this.searchProviders = [];

    knockout.track(this, ['name', 'searchText', 'searchProviders']);

    // Knockout's hasFocus binding doesn't work with a knockout-es5 property (as of v3.2.0).
    // So, just use a regular observable.
    this.searchBoxHasFocus = knockout.observable(false);

    this.svgArrowDown = svgArrowDown;
    this.svgArrowRight = svgArrowRight;
    this.svgCheckboxChecked = svgCheckboxChecked;
    this.svgCheckboxUnchecked = svgCheckboxUnchecked;
    this.svgInfo = svgInfo;

    var searchTextObservable = knockout.getObservable(this, 'searchText');

    searchTextObservable.extend({ rateLimit: 250 });

    searchTextObservable.subscribe(function() {
        this.search();
    }, this);

    // Focus the search box when the tab is activated.
    knockout.getObservable(this, 'isActive').subscribe(function(newValue) {
        if (newValue) {
            this.searchBoxHasFocus(true);
        }
    }, this);
};

inherit(ExplorerTabViewModel, SearchTabViewModel);

SearchTabViewModel.prototype.show = function(container) {
    loadView("<script type=\"text/html\" id=\"search-catalog-item-template\">\n    <!-- ko if: typeof items === 'undefined' -->\n        <div class=\"data-catalog-member\" data-bind=\"css: 'data-catalog-indent' + ($parents.length - 2)\">\n            <div class=\"data-catalog-member-top-row\">\n                <div class=\"data-catalog-icon-holder\">\n                    <div class=\"data-catalog-icon clickable\" data-bind=\"click: toggleEnabled, cesiumSvgPath: { path: isEnabled ? $root.svgCheckboxChecked : $root.svgCheckboxUnchecked, width: 32, height: 32 }, css: { 'data-catalog-enabled-item': isEnabled }\"></div>\n                </div>\n                <div class=\"data-catalog-item-label data-catalog-enabled-item clickable\" data-bind=\"visible: isEnabled, text: name, click: zoomToAndUseClock\"></div>\n                <div class=\"data-catalog-item-label\" data-bind=\"visible: !isEnabled, text: name\"></div>\n                <div class=\"data-catalog-item-info\">\n                    <div class=\"data-catalog-info-icon clickable\" data-bind=\"click: $root.showInfo.bind($root), cesiumSvgPath: { path: $root.svgInfo, width: 18, height: 18, 'fill-rule': 'evenodd' }\"></div>\n                </div>\n            </div>\n        </div>\n    <!-- /ko -->\n\n    <!-- ko if: typeof items !== 'undefined' -->\n        <div class=\"data-catalog-member\" data-bind=\"css: 'data-catalog-indent' + ($parents.length - 2)\">\n            <div class=\"data-catalog-member-top-row\">\n                <div class=\"data-catalog-icon-holder\">\n                    <div class=\"data-catalog-icon clickable\" data-bind=\"click: $parent.toggleOpen.bind($parent), cesiumSvgPath: { path: $parent.isOpen ? $root.svgArrowDown : $root.svgArrowRight, width: 32, height: 32 }, css: { 'data-catalog-opened-group': $parent.isOpen }\"></div>\n                </div>\n                <div class=\"data-catalog-group-label clickable\" data-bind=\"click: $parent.toggleOpen.bind($parent), text: name, css: { 'data-catalog-opened-group': $parent.isOpen }\"></div>\n            </div>\n\n            <!-- ko if: $parent.isOpen && (isLoading || items.length === 0) -->\n                <div class=\"data-catalog-group-contents\">\n                    <div class=\"data-catalog-member\" data-bind=\"css: 'data-catalog-indent' + ($parents.length - 1)\">\n                        <div class=\"data-catalog-item-label\" data-bind=\"if: isLoading\">Loading...</div>\n                        <div class=\"data-catalog-item-label\" data-bind=\"if: !isLoading\">This group does not contain any data items.</div>\n                    </div>\n                </div>\n            <!-- /ko -->\n\n            <!-- ko if: $parent.isOpen -->\n                <div class=\"data-catalog-group-contents\" data-bind=\"template: { name: 'data-catalog-item-template', foreach: items }\"></div>\n            <!-- /ko -->\n        </div>\n    <!-- /ko -->\n</script>\n\n<div class=\"search-tab\">\n    <form class=\"search-tab-form\" data-bind=\"submit: activateFirstResult\">\n        <input class=\"search-tab-input\" type=\"text\" data-bind=\"value: searchText, valueUpdate: 'input', hasFocus: searchBoxHasFocus\" />\n        <div class=\"search-tab-input-clear\" data-bind=\"visible: searchText.length > 0, click: clearSearchText\">&times;</div>\n    </form>\n    <div class=\"search-tab-results-area\" data-bind=\"visible: searchText, foreach: searchProviders\">\n        <div class=\"search-tab-provider\">\n            <div class=\"search-tab-provider-header\" data-bind=\"click: toggleOpen\">\n                <div class=\"search-tab-provider-label\" data-bind=\"text: name\"></div>\n                <div class=\"search-tab-provider-icon-holder\">\n                    <div class=\"search-tab-provider-icon\" data-bind=\"cesiumSvgPath: { path: isOpen ? $root.svgArrowDown : $root.svgArrowRight, width: 32, height: 32 }\"></div>\n                </div>\n            </div>\n            <div class=\"search-tab-provider-message\" data-bind=\"visible: isOpen && searchMessage, text: searchMessage\"></div>\n            <div class=\"search-tab-provider-results\" data-bind=\"visible: isOpen, foreach: searchResults\">\n                <!-- ko if: typeof catalogItem === 'undefined' -->\n                    <div class=\"search-tab-provider-result\" data-bind=\"css: { 'search-tab-provider-result-clickable': typeof clickAction !== 'undefined', 'search-tab-provider-result-important': isImportant }, click: clickAction\">\n                        <div class=\"search-tab-provider-result-top-row\">\n                            <div class=\"search-tab-provider-result-label\" data-bind=\"text: name\"></div>\n                        </div>\n                    </div>\n                <!-- /ko -->\n                <!-- ko if: typeof catalogItem !== 'undefined' -->\n                    <div class=\"search-tab-provider-result\" data-bind=\"template: { name: 'search-catalog-item-template', data: catalogItem }, attr: { title: tooltip }\">\n                    </div>\n                <!-- /ko -->\n            </div>\n            <div class=\"search-tab-provider-searching\" data-bind=\"visible: isOpen && isSearching\">Searching...</div>\n        </div>\n    </div>\n</div>\n", container, this);
};

SearchTabViewModel.prototype.search = function() {
    for (var i = 0; i < this.searchProviders.length; ++i) {
        this.searchProviders[i].search(this.searchText);
    }
};

SearchTabViewModel.prototype.activateFirstResult = function() {
    for (var i = 0; i < this.searchProviders.length; ++i) {
        var searchProvider = this.searchProviders[i];
        for (var j = 0; j < searchProvider.searchResults.length; ++j) {
            var searchResult = searchProvider.searchResults[j];
            if (defined(searchResult.clickAction)) {
                searchResult.clickAction();
                return;
            }
        }
    }
};

SearchTabViewModel.prototype.showInfo = function(item) {
    ga('send', 'event', 'dataSource', 'info', item.name);
    CatalogItemInfoViewModel.open('ui', item);
};

SearchTabViewModel.prototype.clearSearchText = function() {
    this.searchText = '';
};

module.exports = SearchTabViewModel;

},{"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/inherit":7,"../Core/loadView":8,"../SvgPaths/svgArrowDown":57,"../SvgPaths/svgArrowRight":58,"../SvgPaths/svgCheckboxChecked":59,"../SvgPaths/svgCheckboxUnchecked":60,"../SvgPaths/svgInfo":62,"./CatalogItemInfoViewModel":72,"./ExplorerTabViewModel":78}],89:[function(require,module,exports){
'use strict';

/*global require*/
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var DeveloperError = require('../../third_party/cesium/Source/Core/DeveloperError');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var loadView = require('../Core/loadView');
var ViewerMode = require('../Models/ViewerMode');

var SettingsPanelViewModel = function(options) {
    if (!defined(options) || !defined(options.application)) {
        throw new DeveloperError('options.application is required.');
    }

    this.application = options.application;

    this._domNodes = undefined;

    this.isVisible = defaultValue(options.isVisible, true);
    this.baseMaps = [];
    this.mouseOverBaseMap = undefined;

    knockout.track(this, ['isVisible', 'baseMaps', 'mouseOverBaseMap']);
};

SettingsPanelViewModel.prototype.show = function(container) {
    if (!defined(this._domNodes)) {
        this._domNodes = loadView("<div class=\"settings-panel-background\" data-bind=\"css: { 'settings-panel-background-hidden': !isVisible }, click: closeIfClickOnBackground\">\n    <div class=\"settings-panel\">\n        <div class=\"settings-panel-callout\"></div>\n        <div class=\"settings-panel-body\">\n            <div class=\"settings-panel-section\">\n                <div class=\"settings-panel-section-header\">View</div>\n                <div class=\"settings-panel-section-content\">\n                    <div class=\"settings-panel-map-view-button\" data-bind=\"click: select2D, css: { 'settings-panel-map-view-button-selected': application.viewerMode === 2 }\">2D</div>\n                    <div class=\"settings-panel-map-view-button\" data-bind=\"click: select3DSmooth, css: { 'settings-panel-map-view-button-selected': application.viewerMode === 1 }\">3D Smooth</div>\n                    <div class=\"settings-panel-map-view-button\" data-bind=\"click: select3DTerrain, css: { 'settings-panel-map-view-button-selected': application.viewerMode === 0 }\">3D Terrain</div>\n                </div>\n            </div>\n            <div class=\"settings-panel-section\">\n                <div class=\"settings-panel-section-header\">Base Map</div>\n                <div class=\"settings-panel-section-content\">\n                    <div class=\"settings-panel-base-map-label\" data-bind=\"text: mouseOverBaseMap ? mouseOverBaseMap.catalogItem.name : application.baseMap.name\"></div>\n                    <div class=\"settings-panel-base-map-choices\" data-bind=\"foreach: baseMaps\">\n                        <img class=\"settings-panel-base-map-button\" data-bind=\"attr: { src: image, title: catalogItem.name }, css: { 'settings-panel-base-map-button-selected': catalogItem === $root.application.baseMap }, event: { mouseover: $root.changeHighlightedBaseMap.bind($root), mouseout: $root.resetHightedBaseMap.bind($root) }, click: $root.selectBaseMap.bind($root)\" width=\"75\" height=\"75\" />\n                    </div>\n                </div>\n            </div>\n            <div class=\"settings-panel-close-button\" data-bind=\"click: close\">&times;</div>\n        </div>\n    </div>\n</div>\n", container, this);
    }
};

SettingsPanelViewModel.prototype.close = function() {
    this.isVisible = false;
};

SettingsPanelViewModel.prototype.closeIfClickOnBackground = function(viewModel, e) {
    if (e.target.className === 'settings-panel-background') {
        this.close();
    }
    return true;
};

SettingsPanelViewModel.prototype.select2D = function() {
    this.application.viewerMode = ViewerMode.Leaflet;
};

SettingsPanelViewModel.prototype.select3DSmooth = function() {
    this.application.viewerMode = ViewerMode.CesiumEllipsoid;
};

SettingsPanelViewModel.prototype.select3DTerrain = function() {
    this.application.viewerMode = ViewerMode.CesiumTerrain;
};

SettingsPanelViewModel.prototype.changeHighlightedBaseMap = function(baseMap) {
    this.mouseOverBaseMap = baseMap;
};

SettingsPanelViewModel.prototype.selectBaseMap = function(baseMap) {
    this.application.baseMap = baseMap.catalogItem;
};

SettingsPanelViewModel.prototype.resetHightedBaseMap = function() {
    this.mouseOverBaseMap = undefined;
};

module.exports = SettingsPanelViewModel;
},{"../../third_party/cesium/Source/Core/DeveloperError":123,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/loadView":8,"../Models/ViewerMode":45}],90:[function(require,module,exports){
'use strict';

/*global require,URI*/
var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var defined = require('../../third_party/cesium/Source/Core/defined');
var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var loadView = require('../Core/loadView');

var SharePopupViewModel = function(options) {
    this.application = options.application;
    this._domNodes = undefined;

    this.imageUrl = '';
    this.url = '';
    this.embedCode = '';
    this.itemsSkippedBecauseTheyHaveLocalData = [];

    knockout.track(this, ['imageUrl', 'url', 'embedCode', 'itemsSkippedBecauseTheyHaveLocalData']);

    // Build the share URL.
    var camera = this.application.currentViewer.getCurrentExtent();

    var request = {
        version: '0.0.03',
        initSources: this.application.initSources.slice()
    };

    var initSources = request.initSources;

    // Add an init source with user-added catalog members.
    var userDataSerializeOptions = {
        userSuppliedOnly: true,
        skipItemsWithLocalData: true,
        itemsSkippedBecauseTheyHaveLocalData: []
    };

    var userAddedCatalog = this.application.catalog.serializeToJson(userDataSerializeOptions);
    if (userAddedCatalog.length > 0) {
        initSources.push({
            catalog: userAddedCatalog,
            catalogIsUserSupplied: true
        });
    }

    // Add an init source with the enabled/opened catalog members.
    var enabledAndOpenedCatalog = this.application.catalog.serializeToJson({
        enabledItemsOnly: true,
        skipItemsWithLocalData: true,
        serializeForSharing: true,
    });

    if (enabledAndOpenedCatalog.length > 0) {
        initSources.push({
            catalog: enabledAndOpenedCatalog,
            catalogOnlyUpdatesExistingItems: true
        });
    }

    // Add an init source with the camera position.
    initSources.push({
        camera: {
            west: CesiumMath.toDegrees(camera.west),
            south: CesiumMath.toDegrees(camera.south),
            east: CesiumMath.toDegrees(camera.east),
            north: CesiumMath.toDegrees(camera.north)
        }
    });

    var uri = new URI(window.location);
    var visServer = uri.protocol() + '://' + uri.host();

    var requestString = JSON.stringify(request);

    this.url = visServer + '#start=' + encodeURIComponent(requestString);
    this.embedCode = '<iframe style="width: 720px; height: 405px; border: none;" src="' + this.url + '" allowFullScreen mozAllowFullScreen webkitAllowFullScreen></iframe>';
    this.itemsSkippedBecauseTheyHaveLocalData.push.apply(this.itemsSkippedBecauseTheyHaveLocalData, userDataSerializeOptions.itemsSkippedBecauseTheyHaveLocalData);

    var that = this;
    this.application.currentViewer.captureScreenshot().then(function(dataUrl) {
        that.imageUrl = dataUrl;
    });
};

SharePopupViewModel.prototype.show = function(container) {
    this._domNodes = loadView("<div class=\"modal-background\" data-bind=\"click: closeIfClickOnBackground\">\n    <div class=\"share-popup\">\n        <div class=\"share-popup-header\">\n            <div class=\"share-popup-close-button\" data-bind=\"click: close\">&times;</div>\n            <h1>Share</h1>\n        </div>\n        <div class=\"share-popup-content\">\n            <div class=\"share-popup-image\">\n                <img data-bind=\"attr: { src: imageUrl }\" height=\"300\" />\n            </div>\n            <div class=\"share-popup-right\">\n                <div class=\"share-popup-label\" data-bind=\"visible: itemsSkippedBecauseTheyHaveLocalData.length > 0\">\n                    The following data sources will NOT be shared because they include data from this local system.\n                    To share these data sources, publish their data on a web server and add them to National Map using\n                    the URL instead of by dragging/dropping or selecting a local file.\n                    <ul data-bind=\"foreach: itemsSkippedBecauseTheyHaveLocalData\">\n                        <li data-bind=\"text: name\"></li>\n                    </ul>\n                </div>\n                <div class=\"share-popup-label\">\n                    To <strong>copy</strong> to clipboard, click the link below and press CTRL+C or &#8984;+C:\n                    <input readonly type=\"text\" data-bind=\"value: url\" size=\"100\" onclick=\"this.select();\" />\n                </div>\n                <div class=\"share-popup-label\">\n                    To <strong>embed</strong>, copy this code to embed this map into an HTML page:\n                    <input readonly type=\"text\" data-bind=\"value: embedCode\" size=\"100\" onclick=\"this.select();\" />\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n", container, this);
};

SharePopupViewModel.prototype.close = function() {
    for (var i = 0; i < this._domNodes.length; ++i) {
        var node = this._domNodes[i];
        if (defined(node.parentElement)) {
            node.parentElement.removeChild(node);
        }
    }
};

SharePopupViewModel.prototype.closeIfClickOnBackground = function(viewModel, e) {
    if (e.target.className === 'modal-background') {
        this.close();
    }
    return true;
};

SharePopupViewModel.open = function(container, options) {
    var viewModel = new SharePopupViewModel(options);
    viewModel.show(container);
    return viewModel;
};

module.exports = SharePopupViewModel;

},{"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../Core/loadView":8}],91:[function(require,module,exports){
"use strict";

/*global require*/

var start = true;

var PopupMessageViewModel = require('./ViewModels/PopupMessageViewModel');
var FeatureDetection = require('../third_party/cesium/Source/Core/FeatureDetection');

// If we're not in a normal browser environment (Web Worker maybe?), do nothing.
if (typeof window === 'undefined') {
    start = false;
} else {
    if (FeatureDetection.isInternetExplorer() && FeatureDetection.internetExplorerVersion()[0] < 9) {
        PopupMessageViewModel.open('ui', {
            title : 'Internet Explorer 8 or earlier detected',
            message : '\
    National Map requires Internet Explorer 9 or later.  For the best experience, we recommend \
    <a href="http://www.microsoft.com/ie" target="_blank">Internet Explorer 11</a> or the latest version of \
    <a href="http://www.google.com/chrome" target="_blank">Google Chrome</a> or \
    <a href="http://www.mozilla.org/firefox" target="_blank">Mozilla Firefox</a>.'
        });

        start = false;
    } else if (typeof Object.create === 'undefined') {
        PopupMessageViewModel.open('ui', {
            title : 'Very old browser detected',
            message : '\
    National Map requires a web browser with support for ECMAScript 5, a feature that has been available in all major browsers since 2009 but that does \
    not appear to be supported by your current browser.  Please update your browser \
    and try again.  For the best experience, we recommend \
    <a href="http://www.microsoft.com/ie" target="_blank">Internet Explorer 11</a> or the latest version of \
    <a href="http://www.google.com/chrome" target="_blank">Google Chrome</a> or \
    <a href="http://www.mozilla.org/firefox" target="_blank">Mozilla Firefox</a>.'
        });

        start = false;
    }
}

if (start) {
    // IE9 doesn't have a console object until the debugging tools are opened.
    if (typeof window.console === 'undefined') {
        window.console = {
            log : function() {}
        };
    }

    window.CESIUM_BASE_URL = 'build/Cesium/';

    var copyright = require('./CopyrightModule'); // jshint ignore:line

    var BingMapsStyle = require('../third_party/cesium/Source/Scene/BingMapsStyle');
    var defined = require('../third_party/cesium/Source/Core/defined');
    var knockout = require('../third_party/cesium/Source/ThirdParty/knockout');

    var AusGlobeViewer = require('./viewer/AusGlobeViewer');
    var registerKnockoutBindings = require('./Core/registerKnockoutBindings');

    var AddDataPanelViewModel = require('./ViewModels/AddDataPanelViewModel');
    var BaseMapViewModel = require('./ViewModels/BaseMapViewModel');
    var BingMapsSearchProviderViewModel = require('./ViewModels/BingMapsSearchProviderViewModel');
    var CatalogItemNameSearchProviderViewModel = require('./ViewModels/CatalogItemNameSearchProviderViewModel');
    var BrandBarViewModel = require('./ViewModels/BrandBarViewModel');
    var DataCatalogTabViewModel = require('./ViewModels/DataCatalogTabViewModel');
    var DistanceLegendViewModel = require('./ViewModels/DistanceLegendViewModel');
    var DragDropViewModel = require('./ViewModels/DragDropViewModel');
    var ExplorerPanelViewModel = require('./ViewModels/ExplorerPanelViewModel');
    var GazetteerSearchProviderViewModel = require('./ViewModels/GazetteerSearchProviderViewModel');
    var LocationBarViewModel = require('./ViewModels/LocationBarViewModel');
    var MenuBarViewModel = require('./ViewModels/MenuBarViewModel');
    var MenuBarItemViewModel = require('./ViewModels/MenuBarItemViewModel');
    var NavigationViewModel = require('./ViewModels/NavigationViewModel');
    var NowViewingTabViewModel = require('./ViewModels/NowViewingTabViewModel');
    var SearchTabViewModel = require('./ViewModels/SearchTabViewModel');
    var SettingsPanelViewModel = require('./ViewModels/SettingsPanelViewModel');
    var SharePopupViewModel = require('./ViewModels/SharePopupViewModel');

    var Application = require('./Models/Application');
    var ArcGisMapServerCatalogItem = require('./Models/ArcGisMapServerCatalogItem');
    var BingMapsCatalogItem = require('./Models/BingMapsCatalogItem');
    var CompositeCatalogItem = require('./Models/CompositeCatalogItem');
    var WebMapServiceCatalogItem = require('./Models/WebMapServiceCatalogItem');
    var registerCatalogMembers = require('./Models/registerCatalogMembers');
    var raiseErrorToUser = require('./Models/raiseErrorToUser');

    registerKnockoutBindings();
    registerCatalogMembers();

    var application = new Application();
    application.catalog.isLoading = true;

    application.error.addEventListener(function(e) {
        PopupMessageViewModel.open('ui', {
            title: e.title,
            message: e.message
        });
    });

    application.start({
        applicationUrl: window.location,
        configUrl: 'config.json',
        useUrlHashAsInitSource: true
    }).otherwise(function(e) {
        raiseErrorToUser(application, e);
    }).always(function() {
        // Watch the hash portion of the URL.  If it changes, try to interpret as an init source.
        window.addEventListener("hashchange", function() {
            application.updateApplicationUrl(window.location);
        }, false);

        application.catalog.isLoading = false;

        // Start with "National Data Sets" open.
        var nds = application.catalog.group.findFirstItemByName('National Data Sets');
        if (defined(nds)) {
            nds.isOpen = true;
        }

        // Create the map/globe.
        AusGlobeViewer.create(application);

        var defaultBaseMap = new BingMapsCatalogItem(application);
        defaultBaseMap.name = 'Bing Maps Aerial with Labels';
        defaultBaseMap.mapStyle = BingMapsStyle.AERIAL_WITH_LABELS;
        defaultBaseMap.opacity = 1.0;

        application.baseMap = defaultBaseMap;

        // Create the user interface.
        var ui = document.getElementById('ui');

        BrandBarViewModel.create(ui, {
            name: 'NATIONAL<br/><strong>MAP</strong> <small>beta</small>',
            leftLogo: 'images/gov-brand.png'
        });

        // Create the various base layer options.
        var naturalEarthII = new WebMapServiceCatalogItem(application);
        naturalEarthII.name = 'Natural Earth II';
        naturalEarthII.url = 'http://geoserver-nm.nicta.com.au/imagery/natural-earth-ii/wms';
        naturalEarthII.layers = 'natural-earth-ii:NE2_HR_LC_SR_W_DR';
        naturalEarthII.parameters = {
            tiled: true
        };
        naturalEarthII.opacity = 1.0;

        var australianTopoOverlay = new ArcGisMapServerCatalogItem(application);
        australianTopoOverlay.name = 'Australian Topography';
        australianTopoOverlay.url = 'http://www.ga.gov.au/gis/rest/services/topography/Australian_Topography_2014_WM/MapServer';
        australianTopoOverlay.opacity = 1.0;

        var australianTopo = new CompositeCatalogItem(application, [naturalEarthII, australianTopoOverlay]);
        australianTopo.name = 'Australian Topography';

        var blackMarble = new WebMapServiceCatalogItem(application);
        blackMarble.name = 'NASA Black Marble';
        blackMarble.url = 'http://geoserver-nm.nicta.com.au/imagery/nasa-black-marble/wms';
        blackMarble.layers = 'nasa-black-marble:dnb_land_ocean_ice.2012.54000x27000_geo';
        blackMarble.parameters = {
            tiled: true
        };
        blackMarble.opacity = 1.0;

        var bingMapsAerial = new BingMapsCatalogItem(application);
        bingMapsAerial.name = 'Bing Maps Aerial';
        bingMapsAerial.mapStyle = BingMapsStyle.AERIAL;
        bingMapsAerial.opacity = 1.0;

        var bingMapsRoads = new BingMapsCatalogItem(application);
        bingMapsRoads.name = 'Bing Maps Roads';
        bingMapsRoads.mapStyle = BingMapsStyle.ROAD;
        bingMapsRoads.opacity = 1.0;

        var australianHydroOverlay = new ArcGisMapServerCatalogItem(application);
        australianHydroOverlay.name = 'Australian Hydrography';
        australianHydroOverlay.url = 'http://www.ga.gov.au/gis/rest/services/topography/AusHydro_WM/MapServer';
        australianHydroOverlay.opacity = 1.0;

        var australianHydro = new CompositeCatalogItem(application, [naturalEarthII, australianHydroOverlay]);
        australianHydro.name = 'Australian Hydrography';

        var settingsPanel = new SettingsPanelViewModel({
            application: application,
            isVisible: false
        });

        settingsPanel.baseMaps.push(new BaseMapViewModel({
            image: 'images/australian-topo.png',
            catalogItem: australianTopo,
        }));

        settingsPanel.baseMaps.push(new BaseMapViewModel({
            image: 'images/bing-aerial-labels.png',
            catalogItem: defaultBaseMap
        }));

        settingsPanel.baseMaps.push(new BaseMapViewModel({
            image: 'images/bing-aerial.png',
            catalogItem: bingMapsAerial,
        }));

        settingsPanel.baseMaps.push(new BaseMapViewModel({
            image: 'images/bing-maps-roads.png',
            catalogItem: bingMapsRoads,
        }));

        settingsPanel.baseMaps.push(new BaseMapViewModel({
            image: 'images/hydro.png',
            catalogItem: australianHydro,
        }));

        settingsPanel.baseMaps.push(new BaseMapViewModel({
            image: 'images/black-marble.png',
            catalogItem: blackMarble,
        }));

        settingsPanel.baseMaps.push(new BaseMapViewModel({
            image: 'images/natural-earth.png',
            catalogItem: naturalEarthII,
        }));

        settingsPanel.show(ui);

        var menuBar = new MenuBarViewModel();
        menuBar.items.push(new MenuBarItemViewModel({
            label: 'Add data',
            tooltip: 'Add your own data to the map.',
            callback: function() {
                AddDataPanelViewModel.open(ui, {
                    application: application
                });
            }
        }));
        menuBar.items.push(new MenuBarItemViewModel({
            label: 'Maps',
            tooltip: 'Change the map mode (2D/3D) and base map.',
            observableToToggle: knockout.getObservable(settingsPanel, 'isVisible')
        }));
        menuBar.items.push(new MenuBarItemViewModel({
            label: 'Share',
            tooltip: 'Share your map with others.',
            callback: function() {
                SharePopupViewModel.open(ui, {
                    application: application
                });
            }
        }));
        menuBar.items.push(new MenuBarItemViewModel({
            label: 'About',
            tooltip: 'About National Map.',
            href: 'http://nicta.github.io/nationalmap/public/info.html'
        }));
        menuBar.items.push(new MenuBarItemViewModel({
            label: 'Help',
            tooltip: 'Help using National Map.',
            href: 'http://nicta.github.io/nationalmap/public/faq.html'
        }));
        menuBar.show(ui);

        var locationBar = new LocationBarViewModel(application, document.getElementById('cesiumContainer'));
        locationBar.show(ui);

        var distanceLegend = new DistanceLegendViewModel(application);
        distanceLegend.show(ui);

        var navigation = new NavigationViewModel(application);
        navigation.show(ui);

        var explorer = new ExplorerPanelViewModel({});
        explorer.show(ui);

        explorer.addTab(new DataCatalogTabViewModel({
            catalog: application.catalog
        }));
        explorer.addTab(new NowViewingTabViewModel({
            nowViewing: application.nowViewing
        }));

        var searchTab = new SearchTabViewModel(application);
        
        searchTab.searchProviders.push(new BingMapsSearchProviderViewModel({
            application: application
        }));
        searchTab.searchProviders.push(new GazetteerSearchProviderViewModel({
            application: application
        }));
        searchTab.searchProviders.push(new CatalogItemNameSearchProviderViewModel({
            application: application
        }));

        explorer.addTab(searchTab);

        DragDropViewModel.create(ui, {
            application: application,
            dropTarget: document
        });

        knockout.getObservable(explorer, 'isOpen').subscribe(function() {
            var cesiumContainer = document.getElementById('cesiumContainer');

            if (explorer.isOpen) {
                if (cesiumContainer.className.indexOf(' map-displaced') < 0) {
                    cesiumContainer.className += ' map-displaced';
                }
            } else {
                cesiumContainer.className = cesiumContainer.className.replace(' map-displaced', '');
            }

            // Resize Leaflet once the animation finishes.
            if (defined(application.leaflet)) {
                setTimeout(function() {
                    if (defined(application.leaflet)) {
                        application.leaflet.map.invalidateSize();
                    }
                }, 300);
            }

            application.currentViewer.notifyRepaintRequired();
        });

        document.getElementById('loadingIndicator').style.display = 'none';
    });
}

},{"../third_party/cesium/Source/Core/FeatureDetection":141,"../third_party/cesium/Source/Core/defined":245,"../third_party/cesium/Source/Scene/BingMapsStyle":371,"../third_party/cesium/Source/ThirdParty/knockout":591,"./CopyrightModule":2,"./Core/registerKnockoutBindings":12,"./Models/Application":22,"./Models/ArcGisMapServerCatalogItem":23,"./Models/BingMapsCatalogItem":24,"./Models/CompositeCatalogItem":31,"./Models/WebMapServiceCatalogItem":49,"./Models/raiseErrorToUser":55,"./Models/registerCatalogMembers":56,"./ViewModels/AddDataPanelViewModel":68,"./ViewModels/BaseMapViewModel":69,"./ViewModels/BingMapsSearchProviderViewModel":70,"./ViewModels/BrandBarViewModel":71,"./ViewModels/CatalogItemNameSearchProviderViewModel":73,"./ViewModels/DataCatalogTabViewModel":74,"./ViewModels/DistanceLegendViewModel":75,"./ViewModels/DragDropViewModel":76,"./ViewModels/ExplorerPanelViewModel":77,"./ViewModels/GazetteerSearchProviderViewModel":79,"./ViewModels/LocationBarViewModel":80,"./ViewModels/MenuBarItemViewModel":81,"./ViewModels/MenuBarViewModel":82,"./ViewModels/NavigationViewModel":83,"./ViewModels/NowViewingTabViewModel":84,"./ViewModels/PopupMessageViewModel":85,"./ViewModels/SearchTabViewModel":88,"./ViewModels/SettingsPanelViewModel":89,"./ViewModels/SharePopupViewModel":90,"./viewer/AusGlobeViewer":92}],92:[function(require,module,exports){
/*
 *   A collection of additional viewer functionality independent
 *   of datasets
 */

"use strict";

/*global require,L,URI,$,Document,html2canvas,console,ga*/

var BingMapsApi = require('../../third_party/cesium/Source/Core/BingMapsApi');
var CameraFlightPath = require('../../third_party/cesium/Source/Scene/CameraFlightPath');
var Cartesian2 = require('../../third_party/cesium/Source/Core/Cartesian2');
var Cartesian3 = require('../../third_party/cesium/Source/Core/Cartesian3');
var Cartographic = require('../../third_party/cesium/Source/Core/Cartographic');
var CesiumMath = require('../../third_party/cesium/Source/Core/Math');
var CesiumTerrainProvider = require('../../third_party/cesium/Source/Core/CesiumTerrainProvider');
var Clock = require('../../third_party/cesium/Source/Core/Clock');
var ClockRange = require('../../third_party/cesium/Source/Core/ClockRange');
var Color = require('../../third_party/cesium/Source/Core/Color');
var Clock = require('../../third_party/cesium/Source/Core/Clock');
var Credit = require('../../third_party/cesium/Source/Core/Credit');
var DataSourceDisplay = require('../../third_party/cesium/Source/DataSources/DataSourceDisplay');
var defaultValue = require('../../third_party/cesium/Source/Core/defaultValue');
var defined = require('../../third_party/cesium/Source/Core/defined');
var Ellipsoid = require('../../third_party/cesium/Source/Core/Ellipsoid');
var EllipsoidTerrainProvider = require('../../third_party/cesium/Source/Core/EllipsoidTerrainProvider');
var FeatureDetection = require('../../third_party/cesium/Source/Core/FeatureDetection');
var EventHelper = require('../../third_party/cesium/Source/Core/EventHelper');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var InfoBox = require('../../third_party/cesium/Source/Widgets/InfoBox/InfoBox');
var JulianDate = require('../../third_party/cesium/Source/Core/JulianDate');
var KeyboardEventModifier = require('../../third_party/cesium/Source/Core/KeyboardEventModifier');
var loadJson = require('../../third_party/cesium/Source/Core/loadJson');
var loadXML = require('../../third_party/cesium/Source/Core/loadXML');
var Material = require('../../third_party/cesium/Source/Scene/Material');
var Matrix3 = require('../../third_party/cesium/Source/Core/Matrix3');
var Matrix4 = require('../../third_party/cesium/Source/Core/Matrix4');
var Rectangle = require('../../third_party/cesium/Source/Core/Rectangle');
var RectanglePrimitive = require('../../third_party/cesium/Source/Scene/RectanglePrimitive');
var ScreenSpaceEventHandler = require('../../third_party/cesium/Source/Core/ScreenSpaceEventHandler');
var ScreenSpaceEventType = require('../../third_party/cesium/Source/Core/ScreenSpaceEventType');
var SingleTileImageryProvider = require('../../third_party/cesium/Source/Scene/SingleTileImageryProvider');
var Transforms = require('../../third_party/cesium/Source/Core/Transforms');
var Tween = require('../../third_party/cesium/Source/ThirdParty/Tween');
var Viewer = require('../../third_party/cesium/Source/Widgets/Viewer/Viewer');
var WebMercatorProjection = require('../../third_party/cesium/Source/Core/WebMercatorProjection');
var when = require('../../third_party/cesium/Source/ThirdParty/when');

var Animation = require('../../third_party/cesium/Source/Widgets/Animation/Animation');
var AnimationViewModel = require('../../third_party/cesium/Source/Widgets/Animation/AnimationViewModel');
var Timeline = require('../../third_party/cesium/Source/Widgets/Timeline/Timeline');
var ClockViewModel = require('../../third_party/cesium/Source/Widgets/ClockViewModel');

var knockout = require('../../third_party/cesium/Source/ThirdParty/knockout');

var FrameRateMonitor = require('../../third_party/cesium/Source/Scene/FrameRateMonitor');
var runLater = require('../Core/runLater');

var corsProxy = require('../Core/corsProxy');
var Cesium = require('../Models/Cesium');
var Leaflet = require('../Models/Leaflet');
var PopupMessageViewModel = require('../ViewModels/PopupMessageViewModel');
var rectangleToLatLngBounds = require('../Map/rectangleToLatLngBounds');
var LeafletVisualizer = require('../Map/LeafletVisualizer');
var ViewerMode = require('../Models/ViewerMode');

//use our own bing maps key
BingMapsApi.defaultKey = undefined;

//Initialize the selected viewer - Cesium or Leaflet
var AusGlobeViewer = function(application) {
    this._distanceLegendBarWidth = undefined;
    this._distanceLegendLabel = undefined;

    var that = this;
    
    var url = window.location;
    var uri = new URI(url);
    var params = uri.search(true);

    var useCesium = (application.userProperties.map === '2d' || params.map === '2d') ? false : true;
    
    if (useCesium && !supportsWebgl()) {
        PopupMessageViewModel.open('ui', {
            title : 'WebGL not supported',
            message : '\
National Map works best with a web browser that supports <a href="http://get.webgl.com" target="_blank">WebGL</a>, \
including the latest versions of <a href="http://www.google.com/chrome" target="_blank">Google Chrome</a>, \
<a href="http://www.mozilla.org/firefox" target="_blank">Mozilla Firefox</a>, \
<a href="https://www.apple.com/au/osx/how-to-upgrade/" target="_blank">Apple Safari</a>, and \
<a href="http://www.microsoft.com/ie" target="_blank">Microsoft Internet Explorer</a>. \
Your web browser does not appear to support WebGL, so you will see a limited, 2D-only experience.'
        });
        useCesium = false;
    }

    if (document.body.clientWidth < 520 || document.body.clientHeight < 400) {
        PopupMessageViewModel.open('ui', {
            title : 'Small screen or window',
            message : '\
Hello!<br/>\
<br/>\
Currently the National Map isn\'t optimised for small screens.<br/>\
<br/>\
For a better experience we\'d suggest you visit the application from a larger screen like your tablet, laptop or desktop.  \
If you\'re on a desktop or laptop, consider increasing the size of your window.'
        });
    }

    application.viewerMode = useCesium ? ViewerMode.CesiumTerrain : ViewerMode.Leaflet;
    
    //TODO: perf test to set environment

    this.scene = undefined;
    this.viewer = undefined;
    this.map = undefined;

    this.application = application;

    ga('send', 'event', 'startup', 'initialViewer', useCesium ? 'cesium' : 'leaflet');

    this.selectViewer(useCesium);

    knockout.getObservable(this.application, 'viewerMode').subscribe(function() {
        changeViewer(this);
    }, this);

    this._previousBaseMap = this.application.baseMap;

    knockout.getObservable(this.application, 'baseMap').subscribe(function() {
        changeBaseMap(this, this.application.baseMap);
    }, this);

    knockout.getObservable(this.application, 'initialBoundingBox').subscribe(function() {
        that.updateCameraFromRect(that.application.initialBoundingBox, 2000);
    });
};

AusGlobeViewer.create = function(application) {
    return new AusGlobeViewer(application);
};

function changeViewer(viewer) {
    var application = viewer.application;
    var newMode = application.viewerMode;

    if (newMode === ViewerMode.Leaflet) {
        if (!application.leaflet) {
            ga('send', 'event', 'mapSettings', 'switchViewer', '2D');
            viewer.selectViewer(false);
        }
    } else {
        if (!supportsWebgl()) {
            PopupMessageViewModel.open('ui', {
                title : 'WebGL not supported',
                message : '\
Your web browser cannot display the map in 3D because it does not support WebGL.  Please upgrade to the \
latest version of <a href="http://www.google.com/chrome" target="_blank">Google Chrome</a>, \
<a href="http://www.mozilla.org/firefox" target="_blank">Mozilla Firefox</a>, \
<a href="https://www.apple.com/au/osx/how-to-upgrade/" target="_blank">Apple Safari</a>, or \
<a href="http://www.microsoft.com/ie" target="_blank">Microsoft Internet Explorer</a>.'
            });

            application.viewerMode = ViewerMode.Leaflet;
        } else {
            if (newMode === ViewerMode.CesiumTerrain) {
                ga('send', 'event', 'mapSettings', 'switchViewer', '3D');

                if (defined(application.leaflet)) {
                    viewer.selectViewer(true);
                } else {
                    application.cesium.scene.globe.terrainProvider = new CesiumTerrainProvider({
                        url : '//cesiumjs.org/stk-terrain/tilesets/world/tiles'
                    });
                }
            } else if (newMode === ViewerMode.CesiumEllipsoid) {
                ga('send', 'event', 'mapSettings', 'switchViewer', 'Smooth 3D');

                if (defined(application.leaflet)) {
                    viewer.selectViewer(true);
                }

                application.cesium.scene.globe.terrainProvider = new EllipsoidTerrainProvider();
            }
        }
    }
}

function changeBaseMap(viewer, newBaseMap) {
    if (defined(viewer._previousBaseMap)) {
        viewer._previousBaseMap._hide();
        viewer._previousBaseMap._disable();
    }

    if (defined(newBaseMap)) {
        newBaseMap._enable();
        newBaseMap._show();
        newBaseMap.lowerToBottom();
    }

    viewer._previousBaseMap = newBaseMap;

    if (defined(viewer.application.currentViewer)) {
        viewer.application.currentViewer.notifyRepaintRequired();
    }
}

// -------------------------------------------
// PERF: skip frames where reasonable
// -------------------------------------------
var FrameChecker = function () {
    this._lastDate = new JulianDate(0, 0.0);
    this._lastCam = new Matrix4();
    this._maxFPS = 40.0;
    this._skipCnt = 0;
    this._skipWaitNorm = 3.0; //start skip after launch
    this._skipWaitLim = 10.0; //start skip at launch
};

// call to force draw - usually after long downloads/processes
FrameChecker.prototype.forceFrameUpdate = function() {
    this._skipCnt = 0;
};

// see if we can skip the draw on this frame
FrameChecker.prototype.skipFrame = function(scene, date) {
    //check if anything actually changed
    if (this._lastDate) {
        var bDateSame = this._lastDate.equals(date);
        var bCamSame = this._lastCam.equalsEpsilon(scene.camera.viewMatrix, CesiumMath.EPSILON5);
        if (bDateSame && bCamSame) {
            this._skipCnt++;
        }
        else {
            this._skipCnt = 0;
        }
    }

    // If terrain/imagery is loading, force another render immediately so that the loading
    // happens as quickly as possible.
    var surface = scene.globe._surface;
    if (surface._tileLoadQueue.length > 0 || surface._debug.tilesWaitingForChildren > 0) {
        this._skipCnt = 0;
    }

    if (this._skipCnt > (this._maxFPS * this._skipWaitLim)) {
        this._skipWaitLim = this._skipWaitNorm; //go to normal skip wait
        return true;
    }

    this._lastDate = date.clone(this._lastDate);
    this._lastCam = scene.camera.viewMatrix.clone(this._lastCam);
    return false;
};

// -------------------------------------------
// DrawExtentHelper from the cesium sample code
//  modified to always be available on shift-click
// -------------------------------------------
var DrawExtentHelper = function (scene, handler) {
    this._scene = scene;
    this._ellipsoid = scene.globe.ellipsoid;
    this._finishHandler = handler;
    this._mouseHandler = new ScreenSpaceEventHandler(scene.canvas, false);
    this.active = false;
};

DrawExtentHelper.prototype.enableInput = function () {
    var controller = this._scene.screenSpaceCameraController;
    controller.enableInputs = true;
};

DrawExtentHelper.prototype.disableInput = function () {
    var controller = this._scene.screenSpaceCameraController;
    controller.enableInputs = false;
};

DrawExtentHelper.prototype.getExtent = function (mn, mx) {
    var e = new Rectangle();

    // Re-order so west < east and south < north
    e.west = Math.min(mn.longitude, mx.longitude);
    e.east = Math.max(mn.longitude, mx.longitude);
    e.south = Math.min(mn.latitude, mx.latitude);
    e.north = Math.max(mn.latitude, mx.latitude);

    // Check for approx equal (shouldn't require abs due to re-order)
    var epsilon = CesiumMath.EPSILON6;

    if (Math.abs(e.east - e.west) < epsilon) {
        e.east += epsilon * 2.0;
        return;
    }

    if (Math.abs(e.north - e.south) < epsilon) {
        e.north += epsilon * 2.0;
        return;
    }
    return e;
};

DrawExtentHelper.prototype.setPolyPts = function (mn, mx) {
    var e = this.getExtent(mn, mx);
    if (e) {
        this._extentPrimitive.rectangle = e;
    }
};

DrawExtentHelper.prototype.setToDegrees = function (w, s, e, n) {
    var toRad = CesiumMath.toRadians;
    var mn = new Cartographic(toRad(w), toRad(s));
    var mx = new Cartographic(toRad(e), toRad(n));
    this.setPolyPts(mn, mx);
};

DrawExtentHelper.prototype.handleRegionStop = function (movement) {
    this.enableInput();
    var ext;
    if (movement) {
        var pickRay = this._scene.camera.getPickRay(movement.position);
        var cartesian = this._scene.globe.pick(pickRay, this._scene);
        if (cartesian) {
            this._click2 = this._ellipsoid.cartesianToCartographic(cartesian);
        }
        ext = this.getExtent(this._click1, this._click2);
    }
    this._scene.primitives.remove(this._extentPrimitive);
    this.active = false;
    this._finishHandler(ext);
};

DrawExtentHelper.prototype.handleRegionInter = function (movement) {
    var pickRay = this._scene.camera.getPickRay(movement.endPosition);
    var cartesian = this._scene.globe.pick(pickRay, this._scene);
    if (cartesian) {
        var cartographic = this._ellipsoid.cartesianToCartographic(cartesian);
        this.setPolyPts(this._click1, cartographic);
    }
};

DrawExtentHelper.prototype.handleRegionStart = function (movement) {
    var pickRay = this._scene.camera.getPickRay(movement.position);
    var cartesian = this._scene.globe.pick(pickRay, this._scene);
    if (cartesian) {
        this.disableInput();
        this.active = true;
        this._extentPrimitive = new RectanglePrimitive({
            material : Material.fromType('Color', {
                color : new Color(1.0, 1.0, 1.0, 0.5)
            })
        });
        this._extentPrimitive.asynchronous = false;
        this._scene.primitives.add(this._extentPrimitive);
        var that = this;
        this._click1 = this._ellipsoid.cartesianToCartographic(cartesian);
        this._mouseHandler.setInputAction(function (movement) {
            that.handleRegionStop(movement);
        }, ScreenSpaceEventType.LEFT_UP, KeyboardEventModifier.SHIFT);
        this._mouseHandler.setInputAction(function (movement) {
            that.handleRegionInter(movement);
        }, ScreenSpaceEventType.MOUSE_MOVE, KeyboardEventModifier.SHIFT);
    }
};


DrawExtentHelper.prototype.start = function () {

    var that = this;

    // Now wait for start
    this._mouseHandler.setInputAction(function (movement) {
        that.handleRegionStart(movement);
    }, ScreenSpaceEventType.LEFT_DOWN, KeyboardEventModifier.SHIFT);
};

DrawExtentHelper.prototype.destroy = function () {
    this._mouseHandler.destroy();
    this._scene = undefined;
};


// -------------------------------------------
// Region Selection
// -------------------------------------------
AusGlobeViewer.prototype._enableSelectExtent = function(bActive) {
    if (bActive) {
        var that = this;
        this.regionSelect = new DrawExtentHelper(this.scene, function (ext) {
            if (ext) {
                that.updateCameraFromRect(ext, 2000);
            }
        });
        this.regionSelect.start();
    }
    else {
        this.regionSelect.destroy();
    }
};


AusGlobeViewer.prototype._createCesiumViewer = function(container) {

    var that = this;
    
    var terrainProvider = new CesiumTerrainProvider({
            url : '//cesiumjs.org/stk-terrain/tilesets/world/tiles'
        });

    var options = {
        dataSources: this.application.dataSources,
        clock: this.application.clock,
        homeButton: false,
        sceneModePicker: false,
        navigationInstructionsInitiallyVisible: false,
        geocoder: false,
        baseLayerPicker: false,
        navigationHelpButton: false,
        fullscreenButton : false,
        terrainProvider : terrainProvider,
        imageryProvider : new SingleTileImageryProvider({ url: 'images/nicta.png' }),
        timeControlsInitiallyVisible : false
    };

    // Workaround for Firefox bug with WebGL and printing:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=976173
    if (FeatureDetection.isFirefox()) {
        options.contextOptions = {webgl : {preserveDrawingBuffer : true}};
    }

     //create CesiumViewer
    var viewer = new Viewer(container, options);

    viewer.scene.imageryLayers.removeAll();

    viewer.clock.shouldAnimate = false;

    //catch Cesium terrain provider down and switch to Ellipsoid
    terrainProvider.errorEvent.addEventListener(function(err) {
        console.log('Terrain provider error.  ', err.message);
        if (viewer.scene.terrainProvider instanceof CesiumTerrainProvider) {
            console.log('Switching to EllipsoidTerrainProvider.');
            viewer.scene.terrainProvider = new EllipsoidTerrainProvider();
            if (!defined(that.TerrainMessageViewed)) {
                PopupMessageViewModel.open('ui', {
                    title : 'Terrain Server Not Responding',
                    message : '\
The terrain server is not responding at the moment.  You can still use all the features of National \
Map but there will be no terrain detail in 3D mode.  We\'re sorry for the inconvenience.  Please try \
again later and the terrain server should be responding as expected.  If the issue persists, please contact \
us via email at nationalmap@lists.nicta.com.au.'
                });
                that.TerrainMessageViewed = true;
            }
        }
    });


    var lastHeight = 0;
    viewer.scene.preRender.addEventListener(function(scene, time) {
        var container = viewer._container;
        var height = container.clientHeight;

        if (height !== lastHeight) {
            viewer.infoBox.viewModel.maxHeight = Math.max(height - 300, 100);
            lastHeight = height;
        }
    });


    var scene = viewer.scene;
    var globe = scene.globe;

    globe.depthTestAgainstTerrain = false;

    scene.frameState.creditDisplay.addDefaultCredit(new Credit('CESIUM', undefined, 'http://cesiumjs.org/'));
    scene.frameState.creditDisplay.addDefaultCredit(new Credit('BING', undefined, 'http://www.bing.com/'));

    var inputHandler = viewer.screenSpaceEventHandler;

    // Add double click zoom
    inputHandler.setInputAction(
        function (movement) {
            zoomIn(that.scene, movement.position);
        },
        ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    inputHandler.setInputAction(
        function (movement) {
            zoomOut(that.scene, movement.position);
        },
        ScreenSpaceEventType.LEFT_DOUBLE_CLICK, KeyboardEventModifier.SHIFT);

    return viewer;
};

AusGlobeViewer.prototype.isCesium = function() {
    return defined(this.viewer);
};

function isTimelineVisible() {
    return $('.cesium-viewer-animationContainer').css('visibility') === 'visible';
}

AusGlobeViewer.prototype.selectViewer = function(bCesium) {
    var previousClock;
    if (this.viewer) {
        previousClock = Clock.clone(this.viewer.clock);
    } else if (this.map) {
        previousClock = Clock.clone(this.map.clock);
    }

    changeBaseMap(this, undefined);

    this.application.beforeViewerChanged.raiseEvent();

    var bnds, rect;

    var that = this;

    var timelineVisible = isTimelineVisible();

    if (!bCesium) {

            //shut down existing cesium
        if (defined(this.viewer)) {
            this.application.cesium.destroy();

            //get camera and timeline settings
            rect = getCameraRect(this.scene);
            bnds = [[CesiumMath.toDegrees(rect.south), CesiumMath.toDegrees(rect.west)],
                [CesiumMath.toDegrees(rect.north), CesiumMath.toDegrees(rect.east)]];

            this._enableSelectExtent(false);

            var inputHandler = this.viewer.screenSpaceEventHandler;
            inputHandler.removeInputAction( ScreenSpaceEventType.MOUSE_MOVE );
            inputHandler.removeInputAction( ScreenSpaceEventType.LEFT_DOUBLE_CLICK );
            inputHandler.removeInputAction( ScreenSpaceEventType.LEFT_DOUBLE_CLICK, KeyboardEventModifier.SHIFT );

            if (defined(this.monitor)) {
                this.monitor.destroy();
                this.monitor = undefined;
            }
            this.viewer.destroy();
            this.viewer = undefined;
        }
        else {
            bnds = rectangleToLatLngBounds(this.application.initialBoundingBox);
        }

       //create leaflet viewer
        var map = L.map('cesiumContainer', {
            worldCopyJump: true,
            zoomControl: false
        }).setView([-28.5, 135], 5);

        this.map = map;
        map.clock = this.application.clock;
        map.dataSources = this.application.dataSources;

        map.screenSpaceEventHandler = {
            setInputAction : function() {},
            remoteInputAction : function() {}
        };
        map.destroy = function() {};

        map.infoBox = new InfoBox(document.body);

        if (!defined(this.leafletVisualizer)) {
            this.leafletVisualizer = new LeafletVisualizer();
        }
        this.dataSourceDisplay = new DataSourceDisplay({
            scene : map,
            dataSourceCollection : map.dataSources,
            visualizersCallback: this.leafletVisualizer.visualizersCallback
        });

        var eventHelper = new EventHelper();

        eventHelper.add(map.clock.onTick, function(clock) {
            that.dataSourceDisplay.update(clock.currentTime);
        });

        that.leafletEventHelper = eventHelper;

        var ticker = function() {
            if (that.map === map) {
                map.clock.tick();

                if (typeof requestAnimationFrame !== 'undefined') {
                    requestAnimationFrame(ticker);
                } else {
                    setTimeout(ticker, 15);
                }
            } else {
                console.log('done');
            }
        };

        ticker();

        this.createLeafletTimeline(map.clock);

        Clock.clone(previousClock, map.clock);
        map.timeline.zoomTo(map.clock.startTime, map.clock.stopTime);

        map.on("boxzoomend", function(e) {
            console.log(e.boxZoomBounds);
        });

        map.fitBounds(bnds);

        //redisplay data
        this.map = map;

        this.application.leaflet = new Leaflet(this.application, map);
        this.application.cesium = undefined;
        this.application.currentViewer = this.application.leaflet;

        this.captureCanvas = function() {
            var that = this;
            if (that.startup) {
                that.startup = false;
            }
            that.map.attributionControl.removeFrom(that.map);
            html2canvas( document.getElementById('cesiumContainer'), {
	            useCORS: true,
                onrendered: function(canvas) {
                    var dataUrl = canvas.toDataURL("image/jpeg");
                    that.captureCanvasCallback(dataUrl);
                    that.map.attributionControl.addTo(that.map);
                }
            });
        };

        map.on('click', function(e) {
            selectFeatureLeaflet(that, e.latlng);
        });
    }
    else {
        if (defined(this.map)) {
            this.application.leaflet.destroy();

            //get camera and timeline settings
            rect = getCameraRect(undefined, this.map);

            if (that.leafletEventHelper) {
                that.leafletEventHelper.removeAll();
                that.leafletEventHelper = undefined;
            }

            this.removeLeafletTimeline();
            this.dataSourceDisplay.destroy();
            this.map.dataSources = undefined;
            this.map.remove();
            this.map = undefined;
        }
        else {
            rect = this.application.initialBoundingBox;
         }

        //create Cesium viewer
        this.viewer = this._createCesiumViewer('cesiumContainer');
        this.scene = this.viewer.scene;

        this.application.cesium = new Cesium(this.application, this.viewer);
        this.application.leaflet = undefined;
        this.application.currentViewer = this.application.cesium;

        this.frameChecker = new FrameChecker();

        // Make sure we re-render when data sources or imagery layers are added or removed.
        this.scene.imageryLayers.layerAdded.addEventListener(this.frameChecker.forceFrameUpdate, this.frameChecker);
        this.scene.imageryLayers.layerRemoved.addEventListener(this.frameChecker.forceFrameUpdate, this.frameChecker);
        this.scene.imageryLayers.layerMoved.addEventListener(this.frameChecker.forceFrameUpdate, this.frameChecker);

        this.viewer.dataSources.dataSourceAdded.addEventListener(this.frameChecker.forceFrameUpdate, this.frameChecker);
        this.viewer.dataSources.dataSourceRemoved.addEventListener(this.frameChecker.forceFrameUpdate, this.frameChecker);

        this.updateCameraFromRect(rect, 0);

        this._enableSelectExtent(true);

        Clock.clone(previousClock, this.viewer.clock);

        //Simple monitor to start up and switch to 2D if seem to be stuck.
        if (!defined(this.checkedStartupPerformance)) {
            this.checkedStartupPerformance = true;
            this.monitor = new FrameRateMonitor({ 
                scene: this.scene, 
                minimumFrameRateDuringWarmup: 1,
                minimumFrameRateAfterWarmup: 0,
                samplingWindow: 2
            });
            this.monitor.lowFrameRate.addEventListener( function() {
                if (!that.application.cesium.stoppedRendering) {
                    PopupMessageViewModel.open('ui', {
                        title : 'Unusually Slow Performance Detected',
                        message : '\
        It appears that your system is capable of running National Map in 3D mode, but is having significant performance issues. \
        We are automatically switching to 2D mode to help resolve this issue.  If you want to switch back to 3D mode you can select \
        that option from the Maps button at the top of the screen.'
                    });
                    runLater(function() { 
                        that.selectViewer(false); 
                    });
                }
            });
        }

    }

    this.application.afterViewerChanged.raiseEvent();

    changeBaseMap(this, this.application.baseMap);

    if (timelineVisible) {
        showTimeline(this.viewer);
    } else {
        hideTimeline(this.viewer);
    }
};

//Check for webgl support
function supportsWebgl() {
    //Check for webgl support and if not, then fall back to leaflet
    if (!window.WebGLRenderingContext) {
        // Browser has no idea what WebGL is. Suggest they
        // get a new browser by presenting the user with link to
        // http://get.webgl.org
        console.log('!!No WebGL support.');
        return false;
    }
    var canvas = document.createElement( 'canvas' );

    var webglOptions = {
        alpha : false,
        stencil : false,
        failIfMajorPerformanceCaveat : true
    };

    var gl = canvas.getContext("webgl", webglOptions) || canvas.getContext("experimental-webgl", webglOptions);
    if (!gl) {
        // Browser could not initialize WebGL. User probably needs to
        // update their drivers or get a new browser. Present a link to
        // http://get.webgl.org/troubleshooting
        console.log('!!Unable to successfully create Webgl context.');
        return false;
    }
    return true;
}

//------------------------------------
// Timeline display on selection
//------------------------------------

AusGlobeViewer.prototype.createLeafletTimeline = function(clock) {

    var viewerContainer = document.getElementById('cesiumContainer');

    var clockViewModel = new ClockViewModel(clock);

    var animationContainer = document.createElement('div');
    animationContainer.className = 'cesium-viewer-animationContainer';
    animationContainer.style.bottom = '15px';
    viewerContainer.appendChild(animationContainer);
    this.map.animation = new Animation(animationContainer, new AnimationViewModel(clockViewModel));

    var timelineContainer = document.createElement('div');
    timelineContainer.className = 'cesium-viewer-timelineContainer';
    timelineContainer.style.right = '0px';
    timelineContainer.style.bottom = '15px';
    viewerContainer.appendChild(timelineContainer);
    var timeline = new Timeline(timelineContainer, clock);
    timeline.zoomTo(clock.startTime, clock.stopTime);
    this.map.timeline = timeline;

    var that = this;
    timeline.scrubFunction = function(e) {
        if (that.map.dragging.enabled()) {
            that.map.dragging.disable();
            that.map.on('mouseup', function(e) {
                that.map.dragging.enable();
            });
        }
        var clock = e.clock;
        clock.currentTime = e.timeJulian;
        clock.shouldAnimate = false;
    };
    timeline.addEventListener('settime', timeline.scrubFunction, false);
};

AusGlobeViewer.prototype.removeLeafletTimeline = function() {
    var viewerContainer = document.getElementById('cesiumContainer');

    if (defined(this.map.animation)) {
        viewerContainer.removeChild(this.map.animation.container);
        this.map.animation = this.map.animation.destroy();
    }

    if (defined(this.map.timeline)) {
        this.map.timeline.removeEventListener('settime', this.map.timeline.scrubFunction, false);
        viewerContainer.removeChild(this.map.timeline.container);
        this.map.timeline = this.map.timeline.destroy();
    }
};

function showTimeline(viewer) {
    $('.cesium-viewer-animationContainer').css('visibility', 'visible');
    $('.cesium-viewer-timelineContainer').css('visibility', 'visible');

    if (defined(viewer)) {
        viewer.forceResize();
    }
}

function hideTimeline(viewer) {
    $('.cesium-viewer-animationContainer').css('visibility', 'hidden');
    $('.cesium-viewer-timelineContainer').css('visibility', 'hidden');

    if (defined(viewer)) {
        viewer.forceResize();
    }
}

//update the timeline
AusGlobeViewer.prototype.updateTimeline = function(start, finish, cur, run) {
    var viewer = this.viewer;
    var clock = defined(viewer) ? this.viewer.clock : this.map.clock;
    var timeline = defined(viewer) ? this.viewer.timeline : this.map.timeline;

    if (start === undefined || finish === undefined) {
        hideTimeline(viewer);
        clock.clockRange = ClockRange.UNBOUNDED;
        clock.shouldAnimate = false;
    }
    else {
        showTimeline(viewer);
        clock.startTime = start;
        clock.currentTime = (defined(cur)) ? cur : start;
        clock.stopTime = finish;
        clock.multiplier = JulianDate.secondsDifference(finish, start) / 60.0;
        clock.clockRange = ClockRange.LOOP_STOP;
        clock.shouldAnimate = defined(run) ? run : false;
        timeline.zoomTo(clock.startTime, clock.stopTime);
    }
 };

 AusGlobeViewer.prototype.getTimelineSettings = function() {
    if ($('.cesium-viewer-timelineContainer').css('visibility') === 'hidden' ) {
        return {};
    }
    var viewer = this.viewer;
    var clock = defined(viewer) ? this.viewer.clock : this.map.clock;
    return {start: clock.startTime, stop: clock.stopTime, cur: clock.currentTime};
 };


var cartesian3Scratch = new Cartesian3();

// -------------------------------------------
// Camera management
// -------------------------------------------

//Camera extent approx for 2D viewer
function getCameraFocus(scene) {
    //Hack to get current camera focus
    var pos = Cartesian2.fromArray([$(document).width()/2,$(document).height()/2]);
    var pickRay = scene.camera.getPickRay(pos);
    var focus = scene.globe.pick(pickRay, scene);
    return focus;
}
//Approximate camera extent approx for 2D viewer
function getCameraRect(scene, map) {
    if (scene !== undefined) {
        var focus = getCameraFocus(scene);
        var focus_cart = Ellipsoid.WGS84.cartesianToCartographic(focus);
        var lat = CesiumMath.toDegrees(focus_cart.latitude);
        var lon = CesiumMath.toDegrees(focus_cart.longitude);

        var dist = Cartesian3.magnitude(Cartesian3.subtract(focus, scene.camera.position, cartesian3Scratch));
        var offset = dist * 2.5e-6;

        return Rectangle.fromDegrees(lon-offset, lat-offset, lon+offset, lat+offset);
    }
    else if (map !== undefined) {
        var bnds = map.getBounds();
        return Rectangle.fromDegrees(bnds.getWest(), bnds.getSouth(), bnds.getEast(), bnds.getNorth());
    }
}

function flyToPosition(scene, position, durationMilliseconds) {
    var camera = scene.camera;
    var startPosition = camera.position;
    var endPosition = position;

    durationMilliseconds = defaultValue(durationMilliseconds, 200);

    var initialEnuToFixed = Transforms.eastNorthUpToFixedFrame(startPosition, Ellipsoid.WGS84);

    var initialEnuToFixedRotation = new Matrix4();
    Matrix4.getRotation(initialEnuToFixed, initialEnuToFixedRotation);
    
    var initialFixedToEnuRotation = new Matrix3();
    Matrix3.transpose(initialEnuToFixedRotation, initialFixedToEnuRotation);

    var initialEnuUp = new Matrix3();
    Matrix3.multiplyByVector(initialFixedToEnuRotation, camera.up, initialEnuUp);

    var initialEnuRight = new Matrix3();
    Matrix3.multiplyByVector(initialFixedToEnuRotation, camera.right, initialEnuRight);

    var initialEnuDirection = new Matrix3();
    Matrix3.multiplyByVector(initialFixedToEnuRotation, camera.direction, initialEnuDirection);

    var controller = scene.screenSpaceCameraController;
    controller.enableInputs = false;

    scene.tweens.add({
        duration : durationMilliseconds / 1000.0,
        easingFunction : Tween.Easing.Sinusoidal.InOut,
        startObject : {
            time: 0.0
        },
        stopObject : {
            time : 1.0
        },
        update : function(value) {
            scene.camera.position.x = CesiumMath.lerp(startPosition.x, endPosition.x, value.time);
            scene.camera.position.y = CesiumMath.lerp(startPosition.y, endPosition.y, value.time);
            scene.camera.position.z = CesiumMath.lerp(startPosition.z, endPosition.z, value.time);

            var enuToFixed = Transforms.eastNorthUpToFixedFrame(camera.position, Ellipsoid.WGS84);

            var enuToFixedRotation = new Matrix3();
            Matrix4.getRotation(enuToFixed, enuToFixedRotation);

            camera.up = Matrix3.multiplyByVector(enuToFixedRotation, initialEnuUp, camera.up);
            camera.right = Matrix3.multiplyByVector(enuToFixedRotation, initialEnuRight, camera.right);
            camera.direction = Matrix3.multiplyByVector(enuToFixedRotation, initialEnuDirection, camera.direction);
        },
        complete : function() {
            controller.enableInputs = true;
        },
        cancel: function() {
            controller.enableInputs = true;
        }
    });
}

function zoomCamera(scene, distFactor, pos) { 
    var camera = scene.camera;
    var pickRay = camera.getPickRay(pos);
    var targetCartesian = scene.globe.pick(pickRay, scene);
    if (targetCartesian) {
        // Zoom to the picked latitude/longitude, at a distFactor multiple
        // of the height.
        var targetCartographic = Ellipsoid.WGS84.cartesianToCartographic(targetCartesian);
        var cameraCartographic = Ellipsoid.WGS84.cartesianToCartographic(camera.position);
        targetCartographic.height = cameraCartographic.height - (cameraCartographic.height - targetCartographic.height) * distFactor;
        targetCartesian = Ellipsoid.WGS84.cartographicToCartesian(targetCartographic);
        flyToPosition(scene, targetCartesian);
    }
}

function zoomIn(scene, pos) { zoomCamera(scene, 2.0/3.0, pos); }
function zoomOut(scene, pos) { zoomCamera(scene, -2.0, pos); }

// Move camera to Rectangle
AusGlobeViewer.prototype.updateCameraFromRect = function(rect_in, flightTimeMilliseconds) {
    if (rect_in === undefined) {
        return;
    }

    var scene = this.scene;
    var map = this.map;
    
    //check that we're not too close
    var epsilon = CesiumMath.EPSILON3;
    var rect = rect_in.clone();
    if ((rect.east - rect.west) < epsilon) {
        rect.east += epsilon;
        rect.west -= epsilon;
    }
    if ((rect.north - rect.south) < epsilon) {
        rect.north += epsilon;
        rect.south -= epsilon;
    }
    if (scene !== undefined && !scene.isDestroyed()) {
        var flight = CameraFlightPath.createTweenRectangle(scene, {
            destination : rect,
            duration: flightTimeMilliseconds / 1000.0
        });
        scene.tweens.add(flight);
    }
    else if (map !== undefined) {
        var bnds = [[CesiumMath.toDegrees(rect.south), CesiumMath.toDegrees(rect.west)],
            [CesiumMath.toDegrees(rect.north), CesiumMath.toDegrees(rect.east)]];
        map.fitBounds(bnds);
    }
};

function getWmsFeatureInfo(baseUrl, useProxy, layers, extent, width, height, i, j, useWebMercator, wmsFeatureInfoFilter) {
    var url = baseUrl;
    var indexOfQuestionMark = url.indexOf('?');
    if (indexOfQuestionMark >= 0 && indexOfQuestionMark < url.length - 1) {
        if (url[url.length - 1] !== '&') {
            url += '&';
        }
    } else if (indexOfQuestionMark < 0) {
        url += '?';
    }

    var srs;
    var sw;
    var ne;
    if (useWebMercator) {
        srs = 'EPSG:3857';
        
        var projection = new WebMercatorProjection();
        sw = projection.project(Rectangle.southwest(extent));
        ne = projection.project(Rectangle.northeast(extent));
    } else {
        srs = 'EPSG:4326';
        sw = new Cartesian3(CesiumMath.toDegrees(extent.west), CesiumMath.toDegrees(extent.south), 0.0);
        ne = new Cartesian3(CesiumMath.toDegrees(extent.east), CesiumMath.toDegrees(extent.north), 0.0);
    }

    url += 'service=WMS&request=GetFeatureInfo&version=1.1.1&layers=' + layers + '&query_layers=' + layers + 
           '&srs=' + srs + '&width=' + width + '&height=' + height + '&info_format=application/json' +
           '&x=' + i + '&y=' + j + '&';


    var bbox = sw.x + ',' + sw.y + ',' + ne.x + ',' + ne.y;
    url += 'bbox=' + bbox + '&';

    if (useProxy) {
        url = corsProxy.getURL(url);
    }

    return when(loadJson(url), function(json) {
        if (defined(wmsFeatureInfoFilter)) {
            json = wmsFeatureInfoFilter(json);
        }
        return json;
    }, function (e) {
        // If something goes wrong, try requesting XML instead of GeoJSON.  Then try to interpret it.
        url = url.replace('info_format=application/json', 'info_format=text/xml');
        return loadXML(url);
    });
}

function selectFeatureLeaflet(viewer, latlng) {
    var dataSources = viewer.application.nowViewing.items;

    var pickedXY = viewer.map.latLngToContainerPoint(latlng, viewer.map.getZoom());
    var bounds = viewer.map.getBounds();
    var extent = new Rectangle(CesiumMath.toRadians(bounds.getWest()), CesiumMath.toRadians(bounds.getSouth()), CesiumMath.toRadians(bounds.getEast()), CesiumMath.toRadians(bounds.getNorth()));

    var promises = [];
    for (var i = 0; i < dataSources.length ; ++i) {
        var dataSource = dataSources[i];
        if (dataSource.type === 'wms' || (dataSource.type === 'csv' && defined(dataSource.layers))) {
            var useProxy = corsProxy.shouldUseProxy(dataSource.url);
            promises.push(getWmsFeatureInfo(dataSource.url, useProxy, dataSource.layers, 
                extent, viewer.map.getSize().x, viewer.map.getSize().y, pickedXY.x, pickedXY.y, true, 
                dataSource.wmsFeatureInfoFilter));
        }
    }

    if (promises.length === 0) {
        return;
    }

    selectFeatures(promises, viewer.map, latlng);
}


function selectFeatures(promises, viewer, latlng) {
    var nextPromiseIndex = 0;

    function waitForNextLayersResponse() {
        if (nextPromiseIndex >= promises.length) {
            updatePopup( 'None', 'No features found.');
            return;
        }

        when(promises[nextPromiseIndex++], function(result) {
            function findGoodIdProperty(properties) {
                for (var key in properties) {
                    if (properties.hasOwnProperty(key) && properties[key]) {
                        if (/name/i.test(key) || /title/i.test(key)|| /id/i.test(key)) {
                            return properties[key];
                        }
                    }
                }

                return undefined;
            }

            function describe(properties) {
                var html = '<table class="cesium-infoBox-defaultTable">';
                for ( var key in properties) {
                    if (properties.hasOwnProperty(key)) {
                        var value = properties[key];
                        if (defined(value)) {
                            if (typeof value === 'object') {
                                html += '<tr><td>' + key + '</td><td>' + describe(value) + '</td></tr>';
                            } else {
                                html += '<tr><td>' + key + '</td><td>' + value + '</td></tr>';
                            }
                        }
                    }
                }
                html += '</table>';
                return html;
            }

            // Handle MapInfo MXP.  This is ugly.
            if (result instanceof Document || defined(result.xml)) {
                var json = $.xml2json(result);

                // xml2json returns namespaced property names in IE9.
                if (json['mxp:FeatureCollection']) {
                    json.FeatureCollection = json['mxp:FeatureCollection'];
                    if (json.FeatureCollection['mxp:FeatureMembers']) {
                        json.FeatureCollection.FeatureMembers = json.FeatureCollection['mxp:FeatureMembers'];
                        if (json.FeatureCollection.FeatureMembers['mxp:Feature']) {
                            json.FeatureCollection.FeatureMembers.Feature = json.FeatureCollection.FeatureMembers['mxp:Feature'];
                            if (json.FeatureCollection.FeatureMembers.Feature['mxp:Val']) {
                                json.FeatureCollection.FeatureMembers.Feature.Val = json.FeatureCollection.FeatureMembers.Feature['mxp:Val'];
                            }
                        }
                    }
                }

                var properties;
                if (json.FeatureCollection &&
                    json.FeatureCollection.FeatureMembers && 
                    json.FeatureCollection.FeatureMembers.Feature && 
                    json.FeatureCollection.FeatureMembers.Feature.Val) {

                    properties = {};
                    result = {
                        features : [
                            {
                                properties : properties
                            }
                        ]
                    };

                    var vals = json.FeatureCollection.FeatureMembers.Feature.Val;
                    for (var i = 0; i < vals.length; ++i) {
                        properties[vals[i].ref] = vals[i].text;
                    }
                } else if (json.FIELDS) {
                    properties = {};
                    result = {
                        features : [
                            {
                                properties : properties
                            }
                        ]
                    };

                    var fields = json.FIELDS;
                    for (var field in fields) {
                        if (fields.hasOwnProperty(field)) {
                            properties[field] = fields[field];
                        }
                    }
                }
            }

            if (!defined(result) || !defined(result.features) || result.features.length === 0) {
                waitForNextLayersResponse();
                return;
            }

            // Show information for the first selected feature.
            var feature = result.features[0];
            if (defined(feature)) {
                updatePopup( findGoodIdProperty(feature.properties), describe(feature.properties) );
            } else {
                updatePopup( 'None', 'No features found.');
            }
        }, function() {
            waitForNextLayersResponse();
        });
    }

    waitForNextLayersResponse();

        //create popup but don't show it
    var popup = L.popup({maxHeight: 520 }).setLatLng(latlng);
    function updatePopup(title, text) {
        popup.setContent('<h3><center>'+title+'</center></h3>'+text);
    }
        // Show placeholder text to the infobox so the user knows something is happening.
    updatePopup('', 'Loading WMS feature information...');

        // Wait for .5 seconds to show to let double click through
    setTimeout(function() { popup.openOn(viewer); }, 500);
    
}

module.exports = AusGlobeViewer;

},{"../../third_party/cesium/Source/Core/BingMapsApi":96,"../../third_party/cesium/Source/Core/Cartesian2":101,"../../third_party/cesium/Source/Core/Cartesian3":102,"../../third_party/cesium/Source/Core/Cartographic":104,"../../third_party/cesium/Source/Core/CesiumTerrainProvider":105,"../../third_party/cesium/Source/Core/Clock":108,"../../third_party/cesium/Source/Core/ClockRange":109,"../../third_party/cesium/Source/Core/Color":111,"../../third_party/cesium/Source/Core/Credit":118,"../../third_party/cesium/Source/Core/Ellipsoid":130,"../../third_party/cesium/Source/Core/EllipsoidTerrainProvider":135,"../../third_party/cesium/Source/Core/EventHelper":139,"../../third_party/cesium/Source/Core/FeatureDetection":141,"../../third_party/cesium/Source/Core/JulianDate":168,"../../third_party/cesium/Source/Core/KeyboardEventModifier":169,"../../third_party/cesium/Source/Core/Math":174,"../../third_party/cesium/Source/Core/Matrix3":176,"../../third_party/cesium/Source/Core/Matrix4":177,"../../third_party/cesium/Source/Core/Rectangle":201,"../../third_party/cesium/Source/Core/ScreenSpaceEventHandler":208,"../../third_party/cesium/Source/Core/ScreenSpaceEventType":209,"../../third_party/cesium/Source/Core/Transforms":226,"../../third_party/cesium/Source/Core/WebMercatorProjection":233,"../../third_party/cesium/Source/Core/defaultValue":243,"../../third_party/cesium/Source/Core/defined":245,"../../third_party/cesium/Source/Core/loadJson":261,"../../third_party/cesium/Source/Core/loadXML":264,"../../third_party/cesium/Source/DataSources/DataSourceDisplay":290,"../../third_party/cesium/Source/Scene/CameraFlightPath":378,"../../third_party/cesium/Source/Scene/FrameRateMonitor":387,"../../third_party/cesium/Source/Scene/Material":404,"../../third_party/cesium/Source/Scene/RectanglePrimitive":436,"../../third_party/cesium/Source/Scene/SingleTileImageryProvider":442,"../../third_party/cesium/Source/ThirdParty/Tween":586,"../../third_party/cesium/Source/ThirdParty/knockout":591,"../../third_party/cesium/Source/ThirdParty/when":596,"../../third_party/cesium/Source/Widgets/Animation/Animation":598,"../../third_party/cesium/Source/Widgets/Animation/AnimationViewModel":599,"../../third_party/cesium/Source/Widgets/ClockViewModel":606,"../../third_party/cesium/Source/Widgets/InfoBox/InfoBox":613,"../../third_party/cesium/Source/Widgets/Timeline/Timeline":622,"../../third_party/cesium/Source/Widgets/Viewer/Viewer":626,"../Core/corsProxy":5,"../Core/runLater":13,"../Map/LeafletVisualizer":15,"../Map/rectangleToLatLngBounds":20,"../Models/Cesium":29,"../Models/Leaflet":38,"../Models/ViewerMode":45,"../ViewModels/PopupMessageViewModel":85}],93:[function(require,module,exports){
var defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError');
'use strict';
var AssociativeArray = function () {
    this._array = [];
    this._hash = {};
};
defineProperties(AssociativeArray.prototype, {
    length: {
        get: function () {
            return this._array.length;
        }
    },
    values: {
        get: function () {
            return this._array;
        }
    }
});
AssociativeArray.prototype.contains = function (key) {
    if (typeof key !== 'string' && typeof key !== 'number') {
        throw new DeveloperError('key is required to be a string or number.');
    }
    return defined(this._hash[key]);
};
AssociativeArray.prototype.set = function (key, value) {
    if (typeof key !== 'string' && typeof key !== 'number') {
        throw new DeveloperError('key is required to be a string or number.');
    }
    var oldValue = this._hash[key];
    if (value !== oldValue) {
        this.remove(key);
        this._hash[key] = value;
        this._array.push(value);
    }
};
AssociativeArray.prototype.get = function (key) {
    if (typeof key !== 'string' && typeof key !== 'number') {
        throw new DeveloperError('key is required to be a string or number.');
    }
    return this._hash[key];
};
AssociativeArray.prototype.remove = function (key) {
    if (defined(key) && typeof key !== 'string' && typeof key !== 'number') {
        throw new DeveloperError('key is required to be a string or number.');
    }
    var value = this._hash[key];
    var hasValue = defined(value);
    if (hasValue) {
        var array = this._array;
        array.splice(array.indexOf(value), 1);
        this._hash[key] = undefined;
    }
    return hasValue;
};
AssociativeArray.prototype.removeAll = function () {
    this._hash = {};
    this._array.length = 0;
};
module.exports = AssociativeArray;
},{"./DeveloperError":123,"./defineProperties":244,"./defined":245}],94:[function(require,module,exports){
var Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), CesiumMath = require('./Math');
'use strict';
var AttributeCompression = {};
AttributeCompression.octEncode = function (vector, result) {
    if (!defined(vector)) {
        throw new DeveloperError('vector is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var magSquared = Cartesian3.magnitudeSquared(vector);
    if (Math.abs(magSquared - 1) > CesiumMath.EPSILON6) {
        throw new DeveloperError('vector must be normalized.');
    }
    result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));
    result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));
    if (vector.z < 0) {
        var x = result.x;
        var y = result.y;
        result.x = (1 - Math.abs(y)) * CesiumMath.signNotZero(x);
        result.y = (1 - Math.abs(x)) * CesiumMath.signNotZero(y);
    }
    result.x = CesiumMath.toSNorm(result.x);
    result.y = CesiumMath.toSNorm(result.y);
    return result;
};
AttributeCompression.octDecode = function (x, y, result) {
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    if (x < 0 || x > 255 || y < 0 || y > 255) {
        throw new DeveloperError('x and y must be a signed normalized integer between 0 and 255');
    }
    result.x = CesiumMath.fromSNorm(x);
    result.y = CesiumMath.fromSNorm(y);
    result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
    if (result.z < 0) {
        var oldVX = result.x;
        result.x = (1 - Math.abs(result.y)) * CesiumMath.signNotZero(oldVX);
        result.y = (1 - Math.abs(oldVX)) * CesiumMath.signNotZero(result.y);
    }
    return Cartesian3.normalize(result, result);
};
AttributeCompression.octPackFloat = function (encoded) {
    if (!defined(encoded)) {
        throw new DeveloperError('encoded is required.');
    }
    return 256 * encoded.x + encoded.y;
};
var scratchEncodeCart2 = new Cartesian2();
AttributeCompression.octEncodeFloat = function (vector) {
    AttributeCompression.octEncode(vector, scratchEncodeCart2);
    return AttributeCompression.octPackFloat(scratchEncodeCart2);
};
AttributeCompression.octDecodeFloat = function (value, result) {
    if (!defined(value)) {
        throw new DeveloperError('value is required.');
    }
    var temp = value / 256;
    var x = Math.floor(temp);
    var y = (temp - x) * 256;
    return AttributeCompression.octDecode(x, y, result);
};
AttributeCompression.octPack = function (v1, v2, v3, result) {
    if (!defined(v1)) {
        throw new DeveloperError('v1 is required.');
    }
    if (!defined(v2)) {
        throw new DeveloperError('v2 is required.');
    }
    if (!defined(v3)) {
        throw new DeveloperError('v3 is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var encoded1 = AttributeCompression.octEncodeFloat(v1);
    var encoded2 = AttributeCompression.octEncodeFloat(v2);
    var encoded3 = AttributeCompression.octEncode(v3, scratchEncodeCart2);
    result.x = 65536 * encoded3.x + encoded1;
    result.y = 65536 * encoded3.y + encoded2;
    return result;
};
AttributeCompression.octUnpack = function (packed, v1, v2, v3) {
    if (!defined(packed)) {
        throw new DeveloperError('packed is required.');
    }
    if (!defined(v1)) {
        throw new DeveloperError('v1 is required.');
    }
    if (!defined(v2)) {
        throw new DeveloperError('v2 is required.');
    }
    if (!defined(v3)) {
        throw new DeveloperError('v3 is required.');
    }
    var temp = packed.x / 65536;
    var x = Math.floor(temp);
    var encodedFloat1 = (temp - x) * 65536;
    temp = packed.y / 65536;
    var y = Math.floor(temp);
    var encodedFloat2 = (temp - y) * 65536;
    AttributeCompression.octDecodeFloat(encodedFloat1, v1);
    AttributeCompression.octDecodeFloat(encodedFloat2, v2);
    AttributeCompression.octDecode(x, y, v3);
};
AttributeCompression.compressTextureCoordinates = function (textureCoordinates) {
    if (!defined(textureCoordinates)) {
        throw new DeveloperError('textureCoordinates is required.');
    }
    var x = textureCoordinates.x === 1 ? 4095 : textureCoordinates.x * 4096 | 0;
    var y = textureCoordinates.y === 1 ? 4095 : textureCoordinates.y * 4096 | 0;
    return 4096 * x + y;
};
AttributeCompression.decompressTextureCoordinates = function (compressed, result) {
    if (!defined(compressed)) {
        throw new DeveloperError('compressed is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var temp = compressed / 4096;
    result.x = Math.floor(temp) / 4096;
    result.y = temp - Math.floor(temp);
    return result;
};
module.exports = AttributeCompression;
},{"./Cartesian2":101,"./Cartesian3":102,"./DeveloperError":123,"./Math":174,"./defined":245}],95:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Intersect = require('./Intersect');
'use strict';
var AxisAlignedBoundingBox = function (minimum, maximum, center) {
    this.minimum = Cartesian3.clone(defaultValue(minimum, Cartesian3.ZERO));
    this.maximum = Cartesian3.clone(defaultValue(maximum, Cartesian3.ZERO));
    if (!defined(center)) {
        center = Cartesian3.add(this.minimum, this.maximum, new Cartesian3());
        Cartesian3.multiplyByScalar(center, 0.5, center);
    } else {
        center = Cartesian3.clone(center);
    }
    this.center = center;
};
AxisAlignedBoundingBox.fromPoints = function (positions, result) {
    if (!defined(result)) {
        result = new AxisAlignedBoundingBox();
    }
    if (!defined(positions) || positions.length === 0) {
        result.minimum = Cartesian3.clone(Cartesian3.ZERO, result.minimum);
        result.maximum = Cartesian3.clone(Cartesian3.ZERO, result.maximum);
        result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
        return result;
    }
    var minimumX = positions[0].x;
    var minimumY = positions[0].y;
    var minimumZ = positions[0].z;
    var maximumX = positions[0].x;
    var maximumY = positions[0].y;
    var maximumZ = positions[0].z;
    var length = positions.length;
    for (var i = 1; i < length; i++) {
        var p = positions[i];
        var x = p.x;
        var y = p.y;
        var z = p.z;
        minimumX = Math.min(x, minimumX);
        maximumX = Math.max(x, maximumX);
        minimumY = Math.min(y, minimumY);
        maximumY = Math.max(y, maximumY);
        minimumZ = Math.min(z, minimumZ);
        maximumZ = Math.max(z, maximumZ);
    }
    var minimum = result.minimum;
    minimum.x = minimumX;
    minimum.y = minimumY;
    minimum.z = minimumZ;
    var maximum = result.maximum;
    maximum.x = maximumX;
    maximum.y = maximumY;
    maximum.z = maximumZ;
    var center = Cartesian3.add(minimum, maximum, result.center);
    Cartesian3.multiplyByScalar(center, 0.5, center);
    return result;
};
AxisAlignedBoundingBox.clone = function (box, result) {
    if (!defined(box)) {
        return undefined;
    }
    if (!defined(result)) {
        return new AxisAlignedBoundingBox(box.minimum, box.maximum);
    }
    result.minimum = Cartesian3.clone(box.minimum, result.minimum);
    result.maximum = Cartesian3.clone(box.maximum, result.maximum);
    result.center = Cartesian3.clone(box.center, result.center);
    return result;
};
AxisAlignedBoundingBox.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && Cartesian3.equals(left.minimum, right.minimum) && Cartesian3.equals(left.maximum, right.maximum);
};
var intersectScratch = new Cartesian3();
AxisAlignedBoundingBox.intersect = function (box, plane) {
    if (!defined(box)) {
        throw new DeveloperError('box is required.');
    }
    if (!defined(plane)) {
        throw new DeveloperError('plane is required.');
    }
    intersectScratch = Cartesian3.subtract(box.maximum, box.minimum, intersectScratch);
    var h = Cartesian3.multiplyByScalar(intersectScratch, 0.5, intersectScratch);
    var e = h.x * Math.abs(plane.x) + h.y * Math.abs(plane.y) + h.z * Math.abs(plane.z);
    var s = Cartesian3.dot(box.center, plane) + plane.w;
    if (s - e > 0) {
        return Intersect.INSIDE;
    }
    if (s + e < 0) {
        return Intersect.OUTSIDE;
    }
    return Intersect.INTERSECTING;
};
AxisAlignedBoundingBox.prototype.clone = function (result) {
    return AxisAlignedBoundingBox.clone(this, result);
};
AxisAlignedBoundingBox.prototype.intersect = function (plane) {
    return AxisAlignedBoundingBox.intersect(this, plane);
};
AxisAlignedBoundingBox.prototype.equals = function (right) {
    return AxisAlignedBoundingBox.equals(this, right);
};
module.exports = AxisAlignedBoundingBox;
},{"./Cartesian3":102,"./DeveloperError":123,"./Intersect":163,"./defaultValue":243,"./defined":245}],96:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var BingMapsApi = {};
BingMapsApi.defaultKey = undefined;
var printedBingWarning = false;
BingMapsApi.getKey = function (providedKey) {
    if (defined(providedKey)) {
        return providedKey;
    }
    if (!defined(BingMapsApi.defaultKey)) {
        if (!printedBingWarning) {
            console.log('This application is using Cesium\'s default Bing Maps key.  Please create a new key for the application as soon as possible and prior to deployment by visiting https://www.bingmapsportal.com/, and provide your key to Cesium by setting the Cesium.BingMapsApi.defaultKey property before constructing the CesiumWidget or any other object that uses the Bing Maps API.');
            printedBingWarning = true;
        }
        return 'Aj1ony_-Typ-KjG9SJWiKSHY23U1KmK7yAmZa9lDmuF2osXWkcZ22VPsqmCt0TCt';
    }
    return BingMapsApi.defaultKey;
};
module.exports = BingMapsApi;
},{"./defined":245}],97:[function(require,module,exports){
var Cartesian2 = require('./Cartesian2'), Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), GeographicProjection = require('./GeographicProjection'), Intersect = require('./Intersect'), Rectangle = require('./Rectangle');
'use strict';
var BoundingRectangle = function (x, y, width, height) {
    this.x = defaultValue(x, 0);
    this.y = defaultValue(y, 0);
    this.width = defaultValue(width, 0);
    this.height = defaultValue(height, 0);
};
BoundingRectangle.fromPoints = function (positions, result) {
    if (!defined(result)) {
        result = new BoundingRectangle();
    }
    if (!defined(positions) || positions.length === 0) {
        result.x = 0;
        result.y = 0;
        result.width = 0;
        result.height = 0;
        return result;
    }
    var length = positions.length;
    var minimumX = positions[0].x;
    var minimumY = positions[0].y;
    var maximumX = positions[0].x;
    var maximumY = positions[0].y;
    for (var i = 1; i < length; i++) {
        var p = positions[i];
        var x = p.x;
        var y = p.y;
        minimumX = Math.min(x, minimumX);
        maximumX = Math.max(x, maximumX);
        minimumY = Math.min(y, minimumY);
        maximumY = Math.max(y, maximumY);
    }
    result.x = minimumX;
    result.y = minimumY;
    result.width = maximumX - minimumX;
    result.height = maximumY - minimumY;
    return result;
};
var defaultProjection = new GeographicProjection();
var fromRectangleLowerLeft = new Cartographic();
var fromRectangleUpperRight = new Cartographic();
BoundingRectangle.fromRectangle = function (rectangle, projection, result) {
    if (!defined(result)) {
        result = new BoundingRectangle();
    }
    if (!defined(rectangle)) {
        result.x = 0;
        result.y = 0;
        result.width = 0;
        result.height = 0;
        return result;
    }
    projection = defaultValue(projection, defaultProjection);
    var lowerLeft = projection.project(Rectangle.southwest(rectangle, fromRectangleLowerLeft));
    var upperRight = projection.project(Rectangle.northeast(rectangle, fromRectangleUpperRight));
    Cartesian2.subtract(upperRight, lowerLeft, upperRight);
    result.x = lowerLeft.x;
    result.y = lowerLeft.y;
    result.width = upperRight.x;
    result.height = upperRight.y;
    return result;
};
BoundingRectangle.clone = function (rectangle, result) {
    if (!defined(rectangle)) {
        return undefined;
    }
    if (!defined(result)) {
        return new BoundingRectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    }
    result.x = rectangle.x;
    result.y = rectangle.y;
    result.width = rectangle.width;
    result.height = rectangle.height;
    return result;
};
BoundingRectangle.union = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    if (!defined(result)) {
        result = new BoundingRectangle();
    }
    var lowerLeftX = Math.min(left.x, right.x);
    var lowerLeftY = Math.min(left.y, right.y);
    var upperRightX = Math.max(left.x + left.width, right.x + right.width);
    var upperRightY = Math.max(left.y + left.height, right.y + right.height);
    result.x = lowerLeftX;
    result.y = lowerLeftY;
    result.width = upperRightX - lowerLeftX;
    result.height = upperRightY - lowerLeftY;
    return result;
};
BoundingRectangle.expand = function (rectangle, point, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    if (!defined(point)) {
        throw new DeveloperError('point is required.');
    }
    result = BoundingRectangle.clone(rectangle, result);
    var width = point.x - result.x;
    var height = point.y - result.y;
    if (width > result.width) {
        result.width = width;
    } else if (width < 0) {
        result.width -= width;
        result.x = point.x;
    }
    if (height > result.height) {
        result.height = height;
    } else if (height < 0) {
        result.height -= height;
        result.y = point.y;
    }
    return result;
};
BoundingRectangle.intersect = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    var leftX = left.x;
    var leftY = left.y;
    var rightX = right.x;
    var rightY = right.y;
    if (!(leftX > rightX + right.width || leftX + left.width < rightX || leftY + left.height < rightY || leftY > rightY + right.height)) {
        return Intersect.INTERSECTING;
    }
    return Intersect.OUTSIDE;
};
BoundingRectangle.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.width === right.width && left.height === right.height;
};
BoundingRectangle.prototype.clone = function (result) {
    return BoundingRectangle.clone(this, result);
};
BoundingRectangle.prototype.intersect = function (right) {
    return BoundingRectangle.intersect(this, right);
};
BoundingRectangle.prototype.equals = function (right) {
    return BoundingRectangle.equals(this, right);
};
module.exports = BoundingRectangle;
},{"./Cartesian2":101,"./Cartographic":104,"./DeveloperError":123,"./GeographicProjection":143,"./Intersect":163,"./Rectangle":201,"./defaultValue":243,"./defined":245}],98:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), GeographicProjection = require('./GeographicProjection'), Intersect = require('./Intersect'), Interval = require('./Interval'), Matrix4 = require('./Matrix4'), Rectangle = require('./Rectangle');
'use strict';
var BoundingSphere = function (center, radius) {
    this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));
    this.radius = defaultValue(radius, 0);
};
var fromPointsXMin = new Cartesian3();
var fromPointsYMin = new Cartesian3();
var fromPointsZMin = new Cartesian3();
var fromPointsXMax = new Cartesian3();
var fromPointsYMax = new Cartesian3();
var fromPointsZMax = new Cartesian3();
var fromPointsCurrentPos = new Cartesian3();
var fromPointsScratch = new Cartesian3();
var fromPointsRitterCenter = new Cartesian3();
var fromPointsMinBoxPt = new Cartesian3();
var fromPointsMaxBoxPt = new Cartesian3();
var fromPointsNaiveCenterScratch = new Cartesian3();
BoundingSphere.fromPoints = function (positions, result) {
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    if (!defined(positions) || positions.length === 0) {
        result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
        result.radius = 0;
        return result;
    }
    var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);
    var xMin = Cartesian3.clone(currentPos, fromPointsXMin);
    var yMin = Cartesian3.clone(currentPos, fromPointsYMin);
    var zMin = Cartesian3.clone(currentPos, fromPointsZMin);
    var xMax = Cartesian3.clone(currentPos, fromPointsXMax);
    var yMax = Cartesian3.clone(currentPos, fromPointsYMax);
    var zMax = Cartesian3.clone(currentPos, fromPointsZMax);
    var numPositions = positions.length;
    for (var i = 1; i < numPositions; i++) {
        Cartesian3.clone(positions[i], currentPos);
        var x = currentPos.x;
        var y = currentPos.y;
        var z = currentPos.z;
        if (x < xMin.x) {
            Cartesian3.clone(currentPos, xMin);
        }
        if (x > xMax.x) {
            Cartesian3.clone(currentPos, xMax);
        }
        if (y < yMin.y) {
            Cartesian3.clone(currentPos, yMin);
        }
        if (y > yMax.y) {
            Cartesian3.clone(currentPos, yMax);
        }
        if (z < zMin.z) {
            Cartesian3.clone(currentPos, zMin);
        }
        if (z > zMax.z) {
            Cartesian3.clone(currentPos, zMax);
        }
    }
    var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));
    var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));
    var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));
    var diameter1 = xMin;
    var diameter2 = xMax;
    var maxSpan = xSpan;
    if (ySpan > maxSpan) {
        maxSpan = ySpan;
        diameter1 = yMin;
        diameter2 = yMax;
    }
    if (zSpan > maxSpan) {
        maxSpan = zSpan;
        diameter1 = zMin;
        diameter2 = zMax;
    }
    var ritterCenter = fromPointsRitterCenter;
    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
    var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));
    var ritterRadius = Math.sqrt(radiusSquared);
    var minBoxPt = fromPointsMinBoxPt;
    minBoxPt.x = xMin.x;
    minBoxPt.y = yMin.y;
    minBoxPt.z = zMin.z;
    var maxBoxPt = fromPointsMaxBoxPt;
    maxBoxPt.x = xMax.x;
    maxBoxPt.y = yMax.y;
    maxBoxPt.z = zMax.z;
    var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5, fromPointsNaiveCenterScratch);
    var naiveRadius = 0;
    for (i = 0; i < numPositions; i++) {
        Cartesian3.clone(positions[i], currentPos);
        var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));
        if (r > naiveRadius) {
            naiveRadius = r;
        }
        var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));
        if (oldCenterToPointSquared > radiusSquared) {
            var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
            ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
            radiusSquared = ritterRadius * ritterRadius;
            var oldToNew = oldCenterToPoint - ritterRadius;
            ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
            ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
            ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
        }
    }
    if (ritterRadius < naiveRadius) {
        Cartesian3.clone(ritterCenter, result.center);
        result.radius = ritterRadius;
    } else {
        Cartesian3.clone(naiveCenter, result.center);
        result.radius = naiveRadius;
    }
    return result;
};
var defaultProjection = new GeographicProjection();
var fromRectangle2DLowerLeft = new Cartesian3();
var fromRectangle2DUpperRight = new Cartesian3();
var fromRectangle2DSouthwest = new Cartographic();
var fromRectangle2DNortheast = new Cartographic();
BoundingSphere.fromRectangle2D = function (rectangle, projection, result) {
    return BoundingSphere.fromRectangleWithHeights2D(rectangle, projection, 0, 0, result);
};
BoundingSphere.fromRectangleWithHeights2D = function (rectangle, projection, minimumHeight, maximumHeight, result) {
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    if (!defined(rectangle)) {
        result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
        result.radius = 0;
        return result;
    }
    projection = defaultValue(projection, defaultProjection);
    Rectangle.southwest(rectangle, fromRectangle2DSouthwest);
    fromRectangle2DSouthwest.height = minimumHeight;
    Rectangle.northeast(rectangle, fromRectangle2DNortheast);
    fromRectangle2DNortheast.height = maximumHeight;
    var lowerLeft = projection.project(fromRectangle2DSouthwest, fromRectangle2DLowerLeft);
    var upperRight = projection.project(fromRectangle2DNortheast, fromRectangle2DUpperRight);
    var width = upperRight.x - lowerLeft.x;
    var height = upperRight.y - lowerLeft.y;
    var elevation = upperRight.z - lowerLeft.z;
    result.radius = Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;
    var center = result.center;
    center.x = lowerLeft.x + width * 0.5;
    center.y = lowerLeft.y + height * 0.5;
    center.z = lowerLeft.z + elevation * 0.5;
    return result;
};
var fromRectangle3DScratch = [];
BoundingSphere.fromRectangle3D = function (rectangle, ellipsoid, surfaceHeight, result) {
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    surfaceHeight = defaultValue(surfaceHeight, 0);
    var positions;
    if (defined(rectangle)) {
        positions = Rectangle.subsample(rectangle, ellipsoid, surfaceHeight, fromRectangle3DScratch);
    }
    return BoundingSphere.fromPoints(positions, result);
};
BoundingSphere.fromVertices = function (positions, center, stride, result) {
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    if (!defined(positions) || positions.length === 0) {
        result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
        result.radius = 0;
        return result;
    }
    center = defaultValue(center, Cartesian3.ZERO);
    stride = defaultValue(stride, 3);
    if (stride < 3) {
        throw new DeveloperError('stride must be 3 or greater.');
    }
    var currentPos = fromPointsCurrentPos;
    currentPos.x = positions[0] + center.x;
    currentPos.y = positions[1] + center.y;
    currentPos.z = positions[2] + center.z;
    var xMin = Cartesian3.clone(currentPos, fromPointsXMin);
    var yMin = Cartesian3.clone(currentPos, fromPointsYMin);
    var zMin = Cartesian3.clone(currentPos, fromPointsZMin);
    var xMax = Cartesian3.clone(currentPos, fromPointsXMax);
    var yMax = Cartesian3.clone(currentPos, fromPointsYMax);
    var zMax = Cartesian3.clone(currentPos, fromPointsZMax);
    var numElements = positions.length;
    for (var i = 0; i < numElements; i += stride) {
        var x = positions[i] + center.x;
        var y = positions[i + 1] + center.y;
        var z = positions[i + 2] + center.z;
        currentPos.x = x;
        currentPos.y = y;
        currentPos.z = z;
        if (x < xMin.x) {
            Cartesian3.clone(currentPos, xMin);
        }
        if (x > xMax.x) {
            Cartesian3.clone(currentPos, xMax);
        }
        if (y < yMin.y) {
            Cartesian3.clone(currentPos, yMin);
        }
        if (y > yMax.y) {
            Cartesian3.clone(currentPos, yMax);
        }
        if (z < zMin.z) {
            Cartesian3.clone(currentPos, zMin);
        }
        if (z > zMax.z) {
            Cartesian3.clone(currentPos, zMax);
        }
    }
    var xSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(xMax, xMin, fromPointsScratch));
    var ySpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(yMax, yMin, fromPointsScratch));
    var zSpan = Cartesian3.magnitudeSquared(Cartesian3.subtract(zMax, zMin, fromPointsScratch));
    var diameter1 = xMin;
    var diameter2 = xMax;
    var maxSpan = xSpan;
    if (ySpan > maxSpan) {
        maxSpan = ySpan;
        diameter1 = yMin;
        diameter2 = yMax;
    }
    if (zSpan > maxSpan) {
        maxSpan = zSpan;
        diameter1 = zMin;
        diameter2 = zMax;
    }
    var ritterCenter = fromPointsRitterCenter;
    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;
    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;
    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;
    var radiusSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch));
    var ritterRadius = Math.sqrt(radiusSquared);
    var minBoxPt = fromPointsMinBoxPt;
    minBoxPt.x = xMin.x;
    minBoxPt.y = yMin.y;
    minBoxPt.z = zMin.z;
    var maxBoxPt = fromPointsMaxBoxPt;
    maxBoxPt.x = xMax.x;
    maxBoxPt.y = yMax.y;
    maxBoxPt.z = zMax.z;
    var naiveCenter = Cartesian3.multiplyByScalar(Cartesian3.add(minBoxPt, maxBoxPt, fromPointsScratch), 0.5, fromPointsNaiveCenterScratch);
    var naiveRadius = 0;
    for (i = 0; i < numElements; i += stride) {
        currentPos.x = positions[i] + center.x;
        currentPos.y = positions[i + 1] + center.y;
        currentPos.z = positions[i + 2] + center.z;
        var r = Cartesian3.magnitude(Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch));
        if (r > naiveRadius) {
            naiveRadius = r;
        }
        var oldCenterToPointSquared = Cartesian3.magnitudeSquared(Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch));
        if (oldCenterToPointSquared > radiusSquared) {
            var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
            ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
            radiusSquared = ritterRadius * ritterRadius;
            var oldToNew = oldCenterToPoint - ritterRadius;
            ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;
            ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;
            ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;
        }
    }
    if (ritterRadius < naiveRadius) {
        Cartesian3.clone(ritterCenter, result.center);
        result.radius = ritterRadius;
    } else {
        Cartesian3.clone(naiveCenter, result.center);
        result.radius = naiveRadius;
    }
    return result;
};
BoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {
    if (!defined(corner) || !defined(oppositeCorner)) {
        throw new DeveloperError('corner and oppositeCorner are required.');
    }
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    var center = result.center;
    Cartesian3.add(corner, oppositeCorner, center);
    Cartesian3.multiplyByScalar(center, 0.5, center);
    result.radius = Cartesian3.distance(center, oppositeCorner);
    return result;
};
BoundingSphere.fromEllipsoid = function (ellipsoid, result) {
    if (!defined(ellipsoid)) {
        throw new DeveloperError('ellipsoid is required.');
    }
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    Cartesian3.clone(Cartesian3.ZERO, result.center);
    result.radius = ellipsoid.maximumRadius;
    return result;
};
var fromBoundingSpheresScratch = new Cartesian3();
BoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    if (!defined(boundingSpheres) || boundingSpheres.length === 0) {
        result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);
        result.radius = 0;
        return result;
    }
    var length = boundingSpheres.length;
    if (length === 1) {
        return BoundingSphere.clone(boundingSpheres[0], result);
    }
    if (length === 2) {
        return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);
    }
    var positions = [];
    for (var i = 0; i < length; i++) {
        positions.push(boundingSpheres[i].center);
    }
    result = BoundingSphere.fromPoints(positions, result);
    var center = result.center;
    var radius = result.radius;
    for (i = 0; i < length; i++) {
        var tmp = boundingSpheres[i];
        radius = Math.max(radius, Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) + tmp.radius);
    }
    result.radius = radius;
    return result;
};
BoundingSphere.clone = function (sphere, result) {
    if (!defined(sphere)) {
        return undefined;
    }
    if (!defined(result)) {
        return new BoundingSphere(sphere.center, sphere.radius);
    }
    result.center = Cartesian3.clone(sphere.center, result.center);
    result.radius = sphere.radius;
    return result;
};
BoundingSphere.packedLength = 4;
BoundingSphere.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var center = value.center;
    array[startingIndex++] = center.x;
    array[startingIndex++] = center.y;
    array[startingIndex++] = center.z;
    array[startingIndex] = value.radius;
};
BoundingSphere.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    var center = result.center;
    center.x = array[startingIndex++];
    center.y = array[startingIndex++];
    center.z = array[startingIndex++];
    result.radius = array[startingIndex];
    return result;
};
var unionScratch = new Cartesian3();
var unionScratchCenter = new Cartesian3();
BoundingSphere.union = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    var leftCenter = left.center;
    var rightCenter = right.center;
    Cartesian3.add(leftCenter, rightCenter, unionScratchCenter);
    var center = Cartesian3.multiplyByScalar(unionScratchCenter, 0.5, unionScratchCenter);
    var radius1 = Cartesian3.magnitude(Cartesian3.subtract(leftCenter, center, unionScratch)) + left.radius;
    var radius2 = Cartesian3.magnitude(Cartesian3.subtract(rightCenter, center, unionScratch)) + right.radius;
    result.radius = Math.max(radius1, radius2);
    Cartesian3.clone(center, result.center);
    return result;
};
var expandScratch = new Cartesian3();
BoundingSphere.expand = function (sphere, point, result) {
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    if (!defined(point)) {
        throw new DeveloperError('point is required.');
    }
    result = BoundingSphere.clone(sphere, result);
    var radius = Cartesian3.magnitude(Cartesian3.subtract(point, result.center, expandScratch));
    if (radius > result.radius) {
        result.radius = radius;
    }
    return result;
};
BoundingSphere.intersect = function (sphere, plane) {
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    if (!defined(plane)) {
        throw new DeveloperError('plane is required.');
    }
    var center = sphere.center;
    var radius = sphere.radius;
    var distanceToPlane = Cartesian3.dot(plane, center) + plane.w;
    if (distanceToPlane < -radius) {
        return Intersect.OUTSIDE;
    } else if (distanceToPlane < radius) {
        return Intersect.INTERSECTING;
    }
    return Intersect.INSIDE;
};
BoundingSphere.transform = function (sphere, transform, result) {
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    if (!defined(transform)) {
        throw new DeveloperError('transform is required.');
    }
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);
    result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;
    return result;
};
var distanceSquaredToScratch = new Cartesian3();
BoundingSphere.distanceSquaredTo = function (sphere, cartesian) {
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    var diff = Cartesian3.subtract(sphere.center, cartesian, distanceSquaredToScratch);
    return Cartesian3.magnitudeSquared(diff) - sphere.radius * sphere.radius;
};
BoundingSphere.transformWithoutScale = function (sphere, transform, result) {
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    if (!defined(transform)) {
        throw new DeveloperError('transform is required.');
    }
    if (!defined(result)) {
        result = new BoundingSphere();
    }
    result.center = Matrix4.multiplyByPoint(transform, sphere.center, result.center);
    result.radius = sphere.radius;
    return result;
};
var scratchCartesian3 = new Cartesian3();
BoundingSphere.computePlaneDistances = function (sphere, position, direction, result) {
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    if (!defined(position)) {
        throw new DeveloperError('position is required.');
    }
    if (!defined(direction)) {
        throw new DeveloperError('direction is required.');
    }
    if (!defined(result)) {
        result = new Interval();
    }
    var toCenter = Cartesian3.subtract(sphere.center, position, scratchCartesian3);
    var proj = Cartesian3.multiplyByScalar(direction, Cartesian3.dot(direction, toCenter), scratchCartesian3);
    var mag = Cartesian3.magnitude(proj);
    result.start = mag - sphere.radius;
    result.stop = mag + sphere.radius;
    return result;
};
var projectTo2DNormalScratch = new Cartesian3();
var projectTo2DEastScratch = new Cartesian3();
var projectTo2DNorthScratch = new Cartesian3();
var projectTo2DWestScratch = new Cartesian3();
var projectTo2DSouthScratch = new Cartesian3();
var projectTo2DCartographicScratch = new Cartographic();
var projectTo2DPositionsScratch = new Array(8);
for (var n = 0; n < 8; ++n) {
    projectTo2DPositionsScratch[n] = new Cartesian3();
}
var projectTo2DProjection = new GeographicProjection();
BoundingSphere.projectTo2D = function (sphere, projection, result) {
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    projection = defaultValue(projection, projectTo2DProjection);
    var ellipsoid = projection.ellipsoid;
    var center = sphere.center;
    var radius = sphere.radius;
    var normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);
    var east = Cartesian3.cross(Cartesian3.UNIT_Z, normal, projectTo2DEastScratch);
    Cartesian3.normalize(east, east);
    var north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);
    Cartesian3.normalize(north, north);
    Cartesian3.multiplyByScalar(normal, radius, normal);
    Cartesian3.multiplyByScalar(north, radius, north);
    Cartesian3.multiplyByScalar(east, radius, east);
    var south = Cartesian3.negate(north, projectTo2DSouthScratch);
    var west = Cartesian3.negate(east, projectTo2DWestScratch);
    var positions = projectTo2DPositionsScratch;
    var corner = positions[0];
    Cartesian3.add(normal, north, corner);
    Cartesian3.add(corner, east, corner);
    corner = positions[1];
    Cartesian3.add(normal, north, corner);
    Cartesian3.add(corner, west, corner);
    corner = positions[2];
    Cartesian3.add(normal, south, corner);
    Cartesian3.add(corner, west, corner);
    corner = positions[3];
    Cartesian3.add(normal, south, corner);
    Cartesian3.add(corner, east, corner);
    Cartesian3.negate(normal, normal);
    corner = positions[4];
    Cartesian3.add(normal, north, corner);
    Cartesian3.add(corner, east, corner);
    corner = positions[5];
    Cartesian3.add(normal, north, corner);
    Cartesian3.add(corner, west, corner);
    corner = positions[6];
    Cartesian3.add(normal, south, corner);
    Cartesian3.add(corner, west, corner);
    corner = positions[7];
    Cartesian3.add(normal, south, corner);
    Cartesian3.add(corner, east, corner);
    var length = positions.length;
    for (var i = 0; i < length; ++i) {
        var position = positions[i];
        Cartesian3.add(center, position, position);
        var cartographic = ellipsoid.cartesianToCartographic(position, projectTo2DCartographicScratch);
        projection.project(cartographic, position);
    }
    result = BoundingSphere.fromPoints(positions, result);
    center = result.center;
    var x = center.x;
    var y = center.y;
    var z = center.z;
    center.x = z;
    center.y = x;
    center.z = y;
    return result;
};
BoundingSphere.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && Cartesian3.equals(left.center, right.center) && left.radius === right.radius;
};
BoundingSphere.prototype.intersect = function (plane) {
    return BoundingSphere.intersect(this, plane);
};
BoundingSphere.prototype.equals = function (right) {
    return BoundingSphere.equals(this, right);
};
BoundingSphere.prototype.clone = function (result) {
    return BoundingSphere.clone(this, result);
};
module.exports = BoundingSphere;
},{"./Cartesian3":102,"./Cartographic":104,"./DeveloperError":123,"./Ellipsoid":130,"./GeographicProjection":143,"./Intersect":163,"./Interval":166,"./Matrix4":177,"./Rectangle":201,"./defaultValue":243,"./defined":245}],99:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), PrimitiveType = require('./PrimitiveType'), VertexFormat = require('./VertexFormat');
'use strict';
var diffScratch = new Cartesian3();
var BoxGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var min = options.minimumCorner;
    var max = options.maximumCorner;
    if (!defined(min)) {
        throw new DeveloperError('options.minimumCorner is required.');
    }
    if (!defined(max)) {
        throw new DeveloperError('options.maximumCorner is required');
    }
    var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
    this._minimumCorner = Cartesian3.clone(min);
    this._maximumCorner = Cartesian3.clone(max);
    this._vertexFormat = vertexFormat;
    this._workerName = 'createBoxGeometry';
};
BoxGeometry.fromDimensions = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var dimensions = options.dimensions;
    if (!defined(dimensions)) {
        throw new DeveloperError('options.dimensions is required.');
    }
    if (dimensions.x < 0 || dimensions.y < 0 || dimensions.z < 0) {
        throw new DeveloperError('All dimensions components must be greater than or equal to zero.');
    }
    var corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());
    var min = Cartesian3.negate(corner, new Cartesian3());
    var max = corner;
    var newOptions = {
            minimumCorner: min,
            maximumCorner: max,
            vertexFormat: options.vertexFormat
        };
    return new BoxGeometry(newOptions);
};
BoxGeometry.packedLength = 2 * Cartesian3.packedLength + VertexFormat.packedLength;
BoxGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Cartesian3.pack(value._minimumCorner, array, startingIndex);
    Cartesian3.pack(value._maximumCorner, array, startingIndex + Cartesian3.packedLength);
    VertexFormat.pack(value._vertexFormat, array, startingIndex + 2 * Cartesian3.packedLength);
};
var scratchMin = new Cartesian3();
var scratchMax = new Cartesian3();
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        minimumCorner: scratchMin,
        maximumCorner: scratchMax,
        vertexFormat: scratchVertexFormat
    };
BoxGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var min = Cartesian3.unpack(array, startingIndex, scratchMin);
    var max = Cartesian3.unpack(array, startingIndex + Cartesian3.packedLength, scratchMax);
    var vertexFormat = VertexFormat.unpack(array, startingIndex + 2 * Cartesian3.packedLength, scratchVertexFormat);
    if (!defined(result)) {
        return new BoxGeometry(scratchOptions);
    }
    result._minimumCorner = Cartesian3.clone(min, result._minimumCorner);
    result._maximumCorner = Cartesian3.clone(max, result._maximumCorner);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    return result;
};
BoxGeometry.createGeometry = function (boxGeometry) {
    var min = boxGeometry._minimumCorner;
    var max = boxGeometry._maximumCorner;
    var vertexFormat = boxGeometry._vertexFormat;
    var attributes = new GeometryAttributes();
    var indices;
    var positions;
    if (vertexFormat.position && (vertexFormat.st || vertexFormat.normal || vertexFormat.binormal || vertexFormat.tangent)) {
        if (vertexFormat.position) {
            positions = new Float64Array(6 * 4 * 3);
            positions[0] = min.x;
            positions[1] = min.y;
            positions[2] = max.z;
            positions[3] = max.x;
            positions[4] = min.y;
            positions[5] = max.z;
            positions[6] = max.x;
            positions[7] = max.y;
            positions[8] = max.z;
            positions[9] = min.x;
            positions[10] = max.y;
            positions[11] = max.z;
            positions[12] = min.x;
            positions[13] = min.y;
            positions[14] = min.z;
            positions[15] = max.x;
            positions[16] = min.y;
            positions[17] = min.z;
            positions[18] = max.x;
            positions[19] = max.y;
            positions[20] = min.z;
            positions[21] = min.x;
            positions[22] = max.y;
            positions[23] = min.z;
            positions[24] = max.x;
            positions[25] = min.y;
            positions[26] = min.z;
            positions[27] = max.x;
            positions[28] = max.y;
            positions[29] = min.z;
            positions[30] = max.x;
            positions[31] = max.y;
            positions[32] = max.z;
            positions[33] = max.x;
            positions[34] = min.y;
            positions[35] = max.z;
            positions[36] = min.x;
            positions[37] = min.y;
            positions[38] = min.z;
            positions[39] = min.x;
            positions[40] = max.y;
            positions[41] = min.z;
            positions[42] = min.x;
            positions[43] = max.y;
            positions[44] = max.z;
            positions[45] = min.x;
            positions[46] = min.y;
            positions[47] = max.z;
            positions[48] = min.x;
            positions[49] = max.y;
            positions[50] = min.z;
            positions[51] = max.x;
            positions[52] = max.y;
            positions[53] = min.z;
            positions[54] = max.x;
            positions[55] = max.y;
            positions[56] = max.z;
            positions[57] = min.x;
            positions[58] = max.y;
            positions[59] = max.z;
            positions[60] = min.x;
            positions[61] = min.y;
            positions[62] = min.z;
            positions[63] = max.x;
            positions[64] = min.y;
            positions[65] = min.z;
            positions[66] = max.x;
            positions[67] = min.y;
            positions[68] = max.z;
            positions[69] = min.x;
            positions[70] = min.y;
            positions[71] = max.z;
            attributes.position = new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: positions
            });
        }
        if (vertexFormat.normal) {
            var normals = new Float32Array(6 * 4 * 3);
            normals[0] = 0;
            normals[1] = 0;
            normals[2] = 1;
            normals[3] = 0;
            normals[4] = 0;
            normals[5] = 1;
            normals[6] = 0;
            normals[7] = 0;
            normals[8] = 1;
            normals[9] = 0;
            normals[10] = 0;
            normals[11] = 1;
            normals[12] = 0;
            normals[13] = 0;
            normals[14] = -1;
            normals[15] = 0;
            normals[16] = 0;
            normals[17] = -1;
            normals[18] = 0;
            normals[19] = 0;
            normals[20] = -1;
            normals[21] = 0;
            normals[22] = 0;
            normals[23] = -1;
            normals[24] = 1;
            normals[25] = 0;
            normals[26] = 0;
            normals[27] = 1;
            normals[28] = 0;
            normals[29] = 0;
            normals[30] = 1;
            normals[31] = 0;
            normals[32] = 0;
            normals[33] = 1;
            normals[34] = 0;
            normals[35] = 0;
            normals[36] = -1;
            normals[37] = 0;
            normals[38] = 0;
            normals[39] = -1;
            normals[40] = 0;
            normals[41] = 0;
            normals[42] = -1;
            normals[43] = 0;
            normals[44] = 0;
            normals[45] = -1;
            normals[46] = 0;
            normals[47] = 0;
            normals[48] = 0;
            normals[49] = 1;
            normals[50] = 0;
            normals[51] = 0;
            normals[52] = 1;
            normals[53] = 0;
            normals[54] = 0;
            normals[55] = 1;
            normals[56] = 0;
            normals[57] = 0;
            normals[58] = 1;
            normals[59] = 0;
            normals[60] = 0;
            normals[61] = -1;
            normals[62] = 0;
            normals[63] = 0;
            normals[64] = -1;
            normals[65] = 0;
            normals[66] = 0;
            normals[67] = -1;
            normals[68] = 0;
            normals[69] = 0;
            normals[70] = -1;
            normals[71] = 0;
            attributes.normal = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: normals
            });
        }
        if (vertexFormat.st) {
            var texCoords = new Float32Array(6 * 4 * 2);
            texCoords[0] = 0;
            texCoords[1] = 0;
            texCoords[2] = 1;
            texCoords[3] = 0;
            texCoords[4] = 1;
            texCoords[5] = 1;
            texCoords[6] = 0;
            texCoords[7] = 1;
            texCoords[8] = 1;
            texCoords[9] = 0;
            texCoords[10] = 0;
            texCoords[11] = 0;
            texCoords[12] = 0;
            texCoords[13] = 1;
            texCoords[14] = 1;
            texCoords[15] = 1;
            texCoords[16] = 0;
            texCoords[17] = 0;
            texCoords[18] = 1;
            texCoords[19] = 0;
            texCoords[20] = 1;
            texCoords[21] = 1;
            texCoords[22] = 0;
            texCoords[23] = 1;
            texCoords[24] = 1;
            texCoords[25] = 0;
            texCoords[26] = 0;
            texCoords[27] = 0;
            texCoords[28] = 0;
            texCoords[29] = 1;
            texCoords[30] = 1;
            texCoords[31] = 1;
            texCoords[32] = 1;
            texCoords[33] = 0;
            texCoords[34] = 0;
            texCoords[35] = 0;
            texCoords[36] = 0;
            texCoords[37] = 1;
            texCoords[38] = 1;
            texCoords[39] = 1;
            texCoords[40] = 0;
            texCoords[41] = 0;
            texCoords[42] = 1;
            texCoords[43] = 0;
            texCoords[44] = 1;
            texCoords[45] = 1;
            texCoords[46] = 0;
            texCoords[47] = 1;
            attributes.st = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 2,
                values: texCoords
            });
        }
        if (vertexFormat.tangent) {
            var tangents = new Float32Array(6 * 4 * 3);
            tangents[0] = 1;
            tangents[1] = 0;
            tangents[2] = 0;
            tangents[3] = 1;
            tangents[4] = 0;
            tangents[5] = 0;
            tangents[6] = 1;
            tangents[7] = 0;
            tangents[8] = 0;
            tangents[9] = 1;
            tangents[10] = 0;
            tangents[11] = 0;
            tangents[12] = -1;
            tangents[13] = 0;
            tangents[14] = 0;
            tangents[15] = -1;
            tangents[16] = 0;
            tangents[17] = 0;
            tangents[18] = -1;
            tangents[19] = 0;
            tangents[20] = 0;
            tangents[21] = -1;
            tangents[22] = 0;
            tangents[23] = 0;
            tangents[24] = 0;
            tangents[25] = 1;
            tangents[26] = 0;
            tangents[27] = 0;
            tangents[28] = 1;
            tangents[29] = 0;
            tangents[30] = 0;
            tangents[31] = 1;
            tangents[32] = 0;
            tangents[33] = 0;
            tangents[34] = 1;
            tangents[35] = 0;
            tangents[36] = 0;
            tangents[37] = -1;
            tangents[38] = 0;
            tangents[39] = 0;
            tangents[40] = -1;
            tangents[41] = 0;
            tangents[42] = 0;
            tangents[43] = -1;
            tangents[44] = 0;
            tangents[45] = 0;
            tangents[46] = -1;
            tangents[47] = 0;
            tangents[48] = -1;
            tangents[49] = 0;
            tangents[50] = 0;
            tangents[51] = -1;
            tangents[52] = 0;
            tangents[53] = 0;
            tangents[54] = -1;
            tangents[55] = 0;
            tangents[56] = 0;
            tangents[57] = -1;
            tangents[58] = 0;
            tangents[59] = 0;
            tangents[60] = 1;
            tangents[61] = 0;
            tangents[62] = 0;
            tangents[63] = 1;
            tangents[64] = 0;
            tangents[65] = 0;
            tangents[66] = 1;
            tangents[67] = 0;
            tangents[68] = 0;
            tangents[69] = 1;
            tangents[70] = 0;
            tangents[71] = 0;
            attributes.tangent = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: tangents
            });
        }
        if (vertexFormat.binormal) {
            var binormals = new Float32Array(6 * 4 * 3);
            binormals[0] = 0;
            binormals[1] = 1;
            binormals[2] = 0;
            binormals[3] = 0;
            binormals[4] = 1;
            binormals[5] = 0;
            binormals[6] = 0;
            binormals[7] = 1;
            binormals[8] = 0;
            binormals[9] = 0;
            binormals[10] = 1;
            binormals[11] = 0;
            binormals[12] = 0;
            binormals[13] = 1;
            binormals[14] = 0;
            binormals[15] = 0;
            binormals[16] = 1;
            binormals[17] = 0;
            binormals[18] = 0;
            binormals[19] = 1;
            binormals[20] = 0;
            binormals[21] = 0;
            binormals[22] = 1;
            binormals[23] = 0;
            binormals[24] = 0;
            binormals[25] = 0;
            binormals[26] = 1;
            binormals[27] = 0;
            binormals[28] = 0;
            binormals[29] = 1;
            binormals[30] = 0;
            binormals[31] = 0;
            binormals[32] = 1;
            binormals[33] = 0;
            binormals[34] = 0;
            binormals[35] = 1;
            binormals[36] = 0;
            binormals[37] = 0;
            binormals[38] = 1;
            binormals[39] = 0;
            binormals[40] = 0;
            binormals[41] = 1;
            binormals[42] = 0;
            binormals[43] = 0;
            binormals[44] = 1;
            binormals[45] = 0;
            binormals[46] = 0;
            binormals[47] = 1;
            binormals[48] = 0;
            binormals[49] = 0;
            binormals[50] = 1;
            binormals[51] = 0;
            binormals[52] = 0;
            binormals[53] = 1;
            binormals[54] = 0;
            binormals[55] = 0;
            binormals[56] = 1;
            binormals[57] = 0;
            binormals[58] = 0;
            binormals[59] = 1;
            binormals[60] = 0;
            binormals[61] = 0;
            binormals[62] = 1;
            binormals[63] = 0;
            binormals[64] = 0;
            binormals[65] = 1;
            binormals[66] = 0;
            binormals[67] = 0;
            binormals[68] = 1;
            binormals[69] = 0;
            binormals[70] = 0;
            binormals[71] = 1;
            attributes.binormal = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: binormals
            });
        }
        indices = new Uint16Array(6 * 2 * 3);
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 2;
        indices[3] = 0;
        indices[4] = 2;
        indices[5] = 3;
        indices[6] = 4 + 2;
        indices[7] = 4 + 1;
        indices[8] = 4 + 0;
        indices[9] = 4 + 3;
        indices[10] = 4 + 2;
        indices[11] = 4 + 0;
        indices[12] = 8 + 0;
        indices[13] = 8 + 1;
        indices[14] = 8 + 2;
        indices[15] = 8 + 0;
        indices[16] = 8 + 2;
        indices[17] = 8 + 3;
        indices[18] = 12 + 2;
        indices[19] = 12 + 1;
        indices[20] = 12 + 0;
        indices[21] = 12 + 3;
        indices[22] = 12 + 2;
        indices[23] = 12 + 0;
        indices[24] = 16 + 2;
        indices[25] = 16 + 1;
        indices[26] = 16 + 0;
        indices[27] = 16 + 3;
        indices[28] = 16 + 2;
        indices[29] = 16 + 0;
        indices[30] = 20 + 0;
        indices[31] = 20 + 1;
        indices[32] = 20 + 2;
        indices[33] = 20 + 0;
        indices[34] = 20 + 2;
        indices[35] = 20 + 3;
    } else {
        positions = new Float64Array(8 * 3);
        positions[0] = min.x;
        positions[1] = min.y;
        positions[2] = min.z;
        positions[3] = max.x;
        positions[4] = min.y;
        positions[5] = min.z;
        positions[6] = max.x;
        positions[7] = max.y;
        positions[8] = min.z;
        positions[9] = min.x;
        positions[10] = max.y;
        positions[11] = min.z;
        positions[12] = min.x;
        positions[13] = min.y;
        positions[14] = max.z;
        positions[15] = max.x;
        positions[16] = min.y;
        positions[17] = max.z;
        positions[18] = max.x;
        positions[19] = max.y;
        positions[20] = max.z;
        positions[21] = min.x;
        positions[22] = max.y;
        positions[23] = max.z;
        attributes.position = new GeometryAttribute({
            componentDatatype: ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
        });
        indices = new Uint16Array(6 * 2 * 3);
        indices[0] = 4;
        indices[1] = 5;
        indices[2] = 6;
        indices[3] = 4;
        indices[4] = 6;
        indices[5] = 7;
        indices[6] = 1;
        indices[7] = 0;
        indices[8] = 3;
        indices[9] = 1;
        indices[10] = 3;
        indices[11] = 2;
        indices[12] = 1;
        indices[13] = 6;
        indices[14] = 5;
        indices[15] = 1;
        indices[16] = 2;
        indices[17] = 6;
        indices[18] = 2;
        indices[19] = 3;
        indices[20] = 7;
        indices[21] = 2;
        indices[22] = 7;
        indices[23] = 6;
        indices[24] = 3;
        indices[25] = 0;
        indices[26] = 4;
        indices[27] = 3;
        indices[28] = 4;
        indices[29] = 7;
        indices[30] = 0;
        indices[31] = 1;
        indices[32] = 5;
        indices[33] = 0;
        indices[34] = 5;
        indices[35] = 4;
    }
    var diff = Cartesian3.subtract(max, min, diffScratch);
    var radius = Cartesian3.magnitude(diff) * 0.5;
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius)
    });
};
module.exports = BoxGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./PrimitiveType":193,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],100:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), PrimitiveType = require('./PrimitiveType');
'use strict';
var diffScratch = new Cartesian3();
var BoxOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var min = options.minimumCorner;
    var max = options.maximumCorner;
    if (!defined(min)) {
        throw new DeveloperError('options.minimumCorner is required.');
    }
    if (!defined(max)) {
        throw new DeveloperError('options.maximumCorner is required');
    }
    this._min = Cartesian3.clone(min);
    this._max = Cartesian3.clone(max);
    this._workerName = 'createBoxOutlineGeometry';
};
BoxOutlineGeometry.fromDimensions = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var dimensions = options.dimensions;
    if (!defined(dimensions)) {
        throw new DeveloperError('options.dimensions is required.');
    }
    if (dimensions.x < 0 || dimensions.y < 0 || dimensions.z < 0) {
        throw new DeveloperError('All dimensions components must be greater than or equal to zero.');
    }
    var corner = Cartesian3.multiplyByScalar(dimensions, 0.5, new Cartesian3());
    var min = Cartesian3.negate(corner, new Cartesian3());
    var max = corner;
    var newOptions = {
            minimumCorner: min,
            maximumCorner: max
        };
    return new BoxOutlineGeometry(newOptions);
};
BoxOutlineGeometry.packedLength = 2 * Cartesian3.packedLength;
BoxOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Cartesian3.pack(value._min, array, startingIndex);
    Cartesian3.pack(value._max, array, startingIndex + Cartesian3.packedLength);
};
var scratchMin = new Cartesian3();
var scratchMax = new Cartesian3();
var scratchOptions = {
        minimumCorner: scratchMin,
        maximumCorner: scratchMax
    };
BoxOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var min = Cartesian3.unpack(array, startingIndex, scratchMin);
    var max = Cartesian3.unpack(array, startingIndex + Cartesian3.packedLength, scratchMax);
    if (!defined(result)) {
        return new BoxOutlineGeometry(scratchOptions);
    }
    result._min = Cartesian3.clone(min, result._min);
    result._max = Cartesian3.clone(max, result._max);
    return result;
};
BoxOutlineGeometry.createGeometry = function (boxGeometry) {
    var min = boxGeometry._min;
    var max = boxGeometry._max;
    var attributes = new GeometryAttributes();
    var indices = new Uint16Array(12 * 2);
    var positions = new Float64Array(8 * 3);
    positions[0] = min.x;
    positions[1] = min.y;
    positions[2] = min.z;
    positions[3] = max.x;
    positions[4] = min.y;
    positions[5] = min.z;
    positions[6] = max.x;
    positions[7] = max.y;
    positions[8] = min.z;
    positions[9] = min.x;
    positions[10] = max.y;
    positions[11] = min.z;
    positions[12] = min.x;
    positions[13] = min.y;
    positions[14] = max.z;
    positions[15] = max.x;
    positions[16] = min.y;
    positions[17] = max.z;
    positions[18] = max.x;
    positions[19] = max.y;
    positions[20] = max.z;
    positions[21] = min.x;
    positions[22] = max.y;
    positions[23] = max.z;
    attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: positions
    });
    indices[0] = 4;
    indices[1] = 5;
    indices[2] = 5;
    indices[3] = 6;
    indices[4] = 6;
    indices[5] = 7;
    indices[6] = 7;
    indices[7] = 4;
    indices[8] = 0;
    indices[9] = 1;
    indices[10] = 1;
    indices[11] = 2;
    indices[12] = 2;
    indices[13] = 3;
    indices[14] = 3;
    indices[15] = 0;
    indices[16] = 0;
    indices[17] = 4;
    indices[18] = 1;
    indices[19] = 5;
    indices[20] = 2;
    indices[21] = 6;
    indices[22] = 3;
    indices[23] = 7;
    var diff = Cartesian3.subtract(max, min, diffScratch);
    var radius = Cartesian3.magnitude(diff) * 0.5;
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.LINES,
        boundingSphere: new BoundingSphere(Cartesian3.ZERO, radius)
    });
};
module.exports = BoxOutlineGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./PrimitiveType":193,"./defaultValue":243,"./defined":245}],101:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
var Cartesian2 = function (x, y) {
    this.x = defaultValue(x, 0);
    this.y = defaultValue(y, 0);
};
Cartesian2.fromElements = function (x, y, result) {
    if (!defined(result)) {
        return new Cartesian2(x, y);
    }
    result.x = x;
    result.y = y;
    return result;
};
Cartesian2.clone = function (cartesian, result) {
    if (!defined(cartesian)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Cartesian2(cartesian.x, cartesian.y);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    return result;
};
Cartesian2.fromCartesian3 = Cartesian2.clone;
Cartesian2.fromCartesian4 = Cartesian2.clone;
Cartesian2.packedLength = 2;
Cartesian2.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex] = value.y;
};
Cartesian2.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Cartesian2();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex];
    return result;
};
Cartesian2.fromArray = Cartesian2.unpack;
Cartesian2.maximumComponent = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return Math.max(cartesian.x, cartesian.y);
};
Cartesian2.minimumComponent = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return Math.min(cartesian.x, cartesian.y);
};
Cartesian2.minimumByComponent = function (first, second, result) {
    if (!defined(first)) {
        throw new DeveloperError('first is required.');
    }
    if (!defined(second)) {
        throw new DeveloperError('second is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    return result;
};
Cartesian2.maximumByComponent = function (first, second, result) {
    if (!defined(first)) {
        throw new DeveloperError('first is required.');
    }
    if (!defined(second)) {
        throw new DeveloperError('second is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    return result;
};
Cartesian2.magnitudeSquared = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
};
Cartesian2.magnitude = function (cartesian) {
    return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
};
var distanceScratch = new Cartesian2();
Cartesian2.distance = function (left, right) {
    if (!defined(left) || !defined(right)) {
        throw new DeveloperError('left and right are required.');
    }
    Cartesian2.subtract(left, right, distanceScratch);
    return Cartesian2.magnitude(distanceScratch);
};
Cartesian2.distanceSquared = function (left, right) {
    if (!defined(left) || !defined(right)) {
        throw new DeveloperError('left and right are required.');
    }
    Cartesian2.subtract(left, right, distanceScratch);
    return Cartesian2.magnitudeSquared(distanceScratch);
};
Cartesian2.normalize = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var magnitude = Cartesian2.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;
    return result;
};
Cartesian2.dot = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    return left.x * right.x + left.y * right.y;
};
Cartesian2.multiplyComponents = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x * right.x;
    result.y = left.y * right.y;
    return result;
};
Cartesian2.add = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x + right.x;
    result.y = left.y + right.y;
    return result;
};
Cartesian2.subtract = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x - right.x;
    result.y = left.y - right.y;
    return result;
};
Cartesian2.multiplyByScalar = function (cartesian, scalar, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    return result;
};
Cartesian2.divideByScalar = function (cartesian, scalar, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    return result;
};
Cartesian2.negate = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = -cartesian.x;
    result.y = -cartesian.y;
    return result;
};
Cartesian2.abs = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    return result;
};
var lerpScratch = new Cartesian2();
Cartesian2.lerp = function (start, end, t, result) {
    if (!defined(start)) {
        throw new DeveloperError('start is required.');
    }
    if (!defined(end)) {
        throw new DeveloperError('end is required.');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    Cartesian2.multiplyByScalar(end, t, lerpScratch);
    result = Cartesian2.multiplyByScalar(start, 1 - t, result);
    return Cartesian2.add(lerpScratch, result, result);
};
var angleBetweenScratch = new Cartesian2();
var angleBetweenScratch2 = new Cartesian2();
Cartesian2.angleBetween = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    Cartesian2.normalize(left, angleBetweenScratch);
    Cartesian2.normalize(right, angleBetweenScratch2);
    return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));
};
var mostOrthogonalAxisScratch = new Cartesian2();
Cartesian2.mostOrthogonalAxis = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);
    Cartesian2.abs(f, f);
    if (f.x <= f.y) {
        result = Cartesian2.clone(Cartesian2.UNIT_X, result);
    } else {
        result = Cartesian2.clone(Cartesian2.UNIT_Y, result);
    }
    return result;
};
Cartesian2.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y;
};
Cartesian2.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon);
};
Cartesian2.ZERO = freezeObject(new Cartesian2(0, 0));
Cartesian2.UNIT_X = freezeObject(new Cartesian2(1, 0));
Cartesian2.UNIT_Y = freezeObject(new Cartesian2(0, 1));
Cartesian2.prototype.clone = function (result) {
    return Cartesian2.clone(this, result);
};
Cartesian2.prototype.equals = function (right) {
    return Cartesian2.equals(this, right);
};
Cartesian2.prototype.equalsEpsilon = function (right, epsilon) {
    return Cartesian2.equalsEpsilon(this, right, epsilon);
};
Cartesian2.prototype.toString = function () {
    return '(' + this.x + ', ' + this.y + ')';
};
module.exports = Cartesian2;
},{"./DeveloperError":123,"./Math":174,"./defaultValue":243,"./defined":245,"./freezeObject":249}],102:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
var Cartesian3 = function (x, y, z) {
    this.x = defaultValue(x, 0);
    this.y = defaultValue(y, 0);
    this.z = defaultValue(z, 0);
};
Cartesian3.fromSpherical = function (spherical, result) {
    if (!defined(spherical)) {
        throw new DeveloperError('spherical is required');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    var clock = spherical.clock;
    var cone = spherical.cone;
    var magnitude = defaultValue(spherical.magnitude, 1);
    var radial = magnitude * Math.sin(cone);
    result.x = radial * Math.cos(clock);
    result.y = radial * Math.sin(clock);
    result.z = magnitude * Math.cos(cone);
    return result;
};
Cartesian3.fromElements = function (x, y, z, result) {
    if (!defined(result)) {
        return new Cartesian3(x, y, z);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
Cartesian3.clone = function (cartesian, result) {
    if (!defined(cartesian)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    result.z = cartesian.z;
    return result;
};
Cartesian3.fromCartesian4 = Cartesian3.clone;
Cartesian3.packedLength = 3;
Cartesian3.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex++] = value.y;
    array[startingIndex] = value.z;
};
Cartesian3.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Cartesian3();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex++];
    result.z = array[startingIndex];
    return result;
};
Cartesian3.fromArray = Cartesian3.unpack;
Cartesian3.maximumComponent = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return Math.max(cartesian.x, cartesian.y, cartesian.z);
};
Cartesian3.minimumComponent = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return Math.min(cartesian.x, cartesian.y, cartesian.z);
};
Cartesian3.minimumByComponent = function (first, second, result) {
    if (!defined(first)) {
        throw new DeveloperError('first is required.');
    }
    if (!defined(second)) {
        throw new DeveloperError('second is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    result.z = Math.min(first.z, second.z);
    return result;
};
Cartesian3.maximumByComponent = function (first, second, result) {
    if (!defined(first)) {
        throw new DeveloperError('first is required.');
    }
    if (!defined(second)) {
        throw new DeveloperError('second is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    result.z = Math.max(first.z, second.z);
    return result;
};
Cartesian3.magnitudeSquared = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
};
Cartesian3.magnitude = function (cartesian) {
    return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
};
var distanceScratch = new Cartesian3();
Cartesian3.distance = function (left, right) {
    if (!defined(left) || !defined(right)) {
        throw new DeveloperError('left and right are required.');
    }
    Cartesian3.subtract(left, right, distanceScratch);
    return Cartesian3.magnitude(distanceScratch);
};
Cartesian3.distanceSquared = function (left, right) {
    if (!defined(left) || !defined(right)) {
        throw new DeveloperError('left and right are required.');
    }
    Cartesian3.subtract(left, right, distanceScratch);
    return Cartesian3.magnitudeSquared(distanceScratch);
};
Cartesian3.normalize = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var magnitude = Cartesian3.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;
    result.z = cartesian.z / magnitude;
    return result;
};
Cartesian3.dot = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    return left.x * right.x + left.y * right.y + left.z * right.z;
};
Cartesian3.multiplyComponents = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x * right.x;
    result.y = left.y * right.y;
    result.z = left.z * right.z;
    return result;
};
Cartesian3.add = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x + right.x;
    result.y = left.y + right.y;
    result.z = left.z + right.z;
    return result;
};
Cartesian3.subtract = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x - right.x;
    result.y = left.y - right.y;
    result.z = left.z - right.z;
    return result;
};
Cartesian3.multiplyByScalar = function (cartesian, scalar, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    result.z = cartesian.z * scalar;
    return result;
};
Cartesian3.divideByScalar = function (cartesian, scalar, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    result.z = cartesian.z / scalar;
    return result;
};
Cartesian3.negate = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = -cartesian.x;
    result.y = -cartesian.y;
    result.z = -cartesian.z;
    return result;
};
Cartesian3.abs = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    result.z = Math.abs(cartesian.z);
    return result;
};
var lerpScratch = new Cartesian3();
Cartesian3.lerp = function (start, end, t, result) {
    if (!defined(start)) {
        throw new DeveloperError('start is required.');
    }
    if (!defined(end)) {
        throw new DeveloperError('end is required.');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    Cartesian3.multiplyByScalar(end, t, lerpScratch);
    result = Cartesian3.multiplyByScalar(start, 1 - t, result);
    return Cartesian3.add(lerpScratch, result, result);
};
var angleBetweenScratch = new Cartesian3();
var angleBetweenScratch2 = new Cartesian3();
Cartesian3.angleBetween = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    Cartesian3.normalize(left, angleBetweenScratch);
    Cartesian3.normalize(right, angleBetweenScratch2);
    var cosine = Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2);
    var sine = Cartesian3.magnitude(Cartesian3.cross(angleBetweenScratch, angleBetweenScratch2, angleBetweenScratch));
    return Math.atan2(sine, cosine);
};
var mostOrthogonalAxisScratch = new Cartesian3();
Cartesian3.mostOrthogonalAxis = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var f = Cartesian3.normalize(cartesian, mostOrthogonalAxisScratch);
    Cartesian3.abs(f, f);
    if (f.x <= f.y) {
        if (f.x <= f.z) {
            result = Cartesian3.clone(Cartesian3.UNIT_X, result);
        } else {
            result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
        }
    } else {
        if (f.y <= f.z) {
            result = Cartesian3.clone(Cartesian3.UNIT_Y, result);
        } else {
            result = Cartesian3.clone(Cartesian3.UNIT_Z, result);
        }
    }
    return result;
};
Cartesian3.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z;
};
Cartesian3.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon);
};
Cartesian3.cross = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var leftX = left.x;
    var leftY = left.y;
    var leftZ = left.z;
    var rightX = right.x;
    var rightY = right.y;
    var rightZ = right.z;
    var x = leftY * rightZ - leftZ * rightY;
    var y = leftZ * rightX - leftX * rightZ;
    var z = leftX * rightY - leftY * rightX;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
Cartesian3.fromDegrees = function (longitude, latitude, height, ellipsoid, result) {
    if (!defined(longitude)) {
        throw new DeveloperError('longitude is required');
    }
    if (!defined(latitude)) {
        throw new DeveloperError('latitude is required');
    }
    var lon = CesiumMath.toRadians(longitude);
    var lat = CesiumMath.toRadians(latitude);
    return Cartesian3.fromRadians(lon, lat, height, ellipsoid, result);
};
var scratchN = new Cartesian3();
var scratchK = new Cartesian3();
var wgs84RadiiSquared = new Cartesian3(6378137 * 6378137, 6378137 * 6378137, 6356752.314245179 * 6356752.314245179);
Cartesian3.fromRadians = function (longitude, latitude, height, ellipsoid, result) {
    if (!defined(longitude)) {
        throw new DeveloperError('longitude is required');
    }
    if (!defined(latitude)) {
        throw new DeveloperError('latitude is required');
    }
    height = defaultValue(height, 0);
    var radiiSquared = defined(ellipsoid) ? ellipsoid.radiiSquared : wgs84RadiiSquared;
    var cosLatitude = Math.cos(latitude);
    scratchN.x = cosLatitude * Math.cos(longitude);
    scratchN.y = cosLatitude * Math.sin(longitude);
    scratchN.z = Math.sin(latitude);
    scratchN = Cartesian3.normalize(scratchN, scratchN);
    Cartesian3.multiplyComponents(radiiSquared, scratchN, scratchK);
    var gamma = Math.sqrt(Cartesian3.dot(scratchN, scratchK));
    scratchK = Cartesian3.divideByScalar(scratchK, gamma, scratchK);
    scratchN = Cartesian3.multiplyByScalar(scratchN, height, scratchN);
    if (!defined(result)) {
        result = new Cartesian3();
    }
    return Cartesian3.add(scratchK, scratchN, result);
};
Cartesian3.fromDegreesArray = function (coordinates, ellipsoid, result) {
    if (!defined(coordinates)) {
        throw new DeveloperError('positions is required.');
    }
    var pos = new Array(coordinates.length);
    for (var i = 0; i < coordinates.length; i++) {
        pos[i] = CesiumMath.toRadians(coordinates[i]);
    }
    return Cartesian3.fromRadiansArray(pos, ellipsoid, result);
};
Cartesian3.fromRadiansArray = function (coordinates, ellipsoid, result) {
    if (!defined(coordinates)) {
        throw new DeveloperError('positions is required.');
    }
    if (coordinates.length < 2) {
        throw new DeveloperError('positions length cannot be less than 2.');
    }
    if (coordinates.length % 2 !== 0) {
        throw new DeveloperError('positions length must be a multiple of 2.');
    }
    var length = coordinates.length;
    if (!defined(result)) {
        result = new Array(length / 2);
    } else {
        result.length = length / 2;
    }
    for (var i = 0; i < length; i += 2) {
        var lon = coordinates[i];
        var lat = coordinates[i + 1];
        result[i / 2] = Cartesian3.fromRadians(lon, lat, 0, ellipsoid, result[i / 2]);
    }
    return result;
};
Cartesian3.fromDegreesArrayHeights = function (coordinates, ellipsoid, result) {
    if (!defined(coordinates)) {
        throw new DeveloperError('positions is required.');
    }
    if (coordinates.length < 3) {
        throw new DeveloperError('positions length cannot be less than 3.');
    }
    if (coordinates.length % 3 !== 0) {
        throw new DeveloperError('positions length must be a multiple of 3.');
    }
    var pos = new Array(coordinates.length);
    for (var i = 0; i < coordinates.length; i += 3) {
        pos[i] = CesiumMath.toRadians(coordinates[i]);
        pos[i + 1] = CesiumMath.toRadians(coordinates[i + 1]);
        pos[i + 2] = coordinates[i + 2];
    }
    return Cartesian3.fromRadiansArrayHeights(pos, ellipsoid, result);
};
Cartesian3.fromRadiansArrayHeights = function (coordinates, ellipsoid, result) {
    if (!defined(coordinates)) {
        throw new DeveloperError('positions is required.');
    }
    if (coordinates.length < 3) {
        throw new DeveloperError('positions length cannot be less than 3.');
    }
    if (coordinates.length % 3 !== 0) {
        throw new DeveloperError('positions length must be a multiple of 3.');
    }
    var length = coordinates.length;
    if (!defined(result)) {
        result = new Array(length / 3);
    } else {
        result.length = length / 3;
    }
    for (var i = 0; i < length; i += 3) {
        var lon = coordinates[i];
        var lat = coordinates[i + 1];
        var alt = coordinates[i + 2];
        result[i / 3] = Cartesian3.fromRadians(lon, lat, alt, ellipsoid, result[i / 3]);
    }
    return result;
};
Cartesian3.ZERO = freezeObject(new Cartesian3(0, 0, 0));
Cartesian3.UNIT_X = freezeObject(new Cartesian3(1, 0, 0));
Cartesian3.UNIT_Y = freezeObject(new Cartesian3(0, 1, 0));
Cartesian3.UNIT_Z = freezeObject(new Cartesian3(0, 0, 1));
Cartesian3.prototype.clone = function (result) {
    return Cartesian3.clone(this, result);
};
Cartesian3.prototype.equals = function (right) {
    return Cartesian3.equals(this, right);
};
Cartesian3.prototype.equalsEpsilon = function (right, epsilon) {
    return Cartesian3.equalsEpsilon(this, right, epsilon);
};
Cartesian3.prototype.toString = function () {
    return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';
};
module.exports = Cartesian3;
},{"./DeveloperError":123,"./Math":174,"./defaultValue":243,"./defined":245,"./freezeObject":249}],103:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
var Cartesian4 = function (x, y, z, w) {
    this.x = defaultValue(x, 0);
    this.y = defaultValue(y, 0);
    this.z = defaultValue(z, 0);
    this.w = defaultValue(w, 0);
};
Cartesian4.fromElements = function (x, y, z, w, result) {
    if (!defined(result)) {
        return new Cartesian4(x, y, z, w);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
};
Cartesian4.fromColor = function (color, result) {
    if (!defined(color)) {
        throw new DeveloperError('color is required');
    }
    if (!defined(result)) {
        return new Cartesian4(color.red, color.green, color.blue, color.alpha);
    }
    result.x = color.red;
    result.y = color.green;
    result.z = color.blue;
    result.w = color.alpha;
    return result;
};
Cartesian4.clone = function (cartesian, result) {
    if (!defined(cartesian)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    }
    result.x = cartesian.x;
    result.y = cartesian.y;
    result.z = cartesian.z;
    result.w = cartesian.w;
    return result;
};
Cartesian4.packedLength = 4;
Cartesian4.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex++] = value.y;
    array[startingIndex++] = value.z;
    array[startingIndex] = value.w;
};
Cartesian4.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Cartesian4();
    }
    result.x = array[startingIndex++];
    result.y = array[startingIndex++];
    result.z = array[startingIndex++];
    result.w = array[startingIndex];
    return result;
};
Cartesian4.fromArray = Cartesian4.unpack;
Cartesian4.maximumComponent = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
};
Cartesian4.minimumComponent = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
};
Cartesian4.minimumByComponent = function (first, second, result) {
    if (!defined(first)) {
        throw new DeveloperError('first is required.');
    }
    if (!defined(second)) {
        throw new DeveloperError('second is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    result.x = Math.min(first.x, second.x);
    result.y = Math.min(first.y, second.y);
    result.z = Math.min(first.z, second.z);
    result.w = Math.min(first.w, second.w);
    return result;
};
Cartesian4.maximumByComponent = function (first, second, result) {
    if (!defined(first)) {
        throw new DeveloperError('first is required.');
    }
    if (!defined(second)) {
        throw new DeveloperError('second is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    result.x = Math.max(first.x, second.x);
    result.y = Math.max(first.y, second.y);
    result.z = Math.max(first.z, second.z);
    result.w = Math.max(first.w, second.w);
    return result;
};
Cartesian4.magnitudeSquared = function (cartesian) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;
};
Cartesian4.magnitude = function (cartesian) {
    return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
};
var distanceScratch = new Cartesian4();
Cartesian4.distance = function (left, right) {
    if (!defined(left) || !defined(right)) {
        throw new DeveloperError('left and right are required.');
    }
    Cartesian4.subtract(left, right, distanceScratch);
    return Cartesian4.magnitude(distanceScratch);
};
Cartesian4.distanceSquared = function (left, right) {
    if (!defined(left) || !defined(right)) {
        throw new DeveloperError('left and right are required.');
    }
    Cartesian4.subtract(left, right, distanceScratch);
    return Cartesian4.magnitudeSquared(distanceScratch);
};
Cartesian4.normalize = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var magnitude = Cartesian4.magnitude(cartesian);
    result.x = cartesian.x / magnitude;
    result.y = cartesian.y / magnitude;
    result.z = cartesian.z / magnitude;
    result.w = cartesian.w / magnitude;
    return result;
};
Cartesian4.dot = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
};
Cartesian4.multiplyComponents = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x * right.x;
    result.y = left.y * right.y;
    result.z = left.z * right.z;
    result.w = left.w * right.w;
    return result;
};
Cartesian4.add = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x + right.x;
    result.y = left.y + right.y;
    result.z = left.z + right.z;
    result.w = left.w + right.w;
    return result;
};
Cartesian4.subtract = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x - right.x;
    result.y = left.y - right.y;
    result.z = left.z - right.z;
    result.w = left.w - right.w;
    return result;
};
Cartesian4.multiplyByScalar = function (cartesian, scalar, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = cartesian.x * scalar;
    result.y = cartesian.y * scalar;
    result.z = cartesian.z * scalar;
    result.w = cartesian.w * scalar;
    return result;
};
Cartesian4.divideByScalar = function (cartesian, scalar, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = cartesian.x / scalar;
    result.y = cartesian.y / scalar;
    result.z = cartesian.z / scalar;
    result.w = cartesian.w / scalar;
    return result;
};
Cartesian4.negate = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = -cartesian.x;
    result.y = -cartesian.y;
    result.z = -cartesian.z;
    result.w = -cartesian.w;
    return result;
};
Cartesian4.abs = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = Math.abs(cartesian.x);
    result.y = Math.abs(cartesian.y);
    result.z = Math.abs(cartesian.z);
    result.w = Math.abs(cartesian.w);
    return result;
};
var lerpScratch = new Cartesian4();
Cartesian4.lerp = function (start, end, t, result) {
    if (!defined(start)) {
        throw new DeveloperError('start is required.');
    }
    if (!defined(end)) {
        throw new DeveloperError('end is required.');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    Cartesian4.multiplyByScalar(end, t, lerpScratch);
    result = Cartesian4.multiplyByScalar(start, 1 - t, result);
    return Cartesian4.add(lerpScratch, result, result);
};
var mostOrthogonalAxisScratch = new Cartesian4();
Cartesian4.mostOrthogonalAxis = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);
    Cartesian4.abs(f, f);
    if (f.x <= f.y) {
        if (f.x <= f.z) {
            if (f.x <= f.w) {
                result = Cartesian4.clone(Cartesian4.UNIT_X, result);
            } else {
                result = Cartesian4.clone(Cartesian4.UNIT_W, result);
            }
        } else if (f.z <= f.w) {
            result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
        } else {
            result = Cartesian4.clone(Cartesian4.UNIT_W, result);
        }
    } else if (f.y <= f.z) {
        if (f.y <= f.w) {
            result = Cartesian4.clone(Cartesian4.UNIT_Y, result);
        } else {
            result = Cartesian4.clone(Cartesian4.UNIT_W, result);
        }
    } else if (f.z <= f.w) {
        result = Cartesian4.clone(Cartesian4.UNIT_Z, result);
    } else {
        result = Cartesian4.clone(Cartesian4.UNIT_W, result);
    }
    return result;
};
Cartesian4.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;
};
Cartesian4.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon);
};
Cartesian4.ZERO = freezeObject(new Cartesian4(0, 0, 0, 0));
Cartesian4.UNIT_X = freezeObject(new Cartesian4(1, 0, 0, 0));
Cartesian4.UNIT_Y = freezeObject(new Cartesian4(0, 1, 0, 0));
Cartesian4.UNIT_Z = freezeObject(new Cartesian4(0, 0, 1, 0));
Cartesian4.UNIT_W = freezeObject(new Cartesian4(0, 0, 0, 1));
Cartesian4.prototype.clone = function (result) {
    return Cartesian4.clone(this, result);
};
Cartesian4.prototype.equals = function (right) {
    return Cartesian4.equals(this, right);
};
Cartesian4.prototype.equalsEpsilon = function (right, epsilon) {
    return Cartesian4.equalsEpsilon(this, right, epsilon);
};
Cartesian4.prototype.toString = function () {
    return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
};
module.exports = Cartesian4;
},{"./DeveloperError":123,"./Math":174,"./defaultValue":243,"./defined":245,"./freezeObject":249}],104:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
var Cartographic = function (longitude, latitude, height) {
    this.longitude = defaultValue(longitude, 0);
    this.latitude = defaultValue(latitude, 0);
    this.height = defaultValue(height, 0);
};
Cartographic.fromRadians = function (longitude, latitude, height, result) {
    if (!defined(longitude)) {
        throw new DeveloperError('longitude is required.');
    }
    if (!defined(latitude)) {
        throw new DeveloperError('latitude is required.');
    }
    height = defaultValue(height, 0);
    if (!defined(result)) {
        return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
};
Cartographic.fromDegrees = function (longitude, latitude, height, result) {
    if (!defined(longitude)) {
        throw new DeveloperError('longitude is required.');
    }
    if (!defined(latitude)) {
        throw new DeveloperError('latitude is required.');
    }
    longitude = CesiumMath.toRadians(longitude);
    latitude = CesiumMath.toRadians(latitude);
    return Cartographic.fromRadians(longitude, latitude, height, result);
};
Cartographic.clone = function (cartographic, result) {
    if (!defined(cartographic)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);
    }
    result.longitude = cartographic.longitude;
    result.latitude = cartographic.latitude;
    result.height = cartographic.height;
    return result;
};
Cartographic.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.longitude === right.longitude && left.latitude === right.latitude && left.height === right.height;
};
Cartographic.equalsEpsilon = function (left, right, epsilon) {
    if (typeof epsilon !== 'number') {
        throw new DeveloperError('epsilon is required and must be a number.');
    }
    return left === right || defined(left) && defined(right) && Math.abs(left.longitude - right.longitude) <= epsilon && Math.abs(left.latitude - right.latitude) <= epsilon && Math.abs(left.height - right.height) <= epsilon;
};
Cartographic.ZERO = freezeObject(new Cartographic(0, 0, 0));
Cartographic.prototype.clone = function (result) {
    return Cartographic.clone(this, result);
};
Cartographic.prototype.equals = function (right) {
    return Cartographic.equals(this, right);
};
Cartographic.prototype.equalsEpsilon = function (right, epsilon) {
    return Cartographic.equalsEpsilon(this, right, epsilon);
};
Cartographic.prototype.toString = function () {
    return '(' + this.longitude + ', ' + this.latitude + ', ' + this.height + ')';
};
module.exports = Cartographic;
},{"./DeveloperError":123,"./Math":174,"./defaultValue":243,"./defined":245,"./freezeObject":249}],105:[function(require,module,exports){
var Uri = require('../ThirdParty/Uri'), when = require('../ThirdParty/when'), appendForwardSlash = require('./appendForwardSlash'), BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), Credit = require('./Credit'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Event = require('./Event'), GeographicTilingScheme = require('./GeographicTilingScheme'), HeightmapTerrainData = require('./HeightmapTerrainData'), IndexDatatype = require('./IndexDatatype'), loadArrayBuffer = require('./loadArrayBuffer'), loadJson = require('./loadJson'), QuantizedMeshTerrainData = require('./QuantizedMeshTerrainData'), RuntimeError = require('./RuntimeError'), TerrainProvider = require('./TerrainProvider'), throttleRequestByServer = require('./throttleRequestByServer'), TileProviderError = require('./TileProviderError');
'use strict';
var CesiumTerrainProvider = function CesiumTerrainProvider(options) {
    if (!defined(options) || !defined(options.url)) {
        throw new DeveloperError('options.url is required.');
    }
    this._url = appendForwardSlash(options.url);
    this._proxy = options.proxy;
    this._tilingScheme = new GeographicTilingScheme({
        numberOfLevelZeroTilesX: 2,
        numberOfLevelZeroTilesY: 1
    });
    this._heightmapWidth = 65;
    this._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, this._heightmapWidth, this._tilingScheme.getNumberOfXTilesAtLevel(0));
    this._heightmapStructure = undefined;
    this._hasWaterMask = false;
    this._hasVertexNormals = false;
    this._requestVertexNormals = defaultValue(options.requestVertexNormals, false);
    this._littleEndianExtensionSize = true;
    this._errorEvent = new Event();
    var credit = options.credit;
    if (typeof credit === 'string') {
        credit = new Credit(credit);
    }
    this._credit = credit;
    this._ready = false;
    var metadataUrl = this._url + 'layer.json';
    if (defined(this._proxy)) {
        metadataUrl = this._proxy.getURL(metadataUrl);
    }
    var that = this;
    var metadataError;
    function metadataSuccess(data) {
        var message;
        if (!data.format) {
            message = 'The tile format is not specified in the layer.json file.';
            metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
            return;
        }
        if (!data.tiles || data.tiles.length === 0) {
            message = 'The layer.json file does not specify any tile URL templates.';
            metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
            return;
        }
        if (data.format === 'heightmap-1.0') {
            that._heightmapStructure = {
                heightScale: 1 / 5,
                heightOffset: -1000,
                elementsPerHeight: 1,
                stride: 1,
                elementMultiplier: 256,
                isBigEndian: false
            };
            that._hasWaterMask = true;
        } else if (data.format.indexOf('quantized-mesh-1.') === 0) {
            that._hasWaterMask = false;
        } else {
            message = 'The tile format "' + data.format + '" is invalid or not supported.';
            metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
            return;
        }
        var baseUri = new Uri(metadataUrl);
        that._tileUrlTemplates = data.tiles;
        for (var i = 0; i < that._tileUrlTemplates.length; ++i) {
            that._tileUrlTemplates[i] = new Uri(that._tileUrlTemplates[i]).resolve(baseUri).toString().replace('{version}', data.version);
        }
        that._availableTiles = data.available;
        if (!defined(that._credit) && defined(data.attribution) && data.attribution !== null) {
            that._credit = new Credit(data.attribution);
        }
        if (defined(data.extensions) && data.extensions.indexOf('octvertexnormals') !== -1) {
            that._hasVertexNormals = true;
        } else if (defined(data.extensions) && data.extensions.indexOf('vertexnormals') !== -1) {
            that._hasVertexNormals = true;
            that._littleEndianExtensionSize = false;
        }
        that._ready = true;
    }
    function metadataFailure(data) {
        if (defined(data) && data.statusCode === 404) {
            metadataSuccess({
                tilejson: '2.1.0',
                format: 'heightmap-1.0',
                version: '1.0.0',
                scheme: 'tms',
                tiles: ['{z}/{x}/{y}.terrain?v={version}']
            });
            return;
        }
        var message = 'An error occurred while accessing ' + metadataUrl + '.';
        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
    }
    function requestMetadata() {
        var metadata = loadJson(metadataUrl);
        when(metadata, metadataSuccess, metadataFailure);
    }
    requestMetadata();
};
var QuantizedMeshExtensionIds = { OCT_VERTEX_NORMALS: 1 };
function getRequestHeader(extensionsList) {
    if (!defined(extensionsList) || extensionsList.length === 0) {
        return { Accept: 'application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01' };
    } else {
        var extensions = extensionsList.join('-');
        return { Accept: 'application/vnd.quantized-mesh;extensions=' + extensions + ',application/octet-stream;q=0.9,*/*;q=0.01' };
    }
}
function createHeightmapTerrainData(provider, buffer, level, x, y, tmsY) {
    var heightBuffer = new Uint16Array(buffer, 0, provider._heightmapWidth * provider._heightmapWidth);
    return new HeightmapTerrainData({
        buffer: heightBuffer,
        childTileMask: new Uint8Array(buffer, heightBuffer.byteLength, 1)[0],
        waterMask: new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1),
        width: provider._heightmapWidth,
        height: provider._heightmapWidth,
        structure: provider._heightmapStructure
    });
}
function createQuantizedMeshTerrainData(provider, buffer, level, x, y, tmsY) {
    var pos = 0;
    var cartesian3Elements = 3;
    var boundingSphereElements = cartesian3Elements + 1;
    var cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;
    var boundingSphereLength = Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;
    var encodedVertexElements = 3;
    var encodedVertexLength = Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;
    var triangleElements = 3;
    var bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;
    var triangleLength = bytesPerIndex * triangleElements;
    var view = new DataView(buffer);
    var center = new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));
    pos += cartesian3Length;
    var minimumHeight = view.getFloat32(pos, true);
    pos += Float32Array.BYTES_PER_ELEMENT;
    var maximumHeight = view.getFloat32(pos, true);
    pos += Float32Array.BYTES_PER_ELEMENT;
    var boundingSphere = new BoundingSphere(new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true)), view.getFloat64(pos + cartesian3Length, true));
    pos += boundingSphereLength;
    var horizonOcclusionPoint = new Cartesian3(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));
    pos += cartesian3Length;
    var vertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var encodedVertexBuffer = new Uint16Array(buffer, pos, vertexCount * 3);
    pos += vertexCount * encodedVertexLength;
    if (vertexCount > 64 * 1024) {
        bytesPerIndex = Uint32Array.BYTES_PER_ELEMENT;
        triangleLength = bytesPerIndex * triangleElements;
    }
    var uBuffer = encodedVertexBuffer.subarray(0, vertexCount);
    var vBuffer = encodedVertexBuffer.subarray(vertexCount, 2 * vertexCount);
    var heightBuffer = encodedVertexBuffer.subarray(vertexCount * 2, 3 * vertexCount);
    var i;
    var u = 0;
    var v = 0;
    var height = 0;
    function zigZagDecode(value) {
        return value >> 1 ^ -(value & 1);
    }
    for (i = 0; i < vertexCount; ++i) {
        u += zigZagDecode(uBuffer[i]);
        v += zigZagDecode(vBuffer[i]);
        height += zigZagDecode(heightBuffer[i]);
        uBuffer[i] = u;
        vBuffer[i] = v;
        heightBuffer[i] = height;
    }
    if (pos % bytesPerIndex !== 0) {
        pos += bytesPerIndex - pos % bytesPerIndex;
    }
    var triangleCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var indices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, triangleCount * triangleElements);
    pos += triangleCount * triangleLength;
    var highest = 0;
    for (i = 0; i < indices.length; ++i) {
        var code = indices[i];
        indices[i] = highest - code;
        if (code === 0) {
            ++highest;
        }
    }
    var westVertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var westIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, westVertexCount);
    pos += westVertexCount * bytesPerIndex;
    var southVertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var southIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, southVertexCount);
    pos += southVertexCount * bytesPerIndex;
    var eastVertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var eastIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, eastVertexCount);
    pos += eastVertexCount * bytesPerIndex;
    var northVertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var northIndices = IndexDatatype.createTypedArrayFromArrayBuffer(vertexCount, buffer, pos, northVertexCount);
    pos += northVertexCount * bytesPerIndex;
    var encodedNormalBuffer;
    while (pos < view.byteLength) {
        var extensionId = view.getUint8(pos, true);
        pos += Uint8Array.BYTES_PER_ELEMENT;
        var extensionLength = view.getUint32(pos, provider._littleEndianExtensionSize);
        pos += Uint32Array.BYTES_PER_ELEMENT;
        if (extensionId === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS) {
            encodedNormalBuffer = new Uint8Array(buffer, pos, vertexCount * 2);
        }
        pos += extensionLength;
    }
    var skirtHeight = provider.getLevelMaximumGeometricError(level) * 5;
    return new QuantizedMeshTerrainData({
        center: center,
        minimumHeight: minimumHeight,
        maximumHeight: maximumHeight,
        boundingSphere: boundingSphere,
        horizonOcclusionPoint: horizonOcclusionPoint,
        quantizedVertices: encodedVertexBuffer,
        encodedNormals: encodedNormalBuffer,
        indices: indices,
        westIndices: westIndices,
        southIndices: southIndices,
        eastIndices: eastIndices,
        northIndices: northIndices,
        westSkirtHeight: skirtHeight,
        southSkirtHeight: skirtHeight,
        eastSkirtHeight: skirtHeight,
        northSkirtHeight: skirtHeight,
        childTileMask: getChildMaskForTile(provider, level, x, tmsY)
    });
}
CesiumTerrainProvider.prototype.requestTileGeometry = function (x, y, level, throttleRequests) {
    if (!this._ready) {
        throw new DeveloperError('requestTileGeometry must not be called before the terrain provider is ready.');
    }
    var urlTemplates = this._tileUrlTemplates;
    if (urlTemplates.length === 0) {
        return undefined;
    }
    var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);
    var tmsY = yTiles - y - 1;
    var url = urlTemplates[0].replace('{z}', level).replace('{x}', x).replace('{y}', tmsY);
    var proxy = this._proxy;
    if (defined(proxy)) {
        url = proxy.getURL(url);
    }
    var promise;
    var extensionList = [];
    if (this._requestVertexNormals && this._hasVertexNormals) {
        extensionList.push(this._littleEndianExtensionSize ? 'octvertexnormals' : 'vertexnormals');
    }
    var tileLoader = function (tileUrl) {
        return loadArrayBuffer(tileUrl, getRequestHeader(extensionList));
    };
    throttleRequests = defaultValue(throttleRequests, true);
    if (throttleRequests) {
        promise = throttleRequestByServer(url, tileLoader);
        if (!defined(promise)) {
            return undefined;
        }
    } else {
        promise = tileLoader(url);
    }
    var that = this;
    return when(promise, function (buffer) {
        if (defined(that._heightmapStructure)) {
            return createHeightmapTerrainData(that, buffer, level, x, y, tmsY);
        } else {
            return createQuantizedMeshTerrainData(that, buffer, level, x, y, tmsY);
        }
    });
};
defineProperties(CesiumTerrainProvider.prototype, {
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    credit: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('credit must not be called before the terrain provider is ready.');
            }
            return this._credit;
        }
    },
    tilingScheme: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the terrain provider is ready.');
            }
            return this._tilingScheme;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    hasWaterMask: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('hasWaterMask must not be called before the terrain provider is ready.');
            }
            return this._hasWaterMask;
        }
    },
    hasVertexNormals: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('hasVertexNormals must not be called before the terrain provider is ready.');
            }
            return this._hasVertexNormals && this._requestVertexNormals;
        }
    },
    requestVertexNormals: {
        get: function () {
            return this._requestVertexNormals;
        }
    }
});
CesiumTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {
    return this._levelZeroMaximumGeometricError / (1 << level);
};
function getChildMaskForTile(terrainProvider, level, x, y) {
    var available = terrainProvider._availableTiles;
    if (!available || available.length === 0) {
        return 15;
    }
    var childLevel = level + 1;
    if (childLevel >= available.length) {
        return 0;
    }
    var levelAvailable = available[childLevel];
    var mask = 0;
    mask |= isTileInRange(levelAvailable, 2 * x, 2 * y) ? 1 : 0;
    mask |= isTileInRange(levelAvailable, 2 * x + 1, 2 * y) ? 2 : 0;
    mask |= isTileInRange(levelAvailable, 2 * x, 2 * y + 1) ? 4 : 0;
    mask |= isTileInRange(levelAvailable, 2 * x + 1, 2 * y + 1) ? 8 : 0;
    return mask;
}
function isTileInRange(levelAvailable, x, y) {
    for (var i = 0, len = levelAvailable.length; i < len; ++i) {
        var range = levelAvailable[i];
        if (x >= range.startX && x <= range.endX && y >= range.startY && y <= range.endY) {
            return true;
        }
    }
    return false;
}
CesiumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {
    var available = this._availableTiles;
    if (!available || available.length === 0) {
        return undefined;
    } else {
        if (level >= available.length) {
            return false;
        }
        var levelAvailable = available[level];
        var yTiles = this._tilingScheme.getNumberOfYTilesAtLevel(level);
        var tmsY = yTiles - y - 1;
        return isTileInRange(levelAvailable, x, tmsY);
    }
};
module.exports = CesiumTerrainProvider;
},{"../ThirdParty/Uri":587,"../ThirdParty/when":596,"./BoundingSphere":98,"./Cartesian3":102,"./Credit":118,"./DeveloperError":123,"./Event":138,"./GeographicTilingScheme":144,"./HeightmapTerrainData":153,"./IndexDatatype":162,"./QuantizedMeshTerrainData":195,"./RuntimeError":207,"./TerrainProvider":219,"./TileProviderError":220,"./appendForwardSlash":236,"./defaultValue":243,"./defineProperties":244,"./defined":245,"./loadArrayBuffer":257,"./loadJson":261,"./throttleRequestByServer":272}],106:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EllipseGeometry = require('./EllipseGeometry'), Ellipsoid = require('./Ellipsoid'), VertexFormat = require('./VertexFormat');
'use strict';
var CircleGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var radius = options.radius;
    if (!defined(radius)) {
        throw new DeveloperError('radius is required.');
    }
    if (radius <= 0) {
        throw new DeveloperError('radius must be greater than zero.');
    }
    var ellipseGeometryOptions = {
            center: options.center,
            semiMajorAxis: radius,
            semiMinorAxis: radius,
            ellipsoid: options.ellipsoid,
            height: options.height,
            extrudedHeight: options.extrudedHeight,
            granularity: options.granularity,
            vertexFormat: options.vertexFormat,
            stRotation: options.stRotation
        };
    this._ellipseGeometry = new EllipseGeometry(ellipseGeometryOptions);
    this._workerName = 'createCircleGeometry';
};
CircleGeometry.packedLength = EllipseGeometry.packedLength;
CircleGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    EllipseGeometry.pack(value._ellipseGeometry, array, startingIndex);
};
var scratchEllipseGeometry = new EllipseGeometry({
        center: new Cartesian3(),
        semiMajorAxis: 1,
        semiMinorAxis: 1
    });
var scratchOptions = {
        center: new Cartesian3(),
        radius: undefined,
        ellipsoid: Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),
        height: undefined,
        extrudedHeight: undefined,
        granularity: undefined,
        vertexFormat: new VertexFormat(),
        stRotation: undefined,
        semiMajorAxis: undefined,
        semiMinorAxis: undefined
    };
CircleGeometry.unpack = function (array, startingIndex, result) {
    var ellipseGeometry = EllipseGeometry.unpack(array, startingIndex, scratchEllipseGeometry);
    scratchOptions.center = Cartesian3.clone(ellipseGeometry._center, scratchOptions.center);
    scratchOptions.ellipsoid = Ellipsoid.clone(ellipseGeometry._ellipsoid, scratchOptions.ellipsoid);
    scratchOptions.height = ellipseGeometry._height;
    scratchOptions.extrudedHeight = ellipseGeometry._extrudedHeight;
    scratchOptions.granularity = ellipseGeometry._granularity;
    scratchOptions.vertexFormat = VertexFormat.clone(ellipseGeometry._vertexFormat, scratchOptions.vertexFormat);
    scratchOptions.stRotation = ellipseGeometry._stRotation;
    if (!defined(result)) {
        scratchOptions.radius = ellipseGeometry._semiMajorAxis;
        return new CircleGeometry(scratchOptions);
    }
    scratchOptions.semiMajorAxis = ellipseGeometry._semiMajorAxis;
    scratchOptions.semiMinorAxis = ellipseGeometry._semiMinorAxis;
    result._ellipseGeometry = new EllipseGeometry(scratchOptions);
    return result;
};
CircleGeometry.createGeometry = function (circleGeometry) {
    return EllipseGeometry.createGeometry(circleGeometry._ellipseGeometry);
};
module.exports = CircleGeometry;
},{"./Cartesian3":102,"./DeveloperError":123,"./EllipseGeometry":127,"./Ellipsoid":130,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],107:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EllipseOutlineGeometry = require('./EllipseOutlineGeometry'), Ellipsoid = require('./Ellipsoid');
'use strict';
var CircleOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var radius = options.radius;
    if (!defined(radius)) {
        throw new DeveloperError('radius is required.');
    }
    if (radius <= 0) {
        throw new DeveloperError('radius must be greater than zero.');
    }
    var ellipseGeometryOptions = {
            center: options.center,
            semiMajorAxis: radius,
            semiMinorAxis: radius,
            ellipsoid: options.ellipsoid,
            height: options.height,
            extrudedHeight: options.extrudedHeight,
            granularity: options.granularity,
            numberOfVerticalLines: options.numberOfVerticalLines
        };
    this._ellipseGeometry = new EllipseOutlineGeometry(ellipseGeometryOptions);
    this._workerName = 'createCircleOutlineGeometry';
};
CircleOutlineGeometry.packedLength = EllipseOutlineGeometry.packedLength;
CircleOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    EllipseOutlineGeometry.pack(value._ellipseGeometry, array, startingIndex);
};
var scratchEllipseGeometry = new EllipseOutlineGeometry({
        center: new Cartesian3(),
        semiMajorAxis: 1,
        semiMinorAxis: 1
    });
var scratchOptions = {
        center: new Cartesian3(),
        radius: undefined,
        ellipsoid: Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),
        height: undefined,
        extrudedHeight: undefined,
        granularity: undefined,
        numberOfVerticalLines: undefined,
        semiMajorAxis: undefined,
        semiMinorAxis: undefined
    };
CircleOutlineGeometry.unpack = function (array, startingIndex, result) {
    var ellipseGeometry = EllipseOutlineGeometry.unpack(array, startingIndex, scratchEllipseGeometry);
    scratchOptions.center = Cartesian3.clone(ellipseGeometry._center, scratchOptions.center);
    scratchOptions.ellipsoid = Ellipsoid.clone(ellipseGeometry._ellipsoid, scratchOptions.ellipsoid);
    scratchOptions.height = ellipseGeometry._height;
    scratchOptions.extrudedHeight = ellipseGeometry._extrudedHeight;
    scratchOptions.granularity = ellipseGeometry._granularity;
    scratchOptions.numberOfVerticalLines = ellipseGeometry._numberOfVerticalLines;
    if (!defined(result)) {
        scratchOptions.radius = ellipseGeometry._semiMajorAxis;
        return new CircleOutlineGeometry(scratchOptions);
    }
    scratchOptions.semiMajorAxis = ellipseGeometry._semiMajorAxis;
    scratchOptions.semiMinorAxis = ellipseGeometry._semiMinorAxis;
    result._ellipseGeometry = new EllipseOutlineGeometry(scratchOptions);
    return result;
};
CircleOutlineGeometry.createGeometry = function (circleGeometry) {
    return EllipseOutlineGeometry.createGeometry(circleGeometry._ellipseGeometry);
};
module.exports = CircleOutlineGeometry;
},{"./Cartesian3":102,"./DeveloperError":123,"./EllipseOutlineGeometry":129,"./Ellipsoid":130,"./defaultValue":243,"./defined":245}],108:[function(require,module,exports){
var ClockRange = require('./ClockRange'), ClockStep = require('./ClockStep'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Event = require('./Event'), getTimestamp = require('./getTimestamp'), JulianDate = require('./JulianDate');
'use strict';
var Clock = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var startTime = options.startTime;
    var startTimeUndefined = !defined(startTime);
    var stopTime = options.stopTime;
    var stopTimeUndefined = !defined(stopTime);
    var currentTime = options.currentTime;
    var currentTimeUndefined = !defined(currentTime);
    if (startTimeUndefined && stopTimeUndefined && currentTimeUndefined) {
        currentTime = JulianDate.now();
        startTime = JulianDate.clone(currentTime);
        stopTime = JulianDate.addDays(currentTime, 1, new JulianDate());
    } else if (startTimeUndefined && stopTimeUndefined) {
        startTime = JulianDate.clone(currentTime);
        stopTime = JulianDate.addDays(currentTime, 1, new JulianDate());
    } else if (startTimeUndefined && currentTimeUndefined) {
        startTime = JulianDate.addDays(stopTime, -1, new JulianDate());
        currentTime = JulianDate.clone(startTime);
    } else if (currentTimeUndefined && stopTimeUndefined) {
        currentTime = JulianDate.clone(startTime);
        stopTime = JulianDate.addDays(startTime, 1, new JulianDate());
    } else if (currentTimeUndefined) {
        currentTime = JulianDate.clone(startTime);
    } else if (stopTimeUndefined) {
        stopTime = JulianDate.addDays(currentTime, 1, new JulianDate());
    } else if (startTimeUndefined) {
        startTime = JulianDate.clone(currentTime);
    }
    if (JulianDate.greaterThan(startTime, stopTime)) {
        throw new DeveloperError('startTime must come before stopTime.');
    }
    this.startTime = startTime;
    this.stopTime = stopTime;
    this.currentTime = currentTime;
    this.multiplier = defaultValue(options.multiplier, 1);
    this.clockStep = defaultValue(options.clockStep, ClockStep.SYSTEM_CLOCK_MULTIPLIER);
    this.clockRange = defaultValue(options.clockRange, ClockRange.UNBOUNDED);
    this.canAnimate = defaultValue(options.canAnimate, true);
    this.shouldAnimate = defaultValue(options.shouldAnimate, true);
    this.onTick = new Event();
    this._lastSystemTime = getTimestamp();
};
Clock.prototype.tick = function () {
    var currentSystemTime = getTimestamp();
    var currentTime = JulianDate.clone(this.currentTime);
    var startTime = this.startTime;
    var stopTime = this.stopTime;
    var multiplier = this.multiplier;
    if (this.canAnimate && this.shouldAnimate) {
        if (this.clockStep === ClockStep.SYSTEM_CLOCK) {
            currentTime = JulianDate.now(currentTime);
        } else {
            if (this.clockStep === ClockStep.TICK_DEPENDENT) {
                currentTime = JulianDate.addSeconds(currentTime, multiplier, currentTime);
            } else {
                var milliseconds = currentSystemTime - this._lastSystemTime;
                currentTime = JulianDate.addSeconds(currentTime, multiplier * (milliseconds / 1000), currentTime);
            }
            if (this.clockRange === ClockRange.CLAMPED) {
                if (JulianDate.lessThan(currentTime, startTime)) {
                    currentTime = JulianDate.clone(startTime, currentTime);
                } else if (JulianDate.greaterThan(currentTime, stopTime)) {
                    currentTime = JulianDate.clone(stopTime, currentTime);
                }
            } else if (this.clockRange === ClockRange.LOOP_STOP) {
                if (JulianDate.lessThan(currentTime, startTime)) {
                    currentTime = JulianDate.clone(startTime, currentTime);
                }
                while (JulianDate.greaterThan(currentTime, stopTime)) {
                    currentTime = JulianDate.addSeconds(startTime, JulianDate.secondsDifference(currentTime, stopTime), currentTime);
                }
            }
        }
    }
    this.currentTime = currentTime;
    this._lastSystemTime = currentSystemTime;
    this.onTick.raiseEvent(this);
    return currentTime;
};
Clock.clone = function (clock, result) {
    if (!defined(clock)) {
        return undefined;
    }
    if (!defined(result)) {
        result = new Clock();
    }
    result.startTime = clock.startTime;
    result.stopTime = clock.stopTime;
    result.currentTime = clock.currentTime;
    result.multiplier = clock.multiplier;
    result.clockStep = clock.clockStep;
    result.clockRange = clock.clockRange;
    result.canAnimate = clock.canAnimate;
    result.shouldAnimate = clock.shouldAnimate;
    return result;
};
module.exports = Clock;
},{"./ClockRange":109,"./ClockStep":110,"./DeveloperError":123,"./Event":138,"./JulianDate":168,"./defaultValue":243,"./defined":245,"./getTimestamp":252}],109:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var ClockRange = {
        UNBOUNDED: 0,
        CLAMPED: 1,
        LOOP_STOP: 2
    };
module.exports = freezeObject(ClockRange);
},{"./freezeObject":249}],110:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var ClockStep = {
        TICK_DEPENDENT: 0,
        SYSTEM_CLOCK_MULTIPLIER: 1,
        SYSTEM_CLOCK: 2
    };
module.exports = freezeObject(ClockStep);
},{"./freezeObject":249}],111:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), FeatureDetection = require('./FeatureDetection'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
function hue2rgb(m1, m2, h) {
    if (h < 0) {
        h += 1;
    }
    if (h > 1) {
        h -= 1;
    }
    if (h * 6 < 1) {
        return m1 + (m2 - m1) * 6 * h;
    }
    if (h * 2 < 1) {
        return m2;
    }
    if (h * 3 < 2) {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
}
var Color = function (red, green, blue, alpha) {
    this.red = defaultValue(red, 1);
    this.green = defaultValue(green, 1);
    this.blue = defaultValue(blue, 1);
    this.alpha = defaultValue(alpha, 1);
};
Color.fromCartesian4 = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        return new Color(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    }
    result.red = cartesian.x;
    result.green = cartesian.y;
    result.blue = cartesian.z;
    result.alpha = cartesian.w;
    return result;
};
Color.fromBytes = function (red, green, blue, alpha) {
    red = Color.byteToFloat(defaultValue(red, 255));
    green = Color.byteToFloat(defaultValue(green, 255));
    blue = Color.byteToFloat(defaultValue(blue, 255));
    alpha = Color.byteToFloat(defaultValue(alpha, 255));
    return new Color(red, green, blue, alpha);
};
var scratchArrayBuffer;
var scratchUint32Array;
var scratchUint8Array;
if (FeatureDetection.supportsTypedArrays()) {
    scratchArrayBuffer = new ArrayBuffer(4);
    scratchUint32Array = new Uint32Array(scratchArrayBuffer);
    scratchUint8Array = new Uint8Array(scratchArrayBuffer);
}
Color.fromRgba = function (rgba) {
    scratchUint32Array[0] = rgba;
    return Color.fromBytes(scratchUint8Array[0], scratchUint8Array[1], scratchUint8Array[2], scratchUint8Array[3]);
};
Color.fromHsl = function (hue, saturation, lightness, alpha) {
    hue = defaultValue(hue, 0) % 1;
    saturation = defaultValue(saturation, 0);
    lightness = defaultValue(lightness, 0);
    alpha = defaultValue(alpha, 1);
    var red = lightness;
    var green = lightness;
    var blue = lightness;
    if (saturation !== 0) {
        var m2;
        if (lightness < 0.5) {
            m2 = lightness * (1 + saturation);
        } else {
            m2 = lightness + saturation - lightness * saturation;
        }
        var m1 = 2 * lightness - m2;
        red = hue2rgb(m1, m2, hue + 1 / 3);
        green = hue2rgb(m1, m2, hue);
        blue = hue2rgb(m1, m2, hue - 1 / 3);
    }
    return new Color(red, green, blue, alpha);
};
Color.fromRandom = function (options, result) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var red = options.red;
    if (!defined(red)) {
        var minimumRed = defaultValue(options.minimumRed, 0);
        var maximumRed = defaultValue(options.maximumRed, 1);
        if (minimumRed > maximumRed) {
            throw new DeveloperError('minimumRed must be less than or equal to maximumRed');
        }
        red = minimumRed + CesiumMath.nextRandomNumber() * (maximumRed - minimumRed);
    }
    var green = options.green;
    if (!defined(green)) {
        var minimumGreen = defaultValue(options.minimumGreen, 0);
        var maximumGreen = defaultValue(options.maximumGreen, 1);
        if (minimumGreen > maximumGreen) {
            throw new DeveloperError('minimumGreen must be less than or equal to maximumGreen');
        }
        green = minimumGreen + CesiumMath.nextRandomNumber() * (maximumGreen - minimumGreen);
    }
    var blue = options.blue;
    if (!defined(blue)) {
        var minimumBlue = defaultValue(options.minimumBlue, 0);
        var maximumBlue = defaultValue(options.maximumBlue, 1);
        if (minimumBlue > maximumBlue) {
            throw new DeveloperError('minimumBlue must be less than or equal to maximumBlue');
        }
        blue = minimumBlue + CesiumMath.nextRandomNumber() * (maximumBlue - minimumBlue);
    }
    var alpha = options.alpha;
    if (!defined(alpha)) {
        var minimumAlpha = defaultValue(options.minimumAlpha, 0);
        var maximumAlpha = defaultValue(options.maximumAlpha, 1);
        if (minimumAlpha > maximumAlpha) {
            throw new DeveloperError('minimumAlpha must be less than or equal to maximumAlpha');
        }
        alpha = minimumAlpha + CesiumMath.nextRandomNumber() * (maximumAlpha - minimumAlpha);
    }
    if (!defined(result)) {
        return new Color(red, green, blue, alpha);
    }
    result.red = red;
    result.green = green;
    result.blue = blue;
    result.alpha = alpha;
    return result;
};
var rgbMatcher = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i;
var rrggbbMatcher = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i;
var rgbParenthesesMatcher = /^rgba?\(\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)\s*,\s*([0-9.]+%?)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
var hslParenthesesMatcher = /^hsla?\(\s*([0-9.]+)\s*,\s*([0-9.]+%)\s*,\s*([0-9.]+%)(?:\s*,\s*([0-9.]+))?\s*\)$/i;
Color.fromCssColorString = function (color) {
    if (!defined(color)) {
        throw new DeveloperError('color is required');
    }
    var namedColor = Color[color.toUpperCase()];
    if (defined(namedColor)) {
        return Color.clone(namedColor);
    }
    var matches = rgbMatcher.exec(color);
    if (matches !== null) {
        return new Color(parseInt(matches[1], 16) / 15, parseInt(matches[2], 16) / 15, parseInt(matches[3], 16) / 15);
    }
    matches = rrggbbMatcher.exec(color);
    if (matches !== null) {
        return new Color(parseInt(matches[1], 16) / 255, parseInt(matches[2], 16) / 255, parseInt(matches[3], 16) / 255);
    }
    matches = rgbParenthesesMatcher.exec(color);
    if (matches !== null) {
        return new Color(parseFloat(matches[1]) / ('%' === matches[1].substr(-1) ? 100 : 255), parseFloat(matches[2]) / ('%' === matches[2].substr(-1) ? 100 : 255), parseFloat(matches[3]) / ('%' === matches[3].substr(-1) ? 100 : 255), parseFloat(defaultValue(matches[4], '1.0')));
    }
    matches = hslParenthesesMatcher.exec(color);
    if (matches !== null) {
        return Color.fromHsl(parseFloat(matches[1]) / 360, parseFloat(matches[2]) / 100, parseFloat(matches[3]) / 100, parseFloat(defaultValue(matches[4], '1.0')));
    }
    return undefined;
};
Color.packedLength = 4;
Color.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.red;
    array[startingIndex++] = value.green;
    array[startingIndex++] = value.blue;
    array[startingIndex] = value.alpha;
};
Color.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Color();
    }
    result.red = array[startingIndex++];
    result.green = array[startingIndex++];
    result.blue = array[startingIndex++];
    result.alpha = array[startingIndex];
    return result;
};
Color.byteToFloat = function (number) {
    return number / 255;
};
Color.floatToByte = function (number) {
    return number === 1 ? 255 : number * 256 | 0;
};
Color.clone = function (color, result) {
    if (!defined(color)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Color(color.red, color.green, color.blue, color.alpha);
    }
    result.red = color.red;
    result.green = color.green;
    result.blue = color.blue;
    result.alpha = color.alpha;
    return result;
};
Color.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.red === right.red && left.green === right.green && left.blue === right.blue && left.alpha === right.alpha;
};
Color.prototype.clone = function (result) {
    return Color.clone(this, result);
};
Color.prototype.equals = function (other) {
    return Color.equals(this, other);
};
Color.prototype.equalsEpsilon = function (other, epsilon) {
    return this === other || defined(other) && Math.abs(this.red - other.red) <= epsilon && Math.abs(this.green - other.green) <= epsilon && Math.abs(this.blue - other.blue) <= epsilon && Math.abs(this.alpha - other.alpha) <= epsilon;
};
Color.prototype.toString = function () {
    return '(' + this.red + ', ' + this.green + ', ' + this.blue + ', ' + this.alpha + ')';
};
Color.prototype.toCssColorString = function () {
    var red = Color.floatToByte(this.red);
    var green = Color.floatToByte(this.green);
    var blue = Color.floatToByte(this.blue);
    if (this.alpha === 1) {
        return 'rgb(' + red + ',' + green + ',' + blue + ')';
    }
    return 'rgba(' + red + ',' + green + ',' + blue + ',' + this.alpha + ')';
};
Color.prototype.toBytes = function (result) {
    var red = Color.floatToByte(this.red);
    var green = Color.floatToByte(this.green);
    var blue = Color.floatToByte(this.blue);
    var alpha = Color.floatToByte(this.alpha);
    if (!defined(result)) {
        return [
            red,
            green,
            blue,
            alpha
        ];
    }
    result[0] = red;
    result[1] = green;
    result[2] = blue;
    result[3] = alpha;
    return result;
};
Color.prototype.toRgba = function () {
    scratchUint8Array[0] = Color.floatToByte(this.red);
    scratchUint8Array[1] = Color.floatToByte(this.green);
    scratchUint8Array[2] = Color.floatToByte(this.blue);
    scratchUint8Array[3] = Color.floatToByte(this.alpha);
    return scratchUint32Array[0];
};
Color.prototype.brighten = function (magnitude, result) {
    if (!defined(magnitude)) {
        throw new DeveloperError('magnitude is required.');
    }
    if (magnitude < 0) {
        throw new DeveloperError('magnitude must be positive.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    magnitude = 1 - magnitude;
    result.red = 1 - (1 - this.red) * magnitude;
    result.green = 1 - (1 - this.green) * magnitude;
    result.blue = 1 - (1 - this.blue) * magnitude;
    result.alpha = this.alpha;
    return result;
};
Color.prototype.darken = function (magnitude, result) {
    if (!defined(magnitude)) {
        throw new DeveloperError('magnitude is required.');
    }
    if (magnitude < 0) {
        throw new DeveloperError('magnitude must be positive.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    magnitude = 1 - magnitude;
    result.red = this.red * magnitude;
    result.green = this.green * magnitude;
    result.blue = this.blue * magnitude;
    result.alpha = this.alpha;
    return result;
};
Color.ALICEBLUE = freezeObject(Color.fromCssColorString('#F0F8FF'));
Color.ANTIQUEWHITE = freezeObject(Color.fromCssColorString('#FAEBD7'));
Color.AQUA = freezeObject(Color.fromCssColorString('#00FFFF'));
Color.AQUAMARINE = freezeObject(Color.fromCssColorString('#7FFFD4'));
Color.AZURE = freezeObject(Color.fromCssColorString('#F0FFFF'));
Color.BEIGE = freezeObject(Color.fromCssColorString('#F5F5DC'));
Color.BISQUE = freezeObject(Color.fromCssColorString('#FFE4C4'));
Color.BLACK = freezeObject(Color.fromCssColorString('#000000'));
Color.BLANCHEDALMOND = freezeObject(Color.fromCssColorString('#FFEBCD'));
Color.BLUE = freezeObject(Color.fromCssColorString('#0000FF'));
Color.BLUEVIOLET = freezeObject(Color.fromCssColorString('#8A2BE2'));
Color.BROWN = freezeObject(Color.fromCssColorString('#A52A2A'));
Color.BURLYWOOD = freezeObject(Color.fromCssColorString('#DEB887'));
Color.CADETBLUE = freezeObject(Color.fromCssColorString('#5F9EA0'));
Color.CHARTREUSE = freezeObject(Color.fromCssColorString('#7FFF00'));
Color.CHOCOLATE = freezeObject(Color.fromCssColorString('#D2691E'));
Color.CORAL = freezeObject(Color.fromCssColorString('#FF7F50'));
Color.CORNFLOWERBLUE = freezeObject(Color.fromCssColorString('#6495ED'));
Color.CORNSILK = freezeObject(Color.fromCssColorString('#FFF8DC'));
Color.CRIMSON = freezeObject(Color.fromCssColorString('#DC143C'));
Color.CYAN = freezeObject(Color.fromCssColorString('#00FFFF'));
Color.DARKBLUE = freezeObject(Color.fromCssColorString('#00008B'));
Color.DARKCYAN = freezeObject(Color.fromCssColorString('#008B8B'));
Color.DARKGOLDENROD = freezeObject(Color.fromCssColorString('#B8860B'));
Color.DARKGRAY = freezeObject(Color.fromCssColorString('#A9A9A9'));
Color.DARKGREEN = freezeObject(Color.fromCssColorString('#006400'));
Color.DARKGREY = Color.DARKGRAY;
Color.DARKKHAKI = freezeObject(Color.fromCssColorString('#BDB76B'));
Color.DARKMAGENTA = freezeObject(Color.fromCssColorString('#8B008B'));
Color.DARKOLIVEGREEN = freezeObject(Color.fromCssColorString('#556B2F'));
Color.DARKORANGE = freezeObject(Color.fromCssColorString('#FF8C00'));
Color.DARKORCHID = freezeObject(Color.fromCssColorString('#9932CC'));
Color.DARKRED = freezeObject(Color.fromCssColorString('#8B0000'));
Color.DARKSALMON = freezeObject(Color.fromCssColorString('#E9967A'));
Color.DARKSEAGREEN = freezeObject(Color.fromCssColorString('#8FBC8F'));
Color.DARKSLATEBLUE = freezeObject(Color.fromCssColorString('#483D8B'));
Color.DARKSLATEGRAY = freezeObject(Color.fromCssColorString('#2F4F4F'));
Color.DARKSLATEGREY = Color.DARKSLATEGRAY;
Color.DARKTURQUOISE = freezeObject(Color.fromCssColorString('#00CED1'));
Color.DARKVIOLET = freezeObject(Color.fromCssColorString('#9400D3'));
Color.DEEPPINK = freezeObject(Color.fromCssColorString('#FF1493'));
Color.DEEPSKYBLUE = freezeObject(Color.fromCssColorString('#00BFFF'));
Color.DIMGRAY = freezeObject(Color.fromCssColorString('#696969'));
Color.DIMGREY = Color.DIMGRAY;
Color.DODGERBLUE = freezeObject(Color.fromCssColorString('#1E90FF'));
Color.FIREBRICK = freezeObject(Color.fromCssColorString('#B22222'));
Color.FLORALWHITE = freezeObject(Color.fromCssColorString('#FFFAF0'));
Color.FORESTGREEN = freezeObject(Color.fromCssColorString('#228B22'));
Color.FUSCHIA = freezeObject(Color.fromCssColorString('#FF00FF'));
Color.GAINSBORO = freezeObject(Color.fromCssColorString('#DCDCDC'));
Color.GHOSTWHITE = freezeObject(Color.fromCssColorString('#F8F8FF'));
Color.GOLD = freezeObject(Color.fromCssColorString('#FFD700'));
Color.GOLDENROD = freezeObject(Color.fromCssColorString('#DAA520'));
Color.GRAY = freezeObject(Color.fromCssColorString('#808080'));
Color.GREEN = freezeObject(Color.fromCssColorString('#008000'));
Color.GREENYELLOW = freezeObject(Color.fromCssColorString('#ADFF2F'));
Color.GREY = Color.GRAY;
Color.HONEYDEW = freezeObject(Color.fromCssColorString('#F0FFF0'));
Color.HOTPINK = freezeObject(Color.fromCssColorString('#FF69B4'));
Color.INDIANRED = freezeObject(Color.fromCssColorString('#CD5C5C'));
Color.INDIGO = freezeObject(Color.fromCssColorString('#4B0082'));
Color.IVORY = freezeObject(Color.fromCssColorString('#FFFFF0'));
Color.KHAKI = freezeObject(Color.fromCssColorString('#F0E68C'));
Color.LAVENDER = freezeObject(Color.fromCssColorString('#E6E6FA'));
Color.LAVENDAR_BLUSH = freezeObject(Color.fromCssColorString('#FFF0F5'));
Color.LAWNGREEN = freezeObject(Color.fromCssColorString('#7CFC00'));
Color.LEMONCHIFFON = freezeObject(Color.fromCssColorString('#FFFACD'));
Color.LIGHTBLUE = freezeObject(Color.fromCssColorString('#ADD8E6'));
Color.LIGHTCORAL = freezeObject(Color.fromCssColorString('#F08080'));
Color.LIGHTCYAN = freezeObject(Color.fromCssColorString('#E0FFFF'));
Color.LIGHTGOLDENRODYELLOW = freezeObject(Color.fromCssColorString('#FAFAD2'));
Color.LIGHTGRAY = freezeObject(Color.fromCssColorString('#D3D3D3'));
Color.LIGHTGREEN = freezeObject(Color.fromCssColorString('#90EE90'));
Color.LIGHTGREY = Color.LIGHTGRAY;
Color.LIGHTPINK = freezeObject(Color.fromCssColorString('#FFB6C1'));
Color.LIGHTSEAGREEN = freezeObject(Color.fromCssColorString('#20B2AA'));
Color.LIGHTSKYBLUE = freezeObject(Color.fromCssColorString('#87CEFA'));
Color.LIGHTSLATEGRAY = freezeObject(Color.fromCssColorString('#778899'));
Color.LIGHTSLATEGREY = Color.LIGHTSLATEGRAY;
Color.LIGHTSTEELBLUE = freezeObject(Color.fromCssColorString('#B0C4DE'));
Color.LIGHTYELLOW = freezeObject(Color.fromCssColorString('#FFFFE0'));
Color.LIME = freezeObject(Color.fromCssColorString('#00FF00'));
Color.LIMEGREEN = freezeObject(Color.fromCssColorString('#32CD32'));
Color.LINEN = freezeObject(Color.fromCssColorString('#FAF0E6'));
Color.MAGENTA = freezeObject(Color.fromCssColorString('#FF00FF'));
Color.MAROON = freezeObject(Color.fromCssColorString('#800000'));
Color.MEDIUMAQUAMARINE = freezeObject(Color.fromCssColorString('#66CDAA'));
Color.MEDIUMBLUE = freezeObject(Color.fromCssColorString('#0000CD'));
Color.MEDIUMORCHID = freezeObject(Color.fromCssColorString('#BA55D3'));
Color.MEDIUMPURPLE = freezeObject(Color.fromCssColorString('#9370DB'));
Color.MEDIUMSEAGREEN = freezeObject(Color.fromCssColorString('#3CB371'));
Color.MEDIUMSLATEBLUE = freezeObject(Color.fromCssColorString('#7B68EE'));
Color.MEDIUMSPRINGGREEN = freezeObject(Color.fromCssColorString('#00FA9A'));
Color.MEDIUMTURQUOISE = freezeObject(Color.fromCssColorString('#48D1CC'));
Color.MEDIUMVIOLETRED = freezeObject(Color.fromCssColorString('#C71585'));
Color.MIDNIGHTBLUE = freezeObject(Color.fromCssColorString('#191970'));
Color.MINTCREAM = freezeObject(Color.fromCssColorString('#F5FFFA'));
Color.MISTYROSE = freezeObject(Color.fromCssColorString('#FFE4E1'));
Color.MOCCASIN = freezeObject(Color.fromCssColorString('#FFE4B5'));
Color.NAVAJOWHITE = freezeObject(Color.fromCssColorString('#FFDEAD'));
Color.NAVY = freezeObject(Color.fromCssColorString('#000080'));
Color.OLDLACE = freezeObject(Color.fromCssColorString('#FDF5E6'));
Color.OLIVE = freezeObject(Color.fromCssColorString('#808000'));
Color.OLIVEDRAB = freezeObject(Color.fromCssColorString('#6B8E23'));
Color.ORANGE = freezeObject(Color.fromCssColorString('#FFA500'));
Color.ORANGERED = freezeObject(Color.fromCssColorString('#FF4500'));
Color.ORCHID = freezeObject(Color.fromCssColorString('#DA70D6'));
Color.PALEGOLDENROD = freezeObject(Color.fromCssColorString('#EEE8AA'));
Color.PALEGREEN = freezeObject(Color.fromCssColorString('#98FB98'));
Color.PALETURQUOISE = freezeObject(Color.fromCssColorString('#AFEEEE'));
Color.PALEVIOLETRED = freezeObject(Color.fromCssColorString('#DB7093'));
Color.PAPAYAWHIP = freezeObject(Color.fromCssColorString('#FFEFD5'));
Color.PEACHPUFF = freezeObject(Color.fromCssColorString('#FFDAB9'));
Color.PERU = freezeObject(Color.fromCssColorString('#CD853F'));
Color.PINK = freezeObject(Color.fromCssColorString('#FFC0CB'));
Color.PLUM = freezeObject(Color.fromCssColorString('#DDA0DD'));
Color.POWDERBLUE = freezeObject(Color.fromCssColorString('#B0E0E6'));
Color.PURPLE = freezeObject(Color.fromCssColorString('#800080'));
Color.RED = freezeObject(Color.fromCssColorString('#FF0000'));
Color.ROSYBROWN = freezeObject(Color.fromCssColorString('#BC8F8F'));
Color.ROYALBLUE = freezeObject(Color.fromCssColorString('#4169E1'));
Color.SADDLEBROWN = freezeObject(Color.fromCssColorString('#8B4513'));
Color.SALMON = freezeObject(Color.fromCssColorString('#FA8072'));
Color.SANDYBROWN = freezeObject(Color.fromCssColorString('#F4A460'));
Color.SEAGREEN = freezeObject(Color.fromCssColorString('#2E8B57'));
Color.SEASHELL = freezeObject(Color.fromCssColorString('#FFF5EE'));
Color.SIENNA = freezeObject(Color.fromCssColorString('#A0522D'));
Color.SILVER = freezeObject(Color.fromCssColorString('#C0C0C0'));
Color.SKYBLUE = freezeObject(Color.fromCssColorString('#87CEEB'));
Color.SLATEBLUE = freezeObject(Color.fromCssColorString('#6A5ACD'));
Color.SLATEGRAY = freezeObject(Color.fromCssColorString('#708090'));
Color.SLATEGREY = Color.SLATEGRAY;
Color.SNOW = freezeObject(Color.fromCssColorString('#FFFAFA'));
Color.SPRINGGREEN = freezeObject(Color.fromCssColorString('#00FF7F'));
Color.STEELBLUE = freezeObject(Color.fromCssColorString('#4682B4'));
Color.TAN = freezeObject(Color.fromCssColorString('#D2B48C'));
Color.TEAL = freezeObject(Color.fromCssColorString('#008080'));
Color.THISTLE = freezeObject(Color.fromCssColorString('#D8BFD8'));
Color.TOMATO = freezeObject(Color.fromCssColorString('#FF6347'));
Color.TURQUOISE = freezeObject(Color.fromCssColorString('#40E0D0'));
Color.VIOLET = freezeObject(Color.fromCssColorString('#EE82EE'));
Color.WHEAT = freezeObject(Color.fromCssColorString('#F5DEB3'));
Color.WHITE = freezeObject(Color.fromCssColorString('#FFFFFF'));
Color.WHITESMOKE = freezeObject(Color.fromCssColorString('#F5F5F5'));
Color.YELLOW = freezeObject(Color.fromCssColorString('#FFFF00'));
Color.YELLOWGREEN = freezeObject(Color.fromCssColorString('#9ACD32'));
module.exports = Color;
},{"./DeveloperError":123,"./FeatureDetection":141,"./Math":174,"./defaultValue":243,"./defined":245,"./freezeObject":249}],112:[function(require,module,exports){
var Color = require('./Color'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError');
'use strict';
var ColorGeometryInstanceAttribute = function (red, green, blue, alpha) {
    red = defaultValue(red, 1);
    green = defaultValue(green, 1);
    blue = defaultValue(blue, 1);
    alpha = defaultValue(alpha, 1);
    this.value = new Uint8Array([
        Color.floatToByte(red),
        Color.floatToByte(green),
        Color.floatToByte(blue),
        Color.floatToByte(alpha)
    ]);
};
defineProperties(ColorGeometryInstanceAttribute.prototype, {
    componentDatatype: {
        get: function () {
            return ComponentDatatype.UNSIGNED_BYTE;
        }
    },
    componentsPerAttribute: {
        get: function () {
            return 4;
        }
    },
    normalize: {
        get: function () {
            return true;
        }
    }
});
ColorGeometryInstanceAttribute.fromColor = function (color) {
    if (!defined(color)) {
        throw new DeveloperError('color is required.');
    }
    return new ColorGeometryInstanceAttribute(color.red, color.green, color.blue, color.alpha);
};
ColorGeometryInstanceAttribute.toValue = function (color, result) {
    if (!defined(color)) {
        throw new DeveloperError('color is required.');
    }
    if (!defined(result)) {
        return new Uint8Array(color.toBytes());
    }
    return color.toBytes(result);
};
module.exports = ColorGeometryInstanceAttribute;
},{"./Color":111,"./ComponentDatatype":113,"./DeveloperError":123,"./defaultValue":243,"./defineProperties":244,"./defined":245}],113:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), FeatureDetection = require('./FeatureDetection'), freezeObject = require('./freezeObject');
'use strict';
if (!FeatureDetection.supportsTypedArrays()) {
    return {};
}
var ComponentDatatype = {
        BYTE: 5120,
        UNSIGNED_BYTE: 5121,
        SHORT: 5122,
        UNSIGNED_SHORT: 5123,
        FLOAT: 5126,
        DOUBLE: 5130
    };
ComponentDatatype.getSizeInBytes = function (componentDatatype) {
    if (!defined(componentDatatype)) {
        throw new DeveloperError('value is required.');
    }
    switch (componentDatatype) {
    case ComponentDatatype.BYTE:
        return Int8Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.UNSIGNED_BYTE:
        return Uint8Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.SHORT:
        return Int16Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.UNSIGNED_SHORT:
        return Uint16Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.FLOAT:
        return Float32Array.BYTES_PER_ELEMENT;
    case ComponentDatatype.DOUBLE:
        return Float64Array.BYTES_PER_ELEMENT;
    default:
        throw new DeveloperError('componentDatatype is not a valid value.');
    }
};
ComponentDatatype.fromTypedArray = function (array) {
    if (array instanceof Int8Array) {
        return ComponentDatatype.BYTE;
    }
    if (array instanceof Uint8Array) {
        return ComponentDatatype.UNSIGNED_BYTE;
    }
    if (array instanceof Int16Array) {
        return ComponentDatatype.SHORT;
    }
    if (array instanceof Uint16Array) {
        return ComponentDatatype.UNSIGNED_SHORT;
    }
    if (array instanceof Float32Array) {
        return ComponentDatatype.FLOAT;
    }
    if (array instanceof Float64Array) {
        return ComponentDatatype.DOUBLE;
    }
};
ComponentDatatype.validate = function (componentDatatype) {
    return defined(componentDatatype) && (componentDatatype === ComponentDatatype.BYTE || componentDatatype === ComponentDatatype.UNSIGNED_BYTE || componentDatatype === ComponentDatatype.SHORT || componentDatatype === ComponentDatatype.UNSIGNED_SHORT || componentDatatype === ComponentDatatype.FLOAT || componentDatatype === ComponentDatatype.DOUBLE);
};
ComponentDatatype.createTypedArray = function (componentDatatype, valuesOrLength) {
    if (!defined(componentDatatype)) {
        throw new DeveloperError('componentDatatype is required.');
    }
    if (!defined(valuesOrLength)) {
        throw new DeveloperError('valuesOrLength is required.');
    }
    switch (componentDatatype) {
    case ComponentDatatype.BYTE:
        return new Int8Array(valuesOrLength);
    case ComponentDatatype.UNSIGNED_BYTE:
        return new Uint8Array(valuesOrLength);
    case ComponentDatatype.SHORT:
        return new Int16Array(valuesOrLength);
    case ComponentDatatype.UNSIGNED_SHORT:
        return new Uint16Array(valuesOrLength);
    case ComponentDatatype.FLOAT:
        return new Float32Array(valuesOrLength);
    case ComponentDatatype.DOUBLE:
        return new Float64Array(valuesOrLength);
    default:
        throw new DeveloperError('componentDatatype is not a valid value.');
    }
};
ComponentDatatype.createArrayBufferView = function (componentDatatype, buffer, byteOffset, length) {
    if (!defined(componentDatatype)) {
        throw new DeveloperError('componentDatatype is required.');
    }
    if (!defined(buffer)) {
        throw new DeveloperError('buffer is required.');
    }
    byteOffset = defaultValue(byteOffset, 0);
    length = defaultValue(length, (buffer.byteLength - byteOffset) / ComponentDatatype.getSizeInBytes(componentDatatype));
    switch (componentDatatype) {
    case ComponentDatatype.BYTE:
        return new Int8Array(buffer, byteOffset, length);
    case ComponentDatatype.UNSIGNED_BYTE:
        return new Uint8Array(buffer, byteOffset, length);
    case ComponentDatatype.SHORT:
        return new Int16Array(buffer, byteOffset, length);
    case ComponentDatatype.UNSIGNED_SHORT:
        return new Uint16Array(buffer, byteOffset, length);
    case ComponentDatatype.FLOAT:
        return new Float32Array(buffer, byteOffset, length);
    case ComponentDatatype.DOUBLE:
        return new Float64Array(buffer, byteOffset, length);
    default:
        throw new DeveloperError('componentDatatype is not a valid value.');
    }
};
module.exports = freezeObject(ComponentDatatype);
},{"./DeveloperError":123,"./FeatureDetection":141,"./defaultValue":243,"./defined":245,"./freezeObject":249}],114:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var CornerType = {
        ROUNDED: 0,
        MITERED: 1,
        BEVELED: 2
    };
module.exports = freezeObject(CornerType);
},{"./freezeObject":249}],115:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), CornerType = require('./CornerType'), CorridorGeometryLibrary = require('./CorridorGeometryLibrary'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PolylinePipeline = require('./PolylinePipeline'), PrimitiveType = require('./PrimitiveType'), VertexFormat = require('./VertexFormat');
'use strict';
var cartesian1 = new Cartesian3();
var cartesian2 = new Cartesian3();
var cartesian3 = new Cartesian3();
var cartesian4 = new Cartesian3();
var cartesian5 = new Cartesian3();
var cartesian6 = new Cartesian3();
var scratch1 = new Cartesian3();
var scratch2 = new Cartesian3();
function addNormals(attr, normal, left, front, back, vertexFormat) {
    var normals = attr.normals;
    var tangents = attr.tangents;
    var binormals = attr.binormals;
    var forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);
    if (vertexFormat.normal) {
        CorridorGeometryLibrary.addAttribute(normals, normal, front, back);
    }
    if (vertexFormat.binormal) {
        CorridorGeometryLibrary.addAttribute(binormals, left, front, back);
    }
    if (vertexFormat.tangent) {
        CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);
    }
}
function combine(computedPositions, vertexFormat, ellipsoid) {
    var positions = computedPositions.positions;
    var corners = computedPositions.corners;
    var endPositions = computedPositions.endPositions;
    var computedLefts = computedPositions.lefts;
    var computedNormals = computedPositions.normals;
    var attributes = new GeometryAttributes();
    var corner;
    var leftCount = 0;
    var rightCount = 0;
    var i;
    var indicesLength = 0;
    var length;
    for (i = 0; i < positions.length; i += 2) {
        length = positions[i].length - 3;
        leftCount += length;
        indicesLength += length * 2;
        rightCount += positions[i + 1].length - 3;
    }
    leftCount += 3;
    rightCount += 3;
    for (i = 0; i < corners.length; i++) {
        corner = corners[i];
        var leftSide = corners[i].leftPositions;
        if (defined(leftSide)) {
            length = leftSide.length;
            leftCount += length;
            indicesLength += length;
        } else {
            length = corners[i].rightPositions.length;
            rightCount += length;
            indicesLength += length;
        }
    }
    var addEndPositions = defined(endPositions);
    var endPositionLength;
    if (addEndPositions) {
        endPositionLength = endPositions[0].length - 3;
        leftCount += endPositionLength;
        rightCount += endPositionLength;
        endPositionLength /= 3;
        indicesLength += endPositionLength * 6;
    }
    var size = leftCount + rightCount;
    var finalPositions = new Float64Array(size);
    var normals = vertexFormat.normal ? new Float32Array(size) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(size) : undefined;
    var attr = {
            normals: normals,
            tangents: tangents,
            binormals: binormals
        };
    var front = 0;
    var back = size - 1;
    var UL, LL, UR, LR;
    var normal = cartesian1;
    var left = cartesian2;
    var rightPos, leftPos;
    var halfLength = endPositionLength / 2;
    var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);
    var index = 0;
    if (addEndPositions) {
        leftPos = cartesian3;
        rightPos = cartesian4;
        var firstEndPositions = endPositions[0];
        normal = Cartesian3.fromArray(computedNormals, 0, normal);
        left = Cartesian3.fromArray(computedLefts, 0, left);
        for (i = 0; i < halfLength; i++) {
            leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);
            rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);
            CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);
            CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);
            addNormals(attr, normal, left, front, back, vertexFormat);
            LL = front / 3;
            LR = LL + 1;
            UL = (back - 2) / 3;
            UR = UL - 1;
            indices[index++] = UL;
            indices[index++] = LL;
            indices[index++] = UR;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;
            front += 3;
            back -= 3;
        }
    }
    var posIndex = 0;
    var compIndex = 0;
    var rightEdge = positions[posIndex++];
    var leftEdge = positions[posIndex++];
    finalPositions.set(rightEdge, front);
    finalPositions.set(leftEdge, back - leftEdge.length + 1);
    left = Cartesian3.fromArray(computedLefts, compIndex, left);
    var rightNormal;
    var leftNormal;
    length = leftEdge.length - 3;
    for (i = 0; i < length; i += 3) {
        rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);
        leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);
        normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);
        addNormals(attr, normal, left, front, back, vertexFormat);
        LL = front / 3;
        LR = LL + 1;
        UL = (back - 2) / 3;
        UR = UL - 1;
        indices[index++] = UL;
        indices[index++] = LL;
        indices[index++] = UR;
        indices[index++] = UR;
        indices[index++] = LL;
        indices[index++] = LR;
        front += 3;
        back -= 3;
    }
    rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);
    leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);
    normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);
    compIndex += 3;
    for (i = 0; i < corners.length; i++) {
        var j;
        corner = corners[i];
        var l = corner.leftPositions;
        var r = corner.rightPositions;
        var pivot;
        var start;
        var outsidePoint = cartesian6;
        var previousPoint = cartesian3;
        var nextPoint = cartesian4;
        normal = Cartesian3.fromArray(computedNormals, compIndex, normal);
        if (defined(l)) {
            addNormals(attr, normal, left, undefined, back, vertexFormat);
            back -= 3;
            pivot = LR;
            start = UR;
            for (j = 0; j < l.length / 3; j++) {
                outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);
                indices[index++] = pivot;
                indices[index++] = start - j - 1;
                indices[index++] = start - j;
                CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);
                previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);
                nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);
                left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);
                addNormals(attr, normal, left, undefined, back, vertexFormat);
                back -= 3;
            }
            outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);
            previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, previousPoint), outsidePoint, previousPoint);
            nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);
            left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);
            addNormals(attr, normal, left, front, undefined, vertexFormat);
            front += 3;
        } else {
            addNormals(attr, normal, left, front, undefined, vertexFormat);
            front += 3;
            pivot = UR;
            start = LR;
            for (j = 0; j < r.length / 3; j++) {
                outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);
                indices[index++] = pivot;
                indices[index++] = start + j;
                indices[index++] = start + j + 1;
                CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);
                previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);
                nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);
                left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);
                addNormals(attr, normal, left, front, undefined, vertexFormat);
                front += 3;
            }
            outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);
            previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);
            nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);
            left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);
            addNormals(attr, normal, left, undefined, back, vertexFormat);
            back -= 3;
        }
        rightEdge = positions[posIndex++];
        leftEdge = positions[posIndex++];
        rightEdge.splice(0, 3);
        leftEdge.splice(leftEdge.length - 3, 3);
        finalPositions.set(rightEdge, front);
        finalPositions.set(leftEdge, back - leftEdge.length + 1);
        length = leftEdge.length - 3;
        compIndex += 3;
        left = Cartesian3.fromArray(computedLefts, compIndex, left);
        for (j = 0; j < leftEdge.length; j += 3) {
            rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);
            leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);
            normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);
            addNormals(attr, normal, left, front, back, vertexFormat);
            LR = front / 3;
            LL = LR - 1;
            UR = (back - 2) / 3;
            UL = UR + 1;
            indices[index++] = UL;
            indices[index++] = LL;
            indices[index++] = UR;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;
            front += 3;
            back -= 3;
        }
        front -= 3;
        back += 3;
    }
    normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);
    addNormals(attr, normal, left, front, back, vertexFormat);
    if (addEndPositions) {
        front += 3;
        back -= 3;
        leftPos = cartesian3;
        rightPos = cartesian4;
        var lastEndPositions = endPositions[1];
        for (i = 0; i < halfLength; i++) {
            leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);
            rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);
            CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);
            CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);
            addNormals(attr, normal, left, front, back, vertexFormat);
            LR = front / 3;
            LL = LR - 1;
            UR = (back - 2) / 3;
            UL = UR + 1;
            indices[index++] = UL;
            indices[index++] = LL;
            indices[index++] = UR;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;
            front += 3;
            back -= 3;
        }
    }
    attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: finalPositions
    });
    if (vertexFormat.st) {
        var st = new Float32Array(size / 3 * 2);
        var rightSt;
        var leftSt;
        var stIndex = 0;
        if (addEndPositions) {
            leftCount /= 3;
            rightCount /= 3;
            var theta = Math.PI / (endPositionLength + 1);
            leftSt = 1 / (leftCount - endPositionLength + 1);
            rightSt = 1 / (rightCount - endPositionLength + 1);
            var a;
            var halfEndPos = endPositionLength / 2;
            for (i = halfEndPos + 1; i < endPositionLength + 1; i++) {
                a = CesiumMath.PI_OVER_TWO + theta * i;
                st[stIndex++] = rightSt * (1 + Math.cos(a));
                st[stIndex++] = 0.5 * (1 + Math.sin(a));
            }
            for (i = 1; i < rightCount - endPositionLength + 1; i++) {
                st[stIndex++] = i * rightSt;
                st[stIndex++] = 0;
            }
            for (i = endPositionLength; i > halfEndPos; i--) {
                a = CesiumMath.PI_OVER_TWO - i * theta;
                st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));
                st[stIndex++] = 0.5 * (1 + Math.sin(a));
            }
            for (i = halfEndPos; i > 0; i--) {
                a = CesiumMath.PI_OVER_TWO - theta * i;
                st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));
                st[stIndex++] = 0.5 * (1 + Math.sin(a));
            }
            for (i = leftCount - endPositionLength; i > 0; i--) {
                st[stIndex++] = i * leftSt;
                st[stIndex++] = 1;
            }
            for (i = 1; i < halfEndPos + 1; i++) {
                a = CesiumMath.PI_OVER_TWO + theta * i;
                st[stIndex++] = leftSt * (1 + Math.cos(a));
                st[stIndex++] = 0.5 * (1 + Math.sin(a));
            }
        } else {
            leftCount /= 3;
            rightCount /= 3;
            leftSt = 1 / (leftCount - 1);
            rightSt = 1 / (rightCount - 1);
            for (i = 0; i < rightCount; i++) {
                st[stIndex++] = i * rightSt;
                st[stIndex++] = 0;
            }
            for (i = leftCount; i > 0; i--) {
                st[stIndex++] = (i - 1) * leftSt;
                st[stIndex++] = 1;
            }
        }
        attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: st
        });
    }
    if (vertexFormat.normal) {
        attributes.normal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: attr.normals
        });
    }
    if (vertexFormat.tangent) {
        attributes.tangent = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: attr.tangents
        });
    }
    if (vertexFormat.binormal) {
        attributes.binormal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: attr.binormals
        });
    }
    return {
        attributes: attributes,
        indices: indices
    };
}
function extrudedAttributes(attributes, vertexFormat) {
    if (!vertexFormat.normal && !vertexFormat.binormal && !vertexFormat.tangent && !vertexFormat.st) {
        return attributes;
    }
    var positions = attributes.position.values;
    var topNormals;
    var topBinormals;
    if (vertexFormat.normal || vertexFormat.binormal) {
        topNormals = attributes.normal.values;
        topBinormals = attributes.binormal.values;
    }
    var size = attributes.position.values.length / 18;
    var threeSize = size * 3;
    var twoSize = size * 2;
    var sixSize = threeSize * 2;
    var i;
    if (vertexFormat.normal || vertexFormat.binormal || vertexFormat.tangent) {
        var normals = vertexFormat.normal ? new Float32Array(threeSize * 6) : undefined;
        var binormals = vertexFormat.binormal ? new Float32Array(threeSize * 6) : undefined;
        var tangents = vertexFormat.tangent ? new Float32Array(threeSize * 6) : undefined;
        var topPosition = cartesian1;
        var bottomPosition = cartesian2;
        var previousPosition = cartesian3;
        var normal = cartesian4;
        var tangent = cartesian5;
        var binormal = cartesian6;
        var attrIndex = sixSize;
        for (i = 0; i < threeSize; i += 3) {
            var attrIndexOffset = attrIndex + sixSize;
            topPosition = Cartesian3.fromArray(positions, i, topPosition);
            bottomPosition = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);
            previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);
            bottomPosition = Cartesian3.subtract(bottomPosition, topPosition, bottomPosition);
            previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);
            normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);
            if (vertexFormat.normal) {
                CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);
                CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);
                CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);
                CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);
            }
            if (vertexFormat.tangent || vertexFormat.binormal) {
                binormal = Cartesian3.fromArray(topNormals, i, binormal);
                if (vertexFormat.binormal) {
                    CorridorGeometryLibrary.addAttribute(binormals, binormal, attrIndexOffset);
                    CorridorGeometryLibrary.addAttribute(binormals, binormal, attrIndexOffset + 3);
                    CorridorGeometryLibrary.addAttribute(binormals, binormal, attrIndex);
                    CorridorGeometryLibrary.addAttribute(binormals, binormal, attrIndex + 3);
                }
                if (vertexFormat.tangent) {
                    tangent = Cartesian3.normalize(Cartesian3.cross(binormal, normal, tangent), tangent);
                    CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);
                    CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);
                    CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);
                    CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);
                }
            }
            attrIndex += 6;
        }
        if (vertexFormat.normal) {
            normals.set(topNormals);
            for (i = 0; i < threeSize; i += 3) {
                normals[i + threeSize] = -topNormals[i];
                normals[i + threeSize + 1] = -topNormals[i + 1];
                normals[i + threeSize + 2] = -topNormals[i + 2];
            }
            attributes.normal.values = normals;
        } else {
            attributes.normal = undefined;
        }
        if (vertexFormat.binormal) {
            binormals.set(topBinormals);
            binormals.set(topBinormals, threeSize);
            attributes.binormal.values = binormals;
        } else {
            attributes.binormal = undefined;
        }
        if (vertexFormat.tangent) {
            var topTangents = attributes.tangent.values;
            tangents.set(topTangents);
            tangents.set(topTangents, threeSize);
            attributes.tangent.values = tangents;
        }
    }
    if (vertexFormat.st) {
        var topSt = attributes.st.values;
        var st = new Float32Array(twoSize * 6);
        st.set(topSt);
        st.set(topSt, twoSize);
        var index = twoSize * 2;
        for (var j = 0; j < 2; j++) {
            st[index++] = topSt[0];
            st[index++] = topSt[1];
            for (i = 2; i < twoSize; i += 2) {
                var s = topSt[i];
                var t = topSt[i + 1];
                st[index++] = s;
                st[index++] = t;
                st[index++] = s;
                st[index++] = t;
            }
            st[index++] = topSt[0];
            st[index++] = topSt[1];
        }
        attributes.st.values = st;
    }
    return attributes;
}
function addWallPositions(positions, index, wallPositions) {
    wallPositions[index++] = positions[0];
    wallPositions[index++] = positions[1];
    wallPositions[index++] = positions[2];
    for (var i = 3; i < positions.length; i += 3) {
        var x = positions[i];
        var y = positions[i + 1];
        var z = positions[i + 2];
        wallPositions[index++] = x;
        wallPositions[index++] = y;
        wallPositions[index++] = z;
        wallPositions[index++] = x;
        wallPositions[index++] = y;
        wallPositions[index++] = z;
    }
    wallPositions[index++] = positions[0];
    wallPositions[index++] = positions[1];
    wallPositions[index++] = positions[2];
    return wallPositions;
}
function computePositionsExtruded(params, vertexFormat) {
    var topVertexFormat = new VertexFormat({
            position: vertexFormat.positon,
            normal: vertexFormat.normal || vertexFormat.binormal,
            tangent: vertexFormat.tangent,
            binormal: vertexFormat.normal || vertexFormat.binormal,
            st: vertexFormat.st
        });
    var ellipsoid = params.ellipsoid;
    var computedPositions = CorridorGeometryLibrary.computePositions(params);
    var attr = combine(computedPositions, topVertexFormat, ellipsoid);
    var height = params.height;
    var extrudedHeight = params.extrudedHeight;
    var attributes = attr.attributes;
    var indices = attr.indices;
    var positions = attributes.position.values;
    var length = positions.length;
    var newPositions = new Float64Array(length * 6);
    var extrudedPositions = new Float64Array(length);
    extrudedPositions.set(positions);
    var wallPositions = new Float64Array(length * 4);
    positions = CorridorGeometryLibrary.scaleToGeodeticHeight(positions, height, ellipsoid, positions);
    wallPositions = addWallPositions(positions, 0, wallPositions);
    extrudedPositions = CorridorGeometryLibrary.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid, extrudedPositions);
    wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);
    newPositions.set(positions);
    newPositions.set(extrudedPositions, length);
    newPositions.set(wallPositions, length * 2);
    attributes.position.values = newPositions;
    length /= 3;
    var i;
    var iLength = indices.length;
    var twoLength = length + length;
    var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoLength * 3);
    newIndices.set(indices);
    var index = iLength;
    for (i = 0; i < iLength; i += 3) {
        var v0 = indices[i];
        var v1 = indices[i + 1];
        var v2 = indices[i + 2];
        newIndices[index++] = v2 + length;
        newIndices[index++] = v1 + length;
        newIndices[index++] = v0 + length;
    }
    attributes = extrudedAttributes(attributes, vertexFormat);
    var UL, LL, UR, LR;
    for (i = 0; i < twoLength; i += 2) {
        UL = i + twoLength;
        LL = UL + twoLength;
        UR = UL + 1;
        LR = LL + 1;
        newIndices[index++] = UL;
        newIndices[index++] = LL;
        newIndices[index++] = UR;
        newIndices[index++] = UR;
        newIndices[index++] = LL;
        newIndices[index++] = LR;
    }
    return {
        attributes: attributes,
        indices: newIndices
    };
}
var CorridorGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var positions = options.positions;
    var width = options.width;
    if (!defined(positions)) {
        throw new DeveloperError('options.positions is required.');
    }
    if (!defined(width)) {
        throw new DeveloperError('options.width is required.');
    }
    this._positions = positions;
    this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
    this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));
    this._width = width;
    this._height = defaultValue(options.height, 0);
    this._extrudedHeight = defaultValue(options.extrudedHeight, this._height);
    this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);
    this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    this._workerName = 'createCorridorGeometry';
    this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 5;
};
CorridorGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var positions = value._positions;
    var length = positions.length;
    array[startingIndex++] = length;
    for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        Cartesian3.pack(positions[i], array, startingIndex);
    }
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex++] = value._width;
    array[startingIndex++] = value._height;
    array[startingIndex++] = value._extrudedHeight;
    array[startingIndex++] = value._cornerType;
    array[startingIndex] = value._granularity;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        positions: undefined,
        ellipsoid: scratchEllipsoid,
        vertexFormat: scratchVertexFormat,
        width: undefined,
        height: undefined,
        extrudedHeight: undefined,
        cornerType: undefined,
        granularity: undefined
    };
CorridorGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var length = array[startingIndex++];
    var positions = new Array(length);
    for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var width = array[startingIndex++];
    var height = array[startingIndex++];
    var extrudedHeight = array[startingIndex++];
    var cornerType = array[startingIndex++];
    var granularity = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.positions = positions;
        scratchOptions.width = width;
        scratchOptions.height = height;
        scratchOptions.extrudedHeight = extrudedHeight;
        scratchOptions.cornerType = cornerType;
        scratchOptions.granularity = granularity;
        return new CorridorGeometry(scratchOptions);
    }
    result._positions = positions;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._width = width;
    result._height = height;
    result._extrudedHeight = extrudedHeight;
    result._cornerType = cornerType;
    result._granularity = granularity;
    return result;
};
CorridorGeometry.createGeometry = function (corridorGeometry) {
    var positions = corridorGeometry._positions;
    var height = corridorGeometry._height;
    var extrudedHeight = corridorGeometry._extrudedHeight;
    var extrude = height !== extrudedHeight;
    var cleanPositions = PolylinePipeline.removeDuplicates(positions);
    if (!defined(cleanPositions)) {
        cleanPositions = positions;
    }
    if (cleanPositions.length < 2) {
        return undefined;
    }
    var ellipsoid = corridorGeometry._ellipsoid;
    var vertexFormat = corridorGeometry._vertexFormat;
    var params = {
            ellipsoid: ellipsoid,
            positions: cleanPositions,
            width: corridorGeometry._width,
            cornerType: corridorGeometry._cornerType,
            granularity: corridorGeometry._granularity,
            saveAttributes: true
        };
    var attr;
    if (extrude) {
        var h = Math.max(height, extrudedHeight);
        extrudedHeight = Math.min(height, extrudedHeight);
        height = h;
        params.height = height;
        params.extrudedHeight = extrudedHeight;
        attr = computePositionsExtruded(params, vertexFormat);
    } else {
        var computedPositions = CorridorGeometryLibrary.computePositions(params);
        attr = combine(computedPositions, vertexFormat, ellipsoid);
        attr.attributes.position.values = CorridorGeometryLibrary.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid, attr.attributes.position.values);
    }
    var attributes = attr.attributes;
    var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);
    if (!vertexFormat.position) {
        attr.attributes.position.values = undefined;
    }
    return new Geometry({
        attributes: attributes,
        indices: attr.indices,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingSphere: boundingSphere
    });
};
module.exports = CorridorGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./ComponentDatatype":113,"./CornerType":114,"./CorridorGeometryLibrary":116,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PolylinePipeline":189,"./PrimitiveType":193,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],116:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), CornerType = require('./CornerType'), defined = require('./defined'), isArray = require('./isArray'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), PolylinePipeline = require('./PolylinePipeline'), PolylineVolumeGeometryLibrary = require('./PolylineVolumeGeometryLibrary'), Quaternion = require('./Quaternion');
'use strict';
var CorridorGeometryLibrary = {};
var scratch1 = new Cartesian3();
var scratch2 = new Cartesian3();
var scratch3 = new Cartesian3();
var scratch4 = new Cartesian3();
var scaleArray2 = [
        new Cartesian3(),
        new Cartesian3()
    ];
var cartesian1 = new Cartesian3();
var cartesian2 = new Cartesian3();
var cartesian3 = new Cartesian3();
var cartesian4 = new Cartesian3();
var cartesian5 = new Cartesian3();
var cartesian6 = new Cartesian3();
var cartesian7 = new Cartesian3();
var cartesian8 = new Cartesian3();
var cartesian9 = new Cartesian3();
var cartesian10 = new Cartesian3();
var quaterion = new Quaternion();
var rotMatrix = new Matrix3();
function computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {
    var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));
    var granularity = cornerType === CornerType.BEVELED ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;
    var size = granularity * 3;
    var array = new Array(size);
    array[size - 3] = endPoint.x;
    array[size - 2] = endPoint.y;
    array[size - 1] = endPoint.z;
    var m;
    if (leftIsOutside) {
        m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);
    } else {
        m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);
    }
    var index = 0;
    startPoint = Cartesian3.clone(startPoint, scratch1);
    for (var i = 0; i < granularity; i++) {
        startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);
        array[index++] = startPoint.x;
        array[index++] = startPoint.y;
        array[index++] = startPoint.z;
    }
    return array;
}
function addEndCaps(calculatedPositions) {
    var cornerPoint = cartesian1;
    var startPoint = cartesian2;
    var endPoint = cartesian3;
    var leftEdge = calculatedPositions[1];
    startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);
    endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);
    cornerPoint = Cartesian3.multiplyByScalar(Cartesian3.add(startPoint, endPoint, cornerPoint), 0.5, cornerPoint);
    var firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);
    var length = calculatedPositions.length - 1;
    var rightEdge = calculatedPositions[length - 1];
    leftEdge = calculatedPositions[length];
    startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);
    endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);
    cornerPoint = Cartesian3.multiplyByScalar(Cartesian3.add(startPoint, endPoint, cornerPoint), 0.5, cornerPoint);
    var lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);
    return [
        firstEndCap,
        lastEndCap
    ];
}
function computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {
    var cornerPoint = scratch1;
    if (leftIsOutside) {
        cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);
    } else {
        leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);
        cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);
    }
    return [
        cornerPoint.x,
        cornerPoint.y,
        cornerPoint.z,
        lastPoint.x,
        lastPoint.y,
        lastPoint.z
    ];
}
function addShiftedPositions(positions, left, scalar, calculatedPositions) {
    var rightPositions = new Array(positions.length);
    var leftPositions = new Array(positions.length);
    var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);
    var scaledRight = Cartesian3.negate(scaledLeft, scratch2);
    var rightIndex = 0;
    var leftIndex = positions.length - 1;
    for (var i = 0; i < positions.length; i += 3) {
        var pos = Cartesian3.fromArray(positions, i, scratch3);
        var rightPos = Cartesian3.add(pos, scaledRight, scratch4);
        rightPositions[rightIndex++] = rightPos.x;
        rightPositions[rightIndex++] = rightPos.y;
        rightPositions[rightIndex++] = rightPos.z;
        var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);
        leftPositions[leftIndex--] = leftPos.z;
        leftPositions[leftIndex--] = leftPos.y;
        leftPositions[leftIndex--] = leftPos.x;
    }
    calculatedPositions.push(rightPositions, leftPositions);
    return calculatedPositions;
}
CorridorGeometryLibrary.addAttribute = function (attribute, value, front, back) {
    var x = value.x;
    var y = value.y;
    var z = value.z;
    if (defined(front)) {
        attribute[front] = x;
        attribute[front + 1] = y;
        attribute[front + 2] = z;
    }
    if (defined(back)) {
        attribute[back] = z;
        attribute[back - 1] = y;
        attribute[back - 2] = x;
    }
};
function scaleToSurface(positions, ellipsoid) {
    for (var i = 0; i < positions.length; i++) {
        positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);
    }
    return positions;
}
CorridorGeometryLibrary.computePositions = function (params) {
    var granularity = params.granularity;
    var positions = params.positions;
    var ellipsoid = params.ellipsoid;
    positions = scaleToSurface(positions, ellipsoid);
    var width = params.width / 2;
    var cornerType = params.cornerType;
    var saveAttributes = params.saveAttributes;
    var normal = cartesian1;
    var forward = cartesian2;
    var backward = cartesian3;
    var left = cartesian4;
    var cornerDirection = cartesian5;
    var startPoint = cartesian6;
    var previousPos = cartesian7;
    var rightPos = cartesian8;
    var leftPos = cartesian9;
    var center = cartesian10;
    var calculatedPositions = [];
    var calculatedLefts = saveAttributes ? [] : undefined;
    var calculatedNormals = saveAttributes ? [] : undefined;
    var position = positions[0];
    var nextPosition = positions[1];
    forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);
    normal = ellipsoid.geodeticSurfaceNormal(position, normal);
    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);
    if (saveAttributes) {
        calculatedLefts.push(left.x, left.y, left.z);
        calculatedNormals.push(normal.x, normal.y, normal.z);
    }
    previousPos = Cartesian3.clone(position, previousPos);
    position = nextPosition;
    backward = Cartesian3.negate(forward, backward);
    var subdividedPositions;
    var corners = [];
    var i;
    var length = positions.length;
    for (i = 1; i < length - 1; i++) {
        normal = ellipsoid.geodeticSurfaceNormal(position, normal);
        nextPosition = positions[i + 1];
        forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);
        cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);
        var doCorner = !Cartesian3.equalsEpsilon(Cartesian3.negate(cornerDirection, scratch1), normal, CesiumMath.EPSILON2);
        if (doCorner) {
            cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);
            cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);
            var scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));
            var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);
            cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);
            if (leftIsOutside) {
                rightPos = Cartesian3.add(position, cornerDirection, rightPos);
                center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);
                leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);
                scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);
                scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);
                subdividedPositions = PolylinePipeline.generateArc({
                    positions: scaleArray2,
                    granularity: granularity,
                    ellipsoid: ellipsoid
                });
                calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);
                if (saveAttributes) {
                    calculatedLefts.push(left.x, left.y, left.z);
                    calculatedNormals.push(normal.x, normal.y, normal.z);
                }
                startPoint = Cartesian3.clone(leftPos, startPoint);
                left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);
                leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);
                previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);
                if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {
                    corners.push({ leftPositions: computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside) });
                } else {
                    corners.push({ leftPositions: computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside) });
                }
            } else {
                leftPos = Cartesian3.add(position, cornerDirection, leftPos);
                center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);
                rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);
                scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);
                scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);
                subdividedPositions = PolylinePipeline.generateArc({
                    positions: scaleArray2,
                    granularity: granularity,
                    ellipsoid: ellipsoid
                });
                calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);
                if (saveAttributes) {
                    calculatedLefts.push(left.x, left.y, left.z);
                    calculatedNormals.push(normal.x, normal.y, normal.z);
                }
                startPoint = Cartesian3.clone(rightPos, startPoint);
                left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);
                rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);
                previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);
                if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {
                    corners.push({ rightPositions: computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside) });
                } else {
                    corners.push({ rightPositions: computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside) });
                }
            }
            backward = Cartesian3.negate(forward, backward);
        }
        position = nextPosition;
    }
    normal = ellipsoid.geodeticSurfaceNormal(position, normal);
    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);
    scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);
    subdividedPositions = PolylinePipeline.generateArc({
        positions: scaleArray2,
        granularity: granularity,
        ellipsoid: ellipsoid
    });
    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);
    if (saveAttributes) {
        calculatedLefts.push(left.x, left.y, left.z);
        calculatedNormals.push(normal.x, normal.y, normal.z);
    }
    var endPositions;
    if (cornerType === CornerType.ROUNDED) {
        endPositions = addEndCaps(calculatedPositions);
    }
    return {
        positions: calculatedPositions,
        corners: corners,
        lefts: calculatedLefts,
        normals: calculatedNormals,
        endPositions: endPositions
    };
};
var scaleN = new Cartesian3();
var scaleP = new Cartesian3();
CorridorGeometryLibrary.scaleToGeodeticHeight = function (positions, height, ellipsoid, result) {
    var length = positions.length;
    var newPositions = isArray(result) ? result : new Array(positions.length);
    newPositions.length = positions.length;
    var h = height;
    for (var i = 0; i < length; i += 3) {
        var p = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(positions, i, scaleP), scaleP);
        var n = scaleN;
        if (height !== 0) {
            n = ellipsoid.geodeticSurfaceNormal(p, n);
            n = Cartesian3.multiplyByScalar(n, h, n);
            p = Cartesian3.add(p, n, p);
        }
        newPositions[i] = p.x;
        newPositions[i + 1] = p.y;
        newPositions[i + 2] = p.z;
    }
    return newPositions;
};
module.exports = CorridorGeometryLibrary;
},{"./Cartesian3":102,"./CornerType":114,"./Math":174,"./Matrix3":176,"./PolylinePipeline":189,"./PolylineVolumeGeometryLibrary":191,"./Quaternion":197,"./defined":245,"./isArray":253}],117:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), CornerType = require('./CornerType'), CorridorGeometryLibrary = require('./CorridorGeometryLibrary'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PolylinePipeline = require('./PolylinePipeline'), PrimitiveType = require('./PrimitiveType');
'use strict';
var cartesian1 = new Cartesian3();
var cartesian2 = new Cartesian3();
var cartesian3 = new Cartesian3();
function combine(computedPositions, cornerType) {
    var wallIndices = [];
    var positions = computedPositions.positions;
    var corners = computedPositions.corners;
    var endPositions = computedPositions.endPositions;
    var attributes = new GeometryAttributes();
    var corner;
    var leftCount = 0;
    var rightCount = 0;
    var i;
    var indicesLength = 0;
    var length;
    for (i = 0; i < positions.length; i += 2) {
        length = positions[i].length - 3;
        leftCount += length;
        indicesLength += length / 3 * 4;
        rightCount += positions[i + 1].length - 3;
    }
    leftCount += 3;
    rightCount += 3;
    for (i = 0; i < corners.length; i++) {
        corner = corners[i];
        var leftSide = corners[i].leftPositions;
        if (defined(leftSide)) {
            length = leftSide.length;
            leftCount += length;
            indicesLength += length / 3 * 2;
        } else {
            length = corners[i].rightPositions.length;
            rightCount += length;
            indicesLength += length / 3 * 2;
        }
    }
    var addEndPositions = defined(endPositions);
    var endPositionLength;
    if (addEndPositions) {
        endPositionLength = endPositions[0].length - 3;
        leftCount += endPositionLength;
        rightCount += endPositionLength;
        endPositionLength /= 3;
        indicesLength += endPositionLength * 4;
    }
    var size = leftCount + rightCount;
    var finalPositions = new Float64Array(size);
    var front = 0;
    var back = size - 1;
    var UL, LL, UR, LR;
    var rightPos, leftPos;
    var halfLength = endPositionLength / 2;
    var indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);
    var index = 0;
    indices[index++] = front / 3;
    indices[index++] = (back - 2) / 3;
    if (addEndPositions) {
        wallIndices.push(front / 3);
        leftPos = cartesian1;
        rightPos = cartesian2;
        var firstEndPositions = endPositions[0];
        for (i = 0; i < halfLength; i++) {
            leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);
            rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);
            CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);
            CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);
            LL = front / 3;
            LR = LL + 1;
            UL = (back - 2) / 3;
            UR = UL - 1;
            indices[index++] = UL;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;
            front += 3;
            back -= 3;
        }
    }
    var posIndex = 0;
    var rightEdge = positions[posIndex++];
    var leftEdge = positions[posIndex++];
    finalPositions.set(rightEdge, front);
    finalPositions.set(leftEdge, back - leftEdge.length + 1);
    length = leftEdge.length - 3;
    wallIndices.push(front / 3, (back - 2) / 3);
    for (i = 0; i < length; i += 3) {
        LL = front / 3;
        LR = LL + 1;
        UL = (back - 2) / 3;
        UR = UL - 1;
        indices[index++] = UL;
        indices[index++] = UR;
        indices[index++] = LL;
        indices[index++] = LR;
        front += 3;
        back -= 3;
    }
    for (i = 0; i < corners.length; i++) {
        var j;
        corner = corners[i];
        var l = corner.leftPositions;
        var r = corner.rightPositions;
        var start;
        var outsidePoint = cartesian3;
        if (defined(l)) {
            back -= 3;
            start = UR;
            wallIndices.push(LR);
            for (j = 0; j < l.length / 3; j++) {
                outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);
                indices[index++] = start - j - 1;
                indices[index++] = start - j;
                CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);
                back -= 3;
            }
            wallIndices.push(start - Math.floor(l.length / 6));
            if (cornerType === CornerType.BEVELED) {
                wallIndices.push((back - 2) / 3 + 1);
            }
            front += 3;
        } else {
            front += 3;
            start = LR;
            wallIndices.push(UR);
            for (j = 0; j < r.length / 3; j++) {
                outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);
                indices[index++] = start + j;
                indices[index++] = start + j + 1;
                CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);
                front += 3;
            }
            wallIndices.push(start + Math.floor(r.length / 6));
            if (cornerType === CornerType.BEVELED) {
                wallIndices.push(front / 3 - 1);
            }
            back -= 3;
        }
        rightEdge = positions[posIndex++];
        leftEdge = positions[posIndex++];
        rightEdge.splice(0, 3);
        leftEdge.splice(leftEdge.length - 3, 3);
        finalPositions.set(rightEdge, front);
        finalPositions.set(leftEdge, back - leftEdge.length + 1);
        length = leftEdge.length - 3;
        for (j = 0; j < leftEdge.length; j += 3) {
            LR = front / 3;
            LL = LR - 1;
            UR = (back - 2) / 3;
            UL = UR + 1;
            indices[index++] = UL;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;
            front += 3;
            back -= 3;
        }
        front -= 3;
        back += 3;
        wallIndices.push(front / 3, (back - 2) / 3);
    }
    if (addEndPositions) {
        front += 3;
        back -= 3;
        leftPos = cartesian1;
        rightPos = cartesian2;
        var lastEndPositions = endPositions[1];
        for (i = 0; i < halfLength; i++) {
            leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);
            rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);
            CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);
            CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);
            LR = front / 3;
            LL = LR - 1;
            UR = (back - 2) / 3;
            UL = UR + 1;
            indices[index++] = UL;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;
            front += 3;
            back -= 3;
        }
        wallIndices.push(front / 3);
    } else {
        wallIndices.push(front / 3, (back - 2) / 3);
    }
    indices[index++] = front / 3;
    indices[index++] = (back - 2) / 3;
    attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: finalPositions
    });
    return {
        attributes: attributes,
        indices: indices,
        wallIndices: wallIndices
    };
}
function computePositionsExtruded(params) {
    var ellipsoid = params.ellipsoid;
    var computedPositions = CorridorGeometryLibrary.computePositions(params);
    var attr = combine(computedPositions, params.cornerType);
    var wallIndices = attr.wallIndices;
    var height = params.height;
    var extrudedHeight = params.extrudedHeight;
    var attributes = attr.attributes;
    var indices = attr.indices;
    var positions = attributes.position.values;
    var length = positions.length;
    var extrudedPositions = new Float64Array(length);
    extrudedPositions.set(positions);
    var newPositions = new Float64Array(length * 2);
    positions = CorridorGeometryLibrary.scaleToGeodeticHeight(positions, height, ellipsoid, positions);
    extrudedPositions = CorridorGeometryLibrary.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid, extrudedPositions);
    newPositions.set(positions);
    newPositions.set(extrudedPositions, length);
    attributes.position.values = newPositions;
    length /= 3;
    var i;
    var iLength = indices.length;
    var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, (iLength + wallIndices.length) * 2);
    newIndices.set(indices);
    var index = iLength;
    for (i = 0; i < iLength; i += 2) {
        var v0 = indices[i];
        var v1 = indices[i + 1];
        newIndices[index++] = v0 + length;
        newIndices[index++] = v1 + length;
    }
    var UL, LL;
    for (i = 0; i < wallIndices.length; i++) {
        UL = wallIndices[i];
        LL = UL + length;
        newIndices[index++] = UL;
        newIndices[index++] = LL;
    }
    return {
        attributes: attributes,
        indices: newIndices
    };
}
var CorridorOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var positions = options.positions;
    var width = options.width;
    if (!defined(positions)) {
        throw new DeveloperError('options.positions is required.');
    }
    if (!defined(width)) {
        throw new DeveloperError('options.width is required.');
    }
    this._positions = positions;
    this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
    this._width = width;
    this._height = defaultValue(options.height, 0);
    this._extrudedHeight = defaultValue(options.extrudedHeight, this._height);
    this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);
    this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    this._workerName = 'createCorridorOutlineGeometry';
    this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 5;
};
CorridorOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var positions = value._positions;
    var length = positions.length;
    array[startingIndex++] = length;
    for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        Cartesian3.pack(positions[i], array, startingIndex);
    }
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    array[startingIndex++] = value._width;
    array[startingIndex++] = value._height;
    array[startingIndex++] = value._extrudedHeight;
    array[startingIndex++] = value._cornerType;
    array[startingIndex] = value._granularity;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchOptions = {
        positions: undefined,
        ellipsoid: scratchEllipsoid,
        width: undefined,
        height: undefined,
        extrudedHeight: undefined,
        cornerType: undefined,
        granularity: undefined
    };
CorridorOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var length = array[startingIndex++];
    var positions = new Array(length);
    for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var width = array[startingIndex++];
    var height = array[startingIndex++];
    var extrudedHeight = array[startingIndex++];
    var cornerType = array[startingIndex++];
    var granularity = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.positions = positions;
        scratchOptions.width = width;
        scratchOptions.height = height;
        scratchOptions.extrudedHeight = extrudedHeight;
        scratchOptions.cornerType = cornerType;
        scratchOptions.granularity = granularity;
        return new CorridorOutlineGeometry(scratchOptions);
    }
    result._positions = positions;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._width = width;
    result._height = height;
    result._extrudedHeight = extrudedHeight;
    result._cornerType = cornerType;
    result._granularity = granularity;
    return result;
};
CorridorOutlineGeometry.createGeometry = function (corridorOutlineGeometry) {
    var positions = corridorOutlineGeometry._positions;
    var height = corridorOutlineGeometry._height;
    var extrudedHeight = corridorOutlineGeometry._extrudedHeight;
    var extrude = height !== extrudedHeight;
    var cleanPositions = PolylinePipeline.removeDuplicates(positions);
    if (!defined(cleanPositions)) {
        cleanPositions = positions;
    }
    if (cleanPositions.length < 2) {
        return undefined;
    }
    var ellipsoid = corridorOutlineGeometry._ellipsoid;
    var params = {
            ellipsoid: ellipsoid,
            positions: cleanPositions,
            width: corridorOutlineGeometry._width,
            cornerType: corridorOutlineGeometry._cornerType,
            granularity: corridorOutlineGeometry._granularity,
            saveAttributes: false
        };
    var attr;
    if (extrude) {
        var h = Math.max(height, extrudedHeight);
        extrudedHeight = Math.min(height, extrudedHeight);
        height = h;
        params.height = height;
        params.extrudedHeight = extrudedHeight;
        attr = computePositionsExtruded(params);
    } else {
        var computedPositions = CorridorGeometryLibrary.computePositions(params);
        attr = combine(computedPositions, params.cornerType);
        attr.attributes.position.values = CorridorGeometryLibrary.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid, attr.attributes.position.values);
    }
    var attributes = attr.attributes;
    var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);
    return new Geometry({
        attributes: attributes,
        indices: attr.indices,
        primitiveType: PrimitiveType.LINES,
        boundingSphere: boundingSphere
    });
};
module.exports = CorridorOutlineGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./ComponentDatatype":113,"./CornerType":114,"./CorridorGeometryLibrary":116,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PolylinePipeline":189,"./PrimitiveType":193,"./defaultValue":243,"./defined":245}],118:[function(require,module,exports){
var defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError');
'use strict';
var nextCreditId = 0;
var creditToId = {};
var Credit = function (text, imageUrl, link) {
    var hasLink = defined(link);
    var hasImage = defined(imageUrl);
    var hasText = defined(text);
    if (!hasText && !hasImage && !hasLink) {
        throw new DeveloperError('text, imageUrl or link is required');
    }
    if (!hasText && !hasImage) {
        text = link;
    }
    this._text = text;
    this._imageUrl = imageUrl;
    this._link = link;
    this._hasLink = hasLink;
    this._hasImage = hasImage;
    var id;
    var key = JSON.stringify([
            text,
            imageUrl,
            link
        ]);
    if (defined(creditToId[key])) {
        id = creditToId[key];
    } else {
        id = nextCreditId++;
        creditToId[key] = id;
    }
    this._id = id;
};
defineProperties(Credit.prototype, {
    text: {
        get: function () {
            return this._text;
        }
    },
    imageUrl: {
        get: function () {
            return this._imageUrl;
        }
    },
    link: {
        get: function () {
            return this._link;
        }
    },
    id: {
        get: function () {
            return this._id;
        }
    }
});
Credit.prototype.hasImage = function () {
    return this._hasImage;
};
Credit.prototype.hasLink = function () {
    return this._hasLink;
};
Credit.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left._id === right._id;
};
Credit.prototype.equals = function (credit) {
    return Credit.equals(this, credit);
};
module.exports = Credit;
},{"./DeveloperError":123,"./defineProperties":244,"./defined":245}],119:[function(require,module,exports){
var DeveloperError = require('./DeveloperError'), QuadraticRealPolynomial = require('./QuadraticRealPolynomial');
'use strict';
var CubicRealPolynomial = {};
CubicRealPolynomial.computeDiscriminant = function (a, b, c, d) {
    if (typeof a !== 'number') {
        throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
        throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
        throw new DeveloperError('c is a required number.');
    }
    if (typeof d !== 'number') {
        throw new DeveloperError('d is a required number.');
    }
    var a2 = a * a;
    var b2 = b * b;
    var c2 = c * c;
    var d2 = d * d;
    var discriminant = 18 * a * b * c * d + b2 * c2 - 27 * a2 * d2 - 4 * (a * c2 * c + b2 * b * d);
    return discriminant;
};
function computeRealRoots(a, b, c, d) {
    var A = a;
    var B = b / 3;
    var C = c / 3;
    var D = d;
    var AC = A * C;
    var BD = B * D;
    var B2 = B * B;
    var C2 = C * C;
    var delta1 = A * C - B2;
    var delta2 = A * D - B * C;
    var delta3 = B * D - C2;
    var discriminant = 4 * delta1 * delta3 - delta2 * delta2;
    var temp;
    var temp1;
    if (discriminant < 0) {
        var ABar;
        var CBar;
        var DBar;
        if (B2 * BD >= AC * C2) {
            ABar = A;
            CBar = delta1;
            DBar = -2 * B * delta1 + A * delta2;
        } else {
            ABar = D;
            CBar = delta3;
            DBar = -D * delta2 + 2 * C * delta3;
        }
        var s = DBar < 0 ? -1 : 1;
        var temp0 = -s * Math.abs(ABar) * Math.sqrt(-discriminant);
        temp1 = -DBar + temp0;
        var x = temp1 / 2;
        var p = x < 0 ? -Math.pow(-x, 1 / 3) : Math.pow(x, 1 / 3);
        var q = temp1 === temp0 ? -p : -CBar / p;
        temp = CBar <= 0 ? p + q : -DBar / (p * p + q * q + CBar);
        if (B2 * BD >= AC * C2) {
            return [(temp - B) / A];
        }
        return [-D / (temp + C)];
    }
    var CBarA = delta1;
    var DBarA = -2 * B * delta1 + A * delta2;
    var CBarD = delta3;
    var DBarD = -D * delta2 + 2 * C * delta3;
    var squareRootOfDiscriminant = Math.sqrt(discriminant);
    var halfSquareRootOf3 = Math.sqrt(3) / 2;
    var theta = Math.abs(Math.atan2(A * squareRootOfDiscriminant, -DBarA) / 3);
    temp = 2 * Math.sqrt(-CBarA);
    var cosine = Math.cos(theta);
    temp1 = temp * cosine;
    var temp3 = temp * (-cosine / 2 - halfSquareRootOf3 * Math.sin(theta));
    var numeratorLarge = temp1 + temp3 > 2 * B ? temp1 - B : temp3 - B;
    var denominatorLarge = A;
    var root1 = numeratorLarge / denominatorLarge;
    theta = Math.abs(Math.atan2(D * squareRootOfDiscriminant, -DBarD) / 3);
    temp = 2 * Math.sqrt(-CBarD);
    cosine = Math.cos(theta);
    temp1 = temp * cosine;
    temp3 = temp * (-cosine / 2 - halfSquareRootOf3 * Math.sin(theta));
    var numeratorSmall = -D;
    var denominatorSmall = temp1 + temp3 < 2 * C ? temp1 + C : temp3 + C;
    var root3 = numeratorSmall / denominatorSmall;
    var E = denominatorLarge * denominatorSmall;
    var F = -numeratorLarge * denominatorSmall - denominatorLarge * numeratorSmall;
    var G = numeratorLarge * numeratorSmall;
    var root2 = (C * F - B * G) / (-B * F + C * E);
    if (root1 <= root2) {
        if (root1 <= root3) {
            if (root2 <= root3) {
                return [
                    root1,
                    root2,
                    root3
                ];
            }
            return [
                root1,
                root3,
                root2
            ];
        }
        return [
            root3,
            root1,
            root2
        ];
    }
    if (root1 <= root3) {
        return [
            root2,
            root1,
            root3
        ];
    }
    if (root2 <= root3) {
        return [
            root2,
            root3,
            root1
        ];
    }
    return [
        root3,
        root2,
        root1
    ];
}
CubicRealPolynomial.computeRealRoots = function (a, b, c, d) {
    if (typeof a !== 'number') {
        throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
        throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
        throw new DeveloperError('c is a required number.');
    }
    if (typeof d !== 'number') {
        throw new DeveloperError('d is a required number.');
    }
    var roots;
    var ratio;
    if (a === 0) {
        return QuadraticRealPolynomial.computeRealRoots(b, c, d);
    } else if (b === 0) {
        if (c === 0) {
            if (d === 0) {
                return [
                    0,
                    0,
                    0
                ];
            }
            ratio = -d / a;
            var root = ratio < 0 ? -Math.pow(-ratio, 1 / 3) : Math.pow(ratio, 1 / 3);
            return [
                root,
                root,
                root
            ];
        } else if (d === 0) {
            roots = QuadraticRealPolynomial.computeRealRoots(a, 0, c);
            if (roots.Length === 0) {
                return [0];
            }
            return [
                roots[0],
                0,
                roots[1]
            ];
        }
        return computeRealRoots(a, 0, c, d);
    } else if (c === 0) {
        if (d === 0) {
            ratio = -b / a;
            if (ratio < 0) {
                return [
                    ratio,
                    0,
                    0
                ];
            }
            return [
                0,
                0,
                ratio
            ];
        }
        return computeRealRoots(a, b, 0, d);
    } else if (d === 0) {
        roots = QuadraticRealPolynomial.computeRealRoots(a, b, c);
        if (roots.length === 0) {
            return [0];
        } else if (roots[1] <= 0) {
            return [
                roots[0],
                roots[1],
                0
            ];
        } else if (roots[0] >= 0) {
            return [
                0,
                roots[0],
                roots[1]
            ];
        }
        return [
            roots[0],
            0,
            roots[1]
        ];
    }
    return computeRealRoots(a, b, c, d);
};
module.exports = CubicRealPolynomial;
},{"./DeveloperError":123,"./QuadraticRealPolynomial":194}],120:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), CylinderGeometryLibrary = require('./CylinderGeometryLibrary'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PrimitiveType = require('./PrimitiveType'), VertexFormat = require('./VertexFormat');
'use strict';
var radiusScratch = new Cartesian2();
var normalScratch = new Cartesian3();
var binormalScratch = new Cartesian3();
var tangentScratch = new Cartesian3();
var positionScratch = new Cartesian3();
var CylinderGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var length = options.length;
    var topRadius = options.topRadius;
    var bottomRadius = options.bottomRadius;
    var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
    var slices = defaultValue(options.slices, 128);
    if (!defined(length) || length <= 0) {
        throw new DeveloperError('options.length must be greater than 0.');
    }
    if (!defined(topRadius) || topRadius < 0) {
        throw new DeveloperError('options.topRadius must be greater than 0.');
    }
    if (!defined(bottomRadius) || bottomRadius < 0) {
        throw new DeveloperError('options.bottomRadius must be greater than 0.');
    }
    if (bottomRadius === 0 && topRadius === 0) {
        throw new DeveloperError('bottomRadius and topRadius cannot both equal 0.');
    }
    if (slices < 3) {
        throw new DeveloperError('options.slices must be greater that 3.');
    }
    this._length = length;
    this._topRadius = topRadius;
    this._bottomRadius = bottomRadius;
    this._vertexFormat = VertexFormat.clone(vertexFormat);
    this._slices = slices;
    this._workerName = 'createCylinderGeometry';
};
CylinderGeometry.packedLength = VertexFormat.packedLength + 4;
CylinderGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex++] = value._length;
    array[startingIndex++] = value._topRadius;
    array[startingIndex++] = value._bottomRadius;
    array[startingIndex] = value._slices;
};
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        vertexFormat: scratchVertexFormat,
        length: undefined,
        topRadius: undefined,
        bottomRadius: undefined,
        slices: undefined
    };
CylinderGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var length = array[startingIndex++];
    var topRadius = array[startingIndex++];
    var bottomRadius = array[startingIndex++];
    var slices = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.length = length;
        scratchOptions.topRadius = topRadius;
        scratchOptions.bottomRadius = bottomRadius;
        scratchOptions.slices = slices;
        return new CylinderGeometry(scratchOptions);
    }
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._length = length;
    result._topRadius = topRadius;
    result._bottomRadius = bottomRadius;
    result._slices = slices;
    return result;
};
CylinderGeometry.createGeometry = function (cylinderGeometry) {
    var length = cylinderGeometry._length;
    var topRadius = cylinderGeometry._topRadius;
    var bottomRadius = cylinderGeometry._bottomRadius;
    var vertexFormat = cylinderGeometry._vertexFormat;
    var slices = cylinderGeometry._slices;
    var twoSlices = slices + slices;
    var threeSlices = slices + twoSlices;
    var numVertices = twoSlices + twoSlices;
    var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);
    var st = vertexFormat.st ? new Float32Array(numVertices * 2) : undefined;
    var normals = vertexFormat.normal ? new Float32Array(numVertices * 3) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(numVertices * 3) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(numVertices * 3) : undefined;
    var i;
    var computeNormal = vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal;
    if (computeNormal) {
        var computeTangent = vertexFormat.tangent || vertexFormat.binormal;
        var normalIndex = 0;
        var tangentIndex = 0;
        var binormalIndex = 0;
        var normal = normalScratch;
        normal.z = 0;
        var tangent = tangentScratch;
        var binormal = binormalScratch;
        for (i = 0; i < slices; i++) {
            var angle = i / slices * CesiumMath.TWO_PI;
            var x = Math.cos(angle);
            var y = Math.sin(angle);
            if (computeNormal) {
                normal.x = x;
                normal.y = y;
                if (computeTangent) {
                    tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);
                }
                if (vertexFormat.normal) {
                    normals[normalIndex++] = x;
                    normals[normalIndex++] = y;
                    normals[normalIndex++] = 0;
                    normals[normalIndex++] = x;
                    normals[normalIndex++] = y;
                    normals[normalIndex++] = 0;
                }
                if (vertexFormat.tangent) {
                    tangents[tangentIndex++] = tangent.x;
                    tangents[tangentIndex++] = tangent.y;
                    tangents[tangentIndex++] = tangent.z;
                    tangents[tangentIndex++] = tangent.x;
                    tangents[tangentIndex++] = tangent.y;
                    tangents[tangentIndex++] = tangent.z;
                }
                if (vertexFormat.binormal) {
                    binormal = Cartesian3.normalize(Cartesian3.cross(normal, tangent, binormal), binormal);
                    binormals[binormalIndex++] = binormal.x;
                    binormals[binormalIndex++] = binormal.y;
                    binormals[binormalIndex++] = binormal.z;
                    binormals[binormalIndex++] = binormal.x;
                    binormals[binormalIndex++] = binormal.y;
                    binormals[binormalIndex++] = binormal.z;
                }
            }
        }
        for (i = 0; i < slices; i++) {
            if (vertexFormat.normal) {
                normals[normalIndex++] = 0;
                normals[normalIndex++] = 0;
                normals[normalIndex++] = -1;
            }
            if (vertexFormat.tangent) {
                tangents[tangentIndex++] = 1;
                tangents[tangentIndex++] = 0;
                tangents[tangentIndex++] = 0;
            }
            if (vertexFormat.binormal) {
                binormals[binormalIndex++] = 0;
                binormals[binormalIndex++] = -1;
                binormals[binormalIndex++] = 0;
            }
        }
        for (i = 0; i < slices; i++) {
            if (vertexFormat.normal) {
                normals[normalIndex++] = 0;
                normals[normalIndex++] = 0;
                normals[normalIndex++] = 1;
            }
            if (vertexFormat.tangent) {
                tangents[tangentIndex++] = 1;
                tangents[tangentIndex++] = 0;
                tangents[tangentIndex++] = 0;
            }
            if (vertexFormat.binormal) {
                binormals[binormalIndex++] = 0;
                binormals[binormalIndex++] = 1;
                binormals[binormalIndex++] = 0;
            }
        }
    }
    var numIndices = 12 * slices - 12;
    var indices = IndexDatatype.createTypedArray(numVertices, numIndices);
    var index = 0;
    var j = 0;
    for (i = 0; i < slices - 1; i++) {
        indices[index++] = j;
        indices[index++] = j + 2;
        indices[index++] = j + 3;
        indices[index++] = j;
        indices[index++] = j + 3;
        indices[index++] = j + 1;
        j += 2;
    }
    indices[index++] = twoSlices - 2;
    indices[index++] = 0;
    indices[index++] = 1;
    indices[index++] = twoSlices - 2;
    indices[index++] = 1;
    indices[index++] = twoSlices - 1;
    for (i = 1; i < slices - 1; i++) {
        indices[index++] = twoSlices + i + 1;
        indices[index++] = twoSlices + i;
        indices[index++] = twoSlices;
    }
    for (i = 1; i < slices - 1; i++) {
        indices[index++] = threeSlices;
        indices[index++] = threeSlices + i;
        indices[index++] = threeSlices + i + 1;
    }
    var textureCoordIndex = 0;
    if (vertexFormat.st) {
        var rad = Math.max(topRadius, bottomRadius);
        for (i = 0; i < numVertices; i++) {
            var position = Cartesian3.fromArray(positions, i * 3, positionScratch);
            st[textureCoordIndex++] = (position.x + rad) / (2 * rad);
            st[textureCoordIndex++] = (position.y + rad) / (2 * rad);
        }
    }
    var attributes = new GeometryAttributes();
    if (vertexFormat.position) {
        attributes.position = new GeometryAttribute({
            componentDatatype: ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
        });
    }
    if (vertexFormat.normal) {
        attributes.normal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: normals
        });
    }
    if (vertexFormat.tangent) {
        attributes.tangent = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: tangents
        });
    }
    if (vertexFormat.binormal) {
        attributes.binormal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: binormals
        });
    }
    if (vertexFormat.st) {
        attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: st
        });
    }
    radiusScratch.x = length * 0.5;
    radiusScratch.y = Math.max(bottomRadius, topRadius);
    var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingSphere: boundingSphere
    });
};
module.exports = CylinderGeometry;
},{"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./ComponentDatatype":113,"./CylinderGeometryLibrary":121,"./DeveloperError":123,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PrimitiveType":193,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],121:[function(require,module,exports){
var CesiumMath = require('./Math');
'use strict';
var CylinderGeometryLibrary = {};
CylinderGeometryLibrary.computePositions = function (length, topRadius, bottomRadius, slices, fill) {
    var topZ = length * 0.5;
    var bottomZ = -topZ;
    var twoSlice = slices + slices;
    var size = fill ? 2 * twoSlice : twoSlice;
    var positions = new Float64Array(size * 3);
    var i;
    var index = 0;
    var tbIndex = 0;
    var bottomOffset = fill ? twoSlice * 3 : 0;
    var topOffset = fill ? (twoSlice + slices) * 3 : slices * 3;
    for (i = 0; i < slices; i++) {
        var angle = i / slices * CesiumMath.TWO_PI;
        var x = Math.cos(angle);
        var y = Math.sin(angle);
        var bottomX = x * bottomRadius;
        var bottomY = y * bottomRadius;
        var topX = x * topRadius;
        var topY = y * topRadius;
        positions[tbIndex + bottomOffset] = bottomX;
        positions[tbIndex + bottomOffset + 1] = bottomY;
        positions[tbIndex + bottomOffset + 2] = bottomZ;
        positions[tbIndex + topOffset] = topX;
        positions[tbIndex + topOffset + 1] = topY;
        positions[tbIndex + topOffset + 2] = topZ;
        tbIndex += 3;
        if (fill) {
            positions[index++] = bottomX;
            positions[index++] = bottomY;
            positions[index++] = bottomZ;
            positions[index++] = topX;
            positions[index++] = topY;
            positions[index++] = topZ;
        }
    }
    return positions;
};
module.exports = CylinderGeometryLibrary;
},{"./Math":174}],122:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), CylinderGeometryLibrary = require('./CylinderGeometryLibrary'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), PrimitiveType = require('./PrimitiveType');
'use strict';
var radiusScratch = new Cartesian2();
var CylinderOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var length = options.length;
    var topRadius = options.topRadius;
    var bottomRadius = options.bottomRadius;
    var slices = defaultValue(options.slices, 128);
    var numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);
    if (!defined(length) || length <= 0) {
        throw new DeveloperError('options.length must be greater than 0.');
    }
    if (!defined(topRadius) || topRadius < 0) {
        throw new DeveloperError('options.topRadius must be greater than 0.');
    }
    if (!defined(bottomRadius) || bottomRadius < 0) {
        throw new DeveloperError('options.bottomRadius must be greater than 0.');
    }
    if (bottomRadius === 0 && topRadius === 0) {
        throw new DeveloperError('bottomRadius and topRadius cannot both equal 0.');
    }
    if (slices < 3) {
        throw new DeveloperError('options.slices must be greater that 3.');
    }
    this._length = length;
    this._topRadius = topRadius;
    this._bottomRadius = bottomRadius;
    this._slices = slices;
    this._numberOfVerticalLines = numberOfVerticalLines;
    this._workerName = 'createCylinderOutlineGeometry';
};
CylinderOutlineGeometry.packedLength = 5;
CylinderOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value._length;
    array[startingIndex++] = value._topRadius;
    array[startingIndex++] = value._bottomRadius;
    array[startingIndex++] = value._slices;
    array[startingIndex] = value._numberOfVerticalLines;
};
var scratchOptions = {
        length: undefined,
        topRadius: undefined,
        bottomRadius: undefined,
        slices: undefined,
        numberOfVerticalLines: undefined
    };
CylinderOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var length = array[startingIndex++];
    var topRadius = array[startingIndex++];
    var bottomRadius = array[startingIndex++];
    var slices = array[startingIndex++];
    var numberOfVerticalLines = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.length = length;
        scratchOptions.topRadius = topRadius;
        scratchOptions.bottomRadius = bottomRadius;
        scratchOptions.slices = slices;
        scratchOptions.numberOfVerticalLines = numberOfVerticalLines;
        return new CylinderOutlineGeometry(scratchOptions);
    }
    result._length = length;
    result._topRadius = topRadius;
    result._bottomRadius = bottomRadius;
    result._slices = slices;
    result._numberOfVerticalLines = numberOfVerticalLines;
    return result;
};
CylinderOutlineGeometry.createGeometry = function (cylinderGeometry) {
    var length = cylinderGeometry._length;
    var topRadius = cylinderGeometry._topRadius;
    var bottomRadius = cylinderGeometry._bottomRadius;
    var slices = cylinderGeometry._slices;
    var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;
    var numVertices = slices * 2;
    var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, false);
    var numIndices = slices * 2;
    var numSide;
    if (numberOfVerticalLines > 0) {
        var numSideLines = Math.min(numberOfVerticalLines, slices);
        numSide = Math.round(slices / numSideLines);
        numIndices += numSideLines;
    }
    var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);
    var index = 0;
    for (var i = 0; i < slices - 1; i++) {
        indices[index++] = i;
        indices[index++] = i + 1;
        indices[index++] = i + slices;
        indices[index++] = i + 1 + slices;
    }
    indices[index++] = slices - 1;
    indices[index++] = 0;
    indices[index++] = slices + slices - 1;
    indices[index++] = slices;
    if (numberOfVerticalLines > 0) {
        for (i = 0; i < slices; i += numSide) {
            indices[index++] = i;
            indices[index++] = i + slices;
        }
    }
    var attributes = new GeometryAttributes();
    attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: positions
    });
    radiusScratch.x = length * 0.5;
    radiusScratch.y = Math.max(bottomRadius, topRadius);
    var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.LINES,
        boundingSphere: boundingSphere
    });
};
module.exports = CylinderOutlineGeometry;
},{"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./ComponentDatatype":113,"./CylinderGeometryLibrary":121,"./DeveloperError":123,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./PrimitiveType":193,"./defaultValue":243,"./defined":245}],123:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var DeveloperError = function (message) {
    this.name = 'DeveloperError';
    this.message = message;
    var stack;
    try {
        throw new Error();
    } catch (e) {
        stack = e.stack;
    }
    this.stack = stack;
};
DeveloperError.prototype.toString = function () {
    var str = this.name + ': ' + this.message;
    if (defined(this.stack)) {
        str += '\n' + this.stack.toString();
    }
    return str;
};
DeveloperError.throwInstantiationError = function () {
    throw new DeveloperError('This function defines an interface and should not be called directly.');
};
module.exports = DeveloperError;
},{"./defined":245}],124:[function(require,module,exports){
var when = require('../ThirdParty/when'), binarySearch = require('./binarySearch'), defaultValue = require('./defaultValue'), defined = require('./defined'), EarthOrientationParametersSample = require('./EarthOrientationParametersSample'), freezeObject = require('./freezeObject'), JulianDate = require('./JulianDate'), LeapSecond = require('./LeapSecond'), loadJson = require('./loadJson'), RuntimeError = require('./RuntimeError'), TimeConstants = require('./TimeConstants'), TimeStandard = require('./TimeStandard');
'use strict';
var EarthOrientationParameters = function EarthOrientationParameters(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._dates = undefined;
    this._samples = undefined;
    this._dateColumn = -1;
    this._xPoleWanderRadiansColumn = -1;
    this._yPoleWanderRadiansColumn = -1;
    this._ut1MinusUtcSecondsColumn = -1;
    this._xCelestialPoleOffsetRadiansColumn = -1;
    this._yCelestialPoleOffsetRadiansColumn = -1;
    this._taiMinusUtcSecondsColumn = -1;
    this._columnCount = 0;
    this._lastIndex = -1;
    this._downloadPromise = undefined;
    this._dataError = undefined;
    this._addNewLeapSeconds = defaultValue(options.addNewLeapSeconds, true);
    if (defined(options.data)) {
        onDataReady(this, options.data);
    } else if (defined(options.url)) {
        var that = this;
        this._downloadPromise = when(loadJson(options.url), function (eopData) {
            onDataReady(that, eopData);
        }, function () {
            that._dataError = 'An error occurred while retrieving the EOP data from the URL ' + options.url + '.';
        });
    } else {
        onDataReady(this, {
            'columnNames': [
                'dateIso8601',
                'modifiedJulianDateUtc',
                'xPoleWanderRadians',
                'yPoleWanderRadians',
                'ut1MinusUtcSeconds',
                'lengthOfDayCorrectionSeconds',
                'xCelestialPoleOffsetRadians',
                'yCelestialPoleOffsetRadians',
                'taiMinusUtcSeconds'
            ],
            'samples': []
        });
    }
};
EarthOrientationParameters.NONE = freezeObject({
    getPromiseToLoad: function () {
        return when();
    },
    compute: function (date, result) {
        if (!defined(result)) {
            result = new EarthOrientationParametersSample(0, 0, 0, 0, 0);
        } else {
            result.xPoleWander = 0;
            result.yPoleWander = 0;
            result.xPoleOffset = 0;
            result.yPoleOffset = 0;
            result.ut1MinusUtc = 0;
        }
        return result;
    }
});
EarthOrientationParameters.prototype.getPromiseToLoad = function () {
    return when(this._downloadPromise);
};
EarthOrientationParameters.prototype.compute = function (date, result) {
    if (!defined(this._samples)) {
        if (defined(this._dataError)) {
            throw new RuntimeError(this._dataError);
        }
        return undefined;
    }
    if (!defined(result)) {
        result = new EarthOrientationParametersSample(0, 0, 0, 0, 0);
    }
    if (this._samples.length === 0) {
        result.xPoleWander = 0;
        result.yPoleWander = 0;
        result.xPoleOffset = 0;
        result.yPoleOffset = 0;
        result.ut1MinusUtc = 0;
        return result;
    }
    var dates = this._dates;
    var lastIndex = this._lastIndex;
    var before = 0;
    var after = 0;
    if (defined(lastIndex)) {
        var previousIndexDate = dates[lastIndex];
        var nextIndexDate = dates[lastIndex + 1];
        var isAfterPrevious = JulianDate.lessThanOrEquals(previousIndexDate, date);
        var isAfterLastSample = !defined(nextIndexDate);
        var isBeforeNext = isAfterLastSample || JulianDate.greaterThanOrEquals(nextIndexDate, date);
        if (isAfterPrevious && isBeforeNext) {
            before = lastIndex;
            if (!isAfterLastSample && nextIndexDate.equals(date)) {
                ++before;
            }
            after = before + 1;
            interpolate(this, dates, this._samples, date, before, after, result);
            return result;
        }
    }
    var index = binarySearch(dates, date, JulianDate.compare, this._dateColumn);
    if (index >= 0) {
        if (index < dates.length - 1 && dates[index + 1].equals(date)) {
            ++index;
        }
        before = index;
        after = index;
    } else {
        after = ~index;
        before = after - 1;
        if (before < 0) {
            before = 0;
        }
    }
    this._lastIndex = before;
    interpolate(this, dates, this._samples, date, before, after, result);
    return result;
};
function compareLeapSecondDates(leapSecond, dateToFind) {
    return JulianDate.compare(leapSecond.julianDate, dateToFind);
}
function onDataReady(eop, eopData) {
    if (!defined(eopData.columnNames)) {
        eop._dataError = 'Error in loaded EOP data: The columnNames property is required.';
        return;
    }
    if (!defined(eopData.samples)) {
        eop._dataError = 'Error in loaded EOP data: The samples property is required.';
        return;
    }
    var dateColumn = eopData.columnNames.indexOf('modifiedJulianDateUtc');
    var xPoleWanderRadiansColumn = eopData.columnNames.indexOf('xPoleWanderRadians');
    var yPoleWanderRadiansColumn = eopData.columnNames.indexOf('yPoleWanderRadians');
    var ut1MinusUtcSecondsColumn = eopData.columnNames.indexOf('ut1MinusUtcSeconds');
    var xCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('xCelestialPoleOffsetRadians');
    var yCelestialPoleOffsetRadiansColumn = eopData.columnNames.indexOf('yCelestialPoleOffsetRadians');
    var taiMinusUtcSecondsColumn = eopData.columnNames.indexOf('taiMinusUtcSeconds');
    if (dateColumn < 0 || xPoleWanderRadiansColumn < 0 || yPoleWanderRadiansColumn < 0 || ut1MinusUtcSecondsColumn < 0 || xCelestialPoleOffsetRadiansColumn < 0 || yCelestialPoleOffsetRadiansColumn < 0 || taiMinusUtcSecondsColumn < 0) {
        eop._dataError = 'Error in loaded EOP data: The columnNames property must include modifiedJulianDateUtc, xPoleWanderRadians, yPoleWanderRadians, ut1MinusUtcSeconds, xCelestialPoleOffsetRadians, yCelestialPoleOffsetRadians, and taiMinusUtcSeconds columns';
        return;
    }
    var samples = eop._samples = eopData.samples;
    var dates = eop._dates = [];
    eop._dateColumn = dateColumn;
    eop._xPoleWanderRadiansColumn = xPoleWanderRadiansColumn;
    eop._yPoleWanderRadiansColumn = yPoleWanderRadiansColumn;
    eop._ut1MinusUtcSecondsColumn = ut1MinusUtcSecondsColumn;
    eop._xCelestialPoleOffsetRadiansColumn = xCelestialPoleOffsetRadiansColumn;
    eop._yCelestialPoleOffsetRadiansColumn = yCelestialPoleOffsetRadiansColumn;
    eop._taiMinusUtcSecondsColumn = taiMinusUtcSecondsColumn;
    eop._columnCount = eopData.columnNames.length;
    eop._lastIndex = undefined;
    var lastTaiMinusUtc;
    var addNewLeapSeconds = eop._addNewLeapSeconds;
    for (var i = 0, len = samples.length; i < len; i += eop._columnCount) {
        var mjd = samples[i + dateColumn];
        var taiMinusUtc = samples[i + taiMinusUtcSecondsColumn];
        var day = mjd + TimeConstants.MODIFIED_JULIAN_DATE_DIFFERENCE;
        var date = new JulianDate(day, taiMinusUtc, TimeStandard.TAI);
        dates.push(date);
        if (addNewLeapSeconds) {
            if (taiMinusUtc !== lastTaiMinusUtc && defined(lastTaiMinusUtc)) {
                var leapSeconds = JulianDate.leapSeconds;
                var leapSecondIndex = binarySearch(leapSeconds, date, compareLeapSecondDates);
                if (leapSecondIndex < 0) {
                    var leapSecond = new LeapSecond(date, taiMinusUtc);
                    leapSeconds.splice(~leapSecondIndex, 0, leapSecond);
                }
            }
            lastTaiMinusUtc = taiMinusUtc;
        }
    }
}
function fillResultFromIndex(eop, samples, index, columnCount, result) {
    var start = index * columnCount;
    result.xPoleWander = samples[start + eop._xPoleWanderRadiansColumn];
    result.yPoleWander = samples[start + eop._yPoleWanderRadiansColumn];
    result.xPoleOffset = samples[start + eop._xCelestialPoleOffsetRadiansColumn];
    result.yPoleOffset = samples[start + eop._yCelestialPoleOffsetRadiansColumn];
    result.ut1MinusUtc = samples[start + eop._ut1MinusUtcSecondsColumn];
}
function linearInterp(dx, y1, y2) {
    return y1 + dx * (y2 - y1);
}
function interpolate(eop, dates, samples, date, before, after, result) {
    var columnCount = eop._columnCount;
    if (after > dates.length - 1) {
        result.xPoleWander = 0;
        result.yPoleWander = 0;
        result.xPoleOffset = 0;
        result.yPoleOffset = 0;
        result.ut1MinusUtc = 0;
        return result;
    }
    var beforeDate = dates[before];
    var afterDate = dates[after];
    if (beforeDate.equals(afterDate) || date.equals(beforeDate)) {
        fillResultFromIndex(eop, samples, before, columnCount, result);
        return result;
    } else if (date.equals(afterDate)) {
        fillResultFromIndex(eop, samples, after, columnCount, result);
        return result;
    }
    var factor = JulianDate.secondsDifference(date, beforeDate) / JulianDate.secondsDifference(afterDate, beforeDate);
    var startBefore = before * columnCount;
    var startAfter = after * columnCount;
    var beforeUt1MinusUtc = samples[startBefore + eop._ut1MinusUtcSecondsColumn];
    var afterUt1MinusUtc = samples[startAfter + eop._ut1MinusUtcSecondsColumn];
    var offsetDifference = afterUt1MinusUtc - beforeUt1MinusUtc;
    if (offsetDifference > 0.5 || offsetDifference < -0.5) {
        var beforeTaiMinusUtc = samples[startBefore + eop._taiMinusUtcSecondsColumn];
        var afterTaiMinusUtc = samples[startAfter + eop._taiMinusUtcSecondsColumn];
        if (beforeTaiMinusUtc !== afterTaiMinusUtc) {
            if (afterDate.equals(date)) {
                beforeUt1MinusUtc = afterUt1MinusUtc;
            } else {
                afterUt1MinusUtc -= afterTaiMinusUtc - beforeTaiMinusUtc;
            }
        }
    }
    result.xPoleWander = linearInterp(factor, samples[startBefore + eop._xPoleWanderRadiansColumn], samples[startAfter + eop._xPoleWanderRadiansColumn]);
    result.yPoleWander = linearInterp(factor, samples[startBefore + eop._yPoleWanderRadiansColumn], samples[startAfter + eop._yPoleWanderRadiansColumn]);
    result.xPoleOffset = linearInterp(factor, samples[startBefore + eop._xCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._xCelestialPoleOffsetRadiansColumn]);
    result.yPoleOffset = linearInterp(factor, samples[startBefore + eop._yCelestialPoleOffsetRadiansColumn], samples[startAfter + eop._yCelestialPoleOffsetRadiansColumn]);
    result.ut1MinusUtc = linearInterp(factor, beforeUt1MinusUtc, afterUt1MinusUtc);
    return result;
}
module.exports = EarthOrientationParameters;
},{"../ThirdParty/when":596,"./EarthOrientationParametersSample":125,"./JulianDate":168,"./LeapSecond":171,"./RuntimeError":207,"./TimeConstants":221,"./TimeStandard":224,"./binarySearch":238,"./defaultValue":243,"./defined":245,"./freezeObject":249,"./loadJson":261}],125:[function(require,module,exports){
'use strict';
var EarthOrientationParametersSample = function EarthOrientationParametersSample(xPoleWander, yPoleWander, xPoleOffset, yPoleOffset, ut1MinusUtc) {
    this.xPoleWander = xPoleWander;
    this.yPoleWander = yPoleWander;
    this.xPoleOffset = xPoleOffset;
    this.yPoleOffset = yPoleOffset;
    this.ut1MinusUtc = ut1MinusUtc;
};
module.exports = EarthOrientationParametersSample;
},{}],126:[function(require,module,exports){
var Tween = require('../ThirdParty/Tween'), freezeObject = require('./freezeObject');
'use strict';
var EasingFunction = {
        LINEAR_NONE: Tween.Easing.Linear.None,
        QUADRACTIC_IN: Tween.Easing.Quadratic.In,
        QUADRACTIC_OUT: Tween.Easing.Quadratic.Out,
        QUADRACTIC_IN_OUT: Tween.Easing.Quadratic.InOut,
        CUBIC_IN: Tween.Easing.Cubic.In,
        CUBIC_OUT: Tween.Easing.Cubic.Out,
        CUBIC_IN_OUT: Tween.Easing.Cubic.InOut,
        QUARTIC_IN: Tween.Easing.Quartic.In,
        QUARTIC_OUT: Tween.Easing.Quartic.Out,
        QUARTIC_IN_OUT: Tween.Easing.Quartic.InOut,
        QUINTIC_IN: Tween.Easing.Quintic.In,
        QUINTIC_OUT: Tween.Easing.Quintic.Out,
        QUINTIC_IN_OUT: Tween.Easing.Quintic.InOut,
        SINUSOIDAL_IN: Tween.Easing.Sinusoidal.In,
        SINUSOIDAL_OUT: Tween.Easing.Sinusoidal.Out,
        SINUSOIDAL_IN_OUT: Tween.Easing.Sinusoidal.InOut,
        EXPONENTIAL_IN: Tween.Easing.Exponential.In,
        EXPONENTIAL_OUT: Tween.Easing.Exponential.Out,
        EXPONENTIAL_IN_OUT: Tween.Easing.Exponential.InOut,
        CIRCULAR_IN: Tween.Easing.Circular.In,
        CIRCULAR_OUT: Tween.Easing.Circular.Out,
        CIRCULAR_IN_OUT: Tween.Easing.Circular.InOut,
        ELASTIC_IN: Tween.Easing.Elastic.In,
        ELASTIC_OUT: Tween.Easing.Elastic.Out,
        ELASTIC_IN_OUT: Tween.Easing.Elastic.InOut,
        BACK_IN: Tween.Easing.Back.In,
        BACK_OUT: Tween.Easing.Back.Out,
        BACK_IN_OUT: Tween.Easing.Back.InOut,
        BOUNCE_IN: Tween.Easing.Bounce.In,
        BOUNCE_OUT: Tween.Easing.Bounce.Out,
        BOUNCE_IN_OUT: Tween.Easing.Bounce.InOut
    };
module.exports = freezeObject(EasingFunction);
},{"../ThirdParty/Tween":586,"./freezeObject":249}],127:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EllipseGeometryLibrary = require('./EllipseGeometryLibrary'), Ellipsoid = require('./Ellipsoid'), GeographicProjection = require('./GeographicProjection'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), GeometryInstance = require('./GeometryInstance'), GeometryPipeline = require('./GeometryPipeline'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), PrimitiveType = require('./PrimitiveType'), Quaternion = require('./Quaternion'), VertexFormat = require('./VertexFormat');
'use strict';
var scratchCartesian1 = new Cartesian3();
var scratchCartesian2 = new Cartesian3();
var scratchCartesian3 = new Cartesian3();
var scratchCartesian4 = new Cartesian3();
var texCoordScratch = new Cartesian2();
var textureMatrixScratch = new Matrix3();
var quaternionScratch = new Quaternion();
var scratchNormal = new Cartesian3();
var scratchTangent = new Cartesian3();
var scratchBinormal = new Cartesian3();
var scratchCartographic = new Cartographic();
var projectedCenterScratch = new Cartesian3();
function computeTopBottomAttributes(positions, options, extrude) {
    var vertexFormat = options.vertexFormat;
    var center = options.center;
    var semiMajorAxis = options.semiMajorAxis;
    var ellipsoid = options.ellipsoid;
    var stRotation = options.stRotation;
    var size = extrude ? positions.length / 3 * 2 : positions.length / 3;
    var textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;
    var normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(size * 3) : undefined;
    var textureCoordIndex = 0;
    var normal = scratchNormal;
    var tangent = scratchTangent;
    var binormal = scratchBinormal;
    var projection = new GeographicProjection(ellipsoid);
    var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);
    var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);
    ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);
    var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);
    var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);
    var length = positions.length;
    var bottomOffset = extrude ? length : 0;
    var stOffset = bottomOffset / 3 * 2;
    for (var i = 0; i < length; i += 3) {
        var i1 = i + 1;
        var i2 = i + 2;
        var position = Cartesian3.fromArray(positions, i, scratchCartesian1);
        if (vertexFormat.st) {
            var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);
            var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);
            Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);
            texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2 * semiMajorAxis);
            texCoordScratch.y = (projectedPoint.y + semiMajorAxis) / (2 * semiMajorAxis);
            if (extrude) {
                textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;
                textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;
            }
            textureCoordinates[textureCoordIndex++] = texCoordScratch.x;
            textureCoordinates[textureCoordIndex++] = texCoordScratch.y;
        }
        normal = ellipsoid.geodeticSurfaceNormal(position, normal);
        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {
            if (vertexFormat.tangent || vertexFormat.binormal) {
                tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);
                Matrix3.multiplyByVector(textureMatrix, tangent, tangent);
            }
            if (vertexFormat.normal) {
                normals[i] = normal.x;
                normals[i1] = normal.y;
                normals[i2] = normal.z;
                if (extrude) {
                    normals[i + bottomOffset] = -normal.x;
                    normals[i1 + bottomOffset] = -normal.y;
                    normals[i2 + bottomOffset] = -normal.z;
                }
            }
            if (vertexFormat.tangent) {
                tangents[i] = tangent.x;
                tangents[i1] = tangent.y;
                tangents[i2] = tangent.z;
                if (extrude) {
                    tangents[i + bottomOffset] = -tangent.x;
                    tangents[i1 + bottomOffset] = -tangent.y;
                    tangents[i2 + bottomOffset] = -tangent.z;
                }
            }
            if (vertexFormat.binormal) {
                binormal = Cartesian3.cross(normal, tangent, binormal);
                binormals[i] = binormal.x;
                binormals[i1] = binormal.y;
                binormals[i2] = binormal.z;
                if (extrude) {
                    binormals[i + bottomOffset] = binormal.x;
                    binormals[i1 + bottomOffset] = binormal.y;
                    binormals[i2 + bottomOffset] = binormal.z;
                }
            }
        }
    }
    var attributes = new GeometryAttributes();
    if (vertexFormat.position) {
        var finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(positions, options, extrude);
        attributes.position = new GeometryAttribute({
            componentDatatype: ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: finalPositions
        });
    }
    if (vertexFormat.st) {
        attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: textureCoordinates
        });
    }
    if (vertexFormat.normal) {
        attributes.normal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: normals
        });
    }
    if (vertexFormat.tangent) {
        attributes.tangent = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: tangents
        });
    }
    if (vertexFormat.binormal) {
        attributes.binormal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: binormals
        });
    }
    return attributes;
}
function topIndices(numPts) {
    var indices = new Array(2 * numPts * (numPts + 1));
    var indicesIndex = 0;
    var prevIndex;
    var numInterior;
    var positionIndex;
    var i;
    var j;
    for (i = 1; i < numPts; ++i) {
        positionIndex = i * (i + 1);
        prevIndex = (i - 1) * i;
        indices[indicesIndex++] = positionIndex++;
        indices[indicesIndex++] = prevIndex;
        indices[indicesIndex++] = positionIndex;
        numInterior = 2 * i;
        for (j = 0; j < numInterior - 1; ++j) {
            indices[indicesIndex++] = positionIndex;
            indices[indicesIndex++] = prevIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex;
        }
        indices[indicesIndex++] = positionIndex++;
        indices[indicesIndex++] = prevIndex;
        indices[indicesIndex++] = positionIndex;
    }
    numInterior = numPts * 2;
    ++positionIndex;
    ++prevIndex;
    for (i = 0; i < numInterior - 1; ++i) {
        indices[indicesIndex++] = positionIndex;
        indices[indicesIndex++] = prevIndex++;
        indices[indicesIndex++] = prevIndex;
        indices[indicesIndex++] = positionIndex++;
        indices[indicesIndex++] = prevIndex;
        indices[indicesIndex++] = positionIndex;
    }
    ++prevIndex;
    ++positionIndex;
    for (i = numPts - 1; i > 0; --i) {
        indices[indicesIndex++] = prevIndex++;
        indices[indicesIndex++] = prevIndex;
        indices[indicesIndex++] = positionIndex;
        numInterior = 2 * i;
        for (j = 0; j < numInterior - 1; ++j) {
            indices[indicesIndex++] = positionIndex;
            indices[indicesIndex++] = prevIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex;
        }
        indices[indicesIndex++] = prevIndex++;
        indices[indicesIndex++] = prevIndex++;
        indices[indicesIndex++] = positionIndex++;
    }
    return indices;
}
var boundingSphereCenter = new Cartesian3();
function computeEllipse(options) {
    var center = options.center;
    boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);
    boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);
    var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);
    var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, false);
    var positions = cep.positions;
    var numPts = cep.numPts;
    var attributes = computeTopBottomAttributes(positions, options, false);
    var indices = topIndices(numPts);
    indices = IndexDatatype.createTypedArray(positions.length / 3, indices);
    return {
        boundingSphere: boundingSphere,
        attributes: attributes,
        indices: indices
    };
}
function computeWallAttributes(positions, options) {
    var vertexFormat = options.vertexFormat;
    var center = options.center;
    var semiMajorAxis = options.semiMajorAxis;
    var ellipsoid = options.ellipsoid;
    var height = options.height;
    var extrudedHeight = options.extrudedHeight;
    var stRotation = options.stRotation;
    var size = positions.length / 3 * 2;
    var finalPositions = new Float64Array(size * 3);
    var textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;
    var normals = vertexFormat.normal ? new Float32Array(size * 3) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(size * 3) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(size * 3) : undefined;
    var textureCoordIndex = 0;
    var normal = scratchNormal;
    var tangent = scratchTangent;
    var binormal = scratchBinormal;
    var projection = new GeographicProjection(ellipsoid);
    var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);
    var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);
    ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);
    var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);
    var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);
    var length = positions.length;
    var stOffset = length / 3 * 2;
    for (var i = 0; i < length; i += 3) {
        var i1 = i + 1;
        var i2 = i + 2;
        var position = Cartesian3.fromArray(positions, i, scratchCartesian1);
        var extrudedPosition;
        if (vertexFormat.st) {
            var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);
            var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);
            Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);
            texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2 * semiMajorAxis);
            texCoordScratch.y = (projectedPoint.y + semiMajorAxis) / (2 * semiMajorAxis);
            textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;
            textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;
            textureCoordinates[textureCoordIndex++] = texCoordScratch.x;
            textureCoordinates[textureCoordIndex++] = texCoordScratch.y;
        }
        position = ellipsoid.scaleToGeodeticSurface(position, position);
        extrudedPosition = Cartesian3.clone(position, scratchCartesian2);
        normal = ellipsoid.geodeticSurfaceNormal(position, normal);
        var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian4);
        position = Cartesian3.add(position, scaledNormal, position);
        scaledNormal = Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);
        extrudedPosition = Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);
        if (vertexFormat.position) {
            finalPositions[i + length] = extrudedPosition.x;
            finalPositions[i1 + length] = extrudedPosition.y;
            finalPositions[i2 + length] = extrudedPosition.z;
            finalPositions[i] = position.x;
            finalPositions[i1] = position.y;
            finalPositions[i2] = position.z;
        }
        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {
            binormal = Cartesian3.clone(normal, binormal);
            var next = Cartesian3.fromArray(positions, (i + 3) % length, scratchCartesian4);
            Cartesian3.subtract(next, position, next);
            var bottom = Cartesian3.subtract(extrudedPosition, position, scratchCartesian3);
            normal = Cartesian3.normalize(Cartesian3.cross(bottom, next, normal), normal);
            if (vertexFormat.normal) {
                normals[i] = normal.x;
                normals[i1] = normal.y;
                normals[i2] = normal.z;
                normals[i + length] = normal.x;
                normals[i1 + length] = normal.y;
                normals[i2 + length] = normal.z;
            }
            if (vertexFormat.tangent) {
                tangent = Cartesian3.normalize(Cartesian3.cross(binormal, normal, tangent), tangent);
                tangents[i] = tangent.x;
                tangents[i1] = tangent.y;
                tangents[i2] = tangent.z;
                tangents[i + length] = tangent.x;
                tangents[i + 1 + length] = tangent.y;
                tangents[i + 2 + length] = tangent.z;
            }
            if (vertexFormat.binormal) {
                binormals[i] = binormal.x;
                binormals[i1] = binormal.y;
                binormals[i2] = binormal.z;
                binormals[i + length] = binormal.x;
                binormals[i1 + length] = binormal.y;
                binormals[i2 + length] = binormal.z;
            }
        }
    }
    var attributes = new GeometryAttributes();
    if (vertexFormat.position) {
        attributes.position = new GeometryAttribute({
            componentDatatype: ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: finalPositions
        });
    }
    if (vertexFormat.st) {
        attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: textureCoordinates
        });
    }
    if (vertexFormat.normal) {
        attributes.normal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: normals
        });
    }
    if (vertexFormat.tangent) {
        attributes.tangent = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: tangents
        });
    }
    if (vertexFormat.binormal) {
        attributes.binormal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: binormals
        });
    }
    return attributes;
}
function computeWallIndices(positions) {
    var length = positions.length / 3;
    var indices = IndexDatatype.createTypedArray(length, length * 6);
    var index = 0;
    for (var i = 0; i < length; i++) {
        var UL = i;
        var LL = i + length;
        var UR = (UL + 1) % length;
        var LR = UR + length;
        indices[index++] = UL;
        indices[index++] = LL;
        indices[index++] = UR;
        indices[index++] = UR;
        indices[index++] = LL;
        indices[index++] = LR;
    }
    return indices;
}
var topBoundingSphere = new BoundingSphere();
var bottomBoundingSphere = new BoundingSphere();
function computeExtrudedEllipse(options) {
    var center = options.center;
    var ellipsoid = options.ellipsoid;
    var semiMajorAxis = options.semiMajorAxis;
    var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);
    topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);
    topBoundingSphere.radius = semiMajorAxis;
    scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);
    bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);
    bottomBoundingSphere.radius = semiMajorAxis;
    var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);
    var positions = cep.positions;
    var numPts = cep.numPts;
    var outerPositions = cep.outerPositions;
    var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);
    var topBottomAttributes = computeTopBottomAttributes(positions, options, true);
    var indices = topIndices(numPts);
    var length = indices.length;
    indices.length = length * 2;
    var posLength = positions.length / 3;
    for (var i = 0; i < length; i += 3) {
        indices[i + length] = indices[i + 2] + posLength;
        indices[i + 1 + length] = indices[i + 1] + posLength;
        indices[i + 2 + length] = indices[i] + posLength;
    }
    var topBottomIndices = IndexDatatype.createTypedArray(posLength * 2 / 3, indices);
    var topBottomGeo = new Geometry({
            attributes: topBottomAttributes,
            indices: topBottomIndices,
            primitiveType: PrimitiveType.TRIANGLES
        });
    var wallAttributes = computeWallAttributes(outerPositions, options);
    indices = computeWallIndices(outerPositions);
    var wallIndices = IndexDatatype.createTypedArray(outerPositions.length * 2 / 3, indices);
    var wallGeo = new Geometry({
            attributes: wallAttributes,
            indices: wallIndices,
            primitiveType: PrimitiveType.TRIANGLES
        });
    var geo = GeometryPipeline.combineInstances([
            new GeometryInstance({ geometry: topBottomGeo }),
            new GeometryInstance({ geometry: wallGeo })
        ]);
    return {
        boundingSphere: boundingSphere,
        attributes: geo[0].attributes,
        indices: geo[0].indices
    };
}
var EllipseGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var center = options.center;
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var semiMajorAxis = options.semiMajorAxis;
    var semiMinorAxis = options.semiMinorAxis;
    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    var height = defaultValue(options.height, 0);
    var extrudedHeight = options.extrudedHeight;
    var extrude = defined(extrudedHeight) && Math.abs(height - extrudedHeight) > 1;
    var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
    if (!defined(center)) {
        throw new DeveloperError('center is required.');
    }
    if (!defined(semiMajorAxis)) {
        throw new DeveloperError('semiMajorAxis is required.');
    }
    if (!defined(semiMinorAxis)) {
        throw new DeveloperError('semiMinorAxis is required.');
    }
    if (semiMajorAxis <= 0 || semiMinorAxis <= 0) {
        throw new DeveloperError('Semi-major and semi-minor axes must be greater than zero.');
    }
    if (semiMajorAxis < semiMinorAxis) {
        throw new DeveloperError('semiMajorAxis must be larger than the semiMinorAxis.');
    }
    if (granularity <= 0) {
        throw new DeveloperError('granularity must be greater than zero.');
    }
    this._center = Cartesian3.clone(center);
    this._semiMajorAxis = semiMajorAxis;
    this._semiMinorAxis = semiMinorAxis;
    this._ellipsoid = Ellipsoid.clone(ellipsoid);
    this._rotation = defaultValue(options.rotation, 0);
    this._stRotation = defaultValue(options.stRotation, 0);
    this._height = height;
    this._granularity = granularity;
    this._vertexFormat = VertexFormat.clone(vertexFormat);
    this._extrudedHeight = defaultValue(extrudedHeight, height);
    this._extrude = extrude;
    this._workerName = 'createEllipseGeometry';
};
EllipseGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 8;
EllipseGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Cartesian3.pack(value._center, array, startingIndex);
    startingIndex += Cartesian3.packedLength;
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex++] = value._semiMajorAxis;
    array[startingIndex++] = value._semiMinorAxis;
    array[startingIndex++] = value._rotation;
    array[startingIndex++] = value._stRotation;
    array[startingIndex++] = value._height;
    array[startingIndex++] = value._granularity;
    array[startingIndex++] = value._extrudedHeight;
    array[startingIndex] = value._extrude ? 1 : 0;
};
var scratchCenter = new Cartesian3();
var scratchEllipsoid = new Ellipsoid();
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        center: scratchCenter,
        ellipsoid: scratchEllipsoid,
        vertexFormat: scratchVertexFormat,
        semiMajorAxis: undefined,
        semiMinorAxis: undefined,
        rotation: undefined,
        stRotation: undefined,
        height: undefined,
        granularity: undefined,
        extrudedHeight: undefined
    };
EllipseGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var center = Cartesian3.unpack(array, startingIndex, scratchCenter);
    startingIndex += Cartesian3.packedLength;
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var semiMajorAxis = array[startingIndex++];
    var semiMinorAxis = array[startingIndex++];
    var rotation = array[startingIndex++];
    var stRotation = array[startingIndex++];
    var height = array[startingIndex++];
    var granularity = array[startingIndex++];
    var extrudedHeight = array[startingIndex++];
    var extrude = array[startingIndex] === 1;
    if (!defined(result)) {
        scratchOptions.height = height;
        scratchOptions.extrudedHeight = extrudedHeight;
        scratchOptions.granularity = granularity;
        scratchOptions.stRotation = stRotation;
        scratchOptions.rotation = rotation;
        scratchOptions.semiMajorAxis = semiMajorAxis;
        scratchOptions.semiMinorAxis = semiMinorAxis;
        return new EllipseGeometry(scratchOptions);
    }
    result._center = Cartesian3.clone(center, result._center);
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._semiMajorAxis = semiMajorAxis;
    result._semiMinorAxis = semiMinorAxis;
    result._rotation = rotation;
    result._stRotation = stRotation;
    result._height = height;
    result._granularity = granularity;
    result._extrudedHeight = extrudedHeight;
    result._extrude = extrude;
    return result;
};
EllipseGeometry.createGeometry = function (ellipseGeometry) {
    ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);
    var options = {
            center: ellipseGeometry._center,
            semiMajorAxis: ellipseGeometry._semiMajorAxis,
            semiMinorAxis: ellipseGeometry._semiMinorAxis,
            ellipsoid: ellipseGeometry._ellipsoid,
            rotation: ellipseGeometry._rotation,
            height: ellipseGeometry._height,
            extrudedHeight: ellipseGeometry._extrudedHeight,
            granularity: ellipseGeometry._granularity,
            vertexFormat: ellipseGeometry._vertexFormat,
            stRotation: ellipseGeometry._stRotation
        };
    var geometry;
    if (ellipseGeometry._extrude) {
        options.extrudedHeight = Math.min(ellipseGeometry._extrudedHeight, ellipseGeometry._height);
        options.height = Math.max(ellipseGeometry._extrudedHeight, ellipseGeometry._height);
        geometry = computeExtrudedEllipse(options);
    } else {
        geometry = computeEllipse(options);
    }
    return new Geometry({
        attributes: geometry.attributes,
        indices: geometry.indices,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingSphere: geometry.boundingSphere
    });
};
module.exports = EllipseGeometry;
},{"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./Cartographic":104,"./ComponentDatatype":113,"./DeveloperError":123,"./EllipseGeometryLibrary":128,"./Ellipsoid":130,"./GeographicProjection":143,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./GeometryInstance":148,"./GeometryPipeline":150,"./IndexDatatype":162,"./Math":174,"./Matrix3":176,"./PrimitiveType":193,"./Quaternion":197,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],128:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), Quaternion = require('./Quaternion');
'use strict';
var EllipseGeometryLibrary = {};
var rotAxis = new Cartesian3();
var tempVec = new Cartesian3();
var unitQuat = new Quaternion();
var rotMtx = new Matrix3();
function pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {
    var azimuth = theta + rotation;
    Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);
    Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);
    Cartesian3.add(rotAxis, tempVec, rotAxis);
    var cosThetaSquared = Math.cos(theta);
    cosThetaSquared = cosThetaSquared * cosThetaSquared;
    var sinThetaSquared = Math.sin(theta);
    sinThetaSquared = sinThetaSquared * sinThetaSquared;
    var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);
    var angle = radius / mag;
    Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);
    Matrix3.fromQuaternion(unitQuat, rotMtx);
    Matrix3.multiplyByVector(rotMtx, unitPos, result);
    Cartesian3.normalize(result, result);
    Cartesian3.multiplyByScalar(result, mag, result);
    return result;
}
var scratchCartesian1 = new Cartesian3();
var scratchCartesian2 = new Cartesian3();
var scratchCartesian3 = new Cartesian3();
var scratchNormal = new Cartesian3();
EllipseGeometryLibrary.raisePositionsToHeight = function (positions, options, extrude) {
    var ellipsoid = options.ellipsoid;
    var height = options.height;
    var extrudedHeight = options.extrudedHeight;
    var size = extrude ? positions.length / 3 * 2 : positions.length / 3;
    var finalPositions = new Float64Array(size * 3);
    var length = positions.length;
    var bottomOffset = extrude ? length : 0;
    for (var i = 0; i < length; i += 3) {
        var i1 = i + 1;
        var i2 = i + 2;
        var position = Cartesian3.fromArray(positions, i, scratchCartesian1);
        ellipsoid.scaleToGeodeticSurface(position, position);
        var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);
        var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);
        var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);
        Cartesian3.add(position, scaledNormal, position);
        if (extrude) {
            Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);
            Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);
            finalPositions[i + bottomOffset] = extrudedPosition.x;
            finalPositions[i1 + bottomOffset] = extrudedPosition.y;
            finalPositions[i2 + bottomOffset] = extrudedPosition.z;
        }
        finalPositions[i] = position.x;
        finalPositions[i1] = position.y;
        finalPositions[i2] = position.z;
    }
    return finalPositions;
};
var unitPosScratch = new Cartesian3();
var eastVecScratch = new Cartesian3();
var northVecScratch = new Cartesian3();
EllipseGeometryLibrary.computeEllipsePositions = function (options, addFillPositions, addEdgePositions) {
    var semiMinorAxis = options.semiMinorAxis;
    var semiMajorAxis = options.semiMajorAxis;
    var rotation = options.rotation;
    var center = options.center;
    var granularity = options.granularity * 8;
    var aSqr = semiMinorAxis * semiMinorAxis;
    var bSqr = semiMajorAxis * semiMajorAxis;
    var ab = semiMajorAxis * semiMinorAxis;
    var mag = Cartesian3.magnitude(center);
    var unitPos = Cartesian3.normalize(center, unitPosScratch);
    var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);
    eastVec = Cartesian3.normalize(eastVec, eastVec);
    var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);
    var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);
    var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);
    var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;
    if (theta < 0) {
        numPts -= Math.ceil(Math.abs(theta) / deltaTheta);
    }
    var size = 2 * numPts * (numPts + 1);
    var positions = addFillPositions ? new Array(size * 3) : undefined;
    var positionIndex = 0;
    var position = scratchCartesian1;
    var reflectedPosition = scratchCartesian2;
    var outerPositionsLength = (2 * numPts + 2 * (numPts - 1)) * 3;
    var outerRightIndex = outerPositionsLength - 1;
    var outerLeftIndex = 0;
    var outerPositions = addEdgePositions ? new Array(outerPositionsLength) : undefined;
    var i;
    var j;
    var numInterior;
    var t;
    var interiorPosition;
    theta = CesiumMath.PI_OVER_TWO;
    for (i = 0; i < numPts; ++i) {
        position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);
        reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);
        if (addFillPositions) {
            positions[positionIndex++] = position.x;
            positions[positionIndex++] = position.y;
            positions[positionIndex++] = position.z;
            numInterior = 2 * i + 2;
            for (j = 1; j < numInterior - 1; ++j) {
                t = j / (numInterior - 1);
                interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);
                positions[positionIndex++] = interiorPosition.x;
                positions[positionIndex++] = interiorPosition.y;
                positions[positionIndex++] = interiorPosition.z;
            }
            positions[positionIndex++] = reflectedPosition.x;
            positions[positionIndex++] = reflectedPosition.y;
            positions[positionIndex++] = reflectedPosition.z;
        }
        if (addEdgePositions) {
            outerPositions[outerRightIndex--] = position.z;
            outerPositions[outerRightIndex--] = position.y;
            outerPositions[outerRightIndex--] = position.x;
            if (i !== 0) {
                outerPositions[outerLeftIndex++] = reflectedPosition.x;
                outerPositions[outerLeftIndex++] = reflectedPosition.y;
                outerPositions[outerLeftIndex++] = reflectedPosition.z;
            }
        }
        theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;
    }
    for (i = numPts; i > 0; --i) {
        theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;
        position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);
        reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);
        if (addFillPositions) {
            positions[positionIndex++] = position.x;
            positions[positionIndex++] = position.y;
            positions[positionIndex++] = position.z;
            numInterior = 2 * (i - 1) + 2;
            for (j = 1; j < numInterior - 1; ++j) {
                t = j / (numInterior - 1);
                interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);
                positions[positionIndex++] = interiorPosition.x;
                positions[positionIndex++] = interiorPosition.y;
                positions[positionIndex++] = interiorPosition.z;
            }
            positions[positionIndex++] = reflectedPosition.x;
            positions[positionIndex++] = reflectedPosition.y;
            positions[positionIndex++] = reflectedPosition.z;
        }
        if (addEdgePositions) {
            outerPositions[outerRightIndex--] = position.z;
            outerPositions[outerRightIndex--] = position.y;
            outerPositions[outerRightIndex--] = position.x;
            if (i !== 1) {
                outerPositions[outerLeftIndex++] = reflectedPosition.x;
                outerPositions[outerLeftIndex++] = reflectedPosition.y;
                outerPositions[outerLeftIndex++] = reflectedPosition.z;
            }
        }
    }
    var r = {};
    if (addFillPositions) {
        r.positions = positions;
        r.numPts = numPts;
    }
    if (addEdgePositions) {
        r.outerPositions = outerPositions;
    }
    return r;
};
module.exports = EllipseGeometryLibrary;
},{"./Cartesian3":102,"./Math":174,"./Matrix3":176,"./Quaternion":197}],129:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EllipseGeometryLibrary = require('./EllipseGeometryLibrary'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PrimitiveType = require('./PrimitiveType');
'use strict';
var scratchCartesian1 = new Cartesian3();
var boundingSphereCenter = new Cartesian3();
function computeEllipse(options) {
    var center = options.center;
    boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);
    boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);
    var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);
    var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;
    var attributes = new GeometryAttributes({
            position: new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)
            })
        });
    var length = positions.length / 3;
    var indices = IndexDatatype.createTypedArray(length, length * 2);
    var index = 0;
    for (var i = 0; i < length; ++i) {
        indices[index++] = i;
        indices[index++] = (i + 1) % length;
    }
    return {
        boundingSphere: boundingSphere,
        attributes: attributes,
        indices: indices
    };
}
var topBoundingSphere = new BoundingSphere();
var bottomBoundingSphere = new BoundingSphere();
function computeExtrudedEllipse(options) {
    var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);
    numberOfVerticalLines = Math.max(numberOfVerticalLines, 0);
    var center = options.center;
    var ellipsoid = options.ellipsoid;
    var semiMajorAxis = options.semiMajorAxis;
    var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);
    topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);
    topBoundingSphere.radius = semiMajorAxis;
    scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);
    bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);
    bottomBoundingSphere.radius = semiMajorAxis;
    var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;
    var attributes = new GeometryAttributes({
            position: new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)
            })
        });
    positions = attributes.position.values;
    var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);
    var length = positions.length / 3;
    var indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);
    length /= 2;
    var index = 0;
    var i;
    for (i = 0; i < length; ++i) {
        indices[index++] = i;
        indices[index++] = (i + 1) % length;
        indices[index++] = i + length;
        indices[index++] = (i + 1) % length + length;
    }
    var numSide;
    if (numberOfVerticalLines > 0) {
        var numSideLines = Math.min(numberOfVerticalLines, length);
        numSide = Math.round(length / numSideLines);
    }
    var maxI = Math.min(numSide * numberOfVerticalLines, length);
    if (numberOfVerticalLines > 0) {
        for (i = 0; i < maxI; i += numSide) {
            indices[index++] = i;
            indices[index++] = i + length;
        }
    }
    return {
        boundingSphere: boundingSphere,
        attributes: attributes,
        indices: indices
    };
}
var EllipseOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var center = options.center;
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var semiMajorAxis = options.semiMajorAxis;
    var semiMinorAxis = options.semiMinorAxis;
    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    var height = defaultValue(options.height, 0);
    var extrudedHeight = options.extrudedHeight;
    var extrude = defined(extrudedHeight) && Math.abs(height - extrudedHeight) > 1;
    if (!defined(center)) {
        throw new DeveloperError('center is required.');
    }
    if (!defined(semiMajorAxis)) {
        throw new DeveloperError('semiMajorAxis is required.');
    }
    if (!defined(semiMinorAxis)) {
        throw new DeveloperError('semiMinorAxis is required.');
    }
    if (semiMajorAxis <= 0 || semiMinorAxis <= 0) {
        throw new DeveloperError('Semi-major and semi-minor axes must be greater than zero.');
    }
    if (semiMajorAxis < semiMinorAxis) {
        throw new DeveloperError('semiMajorAxis must be larger than the semiMajorAxis.');
    }
    if (granularity <= 0) {
        throw new DeveloperError('granularity must be greater than zero.');
    }
    this._center = Cartesian3.clone(center);
    this._semiMajorAxis = semiMajorAxis;
    this._semiMinorAxis = semiMinorAxis;
    this._ellipsoid = Ellipsoid.clone(ellipsoid);
    this._rotation = defaultValue(options.rotation, 0);
    this._height = height;
    this._granularity = granularity;
    this._extrudedHeight = defaultValue(extrudedHeight, 0);
    this._extrude = extrude;
    this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);
    this._workerName = 'createEllipseOutlineGeometry';
};
EllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;
EllipseOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Cartesian3.pack(value._center, array, startingIndex);
    startingIndex += Cartesian3.packedLength;
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    array[startingIndex++] = value._semiMajorAxis;
    array[startingIndex++] = value._semiMinorAxis;
    array[startingIndex++] = value._rotation;
    array[startingIndex++] = value._height;
    array[startingIndex++] = value._granularity;
    array[startingIndex++] = value._extrudedHeight;
    array[startingIndex++] = value._extrude ? 1 : 0;
    array[startingIndex] = value._numberOfVerticalLines;
};
var scratchCenter = new Cartesian3();
var scratchEllipsoid = new Ellipsoid();
var scratchOptions = {
        center: scratchCenter,
        ellipsoid: scratchEllipsoid,
        semiMajorAxis: undefined,
        semiMinorAxis: undefined,
        rotation: undefined,
        height: undefined,
        granularity: undefined,
        extrudedHeight: undefined,
        numberOfVerticalLines: undefined
    };
EllipseOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var center = Cartesian3.unpack(array, startingIndex, scratchCenter);
    startingIndex += Cartesian3.packedLength;
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var semiMajorAxis = array[startingIndex++];
    var semiMinorAxis = array[startingIndex++];
    var rotation = array[startingIndex++];
    var height = array[startingIndex++];
    var granularity = array[startingIndex++];
    var extrudedHeight = array[startingIndex++];
    var extrude = array[startingIndex++] === 1;
    var numberOfVerticalLines = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.height = height;
        scratchOptions.extrudedHeight = extrudedHeight;
        scratchOptions.granularity = granularity;
        scratchOptions.rotation = rotation;
        scratchOptions.semiMajorAxis = semiMajorAxis;
        scratchOptions.semiMinorAxis = semiMinorAxis;
        scratchOptions.numberOfVerticalLines = numberOfVerticalLines;
        return new EllipseOutlineGeometry(scratchOptions);
    }
    result._center = Cartesian3.clone(center, result._center);
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._semiMajorAxis = semiMajorAxis;
    result._semiMinorAxis = semiMinorAxis;
    result._rotation = rotation;
    result._height = height;
    result._granularity = granularity;
    result._extrudedHeight = extrudedHeight;
    result._extrude = extrude;
    result._numberOfVerticalLines = numberOfVerticalLines;
    return result;
};
EllipseOutlineGeometry.createGeometry = function (ellipseGeometry) {
    ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);
    var options = {
            center: ellipseGeometry._center,
            semiMajorAxis: ellipseGeometry._semiMajorAxis,
            semiMinorAxis: ellipseGeometry._semiMinorAxis,
            ellipsoid: ellipseGeometry._ellipsoid,
            rotation: ellipseGeometry._rotation,
            height: ellipseGeometry._height,
            extrudedHeight: ellipseGeometry._extrudedHeight,
            granularity: ellipseGeometry._granularity,
            numberOfVerticalLines: ellipseGeometry._numberOfVerticalLines
        };
    var geometry;
    if (ellipseGeometry._extrude) {
        options.extrudedHeight = Math.min(ellipseGeometry._extrudedHeight, ellipseGeometry._height);
        options.height = Math.max(ellipseGeometry._extrudedHeight, ellipseGeometry._height);
        geometry = computeExtrudedEllipse(options);
    } else {
        geometry = computeEllipse(options);
    }
    return new Geometry({
        attributes: geometry.attributes,
        indices: geometry.indices,
        primitiveType: PrimitiveType.LINES,
        boundingSphere: geometry.boundingSphere
    });
};
module.exports = EllipseOutlineGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./EllipseGeometryLibrary":128,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PrimitiveType":193,"./defaultValue":243,"./defined":245}],130:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
function initialize(ellipsoid, x, y, z) {
    x = defaultValue(x, 0);
    y = defaultValue(y, 0);
    z = defaultValue(z, 0);
    if (x < 0 || y < 0 || z < 0) {
        throw new DeveloperError('All radii components must be greater than or equal to zero.');
    }
    ellipsoid._radii = new Cartesian3(x, y, z);
    ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);
    ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x, y * y * y * y, z * z * z * z);
    ellipsoid._oneOverRadii = new Cartesian3(x === 0 ? 0 : 1 / x, y === 0 ? 0 : 1 / y, z === 0 ? 0 : 1 / z);
    ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0 ? 0 : 1 / (x * x), y === 0 ? 0 : 1 / (y * y), z === 0 ? 0 : 1 / (z * z));
    ellipsoid._minimumRadius = Math.min(x, y, z);
    ellipsoid._maximumRadius = Math.max(x, y, z);
    ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;
}
var Ellipsoid = function (x, y, z) {
    this._radii = undefined;
    this._radiiSquared = undefined;
    this._radiiToTheFourth = undefined;
    this._oneOverRadii = undefined;
    this._oneOverRadiiSquared = undefined;
    this._minimumRadius = undefined;
    this._maximumRadius = undefined;
    this._centerToleranceSquared = undefined;
    initialize(this, x, y, z);
};
defineProperties(Ellipsoid.prototype, {
    radii: {
        get: function () {
            return this._radii;
        }
    },
    radiiSquared: {
        get: function () {
            return this._radiiSquared;
        }
    },
    radiiToTheFourth: {
        get: function () {
            return this._radiiToTheFourth;
        }
    },
    oneOverRadii: {
        get: function () {
            return this._oneOverRadii;
        }
    },
    oneOverRadiiSquared: {
        get: function () {
            return this._oneOverRadiiSquared;
        }
    },
    minimumRadius: {
        get: function () {
            return this._minimumRadius;
        }
    },
    maximumRadius: {
        get: function () {
            return this._maximumRadius;
        }
    }
});
Ellipsoid.clone = function (ellipsoid, result) {
    if (!defined(ellipsoid)) {
        return undefined;
    }
    var radii = ellipsoid._radii;
    if (!defined(result)) {
        return new Ellipsoid(radii.x, radii.y, radii.z);
    }
    Cartesian3.clone(radii, result._radii);
    Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);
    Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);
    Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);
    Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);
    result._minimumRadius = ellipsoid._minimumRadius;
    result._maximumRadius = ellipsoid._maximumRadius;
    result._centerToleranceSquared = ellipsoid._centerToleranceSquared;
    return result;
};
Ellipsoid.fromCartesian3 = function (cartesian, result) {
    if (!defined(result)) {
        result = new Ellipsoid();
    }
    if (!defined(cartesian)) {
        return result;
    }
    initialize(result, cartesian.x, cartesian.y, cartesian.z);
    return result;
};
Ellipsoid.WGS84 = freezeObject(new Ellipsoid(6378137, 6378137, 6356752.314245179));
Ellipsoid.UNIT_SPHERE = freezeObject(new Ellipsoid(1, 1, 1));
Ellipsoid.MOON = freezeObject(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));
Ellipsoid.prototype.clone = function (result) {
    return Ellipsoid.clone(this, result);
};
Ellipsoid.packedLength = Cartesian3.packedLength;
Ellipsoid.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Cartesian3.pack(value._radii, array, startingIndex);
};
Ellipsoid.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var radii = Cartesian3.unpack(array, startingIndex);
    return Ellipsoid.fromCartesian3(radii, result);
};
Ellipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;
Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function (cartographic, result) {
    if (!defined(cartographic)) {
        throw new DeveloperError('cartographic is required.');
    }
    var longitude = cartographic.longitude;
    var latitude = cartographic.latitude;
    var cosLatitude = Math.cos(latitude);
    var x = cosLatitude * Math.cos(longitude);
    var y = cosLatitude * Math.sin(longitude);
    var z = Math.sin(latitude);
    if (!defined(result)) {
        result = new Cartesian3();
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return Cartesian3.normalize(result, result);
};
Ellipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {
    if (!defined(result)) {
        result = new Cartesian3();
    }
    result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);
    return Cartesian3.normalize(result, result);
};
var cartographicToCartesianNormal = new Cartesian3();
var cartographicToCartesianK = new Cartesian3();
Ellipsoid.prototype.cartographicToCartesian = function (cartographic, result) {
    var n = cartographicToCartesianNormal;
    var k = cartographicToCartesianK;
    this.geodeticSurfaceNormalCartographic(cartographic, n);
    Cartesian3.multiplyComponents(this._radiiSquared, n, k);
    var gamma = Math.sqrt(Cartesian3.dot(n, k));
    Cartesian3.divideByScalar(k, gamma, k);
    Cartesian3.multiplyByScalar(n, cartographic.height, n);
    if (!defined(result)) {
        result = new Cartesian3();
    }
    return Cartesian3.add(k, n, result);
};
Ellipsoid.prototype.cartographicArrayToCartesianArray = function (cartographics, result) {
    if (!defined(cartographics)) {
        throw new DeveloperError('cartographics is required.');
    }
    var length = cartographics.length;
    if (!defined(result)) {
        result = new Array(length);
    } else {
        result.length = length;
    }
    for (var i = 0; i < length; i++) {
        result[i] = this.cartographicToCartesian(cartographics[i], result[i]);
    }
    return result;
};
var cartesianToCartographicN = new Cartesian3();
var cartesianToCartographicP = new Cartesian3();
var cartesianToCartographicH = new Cartesian3();
Ellipsoid.prototype.cartesianToCartographic = function (cartesian, result) {
    var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);
    if (!defined(p)) {
        return undefined;
    }
    var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);
    var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);
    var longitude = Math.atan2(n.y, n.x);
    var latitude = Math.asin(n.z);
    var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);
    if (!defined(result)) {
        return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
};
Ellipsoid.prototype.cartesianArrayToCartographicArray = function (cartesians, result) {
    if (!defined(cartesians)) {
        throw new DeveloperError('cartesians is required.');
    }
    var length = cartesians.length;
    if (!defined(result)) {
        result = new Array(length);
    } else {
        result.length = length;
    }
    for (var i = 0; i < length; ++i) {
        result[i] = this.cartesianToCartographic(cartesians[i], result[i]);
    }
    return result;
};
var scaleToGeodeticSurfaceIntersection = new Cartesian3();
var scaleToGeodeticSurfaceGradient = new Cartesian3();
Ellipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    var positionX = cartesian.x;
    var positionY = cartesian.y;
    var positionZ = cartesian.z;
    var oneOverRadii = this._oneOverRadii;
    var oneOverRadiiX = oneOverRadii.x;
    var oneOverRadiiY = oneOverRadii.y;
    var oneOverRadiiZ = oneOverRadii.z;
    var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
    var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
    var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
    var squaredNorm = x2 + y2 + z2;
    var ratio = Math.sqrt(1 / squaredNorm);
    var intersection = Cartesian3.multiplyByScalar(cartesian, ratio, scaleToGeodeticSurfaceIntersection);
    if (squaredNorm < this._centerToleranceSquared) {
        return !isFinite(ratio) ? undefined : Cartesian3.clone(intersection, result);
    }
    var oneOverRadiiSquared = this._oneOverRadiiSquared;
    var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
    var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
    var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
    var gradient = scaleToGeodeticSurfaceGradient;
    gradient.x = intersection.x * oneOverRadiiSquaredX * 2;
    gradient.y = intersection.y * oneOverRadiiSquaredY * 2;
    gradient.z = intersection.z * oneOverRadiiSquaredZ * 2;
    var lambda = (1 - ratio) * Cartesian3.magnitude(cartesian) / (0.5 * Cartesian3.magnitude(gradient));
    var correction = 0;
    var func;
    var denominator;
    var xMultiplier;
    var yMultiplier;
    var zMultiplier;
    var xMultiplier2;
    var yMultiplier2;
    var zMultiplier2;
    var xMultiplier3;
    var yMultiplier3;
    var zMultiplier3;
    do {
        lambda -= correction;
        xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
        yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
        zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
        xMultiplier2 = xMultiplier * xMultiplier;
        yMultiplier2 = yMultiplier * yMultiplier;
        zMultiplier2 = zMultiplier * zMultiplier;
        xMultiplier3 = xMultiplier2 * xMultiplier;
        yMultiplier3 = yMultiplier2 * yMultiplier;
        zMultiplier3 = zMultiplier2 * zMultiplier;
        func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1;
        denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
        var derivative = -2 * denominator;
        correction = func / derivative;
    } while (Math.abs(func) > CesiumMath.EPSILON12);
    if (!defined(result)) {
        return new Cartesian3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);
    }
    result.x = positionX * xMultiplier;
    result.y = positionY * yMultiplier;
    result.z = positionZ * zMultiplier;
    return result;
};
Ellipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    var positionX = cartesian.x;
    var positionY = cartesian.y;
    var positionZ = cartesian.z;
    var oneOverRadiiSquared = this._oneOverRadiiSquared;
    var beta = 1 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
    return Cartesian3.multiplyByScalar(cartesian, beta, result);
};
Ellipsoid.prototype.transformPositionToScaledSpace = function (position, result) {
    if (!defined(result)) {
        result = new Cartesian3();
    }
    return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);
};
Ellipsoid.prototype.transformPositionFromScaledSpace = function (position, result) {
    if (!defined(result)) {
        result = new Cartesian3();
    }
    return Cartesian3.multiplyComponents(position, this._radii, result);
};
Ellipsoid.prototype.equals = function (right) {
    return this === right || defined(right) && Cartesian3.equals(this._radii, right._radii);
};
Ellipsoid.prototype.toString = function () {
    return this._radii.toString();
};
module.exports = Ellipsoid;
},{"./Cartesian3":102,"./Cartographic":104,"./DeveloperError":123,"./Math":174,"./defaultValue":243,"./defineProperties":244,"./defined":245,"./freezeObject":249}],131:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), CesiumMath = require('./Math');
'use strict';
function setConstants(ellipsoidGeodesic) {
    var uSquared = ellipsoidGeodesic._uSquared;
    var a = ellipsoidGeodesic._ellipsoid.maximumRadius;
    var b = ellipsoidGeodesic._ellipsoid.minimumRadius;
    var f = (a - b) / a;
    var cosineHeading = Math.cos(ellipsoidGeodesic._startHeading);
    var sineHeading = Math.sin(ellipsoidGeodesic._startHeading);
    var tanU = (1 - f) * Math.tan(ellipsoidGeodesic._start.latitude);
    var cosineU = 1 / Math.sqrt(1 + tanU * tanU);
    var sineU = cosineU * tanU;
    var sigma = Math.atan2(tanU, cosineHeading);
    var sineAlpha = cosineU * sineHeading;
    var sineSquaredAlpha = sineAlpha * sineAlpha;
    var cosineSquaredAlpha = 1 - sineSquaredAlpha;
    var cosineAlpha = Math.sqrt(cosineSquaredAlpha);
    var u2Over4 = uSquared / 4;
    var u4Over16 = u2Over4 * u2Over4;
    var u6Over64 = u4Over16 * u2Over4;
    var u8Over256 = u4Over16 * u4Over16;
    var a0 = 1 + u2Over4 - 3 * u4Over16 / 4 + 5 * u6Over64 / 4 - 175 * u8Over256 / 64;
    var a1 = 1 - u2Over4 + 15 * u4Over16 / 8 - 35 * u6Over64 / 8;
    var a2 = 1 - 3 * u2Over4 + 35 * u4Over16 / 4;
    var a3 = 1 - 5 * u2Over4;
    var distanceRatio = a0 * sigma - a1 * Math.sin(2 * sigma) * u2Over4 / 2 - a2 * Math.sin(4 * sigma) * u4Over16 / 16 - a3 * Math.sin(6 * sigma) * u6Over64 / 48 - Math.sin(8 * sigma) * 5 * u8Over256 / 512;
    var constants = ellipsoidGeodesic._constants;
    constants.a = a;
    constants.b = b;
    constants.f = f;
    constants.cosineHeading = cosineHeading;
    constants.sineHeading = sineHeading;
    constants.tanU = tanU;
    constants.cosineU = cosineU;
    constants.sineU = sineU;
    constants.sigma = sigma;
    constants.sineAlpha = sineAlpha;
    constants.sineSquaredAlpha = sineSquaredAlpha;
    constants.cosineSquaredAlpha = cosineSquaredAlpha;
    constants.cosineAlpha = cosineAlpha;
    constants.u2Over4 = u2Over4;
    constants.u4Over16 = u4Over16;
    constants.u6Over64 = u6Over64;
    constants.u8Over256 = u8Over256;
    constants.a0 = a0;
    constants.a1 = a1;
    constants.a2 = a2;
    constants.a3 = a3;
    constants.distanceRatio = distanceRatio;
}
function computeC(f, cosineSquaredAlpha) {
    return f * cosineSquaredAlpha * (4 + f * (4 - 3 * cosineSquaredAlpha)) / 16;
}
function computeDeltaLambda(f, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint) {
    var C = computeC(f, cosineSquaredAlpha);
    return (1 - C) * f * sineAlpha * (sigma + C * sineSigma * (cosineTwiceSigmaMidpoint + C * cosineSigma * (2 * cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint - 1)));
}
function vincentyInverseFormula(ellipsoidGeodesic, major, minor, firstLongitude, firstLatitude, secondLongitude, secondLatitude) {
    var eff = (major - minor) / major;
    var l = secondLongitude - firstLongitude;
    var u1 = Math.atan((1 - eff) * Math.tan(firstLatitude));
    var u2 = Math.atan((1 - eff) * Math.tan(secondLatitude));
    var cosineU1 = Math.cos(u1);
    var sineU1 = Math.sin(u1);
    var cosineU2 = Math.cos(u2);
    var sineU2 = Math.sin(u2);
    var cc = cosineU1 * cosineU2;
    var cs = cosineU1 * sineU2;
    var ss = sineU1 * sineU2;
    var sc = sineU1 * cosineU2;
    var lambda = l;
    var lambdaDot = CesiumMath.TWO_PI;
    var cosineLambda = Math.cos(lambda);
    var sineLambda = Math.sin(lambda);
    var sigma;
    var cosineSigma;
    var sineSigma;
    var cosineSquaredAlpha;
    var cosineTwiceSigmaMidpoint;
    do {
        cosineLambda = Math.cos(lambda);
        sineLambda = Math.sin(lambda);
        var temp = cs - sc * cosineLambda;
        sineSigma = Math.sqrt(cosineU2 * cosineU2 * sineLambda * sineLambda + temp * temp);
        cosineSigma = ss + cc * cosineLambda;
        sigma = Math.atan2(sineSigma, cosineSigma);
        var sineAlpha;
        if (sineSigma === 0) {
            sineAlpha = 0;
            cosineSquaredAlpha = 1;
        } else {
            sineAlpha = cc * sineLambda / sineSigma;
            cosineSquaredAlpha = 1 - sineAlpha * sineAlpha;
        }
        lambdaDot = lambda;
        cosineTwiceSigmaMidpoint = cosineSigma - 2 * ss / cosineSquaredAlpha;
        if (isNaN(cosineTwiceSigmaMidpoint)) {
            cosineTwiceSigmaMidpoint = 0;
        }
        lambda = l + computeDeltaLambda(eff, sineAlpha, cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);
    } while (Math.abs(lambda - lambdaDot) > CesiumMath.EPSILON12);
    var uSquared = cosineSquaredAlpha * (major * major - minor * minor) / (minor * minor);
    var A = 1 + uSquared * (4096 + uSquared * (uSquared * (320 - 175 * uSquared) - 768)) / 16384;
    var B = uSquared * (256 + uSquared * (uSquared * (74 - 47 * uSquared) - 128)) / 1024;
    var cosineSquaredTwiceSigmaMidpoint = cosineTwiceSigmaMidpoint * cosineTwiceSigmaMidpoint;
    var deltaSigma = B * sineSigma * (cosineTwiceSigmaMidpoint + B * (cosineSigma * (2 * cosineSquaredTwiceSigmaMidpoint - 1) - B * cosineTwiceSigmaMidpoint * (4 * sineSigma * sineSigma - 3) * (4 * cosineSquaredTwiceSigmaMidpoint - 3) / 6) / 4);
    var distance = minor * A * (sigma - deltaSigma);
    var startHeading = Math.atan2(cosineU2 * sineLambda, cs - sc * cosineLambda);
    var endHeading = Math.atan2(cosineU1 * sineLambda, cs * cosineLambda - sc);
    ellipsoidGeodesic._distance = distance;
    ellipsoidGeodesic._startHeading = startHeading;
    ellipsoidGeodesic._endHeading = endHeading;
    ellipsoidGeodesic._uSquared = uSquared;
}
function computeProperties(ellipsoidGeodesic, start, end, ellipsoid) {
    var firstCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(start, scratchCart2), scratchCart1);
    var lastCartesian = Cartesian3.normalize(ellipsoid.cartographicToCartesian(end, scratchCart2), scratchCart2);
    if (Math.abs(Math.abs(Cartesian3.angleBetween(firstCartesian, lastCartesian)) - Math.PI) < 0.0125) {
        throw new DeveloperError('geodesic position is not unique');
    }
    vincentyInverseFormula(ellipsoidGeodesic, ellipsoid.maximumRadius, ellipsoid.minimumRadius, start.longitude, start.latitude, end.longitude, end.latitude);
    ellipsoidGeodesic._start = Cartographic.clone(start, ellipsoidGeodesic._start);
    ellipsoidGeodesic._end = Cartographic.clone(end, ellipsoidGeodesic._end);
    ellipsoidGeodesic._start.height = 0;
    ellipsoidGeodesic._end.height = 0;
    setConstants(ellipsoidGeodesic);
}
var scratchCart1 = new Cartesian3();
var scratchCart2 = new Cartesian3();
var EllipsoidGeodesic = function (start, end, ellipsoid) {
    var e = defaultValue(ellipsoid, Ellipsoid.WGS84);
    this._ellipsoid = e;
    this._start = new Cartographic();
    this._end = new Cartographic();
    this._constants = {};
    this._startHeading = undefined;
    this._endHeading = undefined;
    this._distance = undefined;
    this._uSquared = undefined;
    if (defined(start) && defined(end)) {
        computeProperties(this, start, end, e);
    }
};
defineProperties(EllipsoidGeodesic.prototype, {
    surfaceDistance: {
        get: function () {
            if (!defined(this._distance)) {
                throw new DeveloperError('set end positions before getting surfaceDistance');
            }
            return this._distance;
        }
    },
    start: {
        get: function () {
            return this._start;
        }
    },
    end: {
        get: function () {
            return this._end;
        }
    },
    startHeading: {
        get: function () {
            if (!defined(this._distance)) {
                throw new DeveloperError('set end positions before getting startHeading');
            }
            return this._startHeading;
        }
    },
    endHeading: {
        get: function () {
            if (!defined(this._distance)) {
                throw new DeveloperError('set end positions before getting endHeading');
            }
            return this._endHeading;
        }
    }
});
EllipsoidGeodesic.prototype.setEndPoints = function (start, end) {
    if (!defined(start)) {
        throw new DeveloperError('start cartographic position is required');
    }
    if (!defined(end)) {
        throw new DeveloperError('end cartgraphic position is required');
    }
    computeProperties(this, start, end, this._ellipsoid);
};
EllipsoidGeodesic.prototype.interpolateUsingFraction = function (fraction, result) {
    return this.interpolateUsingSurfaceDistance(this._distance * fraction, result);
};
EllipsoidGeodesic.prototype.interpolateUsingSurfaceDistance = function (distance, result) {
    if (!defined(this._distance)) {
        throw new DeveloperError('start and end must be set before calling funciton interpolateUsingSurfaceDistance');
    }
    var constants = this._constants;
    var s = constants.distanceRatio + distance / constants.b;
    var cosine2S = Math.cos(2 * s);
    var cosine4S = Math.cos(4 * s);
    var cosine6S = Math.cos(6 * s);
    var sine2S = Math.sin(2 * s);
    var sine4S = Math.sin(4 * s);
    var sine6S = Math.sin(6 * s);
    var sine8S = Math.sin(8 * s);
    var s2 = s * s;
    var s3 = s * s2;
    var u8Over256 = constants.u8Over256;
    var u2Over4 = constants.u2Over4;
    var u6Over64 = constants.u6Over64;
    var u4Over16 = constants.u4Over16;
    var sigma = 2 * s3 * u8Over256 * cosine2S / 3 + s * (1 - u2Over4 + 7 * u4Over16 / 4 - 15 * u6Over64 / 4 + 579 * u8Over256 / 64 - (u4Over16 - 15 * u6Over64 / 4 + 187 * u8Over256 / 16) * cosine2S - (5 * u6Over64 / 4 - 115 * u8Over256 / 16) * cosine4S - 29 * u8Over256 * cosine6S / 16) + (u2Over4 / 2 - u4Over16 + 71 * u6Over64 / 32 - 85 * u8Over256 / 16) * sine2S + (5 * u4Over16 / 16 - 5 * u6Over64 / 4 + 383 * u8Over256 / 96) * sine4S - s2 * ((u6Over64 - 11 * u8Over256 / 2) * sine2S + 5 * u8Over256 * sine4S / 2) + (29 * u6Over64 / 96 - 29 * u8Over256 / 16) * sine6S + 539 * u8Over256 * sine8S / 1536;
    var theta = Math.asin(Math.sin(sigma) * constants.cosineAlpha);
    var latitude = Math.atan(constants.a / constants.b * Math.tan(theta));
    sigma = sigma - constants.sigma;
    var cosineTwiceSigmaMidpoint = Math.cos(2 * constants.sigma + sigma);
    var sineSigma = Math.sin(sigma);
    var cosineSigma = Math.cos(sigma);
    var cc = constants.cosineU * cosineSigma;
    var ss = constants.sineU * sineSigma;
    var lambda = Math.atan2(sineSigma * constants.sineHeading, cc - ss * constants.cosineHeading);
    var l = lambda - computeDeltaLambda(constants.f, constants.sineAlpha, constants.cosineSquaredAlpha, sigma, sineSigma, cosineSigma, cosineTwiceSigmaMidpoint);
    if (defined(result)) {
        result.longitude = this._start.longitude + l;
        result.latitude = latitude;
        result.height = 0;
        return result;
    }
    return new Cartographic(this._start.longitude + l, latitude, 0);
};
module.exports = EllipsoidGeodesic;
},{"./Cartesian3":102,"./Cartographic":104,"./DeveloperError":123,"./Ellipsoid":130,"./Math":174,"./defaultValue":243,"./defineProperties":244,"./defined":245}],132:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PrimitiveType = require('./PrimitiveType'), VertexFormat = require('./VertexFormat');
'use strict';
var scratchPosition = new Cartesian3();
var scratchNormal = new Cartesian3();
var scratchTangent = new Cartesian3();
var scratchBinormal = new Cartesian3();
var scratchNormalST = new Cartesian3();
var defaultRadii = new Cartesian3(1, 1, 1);
var cos = Math.cos;
var sin = Math.sin;
var EllipsoidGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var radii = defaultValue(options.radii, defaultRadii);
    var stackPartitions = defaultValue(options.stackPartitions, 64);
    var slicePartitions = defaultValue(options.slicePartitions, 64);
    var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
    if (slicePartitions < 3) {
        throw new DeveloperError('options.slicePartitions cannot be less than three.');
    }
    if (stackPartitions < 3) {
        throw new DeveloperError('options.stackPartitions cannot be less than three.');
    }
    this._radii = Cartesian3.clone(radii);
    this._stackPartitions = stackPartitions;
    this._slicePartitions = slicePartitions;
    this._vertexFormat = VertexFormat.clone(vertexFormat);
    this._workerName = 'createEllipsoidGeometry';
};
EllipsoidGeometry.packedLength = Cartesian3.packedLength + VertexFormat.packedLength + 2;
EllipsoidGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Cartesian3.pack(value._radii, array, startingIndex);
    startingIndex += Cartesian3.packedLength;
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex++] = value._stackPartitions;
    array[startingIndex] = value._slicePartitions;
};
var scratchRadii = new Cartesian3();
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        radii: scratchRadii,
        vertexFormat: scratchVertexFormat,
        stackPartitions: undefined,
        slicePartitions: undefined
    };
EllipsoidGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);
    startingIndex += Cartesian3.packedLength;
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var stackPartitions = array[startingIndex++];
    var slicePartitions = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.stackPartitions = stackPartitions;
        scratchOptions.slicePartitions = slicePartitions;
        return new EllipsoidGeometry(scratchOptions);
    }
    result._radii = Cartesian3.clone(radii, result._radii);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._stackPartitions = stackPartitions;
    result._slicePartitions = slicePartitions;
    return result;
};
EllipsoidGeometry.createGeometry = function (ellipsoidGeometry) {
    var radii = ellipsoidGeometry._radii;
    var ellipsoid = Ellipsoid.fromCartesian3(radii);
    var vertexFormat = ellipsoidGeometry._vertexFormat;
    var slicePartitions = ellipsoidGeometry._slicePartitions + 1;
    var stackPartitions = ellipsoidGeometry._stackPartitions + 1;
    var vertexCount = stackPartitions * slicePartitions;
    var positions = new Float64Array(vertexCount * 3);
    var numIndices = 6 * (slicePartitions - 1) * (stackPartitions - 1);
    var indices = IndexDatatype.createTypedArray(vertexCount, numIndices);
    var normals = vertexFormat.normal ? new Float32Array(vertexCount * 3) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(vertexCount * 3) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(vertexCount * 3) : undefined;
    var st = vertexFormat.st ? new Float32Array(vertexCount * 2) : undefined;
    var cosTheta = new Array(slicePartitions);
    var sinTheta = new Array(slicePartitions);
    var i;
    var j;
    var index = 0;
    for (i = 0; i < slicePartitions; i++) {
        var theta = CesiumMath.TWO_PI * i / (slicePartitions - 1);
        cosTheta[i] = cos(theta);
        sinTheta[i] = sin(theta);
        positions[index++] = 0;
        positions[index++] = 0;
        positions[index++] = radii.z;
    }
    for (i = 1; i < stackPartitions - 1; i++) {
        var phi = Math.PI * i / (stackPartitions - 1);
        var sinPhi = sin(phi);
        var xSinPhi = radii.x * sinPhi;
        var ySinPhi = radii.y * sinPhi;
        var zCosPhi = radii.z * cos(phi);
        for (j = 0; j < slicePartitions; j++) {
            positions[index++] = cosTheta[j] * xSinPhi;
            positions[index++] = sinTheta[j] * ySinPhi;
            positions[index++] = zCosPhi;
        }
    }
    for (i = 0; i < slicePartitions; i++) {
        positions[index++] = 0;
        positions[index++] = 0;
        positions[index++] = -radii.z;
    }
    var attributes = new GeometryAttributes();
    if (vertexFormat.position) {
        attributes.position = new GeometryAttribute({
            componentDatatype: ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
        });
    }
    var stIndex = 0;
    var normalIndex = 0;
    var tangentIndex = 0;
    var binormalIndex = 0;
    if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {
        for (i = 0; i < vertexCount; i++) {
            var position = Cartesian3.fromArray(positions, i * 3, scratchPosition);
            var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);
            if (vertexFormat.st) {
                var normalST = Cartesian2.negate(normal, scratchNormalST);
                if (Cartesian2.magnitude(normalST) < CesiumMath.EPSILON6) {
                    index = (i + slicePartitions * Math.floor(stackPartitions * 0.5)) * 3;
                    if (index > positions.length) {
                        index = (i - slicePartitions * Math.floor(stackPartitions * 0.5)) * 3;
                    }
                    Cartesian3.fromArray(positions, index, normalST);
                    ellipsoid.geodeticSurfaceNormal(normalST, normalST);
                    Cartesian2.negate(normalST, normalST);
                }
                st[stIndex++] = Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI + 0.5;
                st[stIndex++] = Math.asin(normal.z) / Math.PI + 0.5;
            }
            if (vertexFormat.normal) {
                normals[normalIndex++] = normal.x;
                normals[normalIndex++] = normal.y;
                normals[normalIndex++] = normal.z;
            }
            if (vertexFormat.tangent || vertexFormat.binormal) {
                var tangent = scratchTangent;
                if (i < slicePartitions || i > vertexCount - slicePartitions - 1) {
                    Cartesian3.cross(Cartesian3.UNIT_X, normal, tangent);
                    Cartesian3.normalize(tangent, tangent);
                } else {
                    Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);
                    Cartesian3.normalize(tangent, tangent);
                }
                if (vertexFormat.tangent) {
                    tangents[tangentIndex++] = tangent.x;
                    tangents[tangentIndex++] = tangent.y;
                    tangents[tangentIndex++] = tangent.z;
                }
                if (vertexFormat.binormal) {
                    var binormal = Cartesian3.cross(normal, tangent, scratchBinormal);
                    Cartesian3.normalize(binormal, binormal);
                    binormals[binormalIndex++] = binormal.x;
                    binormals[binormalIndex++] = binormal.y;
                    binormals[binormalIndex++] = binormal.z;
                }
            }
        }
        if (vertexFormat.st) {
            attributes.st = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 2,
                values: st
            });
        }
        if (vertexFormat.normal) {
            attributes.normal = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: normals
            });
        }
        if (vertexFormat.tangent) {
            attributes.tangent = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: tangents
            });
        }
        if (vertexFormat.binormal) {
            attributes.binormal = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: binormals
            });
        }
    }
    index = 0;
    for (i = 0; i < stackPartitions; i++) {
        var topOffset = i * slicePartitions;
        var bottomOffset = (i + 1) * slicePartitions;
        for (j = 0; j < slicePartitions - 1; j++) {
            indices[index++] = bottomOffset + j;
            indices[index++] = bottomOffset + j + 1;
            indices[index++] = topOffset + j + 1;
            indices[index++] = bottomOffset + j;
            indices[index++] = topOffset + j + 1;
            indices[index++] = topOffset + j;
        }
    }
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid)
    });
};
module.exports = EllipsoidGeometry;
},{"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PrimitiveType":193,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],133:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PrimitiveType = require('./PrimitiveType');
'use strict';
var defaultRadii = new Cartesian3(1, 1, 1);
var cos = Math.cos;
var sin = Math.sin;
var EllipsoidOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var radii = defaultValue(options.radii, defaultRadii);
    var stackPartitions = defaultValue(options.stackPartitions, 10);
    var slicePartitions = defaultValue(options.slicePartitions, 8);
    var subdivisions = defaultValue(options.subdivisions, 128);
    if (stackPartitions < 1) {
        throw new DeveloperError('options.stackPartitions cannot be less than 1');
    }
    if (slicePartitions < 0) {
        throw new DeveloperError('options.slicePartitions cannot be less than 0');
    }
    if (subdivisions < 0) {
        throw new DeveloperError('options.subdivisions must be greater than or equal to zero.');
    }
    this._radii = Cartesian3.clone(radii);
    this._stackPartitions = stackPartitions;
    this._slicePartitions = slicePartitions;
    this._subdivisions = subdivisions;
    this._workerName = 'createEllipsoidOutlineGeometry';
};
EllipsoidOutlineGeometry.packedLength = Cartesian3.packedLength + 3;
EllipsoidOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Cartesian3.pack(value._radii, array, startingIndex);
    startingIndex += Cartesian3.packedLength;
    array[startingIndex++] = value._stackPartitions;
    array[startingIndex++] = value._slicePartitions;
    array[startingIndex] = value._subdivisions;
};
var scratchRadii = new Cartesian3();
var scratchOptions = {
        radii: scratchRadii,
        stackPartitions: undefined,
        slicePartitions: undefined,
        subdivisions: undefined
    };
EllipsoidOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);
    startingIndex += Cartesian3.packedLength;
    var stackPartitions = array[startingIndex++];
    var slicePartitions = array[startingIndex++];
    var subdivisions = array[startingIndex++];
    if (!defined(result)) {
        scratchOptions.stackPartitions = stackPartitions;
        scratchOptions.slicePartitions = slicePartitions;
        scratchOptions.subdivisions = subdivisions;
        return new EllipsoidOutlineGeometry(scratchOptions);
    }
    result._radii = Cartesian3.clone(radii, result._radii);
    result._stackPartitions = stackPartitions;
    result._slicePartitions = slicePartitions;
    result._subdivisions = subdivisions;
    return result;
};
EllipsoidOutlineGeometry.createGeometry = function (ellipsoidGeometry) {
    var radii = ellipsoidGeometry._radii;
    var ellipsoid = Ellipsoid.fromCartesian3(radii);
    var stackPartitions = ellipsoidGeometry._stackPartitions;
    var slicePartitions = ellipsoidGeometry._slicePartitions;
    var subdivisions = ellipsoidGeometry._subdivisions;
    var indicesSize = subdivisions * (stackPartitions + slicePartitions - 1);
    var positionSize = indicesSize - slicePartitions + 2;
    var positions = new Float64Array(positionSize * 3);
    var indices = IndexDatatype.createTypedArray(positionSize, indicesSize * 2);
    var i;
    var j;
    var theta;
    var phi;
    var cosPhi;
    var sinPhi;
    var index = 0;
    var cosTheta = new Array(subdivisions);
    var sinTheta = new Array(subdivisions);
    for (i = 0; i < subdivisions; i++) {
        theta = CesiumMath.TWO_PI * i / subdivisions;
        cosTheta[i] = cos(theta);
        sinTheta[i] = sin(theta);
    }
    for (i = 1; i < stackPartitions; i++) {
        phi = Math.PI * i / stackPartitions;
        cosPhi = cos(phi);
        sinPhi = sin(phi);
        for (j = 0; j < subdivisions; j++) {
            positions[index++] = radii.x * cosTheta[j] * sinPhi;
            positions[index++] = radii.y * sinTheta[j] * sinPhi;
            positions[index++] = radii.z * cosPhi;
        }
    }
    cosTheta.length = slicePartitions;
    sinTheta.length = slicePartitions;
    for (i = 0; i < slicePartitions; i++) {
        theta = CesiumMath.TWO_PI * i / slicePartitions;
        cosTheta[i] = cos(theta);
        sinTheta[i] = sin(theta);
    }
    positions[index++] = 0;
    positions[index++] = 0;
    positions[index++] = radii.z;
    for (i = 1; i < subdivisions; i++) {
        phi = Math.PI * i / subdivisions;
        cosPhi = cos(phi);
        sinPhi = sin(phi);
        for (j = 0; j < slicePartitions; j++) {
            positions[index++] = radii.x * cosTheta[j] * sinPhi;
            positions[index++] = radii.y * sinTheta[j] * sinPhi;
            positions[index++] = radii.z * cosPhi;
        }
    }
    positions[index++] = 0;
    positions[index++] = 0;
    positions[index++] = -radii.z;
    index = 0;
    for (i = 0; i < stackPartitions - 1; ++i) {
        var topRowOffset = i * subdivisions;
        for (j = 0; j < subdivisions - 1; ++j) {
            indices[index++] = topRowOffset + j;
            indices[index++] = topRowOffset + j + 1;
        }
        indices[index++] = topRowOffset + subdivisions - 1;
        indices[index++] = topRowOffset;
    }
    var sliceOffset = subdivisions * (stackPartitions - 1);
    for (j = 1; j < slicePartitions + 1; ++j) {
        indices[index++] = sliceOffset;
        indices[index++] = sliceOffset + j;
    }
    for (i = 0; i < subdivisions - 2; ++i) {
        var topOffset = i * slicePartitions + 1 + sliceOffset;
        var bottomOffset = (i + 1) * slicePartitions + 1 + sliceOffset;
        for (j = 0; j < slicePartitions - 1; ++j) {
            indices[index++] = bottomOffset + j;
            indices[index++] = topOffset + j;
        }
        indices[index++] = bottomOffset + slicePartitions - 1;
        indices[index++] = topOffset + slicePartitions - 1;
    }
    var lastPosition = positions.length / 3 - 1;
    for (j = lastPosition - 1; j > lastPosition - slicePartitions - 1; --j) {
        indices[index++] = lastPosition;
        indices[index++] = j;
    }
    var attributes = new GeometryAttributes({
            position: new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: positions
            })
        });
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.LINES,
        boundingSphere: BoundingSphere.fromEllipsoid(ellipsoid)
    });
};
module.exports = EllipsoidOutlineGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PrimitiveType":193,"./defaultValue":243,"./defined":245}],134:[function(require,module,exports){
var AxisAlignedBoundingBox = require('./AxisAlignedBoundingBox'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), Cartesian4 = require('./Cartesian4'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), IntersectionTests = require('./IntersectionTests'), Matrix4 = require('./Matrix4'), Plane = require('./Plane'), Ray = require('./Ray'), Transforms = require('./Transforms');
'use strict';
var scratchCart4 = new Cartesian4();
var EllipsoidTangentPlane = function (origin, ellipsoid) {
    if (!defined(origin)) {
        throw new DeveloperError('origin is required.');
    }
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    origin = ellipsoid.scaleToGeodeticSurface(origin);
    if (!defined(origin)) {
        throw new DeveloperError('origin must not be at the center of the ellipsoid.');
    }
    var eastNorthUp = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid);
    this._ellipsoid = ellipsoid;
    this._origin = origin;
    this._xAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 0, scratchCart4));
    this._yAxis = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 1, scratchCart4));
    var normal = Cartesian3.fromCartesian4(Matrix4.getColumn(eastNorthUp, 2, scratchCart4));
    this._plane = Plane.fromPointNormal(origin, normal);
};
defineProperties(EllipsoidTangentPlane.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    },
    origin: {
        get: function () {
            return this._origin;
        }
    }
});
var tmp = new AxisAlignedBoundingBox();
EllipsoidTangentPlane.fromPoints = function (cartesians, ellipsoid) {
    if (!defined(cartesians)) {
        throw new DeveloperError('cartesians is required.');
    }
    var box = AxisAlignedBoundingBox.fromPoints(cartesians, tmp);
    return new EllipsoidTangentPlane(box.center, ellipsoid);
};
var projectPointOntoPlaneRay = new Ray();
var projectPointOntoPlaneCartesian3 = new Cartesian3();
EllipsoidTangentPlane.prototype.projectPointOntoPlane = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    var ray = projectPointOntoPlaneRay;
    ray.origin = cartesian;
    Cartesian3.normalize(cartesian, ray.direction);
    var intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, projectPointOntoPlaneCartesian3);
    if (!defined(intersectionPoint)) {
        Cartesian3.negate(ray.direction, ray.direction);
        intersectionPoint = IntersectionTests.rayPlane(ray, this._plane, projectPointOntoPlaneCartesian3);
    }
    if (defined(intersectionPoint)) {
        var v = Cartesian3.subtract(intersectionPoint, this._origin, intersectionPoint);
        var x = Cartesian3.dot(this._xAxis, v);
        var y = Cartesian3.dot(this._yAxis, v);
        if (!defined(result)) {
            return new Cartesian2(x, y);
        }
        result.x = x;
        result.y = y;
        return result;
    }
    return undefined;
};
EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function (cartesians, result) {
    if (!defined(cartesians)) {
        throw new DeveloperError('cartesians is required.');
    }
    if (!defined(result)) {
        result = [];
    }
    var count = 0;
    var length = cartesians.length;
    for (var i = 0; i < length; i++) {
        var p = this.projectPointOntoPlane(cartesians[i], result[count]);
        if (defined(p)) {
            result[count] = p;
            count++;
        }
    }
    result.length = count;
    return result;
};
var projectPointsOntoEllipsoidScratch = new Cartesian3();
EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function (cartesians, result) {
    if (!defined(cartesians)) {
        throw new DeveloperError('cartesians is required.');
    }
    var length = cartesians.length;
    if (!defined(result)) {
        result = new Array(length);
    } else {
        result.length = length;
    }
    var ellipsoid = this._ellipsoid;
    var origin = this._origin;
    var xAxis = this._xAxis;
    var yAxis = this._yAxis;
    var tmp = projectPointsOntoEllipsoidScratch;
    for (var i = 0; i < length; ++i) {
        var position = cartesians[i];
        Cartesian3.multiplyByScalar(xAxis, position.x, tmp);
        if (!defined(result[i])) {
            result[i] = new Cartesian3();
        }
        var point = Cartesian3.add(origin, tmp, result[i]);
        Cartesian3.multiplyByScalar(yAxis, position.y, tmp);
        Cartesian3.add(point, tmp, point);
        ellipsoid.scaleToGeocentricSurface(point, point);
    }
    return result;
};
module.exports = EllipsoidTangentPlane;
},{"./AxisAlignedBoundingBox":95,"./Cartesian2":101,"./Cartesian3":102,"./Cartesian4":103,"./DeveloperError":123,"./Ellipsoid":130,"./IntersectionTests":164,"./Matrix4":177,"./Plane":182,"./Ray":200,"./Transforms":226,"./defaultValue":243,"./defineProperties":244,"./defined":245}],135:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), Ellipsoid = require('./Ellipsoid'), Event = require('./Event'), GeographicTilingScheme = require('./GeographicTilingScheme'), HeightmapTerrainData = require('./HeightmapTerrainData'), TerrainProvider = require('./TerrainProvider');
'use strict';
var EllipsoidTerrainProvider = function EllipsoidTerrainProvider(options) {
    options = defaultValue(options, {});
    this._tilingScheme = options.tilingScheme;
    if (!defined(this._tilingScheme)) {
        this._tilingScheme = new GeographicTilingScheme({ ellipsoid: defaultValue(options.ellipsoid, Ellipsoid.WGS84) });
    }
    this._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid, 64, this._tilingScheme.getNumberOfXTilesAtLevel(0));
    var width = 16;
    var height = 16;
    this._terrainData = new HeightmapTerrainData({
        buffer: new Uint8Array(width * height),
        width: 16,
        height: 16
    });
    this._errorEvent = new Event();
};
defineProperties(EllipsoidTerrainProvider.prototype, {
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    credit: {
        get: function () {
            return undefined;
        }
    },
    tilingScheme: {
        get: function () {
            return this._tilingScheme;
        }
    },
    ready: {
        get: function () {
            return true;
        }
    },
    hasWaterMask: {
        get: function () {
            return false;
        }
    },
    hasVertexNormals: {
        get: function () {
            return false;
        }
    }
});
EllipsoidTerrainProvider.prototype.requestTileGeometry = function (x, y, level, throttleRequests) {
    return this._terrainData;
};
EllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {
    return this._levelZeroMaximumGeometricError / (1 << level);
};
EllipsoidTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {
    return undefined;
};
module.exports = EllipsoidTerrainProvider;
},{"./Ellipsoid":130,"./Event":138,"./GeographicTilingScheme":144,"./HeightmapTerrainData":153,"./TerrainProvider":219,"./defaultValue":243,"./defineProperties":244,"./defined":245}],136:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Rectangle = require('./Rectangle');
'use strict';
var EllipsoidalOccluder = function (ellipsoid, cameraPosition) {
    if (!defined(ellipsoid)) {
        throw new DeveloperError('ellipsoid is required.');
    }
    this._ellipsoid = ellipsoid;
    this._cameraPosition = new Cartesian3();
    this._cameraPositionInScaledSpace = new Cartesian3();
    this._distanceToLimbInScaledSpaceSquared = 0;
    if (defined(cameraPosition)) {
        this.cameraPosition = cameraPosition;
    }
};
defineProperties(EllipsoidalOccluder.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    },
    cameraPosition: {
        get: function () {
            return this._cameraPosition;
        },
        set: function (cameraPosition) {
            var ellipsoid = this._ellipsoid;
            var cv = ellipsoid.transformPositionToScaledSpace(cameraPosition, this._cameraPositionInScaledSpace);
            var vhMagnitudeSquared = Cartesian3.magnitudeSquared(cv) - 1;
            Cartesian3.clone(cameraPosition, this._cameraPosition);
            this._cameraPositionInScaledSpace = cv;
            this._distanceToLimbInScaledSpaceSquared = vhMagnitudeSquared;
        }
    }
});
var scratchCartesian = new Cartesian3();
EllipsoidalOccluder.prototype.isPointVisible = function (occludee) {
    var ellipsoid = this._ellipsoid;
    var occludeeScaledSpacePosition = ellipsoid.transformPositionToScaledSpace(occludee, scratchCartesian);
    return this.isScaledSpacePointVisible(occludeeScaledSpacePosition);
};
EllipsoidalOccluder.prototype.isScaledSpacePointVisible = function (occludeeScaledSpacePosition) {
    var cv = this._cameraPositionInScaledSpace;
    var vhMagnitudeSquared = this._distanceToLimbInScaledSpaceSquared;
    var vt = Cartesian3.subtract(occludeeScaledSpacePosition, cv, scratchCartesian);
    var vtDotVc = -Cartesian3.dot(vt, cv);
    var isOccluded = vtDotVc > vhMagnitudeSquared && vtDotVc * vtDotVc / Cartesian3.magnitudeSquared(vt) > vhMagnitudeSquared;
    return !isOccluded;
};
EllipsoidalOccluder.prototype.computeHorizonCullingPoint = function (directionToPoint, positions, result) {
    if (!defined(directionToPoint)) {
        throw new DeveloperError('directionToPoint is required');
    }
    if (!defined(positions)) {
        throw new DeveloperError('positions is required');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    var ellipsoid = this._ellipsoid;
    var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);
    var resultMagnitude = 0;
    for (var i = 0, len = positions.length; i < len; ++i) {
        var position = positions[i];
        var candidateMagnitude = computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint);
        resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);
    }
    return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);
};
var positionScratch = new Cartesian3();
EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices = function (directionToPoint, vertices, stride, center, result) {
    if (!defined(directionToPoint)) {
        throw new DeveloperError('directionToPoint is required');
    }
    if (!defined(vertices)) {
        throw new DeveloperError('vertices is required');
    }
    if (!defined(stride)) {
        throw new DeveloperError('stride is required');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    center = defaultValue(center, Cartesian3.ZERO);
    var ellipsoid = this._ellipsoid;
    var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint);
    var resultMagnitude = 0;
    for (var i = 0, len = vertices.length; i < len; i += stride) {
        positionScratch.x = vertices[i] + center.x;
        positionScratch.y = vertices[i + 1] + center.y;
        positionScratch.z = vertices[i + 2] + center.z;
        var candidateMagnitude = computeMagnitude(ellipsoid, positionScratch, scaledSpaceDirectionToPoint);
        resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);
    }
    return magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);
};
var subsampleScratch = [];
EllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle = function (rectangle, ellipsoid, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    var positions = Rectangle.subsample(rectangle, ellipsoid, 0, subsampleScratch);
    var bs = BoundingSphere.fromPoints(positions);
    if (Cartesian3.magnitude(bs.center) < 0.1 * ellipsoid.minimumRadius) {
        return undefined;
    }
    return this.computeHorizonCullingPoint(bs.center, positions, result);
};
var scaledSpaceScratch = new Cartesian3();
var directionScratch = new Cartesian3();
function computeMagnitude(ellipsoid, position, scaledSpaceDirectionToPoint) {
    var scaledSpacePosition = ellipsoid.transformPositionToScaledSpace(position, scaledSpaceScratch);
    var magnitudeSquared = Cartesian3.magnitudeSquared(scaledSpacePosition);
    var magnitude = Math.sqrt(magnitudeSquared);
    var direction = Cartesian3.divideByScalar(scaledSpacePosition, magnitude, directionScratch);
    magnitudeSquared = Math.max(1, magnitudeSquared);
    magnitude = Math.max(1, magnitude);
    var cosAlpha = Cartesian3.dot(direction, scaledSpaceDirectionToPoint);
    var sinAlpha = Cartesian3.magnitude(Cartesian3.cross(direction, scaledSpaceDirectionToPoint, direction));
    var cosBeta = 1 / magnitude;
    var sinBeta = Math.sqrt(magnitudeSquared - 1) * cosBeta;
    return 1 / (cosAlpha * cosBeta - sinAlpha * sinBeta);
}
function magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result) {
    if (resultMagnitude <= 0 || resultMagnitude === 1 / 0 || resultMagnitude !== resultMagnitude) {
        return undefined;
    }
    return Cartesian3.multiplyByScalar(scaledSpaceDirectionToPoint, resultMagnitude, result);
}
var directionToPointScratch = new Cartesian3();
function computeScaledSpaceDirectionToPoint(ellipsoid, directionToPoint) {
    ellipsoid.transformPositionToScaledSpace(directionToPoint, directionToPointScratch);
    return Cartesian3.normalize(directionToPointScratch, directionToPointScratch);
}
module.exports = EllipsoidalOccluder;
},{"./BoundingSphere":98,"./Cartesian3":102,"./DeveloperError":123,"./Rectangle":201,"./defaultValue":243,"./defineProperties":244,"./defined":245}],137:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var EncodedCartesian3 = function () {
    this.high = Cartesian3.clone(Cartesian3.ZERO);
    this.low = Cartesian3.clone(Cartesian3.ZERO);
};
EncodedCartesian3.encode = function (value, result) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(result)) {
        result = {
            high: 0,
            low: 0
        };
    }
    var doubleHigh;
    if (value >= 0) {
        doubleHigh = Math.floor(value / 65536) * 65536;
        result.high = doubleHigh;
        result.low = value - doubleHigh;
    } else {
        doubleHigh = Math.floor(-value / 65536) * 65536;
        result.high = -doubleHigh;
        result.low = value + doubleHigh;
    }
    return result;
};
var scratchEncode = {
        high: 0,
        low: 0
    };
EncodedCartesian3.fromCartesian = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        result = new EncodedCartesian3();
    }
    var high = result.high;
    var low = result.low;
    EncodedCartesian3.encode(cartesian.x, scratchEncode);
    high.x = scratchEncode.high;
    low.x = scratchEncode.low;
    EncodedCartesian3.encode(cartesian.y, scratchEncode);
    high.y = scratchEncode.high;
    low.y = scratchEncode.low;
    EncodedCartesian3.encode(cartesian.z, scratchEncode);
    high.z = scratchEncode.high;
    low.z = scratchEncode.low;
    return result;
};
var encodedP = new EncodedCartesian3();
EncodedCartesian3.writeElements = function (cartesian, cartesianArray, index) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(cartesianArray)) {
        throw new DeveloperError('cartesianArray is required');
    }
    if (typeof index !== 'number' || index < 0) {
        throw new DeveloperError('index must be a number greater than or equal to 0.');
    }
    EncodedCartesian3.fromCartesian(cartesian, encodedP);
    var high = encodedP.high;
    var low = encodedP.low;
    cartesianArray[index] = high.x;
    cartesianArray[index + 1] = high.y;
    cartesianArray[index + 2] = high.z;
    cartesianArray[index + 3] = low.x;
    cartesianArray[index + 4] = low.y;
    cartesianArray[index + 5] = low.z;
};
module.exports = EncodedCartesian3;
},{"./Cartesian3":102,"./DeveloperError":123,"./defined":245}],138:[function(require,module,exports){
var defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError');
'use strict';
var Event = function () {
    this._listeners = [];
    this._scopes = [];
    this._toRemove = [];
    this._insideRaiseEvent = false;
};
defineProperties(Event.prototype, {
    numberOfListeners: {
        get: function () {
            return this._listeners.length - this._toRemove.length;
        }
    }
});
Event.prototype.addEventListener = function (listener, scope) {
    if (typeof listener !== 'function') {
        throw new DeveloperError('listener is required and must be a function.');
    }
    this._listeners.push(listener);
    this._scopes.push(scope);
    var event = this;
    return function () {
        event.removeEventListener(listener, scope);
    };
};
Event.prototype.removeEventListener = function (listener, scope) {
    if (typeof listener !== 'function') {
        throw new DeveloperError('listener is required and must be a function.');
    }
    var listeners = this._listeners;
    var scopes = this._scopes;
    var index = -1;
    for (var i = 0; i < listeners.length; i++) {
        if (listeners[i] === listener && scopes[i] === scope) {
            index = i;
            break;
        }
    }
    if (index !== -1) {
        if (this._insideRaiseEvent) {
            this._toRemove.push(index);
            listeners[index] = undefined;
            scopes[index] = undefined;
        } else {
            listeners.splice(index, 1);
            scopes.splice(index, 1);
        }
        return true;
    }
    return false;
};
Event.prototype.raiseEvent = function () {
    this._insideRaiseEvent = true;
    var i;
    var listeners = this._listeners;
    var scopes = this._scopes;
    var length = listeners.length;
    for (i = 0; i < length; i++) {
        var listener = listeners[i];
        if (defined(listener)) {
            listeners[i].apply(scopes[i], arguments);
        }
    }
    var toRemove = this._toRemove;
    length = toRemove.length;
    for (i = 0; i < length; i++) {
        var index = toRemove[i];
        listeners.splice(index, 1);
        scopes.splice(index, 1);
    }
    toRemove.length = 0;
    this._insideRaiseEvent = false;
};
module.exports = Event;
},{"./DeveloperError":123,"./defineProperties":244,"./defined":245}],139:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var EventHelper = function () {
    this._removalFunctions = [];
};
EventHelper.prototype.add = function (event, listener, scope) {
    if (!defined(event)) {
        throw new DeveloperError('event is required');
    }
    var removalFunction = event.addEventListener(listener, scope);
    this._removalFunctions.push(removalFunction);
    var that = this;
    return function () {
        removalFunction();
        var removalFunctions = that._removalFunctions;
        removalFunctions.splice(removalFunctions.indexOf(removalFunction), 1);
    };
};
EventHelper.prototype.removeAll = function () {
    var removalFunctions = this._removalFunctions;
    for (var i = 0, len = removalFunctions.length; i < len; ++i) {
        removalFunctions[i]();
    }
    removalFunctions.length = 0;
};
module.exports = EventHelper;
},{"./DeveloperError":123,"./defined":245}],140:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var ExtrapolationType = {
        NONE: 0,
        HOLD: 1,
        EXTRAPOLATE: 2
    };
module.exports = freezeObject(ExtrapolationType);
},{"./freezeObject":249}],141:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), Fullscreen = require('./Fullscreen');
'use strict';
function extractVersion(versionString) {
    var parts = versionString.split('.');
    for (var i = 0, len = parts.length; i < len; ++i) {
        parts[i] = parseInt(parts[i], 10);
    }
    return parts;
}
var isChromeResult;
var chromeVersionResult;
function isChrome() {
    if (!defined(isChromeResult)) {
        isChromeResult = false;
        var fields = / Chrome\/([\.0-9]+)/.exec(navigator.userAgent);
        if (fields !== null) {
            isChromeResult = true;
            chromeVersionResult = extractVersion(fields[1]);
        }
    }
    return isChromeResult;
}
function chromeVersion() {
    return isChrome() && chromeVersionResult;
}
var isSafariResult;
var safariVersionResult;
function isSafari() {
    if (!defined(isSafariResult)) {
        isSafariResult = false;
        if (!isChrome() && / Safari\/[\.0-9]+/.test(navigator.userAgent)) {
            var fields = / Version\/([\.0-9]+)/.exec(navigator.userAgent);
            if (fields !== null) {
                isSafariResult = true;
                safariVersionResult = extractVersion(fields[1]);
            }
        }
    }
    return isSafariResult;
}
function safariVersion() {
    return isSafari() && safariVersionResult;
}
var isWebkitResult;
var webkitVersionResult;
function isWebkit() {
    if (!defined(isWebkitResult)) {
        isWebkitResult = false;
        var fields = / AppleWebKit\/([\.0-9]+)(\+?)/.exec(navigator.userAgent);
        if (fields !== null) {
            isWebkitResult = true;
            webkitVersionResult = extractVersion(fields[1]);
            webkitVersionResult.isNightly = !!fields[2];
        }
    }
    return isWebkitResult;
}
function webkitVersion() {
    return isWebkit() && webkitVersionResult;
}
var isInternetExplorerResult;
var internetExplorerVersionResult;
function isInternetExplorer() {
    if (!defined(isInternetExplorerResult)) {
        isInternetExplorerResult = false;
        var fields;
        if (navigator.appName === 'Microsoft Internet Explorer') {
            fields = /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent);
            if (fields !== null) {
                isInternetExplorerResult = true;
                internetExplorerVersionResult = extractVersion(fields[1]);
            }
        } else if (navigator.appName === 'Netscape') {
            fields = /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent);
            if (fields !== null) {
                isInternetExplorerResult = true;
                internetExplorerVersionResult = extractVersion(fields[1]);
            }
        }
    }
    return isInternetExplorerResult;
}
function internetExplorerVersion() {
    return isInternetExplorer() && internetExplorerVersionResult;
}
var isFirefoxResult;
var firefoxVersionResult;
function isFirefox() {
    if (!defined(isFirefoxResult)) {
        isFirefoxResult = false;
        var fields = /Firefox\/([\.0-9]+)/.exec(navigator.userAgent);
        if (fields !== null) {
            isFirefoxResult = true;
            firefoxVersionResult = extractVersion(fields[1]);
        }
    }
    return isFirefoxResult;
}
function firefoxVersion() {
    return isFirefox() && firefoxVersionResult;
}
var FeatureDetection = {
        isChrome: isChrome,
        chromeVersion: chromeVersion,
        isSafari: isSafari,
        safariVersion: safariVersion,
        isWebkit: isWebkit,
        webkitVersion: webkitVersion,
        isInternetExplorer: isInternetExplorer,
        internetExplorerVersion: internetExplorerVersion,
        isFirefox: isFirefox,
        firefoxVersion: firefoxVersion,
        hardwareConcurrency: defaultValue(navigator.hardwareConcurrency, 3)
    };
FeatureDetection.supportsFullscreen = function () {
    return Fullscreen.supportsFullscreen();
};
FeatureDetection.supportsTypedArrays = function () {
    return typeof ArrayBuffer !== 'undefined';
};
FeatureDetection.supportsWebWorkers = function () {
    return typeof Worker !== 'undefined';
};
module.exports = FeatureDetection;
},{"./Fullscreen":142,"./defaultValue":243,"./defined":245}],142:[function(require,module,exports){
var defined = require('./defined'), defineProperties = require('./defineProperties');
'use strict';
var _supportsFullscreen;
var _names = {
        requestFullscreen: undefined,
        exitFullscreen: undefined,
        fullscreenEnabled: undefined,
        fullscreenElement: undefined,
        fullscreenchange: undefined,
        fullscreenerror: undefined
    };
var Fullscreen = {};
defineProperties(Fullscreen, {
    element: {
        get: function () {
            if (!Fullscreen.supportsFullscreen()) {
                return undefined;
            }
            return document[_names.fullscreenElement];
        }
    },
    changeEventName: {
        get: function () {
            if (!Fullscreen.supportsFullscreen()) {
                return undefined;
            }
            return _names.fullscreenchange;
        }
    },
    errorEventName: {
        get: function () {
            if (!Fullscreen.supportsFullscreen()) {
                return undefined;
            }
            return _names.fullscreenerror;
        }
    },
    enabled: {
        get: function () {
            if (!Fullscreen.supportsFullscreen()) {
                return undefined;
            }
            return document[_names.fullscreenEnabled];
        }
    },
    fullscreen: {
        get: function () {
            if (!Fullscreen.supportsFullscreen()) {
                return undefined;
            }
            return Fullscreen.element !== null;
        }
    }
});
Fullscreen.supportsFullscreen = function () {
    if (defined(_supportsFullscreen)) {
        return _supportsFullscreen;
    }
    _supportsFullscreen = false;
    var body = document.body;
    if (typeof body.requestFullscreen === 'function') {
        _names.requestFullscreen = 'requestFullscreen';
        _names.exitFullscreen = 'exitFullscreen';
        _names.fullscreenEnabled = 'fullscreenEnabled';
        _names.fullscreenElement = 'fullscreenElement';
        _names.fullscreenchange = 'fullscreenchange';
        _names.fullscreenerror = 'fullscreenerror';
        _supportsFullscreen = true;
        return _supportsFullscreen;
    }
    var prefixes = [
            'webkit',
            'moz',
            'o',
            'ms',
            'khtml'
        ];
    var name;
    for (var i = 0, len = prefixes.length; i < len; ++i) {
        var prefix = prefixes[i];
        name = prefix + 'RequestFullscreen';
        if (typeof body[name] === 'function') {
            _names.requestFullscreen = name;
            _supportsFullscreen = true;
        } else {
            name = prefix + 'RequestFullScreen';
            if (typeof body[name] === 'function') {
                _names.requestFullscreen = name;
                _supportsFullscreen = true;
            }
        }
        name = prefix + 'ExitFullscreen';
        if (typeof document[name] === 'function') {
            _names.exitFullscreen = name;
        } else {
            name = prefix + 'CancelFullScreen';
            if (typeof document[name] === 'function') {
                _names.exitFullscreen = name;
            }
        }
        name = prefix + 'FullscreenEnabled';
        if (defined(document[name])) {
            _names.fullscreenEnabled = name;
        } else {
            name = prefix + 'FullScreenEnabled';
            if (defined(document[name])) {
                _names.fullscreenEnabled = name;
            }
        }
        name = prefix + 'FullscreenElement';
        if (defined(document[name])) {
            _names.fullscreenElement = name;
        } else {
            name = prefix + 'FullScreenElement';
            if (defined(document[name])) {
                _names.fullscreenElement = name;
            }
        }
        name = prefix + 'fullscreenchange';
        if (defined(document['on' + name])) {
            if (prefix === 'ms') {
                name = 'MSFullscreenChange';
            }
            _names.fullscreenchange = name;
        }
        name = prefix + 'fullscreenerror';
        if (defined(document['on' + name])) {
            if (prefix === 'ms') {
                name = 'MSFullscreenError';
            }
            _names.fullscreenerror = name;
        }
    }
    return _supportsFullscreen;
};
Fullscreen.requestFullscreen = function (element) {
    if (!Fullscreen.supportsFullscreen()) {
        return;
    }
    element[_names.requestFullscreen]();
};
Fullscreen.exitFullscreen = function () {
    if (!Fullscreen.supportsFullscreen()) {
        return;
    }
    document[_names.exitFullscreen]();
};
module.exports = Fullscreen;
},{"./defineProperties":244,"./defined":245}],143:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid');
'use strict';
var GeographicProjection = function (ellipsoid) {
    this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    this._semimajorAxis = this._ellipsoid.maximumRadius;
    this._oneOverSemimajorAxis = 1 / this._semimajorAxis;
};
defineProperties(GeographicProjection.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    }
});
GeographicProjection.prototype.project = function (cartographic, result) {
    var semimajorAxis = this._semimajorAxis;
    var x = cartographic.longitude * semimajorAxis;
    var y = cartographic.latitude * semimajorAxis;
    var z = cartographic.height;
    if (!defined(result)) {
        return new Cartesian3(x, y, z);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
GeographicProjection.prototype.unproject = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
    var longitude = cartesian.x * oneOverEarthSemimajorAxis;
    var latitude = cartesian.y * oneOverEarthSemimajorAxis;
    var height = cartesian.z;
    if (!defined(result)) {
        return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
};
module.exports = GeographicProjection;
},{"./Cartesian3":102,"./Cartographic":104,"./DeveloperError":123,"./Ellipsoid":130,"./defaultValue":243,"./defineProperties":244,"./defined":245}],144:[function(require,module,exports){
var Cartesian2 = require('./Cartesian2'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), GeographicProjection = require('./GeographicProjection'), CesiumMath = require('./Math'), Rectangle = require('./Rectangle');
'use strict';
var GeographicTilingScheme = function GeographicTilingScheme(options) {
    options = defaultValue(options, {});
    this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);
    this._projection = new GeographicProjection(this._ellipsoid);
    this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 2);
    this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);
};
defineProperties(GeographicTilingScheme.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    },
    rectangle: {
        get: function () {
            return this._rectangle;
        }
    },
    projection: {
        get: function () {
            return this._projection;
        }
    }
});
GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {
    return this._numberOfLevelZeroTilesX << level;
};
GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {
    return this._numberOfLevelZeroTilesY << level;
};
GeographicTilingScheme.prototype.rectangleToNativeRectangle = function (rectangle, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    var west = CesiumMath.toDegrees(rectangle.west);
    var south = CesiumMath.toDegrees(rectangle.south);
    var east = CesiumMath.toDegrees(rectangle.east);
    var north = CesiumMath.toDegrees(rectangle.north);
    if (!defined(result)) {
        return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
};
GeographicTilingScheme.prototype.tileXYToNativeRectangle = function (x, y, level, result) {
    var rectangleRadians = this.tileXYToRectangle(x, y, level, result);
    rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);
    rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);
    rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);
    rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);
    return rectangleRadians;
};
GeographicTilingScheme.prototype.tileXYToRectangle = function (x, y, level, result) {
    var rectangle = this._rectangle;
    var xTiles = this.getNumberOfXTilesAtLevel(level);
    var yTiles = this.getNumberOfYTilesAtLevel(level);
    var xTileWidth = rectangle.width / xTiles;
    var west = x * xTileWidth + rectangle.west;
    var east = (x + 1) * xTileWidth + rectangle.west;
    var yTileHeight = rectangle.height / yTiles;
    var north = rectangle.north - y * yTileHeight;
    var south = rectangle.north - (y + 1) * yTileHeight;
    if (!defined(result)) {
        result = new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
};
GeographicTilingScheme.prototype.positionToTileXY = function (position, level, result) {
    var rectangle = this._rectangle;
    if (!Rectangle.contains(rectangle, position)) {
        return undefined;
    }
    var xTiles = this.getNumberOfXTilesAtLevel(level);
    var yTiles = this.getNumberOfYTilesAtLevel(level);
    var xTileWidth = rectangle.width / xTiles;
    var yTileHeight = rectangle.height / yTiles;
    var longitude = position.longitude;
    if (rectangle.east < rectangle.west) {
        longitude += CesiumMath.TWO_PI;
    }
    var xTileCoordinate = (longitude - rectangle.west) / xTileWidth | 0;
    if (xTileCoordinate >= xTiles) {
        xTileCoordinate = xTiles - 1;
    }
    var yTileCoordinate = (rectangle.north - position.latitude) / yTileHeight | 0;
    if (yTileCoordinate >= yTiles) {
        yTileCoordinate = yTiles - 1;
    }
    if (!defined(result)) {
        return new Cartesian2(xTileCoordinate, yTileCoordinate);
    }
    result.x = xTileCoordinate;
    result.y = yTileCoordinate;
    return result;
};
module.exports = GeographicTilingScheme;
},{"./Cartesian2":101,"./DeveloperError":123,"./Ellipsoid":130,"./GeographicProjection":143,"./Math":174,"./Rectangle":201,"./defaultValue":243,"./defineProperties":244,"./defined":245}],145:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), GeometryType = require('./GeometryType'), PrimitiveType = require('./PrimitiveType');
'use strict';
var Geometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.attributes)) {
        throw new DeveloperError('options.attributes is required.');
    }
    this.attributes = options.attributes;
    this.indices = options.indices;
    this.primitiveType = defaultValue(options.primitiveType, PrimitiveType.TRIANGLES);
    this.boundingSphere = options.boundingSphere;
    this.geometryType = defaultValue(options.geometryType, GeometryType.NONE);
    this.boundingSphereCV = undefined;
};
Geometry.computeNumberOfVertices = function (geometry) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    var numberOfVertices = -1;
    for (var property in geometry.attributes) {
        if (geometry.attributes.hasOwnProperty(property) && defined(geometry.attributes[property]) && defined(geometry.attributes[property].values)) {
            var attribute = geometry.attributes[property];
            var num = attribute.values.length / attribute.componentsPerAttribute;
            if (numberOfVertices !== num && numberOfVertices !== -1) {
                throw new DeveloperError('All attribute lists must have the same number of attributes.');
            }
            numberOfVertices = num;
        }
    }
    return numberOfVertices;
};
module.exports = Geometry;
},{"./DeveloperError":123,"./GeometryType":151,"./PrimitiveType":193,"./defaultValue":243,"./defined":245}],146:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var GeometryAttribute = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.componentDatatype)) {
        throw new DeveloperError('options.componentDatatype is required.');
    }
    if (!defined(options.componentsPerAttribute)) {
        throw new DeveloperError('options.componentsPerAttribute is required.');
    }
    if (options.componentsPerAttribute < 1 || options.componentsPerAttribute > 4) {
        throw new DeveloperError('options.componentsPerAttribute must be between 1 and 4.');
    }
    if (!defined(options.values)) {
        throw new DeveloperError('options.values is required.');
    }
    this.componentDatatype = options.componentDatatype;
    this.componentsPerAttribute = options.componentsPerAttribute;
    this.normalize = defaultValue(options.normalize, false);
    this.values = options.values;
};
module.exports = GeometryAttribute;
},{"./DeveloperError":123,"./defaultValue":243,"./defined":245}],147:[function(require,module,exports){
var defaultValue = require('./defaultValue');
'use strict';
var GeometryAttributes = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.position = options.position;
    this.normal = options.normal;
    this.st = options.st;
    this.binormal = options.binormal;
    this.tangent = options.tangent;
    this.color = options.color;
};
module.exports = GeometryAttributes;
},{"./defaultValue":243}],148:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Matrix4 = require('./Matrix4');
'use strict';
var GeometryInstance = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.geometry)) {
        throw new DeveloperError('options.geometry is required.');
    }
    this.geometry = options.geometry;
    this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));
    this.id = options.id;
    this.pickPrimitive = options.pickPrimitive;
    this.attributes = defaultValue(options.attributes, {});
    this.westHemisphereGeometry = undefined;
    this.eastHemisphereGeometry = undefined;
};
module.exports = GeometryInstance;
},{"./DeveloperError":123,"./Matrix4":177,"./defaultValue":243,"./defined":245}],149:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var GeometryInstanceAttribute = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.componentDatatype)) {
        throw new DeveloperError('options.componentDatatype is required.');
    }
    if (!defined(options.componentsPerAttribute)) {
        throw new DeveloperError('options.componentsPerAttribute is required.');
    }
    if (options.componentsPerAttribute < 1 || options.componentsPerAttribute > 4) {
        throw new DeveloperError('options.componentsPerAttribute must be between 1 and 4.');
    }
    if (!defined(options.value)) {
        throw new DeveloperError('options.value is required.');
    }
    this.componentDatatype = options.componentDatatype;
    this.componentsPerAttribute = options.componentsPerAttribute;
    this.normalize = defaultValue(options.normalize, false);
    this.value = options.value;
};
module.exports = GeometryInstanceAttribute;
},{"./DeveloperError":123,"./defaultValue":243,"./defined":245}],150:[function(require,module,exports){
var AttributeCompression = require('./AttributeCompression'), barycentricCoordinates = require('./barycentricCoordinates'), BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), Cartesian4 = require('./Cartesian4'), Cartographic = require('./Cartographic'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EncodedCartesian3 = require('./EncodedCartesian3'), GeographicProjection = require('./GeographicProjection'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryInstance = require('./GeometryInstance'), GeometryType = require('./GeometryType'), IndexDatatype = require('./IndexDatatype'), Intersect = require('./Intersect'), IntersectionTests = require('./IntersectionTests'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), Matrix4 = require('./Matrix4'), Plane = require('./Plane'), PrimitiveType = require('./PrimitiveType'), Tipsify = require('./Tipsify');
'use strict';
var GeometryPipeline = {};
function addTriangle(lines, index, i0, i1, i2) {
    lines[index++] = i0;
    lines[index++] = i1;
    lines[index++] = i1;
    lines[index++] = i2;
    lines[index++] = i2;
    lines[index] = i0;
}
function trianglesToLines(triangles) {
    var count = triangles.length;
    var size = count / 3 * 6;
    var lines = IndexDatatype.createTypedArray(count, size);
    var index = 0;
    for (var i = 0; i < count; i += 3, index += 6) {
        addTriangle(lines, index, triangles[i], triangles[i + 1], triangles[i + 2]);
    }
    return lines;
}
function triangleStripToLines(triangles) {
    var count = triangles.length;
    if (count >= 3) {
        var size = (count - 2) * 6;
        var lines = IndexDatatype.createTypedArray(count, size);
        addTriangle(lines, 0, triangles[0], triangles[1], triangles[2]);
        var index = 6;
        for (var i = 3; i < count; ++i, index += 6) {
            addTriangle(lines, index, triangles[i - 1], triangles[i], triangles[i - 2]);
        }
        return lines;
    }
    return new Uint16Array();
}
function triangleFanToLines(triangles) {
    if (triangles.length > 0) {
        var count = triangles.length - 1;
        var size = (count - 1) * 6;
        var lines = IndexDatatype.createTypedArray(count, size);
        var base = triangles[0];
        var index = 0;
        for (var i = 1; i < count; ++i, index += 6) {
            addTriangle(lines, index, base, triangles[i], triangles[i + 1]);
        }
        return lines;
    }
    return new Uint16Array();
}
GeometryPipeline.toWireframe = function (geometry) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    var indices = geometry.indices;
    if (defined(indices)) {
        switch (geometry.primitiveType) {
        case PrimitiveType.TRIANGLES:
            geometry.indices = trianglesToLines(indices);
            break;
        case PrimitiveType.TRIANGLE_STRIP:
            geometry.indices = triangleStripToLines(indices);
            break;
        case PrimitiveType.TRIANGLE_FAN:
            geometry.indices = triangleFanToLines(indices);
            break;
        default:
            throw new DeveloperError('geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.');
        }
        geometry.primitiveType = PrimitiveType.LINES;
    }
    return geometry;
};
GeometryPipeline.createLineSegmentsForVectors = function (geometry, attributeName, length) {
    attributeName = defaultValue(attributeName, 'normal');
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    if (!defined(geometry.attributes.position)) {
        throw new DeveloperError('geometry.attributes.position is required.');
    }
    if (!defined(geometry.attributes[attributeName])) {
        throw new DeveloperError('geometry.attributes must have an attribute with the same name as the attributeName parameter, ' + attributeName + '.');
    }
    length = defaultValue(length, 10000);
    var positions = geometry.attributes.position.values;
    var vectors = geometry.attributes[attributeName].values;
    var positionsLength = positions.length;
    var newPositions = new Float64Array(2 * positionsLength);
    var j = 0;
    for (var i = 0; i < positionsLength; i += 3) {
        newPositions[j++] = positions[i];
        newPositions[j++] = positions[i + 1];
        newPositions[j++] = positions[i + 2];
        newPositions[j++] = positions[i] + vectors[i] * length;
        newPositions[j++] = positions[i + 1] + vectors[i + 1] * length;
        newPositions[j++] = positions[i + 2] + vectors[i + 2] * length;
    }
    var newBoundingSphere;
    var bs = geometry.boundingSphere;
    if (defined(bs)) {
        newBoundingSphere = new BoundingSphere(bs.center, bs.radius + length);
    }
    return new Geometry({
        attributes: {
            position: new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: newPositions
            })
        },
        primitiveType: PrimitiveType.LINES,
        boundingSphere: newBoundingSphere
    });
};
GeometryPipeline.createAttributeLocations = function (geometry) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    var semantics = [
            'position',
            'positionHigh',
            'positionLow',
            'position3DHigh',
            'position3DLow',
            'position2DHigh',
            'position2DLow',
            'pickColor',
            'normal',
            'st',
            'binormal',
            'tangent',
            'compressedAttributes'
        ];
    var attributes = geometry.attributes;
    var indices = {};
    var j = 0;
    var i;
    var len = semantics.length;
    for (i = 0; i < len; ++i) {
        var semantic = semantics[i];
        if (defined(attributes[semantic])) {
            indices[semantic] = j++;
        }
    }
    for (var name in attributes) {
        if (attributes.hasOwnProperty(name) && !defined(indices[name])) {
            indices[name] = j++;
        }
    }
    return indices;
};
GeometryPipeline.reorderForPreVertexCache = function (geometry) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    var numVertices = Geometry.computeNumberOfVertices(geometry);
    var indices = geometry.indices;
    if (defined(indices)) {
        var indexCrossReferenceOldToNew = new Int32Array(numVertices);
        for (var i = 0; i < numVertices; i++) {
            indexCrossReferenceOldToNew[i] = -1;
        }
        var indicesIn = indices;
        var numIndices = indicesIn.length;
        var indicesOut = IndexDatatype.createTypedArray(numVertices, numIndices);
        var intoIndicesIn = 0;
        var intoIndicesOut = 0;
        var nextIndex = 0;
        var tempIndex;
        while (intoIndicesIn < numIndices) {
            tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];
            if (tempIndex !== -1) {
                indicesOut[intoIndicesOut] = tempIndex;
            } else {
                tempIndex = indicesIn[intoIndicesIn];
                indexCrossReferenceOldToNew[tempIndex] = nextIndex;
                indicesOut[intoIndicesOut] = nextIndex;
                ++nextIndex;
            }
            ++intoIndicesIn;
            ++intoIndicesOut;
        }
        geometry.indices = indicesOut;
        var attributes = geometry.attributes;
        for (var property in attributes) {
            if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {
                var attribute = attributes[property];
                var elementsIn = attribute.values;
                var intoElementsIn = 0;
                var numComponents = attribute.componentsPerAttribute;
                var elementsOut = ComponentDatatype.createTypedArray(attribute.componentDatatype, nextIndex * numComponents);
                while (intoElementsIn < numVertices) {
                    var temp = indexCrossReferenceOldToNew[intoElementsIn];
                    if (temp !== -1) {
                        for (i = 0; i < numComponents; i++) {
                            elementsOut[numComponents * temp + i] = elementsIn[numComponents * intoElementsIn + i];
                        }
                    }
                    ++intoElementsIn;
                }
                attribute.values = elementsOut;
            }
        }
    }
    return geometry;
};
GeometryPipeline.reorderForPostVertexCache = function (geometry, cacheCapacity) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    var indices = geometry.indices;
    if (geometry.primitiveType === PrimitiveType.TRIANGLES && defined(indices)) {
        var numIndices = indices.length;
        var maximumIndex = 0;
        for (var j = 0; j < numIndices; j++) {
            if (indices[j] > maximumIndex) {
                maximumIndex = indices[j];
            }
        }
        geometry.indices = Tipsify.tipsify({
            indices: indices,
            maximumIndex: maximumIndex,
            cacheSize: cacheCapacity
        });
    }
    return geometry;
};
function copyAttributesDescriptions(attributes) {
    var newAttributes = {};
    for (var attribute in attributes) {
        if (attributes.hasOwnProperty(attribute) && defined(attributes[attribute]) && defined(attributes[attribute].values)) {
            var attr = attributes[attribute];
            newAttributes[attribute] = new GeometryAttribute({
                componentDatatype: attr.componentDatatype,
                componentsPerAttribute: attr.componentsPerAttribute,
                normalize: attr.normalize,
                values: []
            });
        }
    }
    return newAttributes;
}
function copyVertex(destinationAttributes, sourceAttributes, index) {
    for (var attribute in sourceAttributes) {
        if (sourceAttributes.hasOwnProperty(attribute) && defined(sourceAttributes[attribute]) && defined(sourceAttributes[attribute].values)) {
            var attr = sourceAttributes[attribute];
            for (var k = 0; k < attr.componentsPerAttribute; ++k) {
                destinationAttributes[attribute].values.push(attr.values[index * attr.componentsPerAttribute + k]);
            }
        }
    }
}
GeometryPipeline.fitToUnsignedShortIndices = function (geometry) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    if (defined(geometry.indices) && (geometry.primitiveType !== PrimitiveType.TRIANGLES && geometry.primitiveType !== PrimitiveType.LINES && geometry.primitiveType !== PrimitiveType.POINTS)) {
        throw new DeveloperError('geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.');
    }
    var geometries = [];
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    if (defined(geometry.indices) && numberOfVertices > CesiumMath.SIXTY_FOUR_KILOBYTES) {
        var oldToNewIndex = [];
        var newIndices = [];
        var currentIndex = 0;
        var newAttributes = copyAttributesDescriptions(geometry.attributes);
        var originalIndices = geometry.indices;
        var numberOfIndices = originalIndices.length;
        var indicesPerPrimitive;
        if (geometry.primitiveType === PrimitiveType.TRIANGLES) {
            indicesPerPrimitive = 3;
        } else if (geometry.primitiveType === PrimitiveType.LINES) {
            indicesPerPrimitive = 2;
        } else if (geometry.primitiveType === PrimitiveType.POINTS) {
            indicesPerPrimitive = 1;
        }
        for (var j = 0; j < numberOfIndices; j += indicesPerPrimitive) {
            for (var k = 0; k < indicesPerPrimitive; ++k) {
                var x = originalIndices[j + k];
                var i = oldToNewIndex[x];
                if (!defined(i)) {
                    i = currentIndex++;
                    oldToNewIndex[x] = i;
                    copyVertex(newAttributes, geometry.attributes, x);
                }
                newIndices.push(i);
            }
            if (currentIndex + indicesPerPrimitive > CesiumMath.SIXTY_FOUR_KILOBYTES) {
                geometries.push(new Geometry({
                    attributes: newAttributes,
                    indices: newIndices,
                    primitiveType: geometry.primitiveType,
                    boundingSphere: geometry.boundingSphere,
                    boundingSphereCV: geometry.boundingSphereCV
                }));
                oldToNewIndex = [];
                newIndices = [];
                currentIndex = 0;
                newAttributes = copyAttributesDescriptions(geometry.attributes);
            }
        }
        if (newIndices.length !== 0) {
            geometries.push(new Geometry({
                attributes: newAttributes,
                indices: newIndices,
                primitiveType: geometry.primitiveType,
                boundingSphere: geometry.boundingSphere,
                boundingSphereCV: geometry.boundingSphereCV
            }));
        }
    } else {
        geometries.push(geometry);
    }
    return geometries;
};
var scratchProjectTo2DCartesian3 = new Cartesian3();
var scratchProjectTo2DCartographic = new Cartographic();
GeometryPipeline.projectTo2D = function (geometry, attributeName, attributeName3D, attributeName2D, projection) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    if (!defined(attributeName)) {
        throw new DeveloperError('attributeName is required.');
    }
    if (!defined(attributeName3D)) {
        throw new DeveloperError('attributeName3D is required.');
    }
    if (!defined(attributeName2D)) {
        throw new DeveloperError('attributeName2D is required.');
    }
    if (!defined(geometry.attributes[attributeName])) {
        throw new DeveloperError('geometry must have attribute matching the attributeName argument: ' + attributeName + '.');
    }
    if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {
        throw new DeveloperError('The attribute componentDatatype must be ComponentDatatype.DOUBLE.');
    }
    var attribute = geometry.attributes[attributeName];
    projection = defined(projection) ? projection : new GeographicProjection();
    var ellipsoid = projection.ellipsoid;
    var values3D = attribute.values;
    var projectedValues = new Float64Array(values3D.length);
    var index = 0;
    for (var i = 0; i < values3D.length; i += 3) {
        var value = Cartesian3.fromArray(values3D, i, scratchProjectTo2DCartesian3);
        var lonLat = ellipsoid.cartesianToCartographic(value, scratchProjectTo2DCartographic);
        if (!defined(lonLat)) {
            throw new DeveloperError('Could not project point (' + value.x + ', ' + value.y + ', ' + value.z + ') to 2D.');
        }
        var projectedLonLat = projection.project(lonLat, scratchProjectTo2DCartesian3);
        projectedValues[index++] = projectedLonLat.x;
        projectedValues[index++] = projectedLonLat.y;
        projectedValues[index++] = projectedLonLat.z;
    }
    geometry.attributes[attributeName3D] = attribute;
    geometry.attributes[attributeName2D] = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: projectedValues
    });
    delete geometry.attributes[attributeName];
    return geometry;
};
var encodedResult = {
        high: 0,
        low: 0
    };
GeometryPipeline.encodeAttribute = function (geometry, attributeName, attributeHighName, attributeLowName) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    if (!defined(attributeName)) {
        throw new DeveloperError('attributeName is required.');
    }
    if (!defined(attributeHighName)) {
        throw new DeveloperError('attributeHighName is required.');
    }
    if (!defined(attributeLowName)) {
        throw new DeveloperError('attributeLowName is required.');
    }
    if (!defined(geometry.attributes[attributeName])) {
        throw new DeveloperError('geometry must have attribute matching the attributeName argument: ' + attributeName + '.');
    }
    if (geometry.attributes[attributeName].componentDatatype !== ComponentDatatype.DOUBLE) {
        throw new DeveloperError('The attribute componentDatatype must be ComponentDatatype.DOUBLE.');
    }
    var attribute = geometry.attributes[attributeName];
    var values = attribute.values;
    var length = values.length;
    var highValues = new Float32Array(length);
    var lowValues = new Float32Array(length);
    for (var i = 0; i < length; ++i) {
        EncodedCartesian3.encode(values[i], encodedResult);
        highValues[i] = encodedResult.high;
        lowValues[i] = encodedResult.low;
    }
    var componentsPerAttribute = attribute.componentsPerAttribute;
    geometry.attributes[attributeHighName] = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: componentsPerAttribute,
        values: highValues
    });
    geometry.attributes[attributeLowName] = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: componentsPerAttribute,
        values: lowValues
    });
    delete geometry.attributes[attributeName];
    return geometry;
};
var scratchCartesian3 = new Cartesian3();
function transformPoint(matrix, attribute) {
    if (defined(attribute)) {
        var values = attribute.values;
        var length = values.length;
        for (var i = 0; i < length; i += 3) {
            Cartesian3.unpack(values, i, scratchCartesian3);
            Matrix4.multiplyByPoint(matrix, scratchCartesian3, scratchCartesian3);
            Cartesian3.pack(scratchCartesian3, values, i);
        }
    }
}
function transformVector(matrix, attribute) {
    if (defined(attribute)) {
        var values = attribute.values;
        var length = values.length;
        for (var i = 0; i < length; i += 3) {
            Cartesian3.unpack(values, i, scratchCartesian3);
            Matrix3.multiplyByVector(matrix, scratchCartesian3, scratchCartesian3);
            scratchCartesian3 = Cartesian3.normalize(scratchCartesian3, scratchCartesian3);
            Cartesian3.pack(scratchCartesian3, values, i);
        }
    }
}
var inverseTranspose = new Matrix4();
var normalMatrix = new Matrix3();
GeometryPipeline.transformToWorldCoordinates = function (instance) {
    if (!defined(instance)) {
        throw new DeveloperError('instance is required.');
    }
    var modelMatrix = instance.modelMatrix;
    if (Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {
        return instance;
    }
    var attributes = instance.geometry.attributes;
    transformPoint(modelMatrix, attributes.position);
    transformPoint(modelMatrix, attributes.prevPosition);
    transformPoint(modelMatrix, attributes.nextPosition);
    if (defined(attributes.normal) || defined(attributes.binormal) || defined(attributes.tangent)) {
        Matrix4.inverse(modelMatrix, inverseTranspose);
        Matrix4.transpose(inverseTranspose, inverseTranspose);
        Matrix4.getRotation(inverseTranspose, normalMatrix);
        transformVector(normalMatrix, attributes.normal);
        transformVector(normalMatrix, attributes.binormal);
        transformVector(normalMatrix, attributes.tangent);
    }
    var boundingSphere = instance.geometry.boundingSphere;
    if (defined(boundingSphere)) {
        instance.geometry.boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, boundingSphere);
    }
    instance.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);
    return instance;
};
function findAttributesInAllGeometries(instances, propertyName) {
    var length = instances.length;
    var attributesInAllGeometries = {};
    var attributes0 = instances[0][propertyName].attributes;
    var name;
    for (name in attributes0) {
        if (attributes0.hasOwnProperty(name) && defined(attributes0[name]) && defined(attributes0[name].values)) {
            var attribute = attributes0[name];
            var numberOfComponents = attribute.values.length;
            var inAllGeometries = true;
            for (var i = 1; i < length; ++i) {
                var otherAttribute = instances[i][propertyName].attributes[name];
                if (!defined(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {
                    inAllGeometries = false;
                    break;
                }
                numberOfComponents += otherAttribute.values.length;
            }
            if (inAllGeometries) {
                attributesInAllGeometries[name] = new GeometryAttribute({
                    componentDatatype: attribute.componentDatatype,
                    componentsPerAttribute: attribute.componentsPerAttribute,
                    normalize: attribute.normalize,
                    values: ComponentDatatype.createTypedArray(attribute.componentDatatype, numberOfComponents)
                });
            }
        }
    }
    return attributesInAllGeometries;
}
var tempScratch = new Cartesian3();
function combineGeometries(instances, propertyName) {
    var length = instances.length;
    var name;
    var i;
    var j;
    var k;
    var m = instances[0].modelMatrix;
    var haveIndices = defined(instances[0][propertyName].indices);
    var primitiveType = instances[0][propertyName].primitiveType;
    for (i = 1; i < length; ++i) {
        if (!Matrix4.equals(instances[i].modelMatrix, m)) {
            throw new DeveloperError('All instances must have the same modelMatrix.');
        }
        if (defined(instances[i][propertyName].indices) !== haveIndices) {
            throw new DeveloperError('All instance geometries must have an indices or not have one.');
        }
        if (instances[i][propertyName].primitiveType !== primitiveType) {
            throw new DeveloperError('All instance geometries must have the same primitiveType.');
        }
    }
    var attributes = findAttributesInAllGeometries(instances, propertyName);
    var values;
    var sourceValues;
    var sourceValuesLength;
    for (name in attributes) {
        if (attributes.hasOwnProperty(name)) {
            values = attributes[name].values;
            k = 0;
            for (i = 0; i < length; ++i) {
                sourceValues = instances[i][propertyName].attributes[name].values;
                sourceValuesLength = sourceValues.length;
                for (j = 0; j < sourceValuesLength; ++j) {
                    values[k++] = sourceValues[j];
                }
            }
        }
    }
    var indices;
    if (haveIndices) {
        var numberOfIndices = 0;
        for (i = 0; i < length; ++i) {
            numberOfIndices += instances[i][propertyName].indices.length;
        }
        var numberOfVertices = Geometry.computeNumberOfVertices(new Geometry({
                attributes: attributes,
                primitiveType: PrimitiveType.POINTS
            }));
        var destIndices = IndexDatatype.createTypedArray(numberOfVertices, numberOfIndices);
        var destOffset = 0;
        var offset = 0;
        for (i = 0; i < length; ++i) {
            var sourceIndices = instances[i][propertyName].indices;
            var sourceIndicesLen = sourceIndices.length;
            for (k = 0; k < sourceIndicesLen; ++k) {
                destIndices[destOffset++] = offset + sourceIndices[k];
            }
            offset += Geometry.computeNumberOfVertices(instances[i][propertyName]);
        }
        indices = destIndices;
    }
    var center = new Cartesian3();
    var radius = 0;
    var bs;
    for (i = 0; i < length; ++i) {
        bs = instances[i][propertyName].boundingSphere;
        if (!defined(bs)) {
            center = undefined;
            break;
        }
        Cartesian3.add(bs.center, center, center);
    }
    if (defined(center)) {
        Cartesian3.divideByScalar(center, length, center);
        for (i = 0; i < length; ++i) {
            bs = instances[i][propertyName].boundingSphere;
            var tempRadius = Cartesian3.magnitude(Cartesian3.subtract(bs.center, center, tempScratch)) + bs.radius;
            if (tempRadius > radius) {
                radius = tempRadius;
            }
        }
    }
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: primitiveType,
        boundingSphere: defined(center) ? new BoundingSphere(center, radius) : undefined
    });
}
GeometryPipeline.combineInstances = function (instances) {
    if (!defined(instances) || instances.length < 1) {
        throw new DeveloperError('instances is required and must have length greater than zero.');
    }
    var instanceGeometry = [];
    var instanceSplitGeometry = [];
    var length = instances.length;
    for (var i = 0; i < length; ++i) {
        var instance = instances[i];
        if (defined(instance.geometry)) {
            instanceGeometry.push(instance);
        } else {
            instanceSplitGeometry.push(instance);
        }
    }
    var geometries = [];
    if (instanceGeometry.length > 0) {
        geometries.push(combineGeometries(instanceGeometry, 'geometry'));
    }
    if (instanceSplitGeometry.length > 0) {
        geometries.push(combineGeometries(instanceSplitGeometry, 'westHemisphereGeometry'));
        geometries.push(combineGeometries(instanceSplitGeometry, 'eastHemisphereGeometry'));
    }
    return geometries;
};
var normal = new Cartesian3();
var v0 = new Cartesian3();
var v1 = new Cartesian3();
var v2 = new Cartesian3();
GeometryPipeline.computeNormal = function (geometry) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    if (!defined(geometry.attributes.position) || !defined(geometry.attributes.position.values)) {
        throw new DeveloperError('geometry.attributes.position.values is required.');
    }
    if (!defined(geometry.indices)) {
        throw new DeveloperError('geometry.indices is required.');
    }
    if (geometry.indices.length < 2 || geometry.indices.length % 3 !== 0) {
        throw new DeveloperError('geometry.indices length must be greater than 0 and be a multiple of 3.');
    }
    if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {
        throw new DeveloperError('geometry.primitiveType must be PrimitiveType.TRIANGLES.');
    }
    var indices = geometry.indices;
    var attributes = geometry.attributes;
    var vertices = attributes.position.values;
    var numVertices = attributes.position.values.length / 3;
    var numIndices = indices.length;
    var normalsPerVertex = new Array(numVertices);
    var normalsPerTriangle = new Array(numIndices / 3);
    var normalIndices = new Array(numIndices);
    for (var i = 0; i < numVertices; i++) {
        normalsPerVertex[i] = {
            indexOffset: 0,
            count: 0,
            currentCount: 0
        };
    }
    var j = 0;
    for (i = 0; i < numIndices; i += 3) {
        var i0 = indices[i];
        var i1 = indices[i + 1];
        var i2 = indices[i + 2];
        var i03 = i0 * 3;
        var i13 = i1 * 3;
        var i23 = i2 * 3;
        v0.x = vertices[i03];
        v0.y = vertices[i03 + 1];
        v0.z = vertices[i03 + 2];
        v1.x = vertices[i13];
        v1.y = vertices[i13 + 1];
        v1.z = vertices[i13 + 2];
        v2.x = vertices[i23];
        v2.y = vertices[i23 + 1];
        v2.z = vertices[i23 + 2];
        normalsPerVertex[i0].count++;
        normalsPerVertex[i1].count++;
        normalsPerVertex[i2].count++;
        Cartesian3.subtract(v1, v0, v1);
        Cartesian3.subtract(v2, v0, v2);
        normalsPerTriangle[j] = Cartesian3.cross(v1, v2, new Cartesian3());
        j++;
    }
    var indexOffset = 0;
    for (i = 0; i < numVertices; i++) {
        normalsPerVertex[i].indexOffset += indexOffset;
        indexOffset += normalsPerVertex[i].count;
    }
    j = 0;
    var vertexNormalData;
    for (i = 0; i < numIndices; i += 3) {
        vertexNormalData = normalsPerVertex[indices[i]];
        var index = vertexNormalData.indexOffset + vertexNormalData.currentCount;
        normalIndices[index] = j;
        vertexNormalData.currentCount++;
        vertexNormalData = normalsPerVertex[indices[i + 1]];
        index = vertexNormalData.indexOffset + vertexNormalData.currentCount;
        normalIndices[index] = j;
        vertexNormalData.currentCount++;
        vertexNormalData = normalsPerVertex[indices[i + 2]];
        index = vertexNormalData.indexOffset + vertexNormalData.currentCount;
        normalIndices[index] = j;
        vertexNormalData.currentCount++;
        j++;
    }
    var normalValues = new Float32Array(numVertices * 3);
    for (i = 0; i < numVertices; i++) {
        var i3 = i * 3;
        vertexNormalData = normalsPerVertex[i];
        if (vertexNormalData.count > 0) {
            Cartesian3.clone(Cartesian3.ZERO, normal);
            for (j = 0; j < vertexNormalData.count; j++) {
                Cartesian3.add(normal, normalsPerTriangle[normalIndices[vertexNormalData.indexOffset + j]], normal);
            }
            Cartesian3.normalize(normal, normal);
            normalValues[i3] = normal.x;
            normalValues[i3 + 1] = normal.y;
            normalValues[i3 + 2] = normal.z;
        } else {
            normalValues[i3] = 0;
            normalValues[i3 + 1] = 0;
            normalValues[i3 + 2] = 1;
        }
    }
    geometry.attributes.normal = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        values: normalValues
    });
    return geometry;
};
var normalScratch = new Cartesian3();
var normalScale = new Cartesian3();
var tScratch = new Cartesian3();
GeometryPipeline.computeBinormalAndTangent = function (geometry) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    var attributes = geometry.attributes;
    var indices = geometry.indices;
    if (!defined(attributes.position) || !defined(attributes.position.values)) {
        throw new DeveloperError('geometry.attributes.position.values is required.');
    }
    if (!defined(attributes.normal) || !defined(attributes.normal.values)) {
        throw new DeveloperError('geometry.attributes.normal.values is required.');
    }
    if (!defined(attributes.st) || !defined(attributes.st.values)) {
        throw new DeveloperError('geometry.attributes.st.values is required.');
    }
    if (!defined(indices)) {
        throw new DeveloperError('geometry.indices is required.');
    }
    if (indices.length < 2 || indices.length % 3 !== 0) {
        throw new DeveloperError('geometry.indices length must be greater than 0 and be a multiple of 3.');
    }
    if (geometry.primitiveType !== PrimitiveType.TRIANGLES) {
        throw new DeveloperError('geometry.primitiveType must be PrimitiveType.TRIANGLES.');
    }
    var vertices = geometry.attributes.position.values;
    var normals = geometry.attributes.normal.values;
    var st = geometry.attributes.st.values;
    var numVertices = geometry.attributes.position.values.length / 3;
    var numIndices = indices.length;
    var tan1 = new Array(numVertices * 3);
    for (var i = 0; i < tan1.length; i++) {
        tan1[i] = 0;
    }
    var i03;
    var i13;
    var i23;
    for (i = 0; i < numIndices; i += 3) {
        var i0 = indices[i];
        var i1 = indices[i + 1];
        var i2 = indices[i + 2];
        i03 = i0 * 3;
        i13 = i1 * 3;
        i23 = i2 * 3;
        var i02 = i0 * 2;
        var i12 = i1 * 2;
        var i22 = i2 * 2;
        var ux = vertices[i03];
        var uy = vertices[i03 + 1];
        var uz = vertices[i03 + 2];
        var wx = st[i02];
        var wy = st[i02 + 1];
        var t1 = st[i12 + 1] - wy;
        var t2 = st[i22 + 1] - wy;
        var r = 1 / ((st[i12] - wx) * t2 - (st[i22] - wx) * t1);
        var sdirx = (t2 * (vertices[i13] - ux) - t1 * (vertices[i23] - ux)) * r;
        var sdiry = (t2 * (vertices[i13 + 1] - uy) - t1 * (vertices[i23 + 1] - uy)) * r;
        var sdirz = (t2 * (vertices[i13 + 2] - uz) - t1 * (vertices[i23 + 2] - uz)) * r;
        tan1[i03] += sdirx;
        tan1[i03 + 1] += sdiry;
        tan1[i03 + 2] += sdirz;
        tan1[i13] += sdirx;
        tan1[i13 + 1] += sdiry;
        tan1[i13 + 2] += sdirz;
        tan1[i23] += sdirx;
        tan1[i23 + 1] += sdiry;
        tan1[i23 + 2] += sdirz;
    }
    var binormalValues = new Float32Array(numVertices * 3);
    var tangentValues = new Float32Array(numVertices * 3);
    for (i = 0; i < numVertices; i++) {
        i03 = i * 3;
        i13 = i03 + 1;
        i23 = i03 + 2;
        var n = Cartesian3.fromArray(normals, i03, normalScratch);
        var t = Cartesian3.fromArray(tan1, i03, tScratch);
        var scalar = Cartesian3.dot(n, t);
        Cartesian3.multiplyByScalar(n, scalar, normalScale);
        Cartesian3.normalize(Cartesian3.subtract(t, normalScale, t), t);
        tangentValues[i03] = t.x;
        tangentValues[i13] = t.y;
        tangentValues[i23] = t.z;
        Cartesian3.normalize(Cartesian3.cross(n, t, t), t);
        binormalValues[i03] = t.x;
        binormalValues[i13] = t.y;
        binormalValues[i23] = t.z;
    }
    geometry.attributes.tangent = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        values: tangentValues
    });
    geometry.attributes.binormal = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: 3,
        values: binormalValues
    });
    return geometry;
};
var scratchCartesian2 = new Cartesian2();
var toEncode1 = new Cartesian3();
var toEncode2 = new Cartesian3();
var toEncode3 = new Cartesian3();
GeometryPipeline.compressVertices = function (geometry) {
    if (!defined(geometry)) {
        throw new DeveloperError('geometry is required.');
    }
    var normalAttribute = geometry.attributes.normal;
    var stAttribute = geometry.attributes.st;
    if (!defined(normalAttribute) && !defined(stAttribute)) {
        return geometry;
    }
    var tangentAttribute = geometry.attributes.tangent;
    var binormalAttribute = geometry.attributes.binormal;
    var normals;
    var st;
    var tangents;
    var binormals;
    if (defined(normalAttribute)) {
        normals = normalAttribute.values;
    }
    if (defined(stAttribute)) {
        st = stAttribute.values;
    }
    if (defined(tangentAttribute)) {
        tangents = tangentAttribute.values;
    }
    if (binormalAttribute) {
        binormals = binormalAttribute.values;
    }
    var length = defined(normals) ? normals.length : st.length;
    var numComponents = defined(normals) ? 3 : 2;
    var numVertices = length / numComponents;
    var compressedLength = numVertices;
    var numCompressedComponents = defined(st) && defined(normals) ? 2 : 1;
    numCompressedComponents += defined(tangents) || defined(binormals) ? 1 : 0;
    compressedLength *= numCompressedComponents;
    var compressedAttributes = new Float32Array(compressedLength);
    var normalIndex = 0;
    for (var i = 0; i < numVertices; ++i) {
        if (defined(st)) {
            Cartesian2.fromArray(st, i * 2, scratchCartesian2);
            compressedAttributes[normalIndex++] = AttributeCompression.compressTextureCoordinates(scratchCartesian2);
        }
        var index = i * 3;
        if (defined(normals) && defined(tangents) && defined(binormals)) {
            Cartesian3.fromArray(normals, index, toEncode1);
            Cartesian3.fromArray(tangents, index, toEncode2);
            Cartesian3.fromArray(binormals, index, toEncode3);
            AttributeCompression.octPack(toEncode1, toEncode2, toEncode3, scratchCartesian2);
            compressedAttributes[normalIndex++] = scratchCartesian2.x;
            compressedAttributes[normalIndex++] = scratchCartesian2.y;
        } else {
            if (defined(normals)) {
                Cartesian3.fromArray(normals, index, toEncode1);
                compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);
            }
            if (defined(tangents)) {
                Cartesian3.fromArray(tangents, index, toEncode1);
                compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);
            }
            if (defined(binormals)) {
                Cartesian3.fromArray(binormals, index, toEncode1);
                compressedAttributes[normalIndex++] = AttributeCompression.octEncodeFloat(toEncode1);
            }
        }
    }
    geometry.attributes.compressedAttributes = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: numCompressedComponents,
        values: compressedAttributes
    });
    if (defined(normals)) {
        delete geometry.attributes.normal;
    }
    if (defined(st)) {
        delete geometry.attributes.st;
    }
    if (defined(tangents)) {
        delete geometry.attributes.tangent;
    }
    if (defined(binormals)) {
        delete geometry.attributes.binormal;
    }
    return geometry;
};
function indexTriangles(geometry) {
    if (defined(geometry.indices)) {
        return geometry;
    }
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    if (numberOfVertices < 3) {
        throw new DeveloperError('The number of vertices must be at least three.');
    }
    if (numberOfVertices % 3 !== 0) {
        throw new DeveloperError('The number of vertices must be a multiple of three.');
    }
    var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);
    for (var i = 0; i < numberOfVertices; ++i) {
        indices[i] = i;
    }
    geometry.indices = indices;
    return geometry;
}
function indexTriangleFan(geometry) {
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    if (numberOfVertices < 3) {
        throw new DeveloperError('The number of vertices must be at least three.');
    }
    var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);
    indices[0] = 1;
    indices[1] = 0;
    indices[2] = 2;
    var indicesIndex = 3;
    for (var i = 3; i < numberOfVertices; ++i) {
        indices[indicesIndex++] = i - 1;
        indices[indicesIndex++] = 0;
        indices[indicesIndex++] = i;
    }
    geometry.indices = indices;
    geometry.primitiveType = PrimitiveType.TRIANGLES;
    return geometry;
}
function indexTriangleStrip(geometry) {
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    if (numberOfVertices < 3) {
        throw new DeveloperError('The number of vertices must be at least 3.');
    }
    var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 2) * 3);
    indices[0] = 0;
    indices[1] = 1;
    indices[2] = 2;
    if (numberOfVertices > 3) {
        indices[3] = 0;
        indices[4] = 2;
        indices[5] = 3;
    }
    var indicesIndex = 6;
    for (var i = 3; i < numberOfVertices - 1; i += 2) {
        indices[indicesIndex++] = i;
        indices[indicesIndex++] = i - 1;
        indices[indicesIndex++] = i + 1;
        if (i + 2 < numberOfVertices) {
            indices[indicesIndex++] = i;
            indices[indicesIndex++] = i + 1;
            indices[indicesIndex++] = i + 2;
        }
    }
    geometry.indices = indices;
    geometry.primitiveType = PrimitiveType.TRIANGLES;
    return geometry;
}
function indexLines(geometry) {
    if (defined(geometry.indices)) {
        return geometry;
    }
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    if (numberOfVertices < 2) {
        throw new DeveloperError('The number of vertices must be at least two.');
    }
    if (numberOfVertices % 2 !== 0) {
        throw new DeveloperError('The number of vertices must be a multiple of 2.');
    }
    var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices);
    for (var i = 0; i < numberOfVertices; ++i) {
        indices[i] = i;
    }
    geometry.indices = indices;
    return geometry;
}
function indexLineStrip(geometry) {
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    if (numberOfVertices < 2) {
        throw new DeveloperError('The number of vertices must be at least two.');
    }
    var indices = IndexDatatype.createTypedArray(numberOfVertices, (numberOfVertices - 1) * 2);
    indices[0] = 0;
    indices[1] = 1;
    var indicesIndex = 2;
    for (var i = 2; i < numberOfVertices; ++i) {
        indices[indicesIndex++] = i - 1;
        indices[indicesIndex++] = i;
    }
    geometry.indices = indices;
    geometry.primitiveType = PrimitiveType.LINES;
    return geometry;
}
function indexLineLoop(geometry) {
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    if (numberOfVertices < 2) {
        throw new DeveloperError('The number of vertices must be at least two.');
    }
    var indices = IndexDatatype.createTypedArray(numberOfVertices, numberOfVertices * 2);
    indices[0] = 0;
    indices[1] = 1;
    var indicesIndex = 2;
    for (var i = 2; i < numberOfVertices; ++i) {
        indices[indicesIndex++] = i - 1;
        indices[indicesIndex++] = i;
    }
    indices[indicesIndex++] = numberOfVertices - 1;
    indices[indicesIndex] = 0;
    geometry.indices = indices;
    geometry.primitiveType = PrimitiveType.LINES;
    return geometry;
}
function indexPrimitive(geometry) {
    switch (geometry.primitiveType) {
    case PrimitiveType.TRIANGLE_FAN:
        return indexTriangleFan(geometry);
    case PrimitiveType.TRIANGLE_STRIP:
        return indexTriangleStrip(geometry);
    case PrimitiveType.TRIANGLES:
        return indexTriangles(geometry);
    case PrimitiveType.LINE_STRIP:
        return indexLineStrip(geometry);
    case PrimitiveType.LINE_LOOP:
        return indexLineLoop(geometry);
    case PrimitiveType.LINES:
        return indexLines(geometry);
    }
    return geometry;
}
function offsetPointFromXZPlane(p, isBehind) {
    if (Math.abs(p.y) < CesiumMath.EPSILON6) {
        if (isBehind) {
            p.y = -CesiumMath.EPSILON6;
        } else {
            p.y = CesiumMath.EPSILON6;
        }
    }
}
function offsetTriangleFromXZPlane(p0, p1, p2) {
    if (p0.y !== 0 && p1.y !== 0 && p2.y !== 0) {
        offsetPointFromXZPlane(p0, p0.y < 0);
        offsetPointFromXZPlane(p1, p1.y < 0);
        offsetPointFromXZPlane(p2, p2.y < 0);
        return;
    }
    var p0y = Math.abs(p0.y);
    var p1y = Math.abs(p1.y);
    var p2y = Math.abs(p2.y);
    var sign;
    if (p0y > p1y) {
        if (p0y > p2y) {
            sign = CesiumMath.sign(p0.y);
        } else {
            sign = CesiumMath.sign(p2.y);
        }
    } else if (p1y > p2y) {
        sign = CesiumMath.sign(p1.y);
    } else {
        sign = CesiumMath.sign(p2.y);
    }
    var isBehind = sign < 0;
    offsetPointFromXZPlane(p0, isBehind);
    offsetPointFromXZPlane(p1, isBehind);
    offsetPointFromXZPlane(p2, isBehind);
}
var c3 = new Cartesian3();
function getXZIntersectionOffsetPoints(p, p1, u1, v1) {
    Cartesian3.add(p, Cartesian3.multiplyByScalar(Cartesian3.subtract(p1, p, c3), p.y / (p.y - p1.y), c3), u1);
    Cartesian3.clone(u1, v1);
    offsetPointFromXZPlane(u1, true);
    offsetPointFromXZPlane(v1, false);
}
var u1 = new Cartesian3();
var u2 = new Cartesian3();
var q1 = new Cartesian3();
var q2 = new Cartesian3();
var splitTriangleResult = {
        positions: new Array(7),
        indices: new Array(3 * 3)
    };
function splitTriangle(p0, p1, p2) {
    if (p0.x >= 0 || p1.x >= 0 || p2.x >= 0) {
        return undefined;
    }
    offsetTriangleFromXZPlane(p0, p1, p2);
    var p0Behind = p0.y < 0;
    var p1Behind = p1.y < 0;
    var p2Behind = p2.y < 0;
    var numBehind = 0;
    numBehind += p0Behind ? 1 : 0;
    numBehind += p1Behind ? 1 : 0;
    numBehind += p2Behind ? 1 : 0;
    var indices = splitTriangleResult.indices;
    if (numBehind === 1) {
        indices[1] = 3;
        indices[2] = 4;
        indices[5] = 6;
        indices[7] = 6;
        indices[8] = 5;
        if (p0Behind) {
            getXZIntersectionOffsetPoints(p0, p1, u1, q1);
            getXZIntersectionOffsetPoints(p0, p2, u2, q2);
            indices[0] = 0;
            indices[3] = 1;
            indices[4] = 2;
            indices[6] = 1;
        } else if (p1Behind) {
            getXZIntersectionOffsetPoints(p1, p2, u1, q1);
            getXZIntersectionOffsetPoints(p1, p0, u2, q2);
            indices[0] = 1;
            indices[3] = 2;
            indices[4] = 0;
            indices[6] = 2;
        } else if (p2Behind) {
            getXZIntersectionOffsetPoints(p2, p0, u1, q1);
            getXZIntersectionOffsetPoints(p2, p1, u2, q2);
            indices[0] = 2;
            indices[3] = 0;
            indices[4] = 1;
            indices[6] = 0;
        }
    } else if (numBehind === 2) {
        indices[2] = 4;
        indices[4] = 4;
        indices[5] = 3;
        indices[7] = 5;
        indices[8] = 6;
        if (!p0Behind) {
            getXZIntersectionOffsetPoints(p0, p1, u1, q1);
            getXZIntersectionOffsetPoints(p0, p2, u2, q2);
            indices[0] = 1;
            indices[1] = 2;
            indices[3] = 1;
            indices[6] = 0;
        } else if (!p1Behind) {
            getXZIntersectionOffsetPoints(p1, p2, u1, q1);
            getXZIntersectionOffsetPoints(p1, p0, u2, q2);
            indices[0] = 2;
            indices[1] = 0;
            indices[3] = 2;
            indices[6] = 1;
        } else if (!p2Behind) {
            getXZIntersectionOffsetPoints(p2, p0, u1, q1);
            getXZIntersectionOffsetPoints(p2, p1, u2, q2);
            indices[0] = 0;
            indices[1] = 1;
            indices[3] = 0;
            indices[6] = 2;
        }
    }
    var positions = splitTriangleResult.positions;
    positions[0] = p0;
    positions[1] = p1;
    positions[2] = p2;
    positions.length = 3;
    if (numBehind === 1 || numBehind === 2) {
        positions[3] = u1;
        positions[4] = u2;
        positions[5] = q1;
        positions[6] = q2;
        positions.length = 7;
    }
    return splitTriangleResult;
}
function updateGeometryAfterSplit(geometry, computeBoundingSphere) {
    var attributes = geometry.attributes;
    if (attributes.position.values.length === 0) {
        return undefined;
    }
    for (var property in attributes) {
        if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {
            var attribute = attributes[property];
            attribute.values = ComponentDatatype.createTypedArray(attribute.componentDatatype, attribute.values);
        }
    }
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    geometry.indices = IndexDatatype.createTypedArray(numberOfVertices, geometry.indices);
    if (computeBoundingSphere) {
        geometry.boundingSphere = BoundingSphere.fromVertices(attributes.position.values);
    }
    return geometry;
}
function copyGeometryForSplit(geometry) {
    var attributes = geometry.attributes;
    var copiedAttributes = {};
    for (var property in attributes) {
        if (attributes.hasOwnProperty(property) && defined(attributes[property]) && defined(attributes[property].values)) {
            var attribute = attributes[property];
            copiedAttributes[property] = new GeometryAttribute({
                componentDatatype: attribute.componentDatatype,
                componentsPerAttribute: attribute.componentsPerAttribute,
                normalize: attribute.normalize,
                values: []
            });
        }
    }
    return new Geometry({
        attributes: copiedAttributes,
        indices: [],
        primitiveType: geometry.primitiveType
    });
}
function updateInstanceAfterSplit(instance, westGeometry, eastGeometry) {
    var computeBoundingSphere = defined(instance.geometry.boundingSphere);
    westGeometry = updateGeometryAfterSplit(westGeometry, computeBoundingSphere);
    eastGeometry = updateGeometryAfterSplit(eastGeometry, computeBoundingSphere);
    if (defined(eastGeometry) && !defined(westGeometry)) {
        instance.geometry = eastGeometry;
    } else if (!defined(eastGeometry) && defined(westGeometry)) {
        instance.geometry = westGeometry;
    } else {
        instance.westHemisphereGeometry = westGeometry;
        instance.eastHemisphereGeometry = eastGeometry;
        instance.geometry = undefined;
    }
}
var p0Scratch = new Cartesian3();
var p1Scratch = new Cartesian3();
var p2Scratch = new Cartesian3();
var barycentricScratch = new Cartesian3();
var s0Scratch = new Cartesian2();
var s1Scratch = new Cartesian2();
var s2Scratch = new Cartesian2();
function computeTriangleAttributes(i0, i1, i2, point, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex) {
    if (!defined(normals) && !defined(binormals) && !defined(tangents) && !defined(texCoords)) {
        return;
    }
    var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);
    var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);
    var p2 = Cartesian3.fromArray(positions, i2 * 3, p2Scratch);
    var coords = barycentricCoordinates(point, p0, p1, p2, barycentricScratch);
    if (defined(normals)) {
        var n0 = Cartesian3.fromArray(normals, i0 * 3, p0Scratch);
        var n1 = Cartesian3.fromArray(normals, i1 * 3, p1Scratch);
        var n2 = Cartesian3.fromArray(normals, i2 * 3, p2Scratch);
        Cartesian3.multiplyByScalar(n0, coords.x, n0);
        Cartesian3.multiplyByScalar(n1, coords.y, n1);
        Cartesian3.multiplyByScalar(n2, coords.z, n2);
        var normal = Cartesian3.add(n0, n1, n0);
        Cartesian3.add(normal, n2, normal);
        Cartesian3.normalize(normal, normal);
        Cartesian3.pack(normal, currentAttributes.normal.values, insertedIndex * 3);
    }
    if (defined(binormals)) {
        var b0 = Cartesian3.fromArray(binormals, i0 * 3, p0Scratch);
        var b1 = Cartesian3.fromArray(binormals, i1 * 3, p1Scratch);
        var b2 = Cartesian3.fromArray(binormals, i2 * 3, p2Scratch);
        Cartesian3.multiplyByScalar(b0, coords.x, b0);
        Cartesian3.multiplyByScalar(b1, coords.y, b1);
        Cartesian3.multiplyByScalar(b2, coords.z, b2);
        var binormal = Cartesian3.add(b0, b1, b0);
        Cartesian3.add(binormal, b2, binormal);
        Cartesian3.normalize(binormal, binormal);
        Cartesian3.pack(binormal, currentAttributes.binormal.values, insertedIndex * 3);
    }
    if (defined(tangents)) {
        var t0 = Cartesian3.fromArray(tangents, i0 * 3, p0Scratch);
        var t1 = Cartesian3.fromArray(tangents, i1 * 3, p1Scratch);
        var t2 = Cartesian3.fromArray(tangents, i2 * 3, p2Scratch);
        Cartesian3.multiplyByScalar(t0, coords.x, t0);
        Cartesian3.multiplyByScalar(t1, coords.y, t1);
        Cartesian3.multiplyByScalar(t2, coords.z, t2);
        var tangent = Cartesian3.add(t0, t1, t0);
        Cartesian3.add(tangent, t2, tangent);
        Cartesian3.normalize(tangent, tangent);
        Cartesian3.pack(tangent, currentAttributes.tangent.values, insertedIndex * 3);
    }
    if (defined(texCoords)) {
        var s0 = Cartesian2.fromArray(texCoords, i0 * 2, s0Scratch);
        var s1 = Cartesian2.fromArray(texCoords, i1 * 2, s1Scratch);
        var s2 = Cartesian2.fromArray(texCoords, i2 * 2, s2Scratch);
        Cartesian2.multiplyByScalar(s0, coords.x, s0);
        Cartesian2.multiplyByScalar(s1, coords.y, s1);
        Cartesian2.multiplyByScalar(s2, coords.z, s2);
        var texCoord = Cartesian2.add(s0, s1, s0);
        Cartesian2.add(texCoord, s2, texCoord);
        Cartesian2.pack(texCoord, currentAttributes.st.values, insertedIndex * 2);
    }
}
function insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, currentIndex, point) {
    var insertIndex = currentAttributes.position.values.length / 3;
    if (currentIndex !== -1) {
        var prevIndex = indices[currentIndex];
        var newIndex = currentIndexMap[prevIndex];
        if (newIndex === -1) {
            currentIndexMap[prevIndex] = insertIndex;
            currentAttributes.position.values.push(point.x, point.y, point.z);
            currentIndices.push(insertIndex);
            return insertIndex;
        }
        currentIndices.push(newIndex);
        return newIndex;
    }
    currentAttributes.position.values.push(point.x, point.y, point.z);
    currentIndices.push(insertIndex);
    return insertIndex;
}
function splitLongitudeTriangles(instance) {
    var geometry = instance.geometry;
    var attributes = geometry.attributes;
    var positions = attributes.position.values;
    var normals = defined(attributes.normal) ? attributes.normal.values : undefined;
    var binormals = defined(attributes.binormal) ? attributes.binormal.values : undefined;
    var tangents = defined(attributes.tangent) ? attributes.tangent.values : undefined;
    var texCoords = defined(attributes.st) ? attributes.st.values : undefined;
    var indices = geometry.indices;
    var eastGeometry = copyGeometryForSplit(geometry);
    var westGeometry = copyGeometryForSplit(geometry);
    var currentAttributes;
    var currentIndices;
    var currentIndexMap;
    var insertedIndex;
    var i;
    var westGeometryIndexMap = [];
    westGeometryIndexMap.length = positions.length / 3;
    var eastGeometryIndexMap = [];
    eastGeometryIndexMap.length = positions.length / 3;
    for (i = 0; i < westGeometryIndexMap.length; ++i) {
        westGeometryIndexMap[i] = -1;
        eastGeometryIndexMap[i] = -1;
    }
    var len = indices.length;
    for (i = 0; i < len; i += 3) {
        var i0 = indices[i];
        var i1 = indices[i + 1];
        var i2 = indices[i + 2];
        var p0 = Cartesian3.fromArray(positions, i0 * 3);
        var p1 = Cartesian3.fromArray(positions, i1 * 3);
        var p2 = Cartesian3.fromArray(positions, i2 * 3);
        var result = splitTriangle(p0, p1, p2);
        if (defined(result) && result.positions.length > 3) {
            var resultPositions = result.positions;
            var resultIndices = result.indices;
            var resultLength = resultIndices.length;
            for (var j = 0; j < resultLength; ++j) {
                var resultIndex = resultIndices[j];
                var point = resultPositions[resultIndex];
                if (point.y < 0) {
                    currentAttributes = westGeometry.attributes;
                    currentIndices = westGeometry.indices;
                    currentIndexMap = westGeometryIndexMap;
                } else {
                    currentAttributes = eastGeometry.attributes;
                    currentIndices = eastGeometry.indices;
                    currentIndexMap = eastGeometryIndexMap;
                }
                insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, resultIndex < 3 ? i + resultIndex : -1, point);
                computeTriangleAttributes(i0, i1, i2, point, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex);
            }
        } else {
            if (defined(result)) {
                p0 = result.positions[0];
                p1 = result.positions[1];
                p2 = result.positions[2];
            }
            if (p0.y < 0) {
                currentAttributes = westGeometry.attributes;
                currentIndices = westGeometry.indices;
                currentIndexMap = westGeometryIndexMap;
            } else {
                currentAttributes = eastGeometry.attributes;
                currentIndices = eastGeometry.indices;
                currentIndexMap = eastGeometryIndexMap;
            }
            insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);
            computeTriangleAttributes(i0, i1, i2, p0, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex);
            insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);
            computeTriangleAttributes(i0, i1, i2, p1, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex);
            insertedIndex = insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 2, p2);
            computeTriangleAttributes(i0, i1, i2, p2, positions, normals, binormals, tangents, texCoords, currentAttributes, insertedIndex);
        }
    }
    updateInstanceAfterSplit(instance, westGeometry, eastGeometry);
}
var xzPlane = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);
var offsetScratch = new Cartesian3();
var offsetPointScratch = new Cartesian3();
function splitLongitudeLines(instance) {
    var geometry = instance.geometry;
    var attributes = geometry.attributes;
    var positions = attributes.position.values;
    var indices = geometry.indices;
    var eastGeometry = copyGeometryForSplit(geometry);
    var westGeometry = copyGeometryForSplit(geometry);
    var i;
    var index;
    var length = indices.length;
    var westGeometryIndexMap = [];
    westGeometryIndexMap.length = positions.length / 3;
    var eastGeometryIndexMap = [];
    eastGeometryIndexMap.length = positions.length / 3;
    for (i = 0; i < westGeometryIndexMap.length; ++i) {
        westGeometryIndexMap[i] = -1;
        eastGeometryIndexMap[i] = -1;
    }
    for (i = 0; i < length; i += 2) {
        var i0 = indices[i];
        var i1 = indices[i + 1];
        var p0 = Cartesian3.fromArray(positions, i0 * 3, p0Scratch);
        var p1 = Cartesian3.fromArray(positions, i1 * 3, p1Scratch);
        if (Math.abs(p0.y) < CesiumMath.EPSILON6) {
            if (p0.y < 0) {
                p0.y = -CesiumMath.EPSILON6;
            } else {
                p0.y = CesiumMath.EPSILON6;
            }
        }
        if (Math.abs(p1.y) < CesiumMath.EPSILON6) {
            if (p1.y < 0) {
                p1.y = -CesiumMath.EPSILON6;
            } else {
                p1.y = CesiumMath.EPSILON6;
            }
        }
        var p0Attributes = eastGeometry.attributes;
        var p0Indices = eastGeometry.indices;
        var p0IndexMap = eastGeometryIndexMap;
        var p1Attributes = westGeometry.attributes;
        var p1Indices = westGeometry.indices;
        var p1IndexMap = westGeometryIndexMap;
        var intersection = IntersectionTests.lineSegmentPlane(p0, p1, xzPlane, p2Scratch);
        if (defined(intersection)) {
            var offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, 5 * CesiumMath.EPSILON9, offsetScratch);
            if (p0.y < 0) {
                Cartesian3.negate(offset, offset);
                p0Attributes = westGeometry.attributes;
                p0Indices = westGeometry.indices;
                p0IndexMap = westGeometryIndexMap;
                p1Attributes = eastGeometry.attributes;
                p1Indices = eastGeometry.indices;
                p1IndexMap = eastGeometryIndexMap;
            }
            var offsetPoint = Cartesian3.add(intersection, offset, offsetPointScratch);
            insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, i, p0);
            insertSplitPoint(p0Attributes, p0Indices, p0IndexMap, indices, -1, offsetPoint);
            Cartesian3.negate(offset, offset);
            Cartesian3.add(intersection, offset, offsetPoint);
            insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, -1, offsetPoint);
            insertSplitPoint(p1Attributes, p1Indices, p1IndexMap, indices, i + 1, p1);
        } else {
            var currentAttributes;
            var currentIndices;
            var currentIndexMap;
            if (p0.y < 0) {
                currentAttributes = westGeometry.attributes;
                currentIndices = westGeometry.indices;
                currentIndexMap = westGeometryIndexMap;
            } else {
                currentAttributes = eastGeometry.attributes;
                currentIndices = eastGeometry.indices;
                currentIndexMap = eastGeometryIndexMap;
            }
            insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i, p0);
            insertSplitPoint(currentAttributes, currentIndices, currentIndexMap, indices, i + 1, p1);
        }
    }
    updateInstanceAfterSplit(instance, westGeometry, eastGeometry);
}
var cartesian2Scratch0 = new Cartesian2();
var cartesian2Scratch1 = new Cartesian2();
var cartesian3Scratch0 = new Cartesian3();
var cartesian3Scratch1 = new Cartesian3();
var cartesian3Scratch2 = new Cartesian3();
var cartesian3Scratch3 = new Cartesian3();
var cartesian3Scratch4 = new Cartesian3();
var cartesian3Scratch5 = new Cartesian3();
var cartesian3Scratch6 = new Cartesian3();
var cartesian4Scratch0 = new Cartesian4();
var cartesian4Scratch1 = new Cartesian4();
function splitLongitudePolyline(instance) {
    var geometry = instance.geometry;
    var attributes = geometry.attributes;
    var positions = attributes.position.values;
    var prevPositions = attributes.prevPosition.values;
    var nextPositions = attributes.nextPosition.values;
    var expandAndWidths = attributes.expandAndWidth.values;
    var indices = geometry.indices;
    var texCoords = defined(attributes.st) ? attributes.st.values : undefined;
    var colors = defined(attributes.color) ? attributes.color.values : undefined;
    var eastGeometry = copyGeometryForSplit(geometry);
    var westGeometry = copyGeometryForSplit(geometry);
    var i;
    var j;
    var index;
    var length = positions.length / 3;
    for (i = 0; i < length; i += 4) {
        var i0 = i;
        var i1 = i + 1;
        var i2 = i + 2;
        var i3 = i + 3;
        var p0 = Cartesian3.fromArray(positions, i0 * 3, cartesian3Scratch0);
        var p1 = Cartesian3.fromArray(positions, i1 * 3, cartesian3Scratch1);
        var p2 = Cartesian3.fromArray(positions, i2 * 3, cartesian3Scratch2);
        var p3 = Cartesian3.fromArray(positions, i3 * 3, cartesian3Scratch3);
        if (Math.abs(p0.y) < CesiumMath.EPSILON6) {
            p0.y = CesiumMath.EPSILON6 * (p2.y < 0 ? -1 : 1);
            p1.y = p0.y;
        }
        if (Math.abs(p2.y) < CesiumMath.EPSILON6) {
            p2.y = CesiumMath.EPSILON6 * (p0.y < 0 ? -1 : 1);
            p3.y = p2.y;
        }
        var p0Attributes = eastGeometry.attributes;
        var p0Indices = eastGeometry.indices;
        var p2Attributes = westGeometry.attributes;
        var p2Indices = westGeometry.indices;
        var intersection = IntersectionTests.lineSegmentPlane(p0, p2, xzPlane, cartesian3Scratch4);
        if (defined(intersection)) {
            var offset = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y, 5 * CesiumMath.EPSILON9, cartesian3Scratch5);
            if (p0.y < 0) {
                Cartesian3.negate(offset, offset);
                p0Attributes = westGeometry.attributes;
                p0Indices = westGeometry.indices;
                p2Attributes = eastGeometry.attributes;
                p2Indices = eastGeometry.indices;
            }
            var offsetPoint = Cartesian3.add(intersection, offset, cartesian3Scratch6);
            p0Attributes.position.values.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);
            p0Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);
            Cartesian3.negate(offset, offset);
            Cartesian3.add(intersection, offset, offsetPoint);
            p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);
            p2Attributes.position.values.push(offsetPoint.x, offsetPoint.y, offsetPoint.z);
            p2Attributes.position.values.push(p2.x, p2.y, p2.z, p3.x, p3.y, p3.z);
            for (j = i0 * 3; j < i0 * 3 + 2 * 3; ++j) {
                p0Attributes.prevPosition.values.push(prevPositions[j]);
            }
            p0Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);
            p2Attributes.prevPosition.values.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z);
            for (j = i2 * 3; j < i2 * 3 + 2 * 3; ++j) {
                p2Attributes.prevPosition.values.push(prevPositions[j]);
            }
            for (j = i0 * 3; j < i0 * 3 + 2 * 3; ++j) {
                p0Attributes.nextPosition.values.push(nextPositions[j]);
            }
            p0Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
            p2Attributes.nextPosition.values.push(p2.x, p2.y, p2.z, p2.x, p2.y, p2.z);
            for (j = i2 * 3; j < i2 * 3 + 2 * 3; ++j) {
                p2Attributes.nextPosition.values.push(nextPositions[j]);
            }
            var ew0 = Cartesian2.fromArray(expandAndWidths, i0 * 2, cartesian2Scratch0);
            var width = Math.abs(ew0.y);
            p0Attributes.expandAndWidth.values.push(-1, width, 1, width);
            p0Attributes.expandAndWidth.values.push(-1, -width, 1, -width);
            p2Attributes.expandAndWidth.values.push(-1, width, 1, width);
            p2Attributes.expandAndWidth.values.push(-1, -width, 1, -width);
            var t = Cartesian3.magnitudeSquared(Cartesian3.subtract(intersection, p0, cartesian3Scratch3));
            t /= Cartesian3.magnitudeSquared(Cartesian3.subtract(p2, p0, cartesian3Scratch3));
            if (defined(colors)) {
                var c0 = Cartesian4.fromArray(colors, i0 * 4, cartesian4Scratch0);
                var c2 = Cartesian4.fromArray(colors, i2 * 4, cartesian4Scratch0);
                var r = CesiumMath.lerp(c0.x, c2.x, t);
                var g = CesiumMath.lerp(c0.y, c2.y, t);
                var b = CesiumMath.lerp(c0.z, c2.z, t);
                var a = CesiumMath.lerp(c0.w, c2.w, t);
                for (j = i0 * 4; j < i0 * 4 + 2 * 4; ++j) {
                    p0Attributes.color.values.push(colors[j]);
                }
                p0Attributes.color.values.push(r, g, b, a);
                p0Attributes.color.values.push(r, g, b, a);
                p2Attributes.color.values.push(r, g, b, a);
                p2Attributes.color.values.push(r, g, b, a);
                for (j = i2 * 4; j < i2 * 4 + 2 * 4; ++j) {
                    p2Attributes.color.values.push(colors[j]);
                }
            }
            if (defined(texCoords)) {
                var s0 = Cartesian2.fromArray(texCoords, i0 * 2, cartesian2Scratch0);
                var s3 = Cartesian2.fromArray(texCoords, (i + 3) * 2, cartesian2Scratch1);
                var sx = CesiumMath.lerp(s0.x, s3.x, t);
                for (j = i0 * 2; j < i0 * 2 + 2 * 2; ++j) {
                    p0Attributes.st.values.push(texCoords[j]);
                }
                p0Attributes.st.values.push(sx, s0.y);
                p0Attributes.st.values.push(sx, s3.y);
                p2Attributes.st.values.push(sx, s0.y);
                p2Attributes.st.values.push(sx, s3.y);
                for (j = i2 * 2; j < i2 * 2 + 2 * 2; ++j) {
                    p2Attributes.st.values.push(texCoords[j]);
                }
            }
            index = p0Attributes.position.values.length / 3 - 4;
            p0Indices.push(index, index + 2, index + 1);
            p0Indices.push(index + 1, index + 2, index + 3);
            index = p2Attributes.position.values.length / 3 - 4;
            p2Indices.push(index, index + 2, index + 1);
            p2Indices.push(index + 1, index + 2, index + 3);
        } else {
            var currentAttributes;
            var currentIndices;
            if (p0.y < 0) {
                currentAttributes = westGeometry.attributes;
                currentIndices = westGeometry.indices;
            } else {
                currentAttributes = eastGeometry.attributes;
                currentIndices = eastGeometry.indices;
            }
            currentAttributes.position.values.push(p0.x, p0.y, p0.z);
            currentAttributes.position.values.push(p1.x, p1.y, p1.z);
            currentAttributes.position.values.push(p2.x, p2.y, p2.z);
            currentAttributes.position.values.push(p3.x, p3.y, p3.z);
            for (j = i * 3; j < i * 3 + 4 * 3; ++j) {
                currentAttributes.prevPosition.values.push(prevPositions[j]);
                currentAttributes.nextPosition.values.push(nextPositions[j]);
            }
            for (j = i * 2; j < i * 2 + 4 * 2; ++j) {
                currentAttributes.expandAndWidth.values.push(expandAndWidths[j]);
                if (defined(texCoords)) {
                    currentAttributes.st.values.push(texCoords[j]);
                }
            }
            if (defined(colors)) {
                for (j = i * 4; j < i * 4 + 4 * 4; ++j) {
                    currentAttributes.color.values.push(colors[j]);
                }
            }
            index = currentAttributes.position.values.length / 3 - 4;
            currentIndices.push(index, index + 2, index + 1);
            currentIndices.push(index + 1, index + 2, index + 3);
        }
    }
    updateInstanceAfterSplit(instance, westGeometry, eastGeometry);
}
GeometryPipeline.splitLongitude = function (instance) {
    if (!defined(instance)) {
        throw new DeveloperError('instance is required.');
    }
    var geometry = instance.geometry;
    var boundingSphere = geometry.boundingSphere;
    if (defined(boundingSphere)) {
        var minX = boundingSphere.center.x - boundingSphere.radius;
        if (minX > 0 || BoundingSphere.intersect(boundingSphere, Cartesian4.UNIT_Y) !== Intersect.INTERSECTING) {
            return instance;
        }
    }
    if (geometry.geometryType !== GeometryType.NONE) {
        switch (geometry.geometryType) {
        case GeometryType.POLYLINES:
            splitLongitudePolyline(instance);
            break;
        case GeometryType.TRIANGLES:
            splitLongitudeTriangles(instance);
            break;
        case GeometryType.LINES:
            splitLongitudeLines(instance);
            break;
        }
    } else {
        indexPrimitive(geometry);
        if (geometry.primitiveType === PrimitiveType.TRIANGLES) {
            splitLongitudeTriangles(instance);
        } else if (geometry.primitiveType === PrimitiveType.LINES) {
            splitLongitudeLines(instance);
        }
    }
    return instance;
};
module.exports = GeometryPipeline;
},{"./AttributeCompression":94,"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./Cartesian4":103,"./Cartographic":104,"./ComponentDatatype":113,"./DeveloperError":123,"./EncodedCartesian3":137,"./GeographicProjection":143,"./Geometry":145,"./GeometryAttribute":146,"./GeometryInstance":148,"./GeometryType":151,"./IndexDatatype":162,"./Intersect":163,"./IntersectionTests":164,"./Math":174,"./Matrix3":176,"./Matrix4":177,"./Plane":182,"./PrimitiveType":193,"./Tipsify":225,"./barycentricCoordinates":237,"./defaultValue":243,"./defined":245}],151:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var GeometryType = {
        NONE: 0,
        TRIANGLES: 1,
        LINES: 2,
        POLYLINES: 3
    };
module.exports = freezeObject(GeometryType);
},{"./freezeObject":249}],152:[function(require,module,exports){
'use strict';
var GregorianDate = function (year, month, day, hour, minute, second, millisecond, isLeapSecond) {
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    this.isLeapSecond = isLeapSecond;
};
module.exports = GregorianDate;
},{}],153:[function(require,module,exports){
var when = require('../ThirdParty/when'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), GeographicTilingScheme = require('./GeographicTilingScheme'), HeightmapTessellator = require('./HeightmapTessellator'), CesiumMath = require('./Math'), Rectangle = require('./Rectangle'), TaskProcessor = require('./TaskProcessor'), TerrainMesh = require('./TerrainMesh'), TerrainProvider = require('./TerrainProvider');
'use strict';
var HeightmapTerrainData = function HeightmapTerrainData(options) {
    if (!defined(options) || !defined(options.buffer)) {
        throw new DeveloperError('options.buffer is required.');
    }
    if (!defined(options.width)) {
        throw new DeveloperError('options.width is required.');
    }
    if (!defined(options.height)) {
        throw new DeveloperError('options.height is required.');
    }
    this._buffer = options.buffer;
    this._width = options.width;
    this._height = options.height;
    this._childTileMask = defaultValue(options.childTileMask, 15);
    var defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;
    var structure = options.structure;
    if (!defined(structure)) {
        structure = defaultStructure;
    } else if (structure !== defaultStructure) {
        structure.heightScale = defaultValue(structure.heightScale, defaultStructure.heightScale);
        structure.heightOffset = defaultValue(structure.heightOffset, defaultStructure.heightOffset);
        structure.elementsPerHeight = defaultValue(structure.elementsPerHeight, defaultStructure.elementsPerHeight);
        structure.stride = defaultValue(structure.stride, defaultStructure.stride);
        structure.elementMultiplier = defaultValue(structure.elementMultiplier, defaultStructure.elementMultiplier);
        structure.isBigEndian = defaultValue(structure.isBigEndian, defaultStructure.isBigEndian);
    }
    this._structure = structure;
    this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);
    this._waterMask = options.waterMask;
};
defineProperties(HeightmapTerrainData.prototype, {
    waterMask: {
        get: function () {
            return this._waterMask;
        }
    }
});
var taskProcessor = new TaskProcessor('createVerticesFromHeightmap');
HeightmapTerrainData.prototype.createMesh = function (tilingScheme, x, y, level) {
    if (!defined(tilingScheme)) {
        throw new DeveloperError('tilingScheme is required.');
    }
    if (!defined(x)) {
        throw new DeveloperError('x is required.');
    }
    if (!defined(y)) {
        throw new DeveloperError('y is required.');
    }
    if (!defined(level)) {
        throw new DeveloperError('level is required.');
    }
    var ellipsoid = tilingScheme.ellipsoid;
    var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);
    var rectangle = tilingScheme.tileXYToRectangle(x, y, level);
    var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));
    var structure = this._structure;
    var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, this._width, tilingScheme.getNumberOfXTilesAtLevel(0));
    var thisLevelMaxError = levelZeroMaxError / (1 << level);
    var verticesPromise = taskProcessor.scheduleTask({
            heightmap: this._buffer,
            structure: structure,
            width: this._width,
            height: this._height,
            nativeRectangle: nativeRectangle,
            rectangle: rectangle,
            relativeToCenter: center,
            ellipsoid: ellipsoid,
            skirtHeight: Math.min(thisLevelMaxError * 4, 1000),
            isGeographic: tilingScheme instanceof GeographicTilingScheme
        });
    if (!defined(verticesPromise)) {
        return undefined;
    }
    return when(verticesPromise, function (result) {
        return new TerrainMesh(center, new Float32Array(result.vertices), TerrainProvider.getRegularGridIndices(result.gridWidth, result.gridHeight), result.minimumHeight, result.maximumHeight, result.boundingSphere3D, result.occludeePointInScaledSpace);
    });
};
HeightmapTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {
    var width = this._width;
    var height = this._height;
    var heightSample;
    var structure = this._structure;
    var stride = structure.stride;
    if (stride > 1) {
        var elementsPerHeight = structure.elementsPerHeight;
        var elementMultiplier = structure.elementMultiplier;
        var isBigEndian = structure.isBigEndian;
        heightSample = interpolateHeightWithStride(this._buffer, elementsPerHeight, elementMultiplier, stride, isBigEndian, rectangle, width, height, longitude, latitude);
    } else {
        heightSample = interpolateHeight(this._buffer, rectangle, width, height, longitude, latitude);
    }
    return heightSample * structure.heightScale + structure.heightOffset;
};
HeightmapTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {
    if (!defined(tilingScheme)) {
        throw new DeveloperError('tilingScheme is required.');
    }
    if (!defined(thisX)) {
        throw new DeveloperError('thisX is required.');
    }
    if (!defined(thisY)) {
        throw new DeveloperError('thisY is required.');
    }
    if (!defined(thisLevel)) {
        throw new DeveloperError('thisLevel is required.');
    }
    if (!defined(descendantX)) {
        throw new DeveloperError('descendantX is required.');
    }
    if (!defined(descendantY)) {
        throw new DeveloperError('descendantY is required.');
    }
    if (!defined(descendantLevel)) {
        throw new DeveloperError('descendantLevel is required.');
    }
    var levelDifference = descendantLevel - thisLevel;
    if (levelDifference > 1) {
        throw new DeveloperError('Upsampling through more than one level at a time is not currently supported.');
    }
    var result;
    if (this._width % 2 === 1 && this._height % 2 === 1) {
        result = upsampleBySubsetting(this, tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel);
    } else {
        result = upsampleByInterpolating(this, tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel);
    }
    return result;
};
HeightmapTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {
    if (!defined(thisX)) {
        throw new DeveloperError('thisX is required.');
    }
    if (!defined(thisY)) {
        throw new DeveloperError('thisY is required.');
    }
    if (!defined(childX)) {
        throw new DeveloperError('childX is required.');
    }
    if (!defined(childY)) {
        throw new DeveloperError('childY is required.');
    }
    var bitNumber = 2;
    if (childX !== thisX * 2) {
        ++bitNumber;
    }
    if (childY !== thisY * 2) {
        bitNumber -= 2;
    }
    return (this._childTileMask & 1 << bitNumber) !== 0;
};
HeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {
    return this._createdByUpsampling;
};
function upsampleBySubsetting(terrainData, tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {
    var levelDifference = 1;
    var width = terrainData._width;
    var height = terrainData._height;
    var leftPostIndex = descendantX * (width - 1);
    var rightPostIndex = leftPostIndex + width - 1;
    var topPostIndex = descendantY * (height - 1);
    var bottomPostIndex = topPostIndex + height - 1;
    var twoToTheLevelDifference = 1 << levelDifference;
    leftPostIndex /= twoToTheLevelDifference;
    rightPostIndex /= twoToTheLevelDifference;
    topPostIndex /= twoToTheLevelDifference;
    bottomPostIndex /= twoToTheLevelDifference;
    var sourceLeft = thisX * (width - 1);
    var sourceTop = thisY * (height - 1);
    leftPostIndex -= sourceLeft;
    rightPostIndex -= sourceLeft;
    topPostIndex -= sourceTop;
    bottomPostIndex -= sourceTop;
    var leftInteger = leftPostIndex | 0;
    var rightInteger = rightPostIndex | 0;
    var topInteger = topPostIndex | 0;
    var bottomInteger = bottomPostIndex | 0;
    var upsampledWidth = rightInteger - leftInteger + 1;
    var upsampledHeight = bottomInteger - topInteger + 1;
    var sourceHeights = terrainData._buffer;
    var structure = terrainData._structure;
    var numberOfHeights = upsampledWidth * upsampledHeight;
    var numberOfElements = numberOfHeights * structure.stride;
    var heights = new sourceHeights.constructor(numberOfElements);
    var outputIndex = 0;
    var i, j;
    var stride = structure.stride;
    if (stride > 1) {
        for (j = topInteger; j <= bottomInteger; ++j) {
            for (i = leftInteger; i <= rightInteger; ++i) {
                var index = (j * width + i) * stride;
                for (var k = 0; k < stride; ++k) {
                    heights[outputIndex++] = sourceHeights[index + k];
                }
            }
        }
    } else {
        for (j = topInteger; j <= bottomInteger; ++j) {
            for (i = leftInteger; i <= rightInteger; ++i) {
                heights[outputIndex++] = sourceHeights[j * width + i];
            }
        }
    }
    return new HeightmapTerrainData({
        buffer: heights,
        width: upsampledWidth,
        height: upsampledHeight,
        childTileMask: 0,
        structure: terrainData._structure,
        createdByUpsampling: true
    });
}
function upsampleByInterpolating(terrainData, tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {
    var width = terrainData._width;
    var height = terrainData._height;
    var structure = terrainData._structure;
    var stride = structure.stride;
    var sourceHeights = terrainData._buffer;
    var heights = new sourceHeights.constructor(width * height * stride);
    var sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);
    var destinationRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);
    var i, j, latitude, longitude;
    if (stride > 1) {
        var elementsPerHeight = structure.elementsPerHeight;
        var elementMultiplier = structure.elementMultiplier;
        var isBigEndian = structure.isBigEndian;
        var divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);
        for (j = 0; j < height; ++j) {
            latitude = CesiumMath.lerp(destinationRectangle.north, destinationRectangle.south, j / (height - 1));
            for (i = 0; i < width; ++i) {
                longitude = CesiumMath.lerp(destinationRectangle.west, destinationRectangle.east, i / (width - 1));
                var heightSample = interpolateHeightWithStride(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, sourceRectangle, width, height, longitude, latitude);
                setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, j * width + i, heightSample);
            }
        }
    } else {
        for (j = 0; j < height; ++j) {
            latitude = CesiumMath.lerp(destinationRectangle.north, destinationRectangle.south, j / (height - 1));
            for (i = 0; i < width; ++i) {
                longitude = CesiumMath.lerp(destinationRectangle.west, destinationRectangle.east, i / (width - 1));
                heights[j * width + i] = interpolateHeight(sourceHeights, sourceRectangle, width, height, longitude, latitude);
            }
        }
    }
    return new HeightmapTerrainData({
        buffer: heights,
        width: width,
        height: height,
        childTileMask: 0,
        structure: terrainData._structure,
        createdByUpsampling: true
    });
}
function interpolateHeight(sourceHeights, sourceRectangle, width, height, longitude, latitude) {
    var fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);
    var fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);
    var westInteger = fromWest | 0;
    var eastInteger = westInteger + 1;
    if (eastInteger >= width) {
        eastInteger = width - 1;
        westInteger = width - 2;
    }
    var southInteger = fromSouth | 0;
    var northInteger = southInteger + 1;
    if (northInteger >= height) {
        northInteger = height - 1;
        southInteger = height - 2;
    }
    var dx = fromWest - westInteger;
    var dy = fromSouth - southInteger;
    southInteger = height - 1 - southInteger;
    northInteger = height - 1 - northInteger;
    var southwestHeight = sourceHeights[southInteger * width + westInteger];
    var southeastHeight = sourceHeights[southInteger * width + eastInteger];
    var northwestHeight = sourceHeights[northInteger * width + westInteger];
    var northeastHeight = sourceHeights[northInteger * width + eastInteger];
    return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);
}
function interpolateHeightWithStride(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, sourceRectangle, width, height, longitude, latitude) {
    var fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);
    var fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);
    var westInteger = fromWest | 0;
    var eastInteger = westInteger + 1;
    if (eastInteger >= width) {
        eastInteger = width - 1;
        westInteger = width - 2;
    }
    var southInteger = fromSouth | 0;
    var northInteger = southInteger + 1;
    if (northInteger >= height) {
        northInteger = height - 1;
        southInteger = height - 2;
    }
    var dx = fromWest - westInteger;
    var dy = fromSouth - southInteger;
    southInteger = height - 1 - southInteger;
    northInteger = height - 1 - northInteger;
    var southwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + westInteger);
    var southeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + eastInteger);
    var northwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + westInteger);
    var northeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + eastInteger);
    return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);
}
function triangleInterpolateHeight(dX, dY, southwestHeight, southeastHeight, northwestHeight, northeastHeight) {
    if (dY < dX) {
        return southwestHeight + dX * (southeastHeight - southwestHeight) + dY * (northeastHeight - southeastHeight);
    }
    return southwestHeight + dX * (northeastHeight - northwestHeight) + dY * (northwestHeight - southwestHeight);
}
function getHeight(heights, elementsPerHeight, elementMultiplier, stride, isBigEndian, index) {
    index *= stride;
    var height = 0;
    var i;
    if (isBigEndian) {
        for (i = 0; i < elementsPerHeight; ++i) {
            height = height * elementMultiplier + heights[index + i];
        }
    } else {
        for (i = elementsPerHeight - 1; i >= 0; --i) {
            height = height * elementMultiplier + heights[index + i];
        }
    }
    return height;
}
function setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, index, height) {
    index *= stride;
    var i;
    if (isBigEndian) {
        for (i = 0; i < elementsPerHeight; ++i) {
            heights[index + i] = height / divisor | 0;
            height -= heights[index + i] * divisor;
            divisor /= elementMultiplier;
        }
    } else {
        for (i = elementsPerHeight - 1; i >= 0; --i) {
            heights[index + i] = height / divisor | 0;
            height -= heights[index + i] * divisor;
            divisor /= elementMultiplier;
        }
    }
}
module.exports = HeightmapTerrainData;
},{"../ThirdParty/when":596,"./DeveloperError":123,"./GeographicTilingScheme":144,"./HeightmapTessellator":154,"./Math":174,"./Rectangle":201,"./TaskProcessor":217,"./TerrainMesh":218,"./TerrainProvider":219,"./defaultValue":243,"./defineProperties":244,"./defined":245}],154:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math'), Rectangle = require('./Rectangle');
'use strict';
var HeightmapTessellator = {};
HeightmapTessellator.DEFAULT_STRUCTURE = freezeObject({
    heightScale: 1,
    heightOffset: 0,
    elementsPerHeight: 1,
    stride: 1,
    elementMultiplier: 256,
    isBigEndian: false
});
HeightmapTessellator.computeVertices = function (options) {
    if (!defined(options) || !defined(options.heightmap)) {
        throw new DeveloperError('options.heightmap is required.');
    }
    if (!defined(options.width) || !defined(options.height)) {
        throw new DeveloperError('options.width and options.height are required.');
    }
    if (!defined(options.vertices)) {
        throw new DeveloperError('options.vertices is required.');
    }
    if (!defined(options.nativeRectangle)) {
        throw new DeveloperError('options.nativeRectangle is required.');
    }
    if (!defined(options.skirtHeight)) {
        throw new DeveloperError('options.skirtHeight is required.');
    }
    var cos = Math.cos;
    var sin = Math.sin;
    var sqrt = Math.sqrt;
    var atan = Math.atan;
    var exp = Math.exp;
    var piOverTwo = CesiumMath.PI_OVER_TWO;
    var toRadians = CesiumMath.toRadians;
    var vertices = options.vertices;
    var heightmap = options.heightmap;
    var width = options.width;
    var height = options.height;
    var skirtHeight = options.skirtHeight;
    var isGeographic = defaultValue(options.isGeographic, true);
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var oneOverGlobeSemimajorAxis = 1 / ellipsoid.maximumRadius;
    var nativeRectangle = options.nativeRectangle;
    var geographicWest;
    var geographicSouth;
    var geographicEast;
    var geographicNorth;
    var rectangle = options.rectangle;
    if (!defined(rectangle)) {
        if (isGeographic) {
            geographicWest = toRadians(nativeRectangle.west);
            geographicSouth = toRadians(nativeRectangle.south);
            geographicEast = toRadians(nativeRectangle.east);
            geographicNorth = toRadians(nativeRectangle.north);
        } else {
            geographicWest = nativeRectangle.west * oneOverGlobeSemimajorAxis;
            geographicSouth = piOverTwo - 2 * atan(exp(-nativeRectangle.south * oneOverGlobeSemimajorAxis));
            geographicEast = nativeRectangle.east * oneOverGlobeSemimajorAxis;
            geographicNorth = piOverTwo - 2 * atan(exp(-nativeRectangle.north * oneOverGlobeSemimajorAxis));
        }
    } else {
        geographicWest = rectangle.west;
        geographicSouth = rectangle.south;
        geographicEast = rectangle.east;
        geographicNorth = rectangle.north;
    }
    var relativeToCenter = defaultValue(options.relativeToCenter, Cartesian3.ZERO);
    var structure = defaultValue(options.structure, HeightmapTessellator.DEFAULT_STRUCTURE);
    var heightScale = defaultValue(structure.heightScale, HeightmapTessellator.DEFAULT_STRUCTURE.heightScale);
    var heightOffset = defaultValue(structure.heightOffset, HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset);
    var elementsPerHeight = defaultValue(structure.elementsPerHeight, HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight);
    var stride = defaultValue(structure.stride, HeightmapTessellator.DEFAULT_STRUCTURE.stride);
    var elementMultiplier = defaultValue(structure.elementMultiplier, HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier);
    var isBigEndian = defaultValue(structure.isBigEndian, HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian);
    var granularityX = Rectangle.computeWidth(nativeRectangle) / (width - 1);
    var granularityY = Rectangle.computeHeight(nativeRectangle) / (height - 1);
    var radiiSquared = ellipsoid.radiiSquared;
    var radiiSquaredX = radiiSquared.x;
    var radiiSquaredY = radiiSquared.y;
    var radiiSquaredZ = radiiSquared.z;
    var vertexArrayIndex = 0;
    var minimumHeight = 65536;
    var maximumHeight = -65536;
    var startRow = 0;
    var endRow = height;
    var startCol = 0;
    var endCol = width;
    if (skirtHeight > 0) {
        --startRow;
        ++endRow;
        --startCol;
        ++endCol;
    }
    for (var rowIndex = startRow; rowIndex < endRow; ++rowIndex) {
        var row = rowIndex;
        if (row < 0) {
            row = 0;
        }
        if (row >= height) {
            row = height - 1;
        }
        var latitude = nativeRectangle.north - granularityY * row;
        if (!isGeographic) {
            latitude = piOverTwo - 2 * atan(exp(-latitude * oneOverGlobeSemimajorAxis));
        } else {
            latitude = toRadians(latitude);
        }
        var cosLatitude = cos(latitude);
        var nZ = sin(latitude);
        var kZ = radiiSquaredZ * nZ;
        var v = (latitude - geographicSouth) / (geographicNorth - geographicSouth);
        for (var colIndex = startCol; colIndex < endCol; ++colIndex) {
            var col = colIndex;
            if (col < 0) {
                col = 0;
            }
            if (col >= width) {
                col = width - 1;
            }
            var longitude = nativeRectangle.west + granularityX * col;
            if (!isGeographic) {
                longitude = longitude * oneOverGlobeSemimajorAxis;
            } else {
                longitude = toRadians(longitude);
            }
            var terrainOffset = row * (width * stride) + col * stride;
            var heightSample;
            if (elementsPerHeight === 1) {
                heightSample = heightmap[terrainOffset];
            } else {
                heightSample = 0;
                var elementOffset;
                if (isBigEndian) {
                    for (elementOffset = 0; elementOffset < elementsPerHeight; ++elementOffset) {
                        heightSample = heightSample * elementMultiplier + heightmap[terrainOffset + elementOffset];
                    }
                } else {
                    for (elementOffset = elementsPerHeight - 1; elementOffset >= 0; --elementOffset) {
                        heightSample = heightSample * elementMultiplier + heightmap[terrainOffset + elementOffset];
                    }
                }
            }
            heightSample = heightSample * heightScale + heightOffset;
            maximumHeight = Math.max(maximumHeight, heightSample);
            minimumHeight = Math.min(minimumHeight, heightSample);
            if (colIndex !== col || rowIndex !== row) {
                heightSample -= skirtHeight;
            }
            var nX = cosLatitude * cos(longitude);
            var nY = cosLatitude * sin(longitude);
            var kX = radiiSquaredX * nX;
            var kY = radiiSquaredY * nY;
            var gamma = sqrt(kX * nX + kY * nY + kZ * nZ);
            var oneOverGamma = 1 / gamma;
            var rSurfaceX = kX * oneOverGamma;
            var rSurfaceY = kY * oneOverGamma;
            var rSurfaceZ = kZ * oneOverGamma;
            vertices[vertexArrayIndex++] = rSurfaceX + nX * heightSample - relativeToCenter.x;
            vertices[vertexArrayIndex++] = rSurfaceY + nY * heightSample - relativeToCenter.y;
            vertices[vertexArrayIndex++] = rSurfaceZ + nZ * heightSample - relativeToCenter.z;
            vertices[vertexArrayIndex++] = heightSample;
            var u = (longitude - geographicWest) / (geographicEast - geographicWest);
            vertices[vertexArrayIndex++] = u;
            vertices[vertexArrayIndex++] = v;
        }
    }
    return {
        maximumHeight: maximumHeight,
        minimumHeight: minimumHeight
    };
};
module.exports = HeightmapTessellator;
},{"./Cartesian3":102,"./DeveloperError":123,"./Ellipsoid":130,"./Math":174,"./Rectangle":201,"./defaultValue":243,"./defined":245,"./freezeObject":249}],155:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), CesiumMath = require('./Math');
'use strict';
var factorial = CesiumMath.factorial;
function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {
    var result = 0;
    var reserved;
    var i;
    var j;
    if (derivOrder > 0) {
        for (i = 0; i < termOrder; i++) {
            reserved = false;
            for (j = 0; j < reservedIndices.length && !reserved; j++) {
                if (i === reservedIndices[j]) {
                    reserved = true;
                }
            }
            if (!reserved) {
                reservedIndices.push(i);
                result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);
                reservedIndices.splice(reservedIndices.length - 1, 1);
            }
        }
        return result;
    }
    result = 1;
    for (i = 0; i < termOrder; i++) {
        reserved = false;
        for (j = 0; j < reservedIndices.length && !reserved; j++) {
            if (i === reservedIndices[j]) {
                reserved = true;
            }
        }
        if (!reserved) {
            result *= x - xTable[zIndices[i]];
        }
    }
    return result;
}
var HermitePolynomialApproximation = { type: 'Hermite' };
HermitePolynomialApproximation.getRequiredDataPoints = function (degree, inputOrder) {
    inputOrder = defaultValue(inputOrder, 0);
    if (!defined(degree)) {
        throw new DeveloperError('degree is required.');
    }
    if (degree < 0) {
        throw new DeveloperError('degree must be 0 or greater.');
    }
    if (inputOrder < 0) {
        throw new DeveloperError('inputOrder must be 0 or greater.');
    }
    return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);
};
HermitePolynomialApproximation.interpolateOrderZero = function (x, xTable, yTable, yStride, result) {
    if (!defined(result)) {
        result = new Array(yStride);
    }
    var i;
    var j;
    var d;
    var s;
    var len;
    var index;
    var length = xTable.length;
    var coefficients = new Array(yStride);
    for (i = 0; i < yStride; i++) {
        result[i] = 0;
        var l = new Array(length);
        coefficients[i] = l;
        for (j = 0; j < length; j++) {
            l[j] = [];
        }
    }
    var zIndicesLength = length, zIndices = new Array(zIndicesLength);
    for (i = 0; i < zIndicesLength; i++) {
        zIndices[i] = i;
    }
    var highestNonZeroCoef = length - 1;
    for (s = 0; s < yStride; s++) {
        for (j = 0; j < zIndicesLength; j++) {
            index = zIndices[j] * yStride + s;
            coefficients[s][0].push(yTable[index]);
        }
        for (i = 1; i < zIndicesLength; i++) {
            var nonZeroCoefficients = false;
            for (j = 0; j < zIndicesLength - i; j++) {
                var zj = xTable[zIndices[j]];
                var zn = xTable[zIndices[j + i]];
                var numerator;
                if (zn - zj <= 0) {
                    index = zIndices[j] * yStride + yStride * i + s;
                    numerator = yTable[index];
                    coefficients[s][i].push(numerator / factorial(i));
                } else {
                    numerator = coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j];
                    coefficients[s][i].push(numerator / (zn - zj));
                }
                nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;
            }
            if (!nonZeroCoefficients) {
                highestNonZeroCoef = i - 1;
            }
        }
    }
    for (d = 0, len = 0; d <= len; d++) {
        for (i = d; i <= highestNonZeroCoef; i++) {
            var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);
            for (s = 0; s < yStride; s++) {
                var coeff = coefficients[s][i][0];
                result[s + d * yStride] += coeff * tempTerm;
            }
        }
    }
    return result;
};
var arrayScratch = [];
HermitePolynomialApproximation.interpolate = function (x, xTable, yTable, yStride, inputOrder, outputOrder, result) {
    var resultLength = yStride * (outputOrder + 1);
    if (!defined(result)) {
        result = new Array(resultLength);
    }
    for (var r = 0; r < resultLength; r++) {
        result[r] = 0;
    }
    var length = xTable.length;
    var zIndices = new Array(length * (inputOrder + 1));
    for (var i = 0; i < length; i++) {
        for (var j = 0; j < inputOrder + 1; j++) {
            zIndices[i * (inputOrder + 1) + j] = i;
        }
    }
    var zIndiceslength = zIndices.length;
    var coefficients = arrayScratch;
    var highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);
    var reservedIndices = [];
    var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
    var loopStop = Math.min(highestNonZeroCoef, outputOrder);
    for (var d = 0; d <= loopStop; d++) {
        for (i = d; i <= highestNonZeroCoef; i++) {
            reservedIndices.length = 0;
            var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);
            var dimTwo = Math.floor(i * (1 - i) / 2) + zIndiceslength * i;
            for (var s = 0; s < yStride; s++) {
                var dimOne = Math.floor(s * tmp);
                var coef = coefficients[dimOne + dimTwo];
                result[s + d * yStride] += coef * tempTerm;
            }
        }
    }
    return result;
};
function fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {
    var j;
    var index;
    var highestNonZero = -1;
    var zIndiceslength = zIndices.length;
    var tmp = zIndiceslength * (zIndiceslength + 1) / 2;
    for (var s = 0; s < yStride; s++) {
        var dimOne = Math.floor(s * tmp);
        for (j = 0; j < zIndiceslength; j++) {
            index = zIndices[j] * yStride * (inputOrder + 1) + s;
            coefficients[dimOne + j] = yTable[index];
        }
        for (var i = 1; i < zIndiceslength; i++) {
            var coefIndex = 0;
            var dimTwo = Math.floor(i * (1 - i) / 2) + zIndiceslength * i;
            var nonZeroCoefficients = false;
            for (j = 0; j < zIndiceslength - i; j++) {
                var zj = xTable[zIndices[j]];
                var zn = xTable[zIndices[j + i]];
                var numerator;
                var coefficient;
                if (zn - zj <= 0) {
                    index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;
                    numerator = yTable[index];
                    coefficient = numerator / CesiumMath.factorial(i);
                    coefficients[dimOne + dimTwo + coefIndex] = coefficient;
                    coefIndex++;
                } else {
                    var dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + zIndiceslength * (i - 1);
                    numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];
                    coefficient = numerator / (zn - zj);
                    coefficients[dimOne + dimTwo + coefIndex] = coefficient;
                    coefIndex++;
                }
                nonZeroCoefficients = nonZeroCoefficients || numerator !== 0;
            }
            if (nonZeroCoefficients) {
                highestNonZero = Math.max(highestNonZero, i);
            }
        }
    }
    return highestNonZero;
}
module.exports = HermitePolynomialApproximation;
},{"./DeveloperError":123,"./Math":174,"./defaultValue":243,"./defined":245}],156:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartesian4 = require('./Cartesian4'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), LinearSpline = require('./LinearSpline'), Matrix4 = require('./Matrix4'), Spline = require('./Spline'), TridiagonalSystemSolver = require('./TridiagonalSystemSolver');
'use strict';
var scratchLower = [];
var scratchDiagonal = [];
var scratchUpper = [];
var scratchRight = [];
function generateClamped(points, firstTangent, lastTangent) {
    var l = scratchLower;
    var u = scratchUpper;
    var d = scratchDiagonal;
    var r = scratchRight;
    l.length = u.length = points.length - 1;
    d.length = r.length = points.length;
    var i;
    l[0] = d[0] = 1;
    u[0] = 0;
    var right = r[0];
    if (!defined(right)) {
        right = r[0] = new Cartesian3();
    }
    Cartesian3.clone(firstTangent, right);
    for (i = 1; i < l.length - 1; ++i) {
        l[i] = u[i] = 1;
        d[i] = 4;
        right = r[i];
        if (!defined(right)) {
            right = r[i] = new Cartesian3();
        }
        Cartesian3.subtract(points[i + 1], points[i - 1], right);
        Cartesian3.multiplyByScalar(right, 3, right);
    }
    l[i] = 0;
    u[i] = 1;
    d[i] = 4;
    right = r[i];
    if (!defined(right)) {
        right = r[i] = new Cartesian3();
    }
    Cartesian3.subtract(points[i + 1], points[i - 1], right);
    Cartesian3.multiplyByScalar(right, 3, right);
    d[i + 1] = 1;
    right = r[i + 1];
    if (!defined(right)) {
        right = r[i + 1] = new Cartesian3();
    }
    Cartesian3.clone(lastTangent, right);
    return TridiagonalSystemSolver.solve(l, d, u, r);
}
function generateNatural(points) {
    var l = scratchLower;
    var u = scratchUpper;
    var d = scratchDiagonal;
    var r = scratchRight;
    l.length = u.length = points.length - 1;
    d.length = r.length = points.length;
    var i;
    l[0] = u[0] = 1;
    d[0] = 2;
    var right = r[0];
    if (!defined(right)) {
        right = r[0] = new Cartesian3();
    }
    Cartesian3.subtract(points[1], points[0], right);
    Cartesian3.multiplyByScalar(right, 3, right);
    for (i = 1; i < l.length; ++i) {
        l[i] = u[i] = 1;
        d[i] = 4;
        right = r[i];
        if (!defined(right)) {
            right = r[i] = new Cartesian3();
        }
        Cartesian3.subtract(points[i + 1], points[i - 1], right);
        Cartesian3.multiplyByScalar(right, 3, right);
    }
    d[i] = 2;
    right = r[i];
    if (!defined(right)) {
        right = r[i] = new Cartesian3();
    }
    Cartesian3.subtract(points[i], points[i - 1], right);
    Cartesian3.multiplyByScalar(right, 3, right);
    return TridiagonalSystemSolver.solve(l, d, u, r);
}
var HermiteSpline = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var points = options.points;
    var times = options.times;
    var inTangents = options.inTangents;
    var outTangents = options.outTangents;
    if (!defined(points) || !defined(times) || !defined(inTangents) || !defined(outTangents)) {
        throw new DeveloperError('times, points, inTangents, and outTangents are required.');
    }
    if (points.length < 2) {
        throw new DeveloperError('points.length must be greater than or equal to 2.');
    }
    if (times.length !== points.length) {
        throw new DeveloperError('times.length must be equal to points.length.');
    }
    if (inTangents.length !== outTangents.length || inTangents.length !== points.length - 1) {
        throw new DeveloperError('inTangents and outTangents must have a length equal to points.length - 1.');
    }
    this._times = times;
    this._points = points;
    this._inTangents = inTangents;
    this._outTangents = outTangents;
    this._lastTimeIndex = 0;
};
defineProperties(HermiteSpline.prototype, {
    times: {
        get: function () {
            return this._times;
        }
    },
    points: {
        get: function () {
            return this._points;
        }
    },
    inTangents: {
        get: function () {
            return this._inTangents;
        }
    },
    outTangents: {
        get: function () {
            return this._outTangents;
        }
    }
});
HermiteSpline.createC1 = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var times = options.times;
    var points = options.points;
    var tangents = options.tangents;
    if (!defined(points) || !defined(times) || !defined(tangents)) {
        throw new DeveloperError('points, times and tangents are required.');
    }
    if (points.length < 2) {
        throw new DeveloperError('points.length must be greater than or equal to 2.');
    }
    if (times.length !== points.length || times.length !== tangents.length) {
        throw new DeveloperError('times, points and tangents must have the same length.');
    }
    var outTangents = tangents.slice(0, tangents.length - 1);
    var inTangents = tangents.slice(1, tangents.length);
    return new HermiteSpline({
        times: times,
        points: points,
        inTangents: inTangents,
        outTangents: outTangents
    });
};
HermiteSpline.createNaturalCubic = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var times = options.times;
    var points = options.points;
    if (!defined(points) || !defined(times)) {
        throw new DeveloperError('points and times are required.');
    }
    if (points.length < 2) {
        throw new DeveloperError('points.length must be greater than or equal to 2.');
    }
    if (times.length !== points.length) {
        throw new DeveloperError('times.length must be equal to points.length.');
    }
    if (points.length < 3) {
        return new LinearSpline({
            points: points,
            times: times
        });
    }
    var tangents = generateNatural(points);
    var outTangents = tangents.slice(0, tangents.length - 1);
    var inTangents = tangents.slice(1, tangents.length);
    return new HermiteSpline({
        times: times,
        points: points,
        inTangents: inTangents,
        outTangents: outTangents
    });
};
HermiteSpline.createClampedCubic = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var times = options.times;
    var points = options.points;
    var firstTangent = options.firstTangent;
    var lastTangent = options.lastTangent;
    if (!defined(points) || !defined(times) || !defined(firstTangent) || !defined(lastTangent)) {
        throw new DeveloperError('points, times, firstTangent and lastTangent are required.');
    }
    if (points.length < 2) {
        throw new DeveloperError('points.length must be greater than or equal to 2.');
    }
    if (times.length !== points.length) {
        throw new DeveloperError('times.length must be equal to points.length.');
    }
    if (points.length < 3) {
        return new LinearSpline({
            points: points,
            times: times
        });
    }
    var tangents = generateClamped(points, firstTangent, lastTangent);
    var outTangents = tangents.slice(0, tangents.length - 1);
    var inTangents = tangents.slice(1, tangents.length);
    return new HermiteSpline({
        times: times,
        points: points,
        inTangents: inTangents,
        outTangents: outTangents
    });
};
HermiteSpline.hermiteCoefficientMatrix = new Matrix4(2, -3, 0, 1, -2, 3, 0, 0, 1, -2, 1, 0, 1, -1, 0, 0);
HermiteSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;
var scratchTimeVec = new Cartesian4();
var scratchTemp = new Cartesian3();
HermiteSpline.prototype.evaluate = function (time, result) {
    if (!defined(result)) {
        result = new Cartesian3();
    }
    var points = this.points;
    var times = this.times;
    var inTangents = this.inTangents;
    var outTangents = this.outTangents;
    var i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);
    var u = (time - times[i]) / (times[i + 1] - times[i]);
    var timeVec = scratchTimeVec;
    timeVec.z = u;
    timeVec.y = u * u;
    timeVec.x = timeVec.y * u;
    timeVec.w = 1;
    var coefs = Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix, timeVec, timeVec);
    result = Cartesian3.multiplyByScalar(points[i], coefs.x, result);
    Cartesian3.multiplyByScalar(points[i + 1], coefs.y, scratchTemp);
    Cartesian3.add(result, scratchTemp, result);
    Cartesian3.multiplyByScalar(outTangents[i], coefs.z, scratchTemp);
    Cartesian3.add(result, scratchTemp, result);
    Cartesian3.multiplyByScalar(inTangents[i], coefs.w, scratchTemp);
    return Cartesian3.add(result, scratchTemp, result);
};
module.exports = HermiteSpline;
},{"./Cartesian3":102,"./Cartesian4":103,"./DeveloperError":123,"./LinearSpline":173,"./Matrix4":177,"./Spline":216,"./TridiagonalSystemSolver":227,"./defaultValue":243,"./defineProperties":244,"./defined":245}],157:[function(require,module,exports){
var defined = require('./defined'), IauOrientationParameters = require('./IauOrientationParameters'), JulianDate = require('./JulianDate'), CesiumMath = require('./Math'), TimeConstants = require('./TimeConstants');
'use strict';
var Iau2000Orientation = {};
var TdtMinusTai = 32.184;
var J2000d = 2451545;
var c1 = -0.0529921;
var c2 = -0.1059842;
var c3 = 13.0120009;
var c4 = 13.3407154;
var c5 = 0.9856003;
var c6 = 26.4057084;
var c7 = 13.064993;
var c8 = 0.3287146;
var c9 = 1.7484877;
var c10 = -0.1589763;
var c11 = 0.0036096;
var c12 = 0.1643573;
var c13 = 12.9590088;
var dateTT = new JulianDate();
Iau2000Orientation.ComputeMoon = function (date, result) {
    if (!defined(date)) {
        date = JulianDate.now();
    }
    dateTT = JulianDate.addSeconds(date, TdtMinusTai, dateTT);
    var d = JulianDate.totalDays(dateTT) - J2000d;
    var T = d / TimeConstants.DAYS_PER_JULIAN_CENTURY;
    var E1 = (125.045 + c1 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E2 = (250.089 + c2 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E3 = (260.008 + c3 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E4 = (176.625 + c4 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E5 = (357.529 + c5 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E6 = (311.589 + c6 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E7 = (134.963 + c7 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E8 = (276.617 + c8 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E9 = (34.226 + c9 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E10 = (15.134 + c10 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E11 = (119.743 + c11 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E12 = (239.961 + c12 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var E13 = (25.053 + c13 * d) * CesiumMath.RADIANS_PER_DEGREE;
    var sinE1 = Math.sin(E1);
    var sinE2 = Math.sin(E2);
    var sinE3 = Math.sin(E3);
    var sinE4 = Math.sin(E4);
    var sinE5 = Math.sin(E5);
    var sinE6 = Math.sin(E6);
    var sinE7 = Math.sin(E7);
    var sinE8 = Math.sin(E8);
    var sinE9 = Math.sin(E9);
    var sinE10 = Math.sin(E10);
    var sinE11 = Math.sin(E11);
    var sinE12 = Math.sin(E12);
    var sinE13 = Math.sin(E13);
    var cosE1 = Math.cos(E1);
    var cosE2 = Math.cos(E2);
    var cosE3 = Math.cos(E3);
    var cosE4 = Math.cos(E4);
    var cosE5 = Math.cos(E5);
    var cosE6 = Math.cos(E6);
    var cosE7 = Math.cos(E7);
    var cosE8 = Math.cos(E8);
    var cosE9 = Math.cos(E9);
    var cosE10 = Math.cos(E10);
    var cosE11 = Math.cos(E11);
    var cosE12 = Math.cos(E12);
    var cosE13 = Math.cos(E13);
    var rightAscension = (269.9949 + 0.0031 * T - 3.8787 * sinE1 - 0.1204 * sinE2 + 0.07 * sinE3 - 0.0172 * sinE4 + 0.0072 * sinE6 - 0.0052 * sinE10 + 0.0043 * sinE13) * CesiumMath.RADIANS_PER_DEGREE;
    var declination = (66.5392 + 0.013 * T + 1.5419 * cosE1 + 0.0239 * cosE2 - 0.0278 * cosE3 + 0.0068 * cosE4 - 0.0029 * cosE6 + 0.0009 * cosE7 + 0.0008 * cosE10 - 0.0009 * cosE13) * CesiumMath.RADIANS_PER_DEGREE;
    var rotation = (38.3213 + 13.17635815 * d - 1.4e-12 * d * d + 3.561 * sinE1 + 0.1208 * sinE2 - 0.0642 * sinE3 + 0.0158 * sinE4 + 0.0252 * sinE5 - 0.0066 * sinE6 - 0.0047 * sinE7 - 0.0046 * sinE8 + 0.0028 * sinE9 + 0.0052 * sinE10 + 0.004 * sinE11 + 0.0019 * sinE12 - 0.0044 * sinE13) * CesiumMath.RADIANS_PER_DEGREE;
    var rotationRate = (13.17635815 - 1.4e-12 * (2 * d) + 3.561 * cosE1 * c1 + 0.1208 * cosE2 * c2 - 0.0642 * cosE3 * c3 + 0.0158 * cosE4 * c4 + 0.0252 * cosE5 * c5 - 0.0066 * cosE6 * c6 - 0.0047 * cosE7 * c7 - 0.0046 * cosE8 * c8 + 0.0028 * cosE9 * c9 + 0.0052 * cosE10 * c10 + 0.004 * cosE11 * c11 + 0.0019 * cosE12 * c12 - 0.0044 * cosE13 * c13) / 86400 * CesiumMath.RADIANS_PER_DEGREE;
    if (!defined(result)) {
        result = new IauOrientationParameters();
    }
    result.rightAscension = rightAscension;
    result.declination = declination;
    result.rotation = rotation;
    result.rotationRate = rotationRate;
    return result;
};
module.exports = Iau2000Orientation;
},{"./IauOrientationParameters":161,"./JulianDate":168,"./Math":174,"./TimeConstants":221,"./defined":245}],158:[function(require,module,exports){
var when = require('../ThirdParty/when'), buildModuleUrl = require('./buildModuleUrl'), defaultValue = require('./defaultValue'), defined = require('./defined'), Iau2006XysSample = require('./Iau2006XysSample'), JulianDate = require('./JulianDate'), loadJson = require('./loadJson'), TimeStandard = require('./TimeStandard');
'use strict';
var Iau2006XysData = function Iau2006XysData(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._xysFileUrlTemplate = options.xysFileUrlTemplate;
    this._interpolationOrder = defaultValue(options.interpolationOrder, 9);
    this._sampleZeroJulianEphemerisDate = defaultValue(options.sampleZeroJulianEphemerisDate, 2442396.5);
    this._sampleZeroDateTT = new JulianDate(this._sampleZeroJulianEphemerisDate, 0, TimeStandard.TAI);
    this._stepSizeDays = defaultValue(options.stepSizeDays, 1);
    this._samplesPerXysFile = defaultValue(options.samplesPerXysFile, 1000);
    this._totalSamples = defaultValue(options.totalSamples, 27426);
    this._samples = new Array(this._totalSamples * 3);
    this._chunkDownloadsInProgress = [];
    var order = this._interpolationOrder;
    var denom = this._denominators = new Array(order + 1);
    var xTable = this._xTable = new Array(order + 1);
    var stepN = Math.pow(this._stepSizeDays, order);
    for (var i = 0; i <= order; ++i) {
        denom[i] = stepN;
        xTable[i] = i * this._stepSizeDays;
        for (var j = 0; j <= order; ++j) {
            if (j !== i) {
                denom[i] *= i - j;
            }
        }
        denom[i] = 1 / denom[i];
    }
    this._work = new Array(order + 1);
    this._coef = new Array(order + 1);
};
var julianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);
function getDaysSinceEpoch(xys, dayTT, secondTT) {
    var dateTT = julianDateScratch;
    dateTT.dayNumber = dayTT;
    dateTT.secondsOfDay = secondTT;
    return JulianDate.daysDifference(dateTT, xys._sampleZeroDateTT);
}
Iau2006XysData.prototype.preload = function (startDayTT, startSecondTT, stopDayTT, stopSecondTT) {
    var startDaysSinceEpoch = getDaysSinceEpoch(this, startDayTT, startSecondTT);
    var stopDaysSinceEpoch = getDaysSinceEpoch(this, stopDayTT, stopSecondTT);
    var startIndex = startDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2 | 0;
    if (startIndex < 0) {
        startIndex = 0;
    }
    var stopIndex = stopDaysSinceEpoch / this._stepSizeDays - this._interpolationOrder / 2 | 0 + this._interpolationOrder;
    if (stopIndex >= this._totalSamples) {
        stopIndex = this._totalSamples - 1;
    }
    var startChunk = startIndex / this._samplesPerXysFile | 0;
    var stopChunk = stopIndex / this._samplesPerXysFile | 0;
    var promises = [];
    for (var i = startChunk; i <= stopChunk; ++i) {
        promises.push(requestXysChunk(this, i));
    }
    return when.all(promises);
};
Iau2006XysData.prototype.computeXysRadians = function (dayTT, secondTT, result) {
    var daysSinceEpoch = getDaysSinceEpoch(this, dayTT, secondTT);
    if (daysSinceEpoch < 0) {
        return undefined;
    }
    var centerIndex = daysSinceEpoch / this._stepSizeDays | 0;
    if (centerIndex >= this._totalSamples) {
        return undefined;
    }
    var degree = this._interpolationOrder;
    var firstIndex = centerIndex - (degree / 2 | 0);
    if (firstIndex < 0) {
        firstIndex = 0;
    }
    var lastIndex = firstIndex + degree;
    if (lastIndex >= this._totalSamples) {
        lastIndex = this._totalSamples - 1;
        firstIndex = lastIndex - degree;
        if (firstIndex < 0) {
            firstIndex = 0;
        }
    }
    var isDataMissing = false;
    var samples = this._samples;
    if (!defined(samples[firstIndex * 3])) {
        requestXysChunk(this, firstIndex / this._samplesPerXysFile | 0);
        isDataMissing = true;
    }
    if (!defined(samples[lastIndex * 3])) {
        requestXysChunk(this, lastIndex / this._samplesPerXysFile | 0);
        isDataMissing = true;
    }
    if (isDataMissing) {
        return undefined;
    }
    if (!defined(result)) {
        result = new Iau2006XysSample(0, 0, 0);
    } else {
        result.x = 0;
        result.y = 0;
        result.s = 0;
    }
    var x = daysSinceEpoch - firstIndex * this._stepSizeDays;
    var work = this._work;
    var denom = this._denominators;
    var coef = this._coef;
    var xTable = this._xTable;
    var i, j;
    for (i = 0; i <= degree; ++i) {
        work[i] = x - xTable[i];
    }
    for (i = 0; i <= degree; ++i) {
        coef[i] = 1;
        for (j = 0; j <= degree; ++j) {
            if (j !== i) {
                coef[i] *= work[j];
            }
        }
        coef[i] *= denom[i];
        var sampleIndex = (firstIndex + i) * 3;
        result.x += coef[i] * samples[sampleIndex++];
        result.y += coef[i] * samples[sampleIndex++];
        result.s += coef[i] * samples[sampleIndex];
    }
    return result;
};
function requestXysChunk(xysData, chunkIndex) {
    if (xysData._chunkDownloadsInProgress[chunkIndex]) {
        return xysData._chunkDownloadsInProgress[chunkIndex];
    }
    var deferred = when.defer();
    xysData._chunkDownloadsInProgress[chunkIndex] = deferred;
    var chunkUrl;
    var xysFileUrlTemplate = xysData._xysFileUrlTemplate;
    if (defined(xysFileUrlTemplate)) {
        chunkUrl = xysFileUrlTemplate.replace('{0}', chunkIndex);
    } else {
        chunkUrl = buildModuleUrl('Assets/IAU2006_XYS/IAU2006_XYS_' + chunkIndex + '.json');
    }
    when(loadJson(chunkUrl), function (chunk) {
        xysData._chunkDownloadsInProgress[chunkIndex] = false;
        var samples = xysData._samples;
        var newSamples = chunk.samples;
        var startIndex = chunkIndex * xysData._samplesPerXysFile * 3;
        for (var i = 0, len = newSamples.length; i < len; ++i) {
            samples[startIndex + i] = newSamples[i];
        }
        deferred.resolve();
    });
    return deferred.promise;
}
module.exports = Iau2006XysData;
},{"../ThirdParty/when":596,"./Iau2006XysSample":159,"./JulianDate":168,"./TimeStandard":224,"./buildModuleUrl":239,"./defaultValue":243,"./defined":245,"./loadJson":261}],159:[function(require,module,exports){
'use strict';
var Iau2006XysSample = function Iau2006XysSample(x, y, s) {
    this.x = x;
    this.y = y;
    this.s = s;
};
module.exports = Iau2006XysSample;
},{}],160:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defined = require('./defined'), Iau2000Orientation = require('./Iau2000Orientation'), JulianDate = require('./JulianDate'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), Quaternion = require('./Quaternion');
'use strict';
var IauOrientationAxes = function (computeFunction) {
    if (!defined(computeFunction) || typeof computeFunction !== 'function') {
        computeFunction = Iau2000Orientation.ComputeMoon;
    }
    this._computeFunction = computeFunction;
};
var xAxisScratch = new Cartesian3();
var yAxisScratch = new Cartesian3();
var zAxisScratch = new Cartesian3();
function computeRotationMatrix(alpha, delta, result) {
    var xAxis = xAxisScratch;
    xAxis.x = Math.cos(alpha + CesiumMath.PI_OVER_TWO);
    xAxis.y = Math.sin(alpha + CesiumMath.PI_OVER_TWO);
    xAxis.z = 0;
    var cosDec = Math.cos(delta);
    var zAxis = zAxisScratch;
    zAxis.x = cosDec * Math.cos(alpha);
    zAxis.y = cosDec * Math.sin(alpha);
    zAxis.z = Math.sin(delta);
    var yAxis = Cartesian3.cross(zAxis, xAxis, yAxisScratch);
    if (!defined(result)) {
        result = new Matrix3();
    }
    result[0] = xAxis.x;
    result[1] = yAxis.x;
    result[2] = zAxis.x;
    result[3] = xAxis.y;
    result[4] = yAxis.y;
    result[5] = zAxis.y;
    result[6] = xAxis.z;
    result[7] = yAxis.z;
    result[8] = zAxis.z;
    return result;
}
var rotMtxScratch = new Matrix3();
var quatScratch = new Quaternion();
IauOrientationAxes.prototype.evaluate = function (date, result) {
    if (!defined(date)) {
        date = JulianDate.now();
    }
    var alphaDeltaW = this._computeFunction(date);
    var precMtx = computeRotationMatrix(alphaDeltaW.rightAscension, alphaDeltaW.declination, result);
    var rot = CesiumMath.zeroToTwoPi(alphaDeltaW.rotation);
    var quat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, rot, quatScratch);
    var rotMtx = Matrix3.fromQuaternion(Quaternion.conjugate(quat, quat), rotMtxScratch);
    var cbi2cbf = Matrix3.multiply(rotMtx, precMtx, precMtx);
    return cbi2cbf;
};
module.exports = IauOrientationAxes;
},{"./Cartesian3":102,"./Iau2000Orientation":157,"./JulianDate":168,"./Math":174,"./Matrix3":176,"./Quaternion":197,"./defined":245}],161:[function(require,module,exports){
'use strict';
var IauOrientationParameters = function (rightAscension, declination, rotation, rotationRate) {
    this.rightAscension = rightAscension;
    this.declination = declination;
    this.rotation = rotation;
    this.rotationRate = rotationRate;
};
module.exports = IauOrientationParameters;
},{}],162:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
var IndexDatatype = {
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123,
        UNSIGNED_INT: 5125
    };
IndexDatatype.getSizeInBytes = function (indexDatatype) {
    switch (indexDatatype) {
    case IndexDatatype.UNSIGNED_BYTE:
        return Uint8Array.BYTES_PER_ELEMENT;
    case IndexDatatype.UNSIGNED_SHORT:
        return Uint16Array.BYTES_PER_ELEMENT;
    case IndexDatatype.UNSIGNED_INT:
        return Uint32Array.BYTES_PER_ELEMENT;
    }
    throw new DeveloperError('indexDatatype is required and must be a valid IndexDatatype constant.');
};
IndexDatatype.validate = function (indexDatatype) {
    return defined(indexDatatype) && (indexDatatype === IndexDatatype.UNSIGNED_BYTE || indexDatatype === IndexDatatype.UNSIGNED_SHORT || indexDatatype === IndexDatatype.UNSIGNED_INT);
};
IndexDatatype.createTypedArray = function (numberOfVertices, indicesLengthOrArray) {
    if (!defined(numberOfVertices)) {
        throw new DeveloperError('numberOfVertices is required.');
    }
    if (numberOfVertices > CesiumMath.SIXTY_FOUR_KILOBYTES) {
        return new Uint32Array(indicesLengthOrArray);
    }
    return new Uint16Array(indicesLengthOrArray);
};
IndexDatatype.createTypedArrayFromArrayBuffer = function (numberOfVertices, sourceArray, byteOffset, length) {
    if (!defined(numberOfVertices)) {
        throw new DeveloperError('numberOfVertices is required.');
    }
    if (!defined(sourceArray)) {
        throw new DeveloperError('sourceArray is required.');
    }
    if (!defined(byteOffset)) {
        throw new DeveloperError('byteOffset is required.');
    }
    if (numberOfVertices > CesiumMath.SIXTY_FOUR_KILOBYTES) {
        return new Uint32Array(sourceArray, byteOffset, length);
    }
    return new Uint16Array(sourceArray, byteOffset, length);
};
module.exports = freezeObject(IndexDatatype);
},{"./DeveloperError":123,"./Math":174,"./defined":245,"./freezeObject":249}],163:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var Intersect = {
        OUTSIDE: -1,
        INTERSECTING: 0,
        INSIDE: 1
    };
module.exports = freezeObject(Intersect);
},{"./freezeObject":249}],164:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), QuadraticRealPolynomial = require('./QuadraticRealPolynomial'), QuarticRealPolynomial = require('./QuarticRealPolynomial'), Ray = require('./Ray');
'use strict';
var IntersectionTests = {};
IntersectionTests.rayPlane = function (ray, plane, result) {
    if (!defined(ray)) {
        throw new DeveloperError('ray is required.');
    }
    if (!defined(plane)) {
        throw new DeveloperError('plane is required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    var origin = ray.origin;
    var direction = ray.direction;
    var normal = plane.normal;
    var denominator = Cartesian3.dot(normal, direction);
    if (Math.abs(denominator) < CesiumMath.EPSILON15) {
        return undefined;
    }
    var t = (-plane.distance - Cartesian3.dot(normal, origin)) / denominator;
    if (t < 0) {
        return undefined;
    }
    result = Cartesian3.multiplyByScalar(direction, t, result);
    return Cartesian3.add(origin, result, result);
};
var scratchEdge0 = new Cartesian3();
var scratchEdge1 = new Cartesian3();
var scratchPVec = new Cartesian3();
var scratchTVec = new Cartesian3();
var scratchQVec = new Cartesian3();
function rayTriangle(ray, p0, p1, p2, cullBackFaces) {
    if (!defined(ray)) {
        throw new DeveloperError('ray is required.');
    }
    if (!defined(p0)) {
        throw new DeveloperError('p0 is required.');
    }
    if (!defined(p1)) {
        throw new DeveloperError('p1 is required.');
    }
    if (!defined(p2)) {
        throw new DeveloperError('p2 is required.');
    }
    cullBackFaces = defaultValue(cullBackFaces, false);
    var origin = ray.origin;
    var direction = ray.direction;
    var edge0 = Cartesian3.subtract(p1, p0, scratchEdge0);
    var edge1 = Cartesian3.subtract(p2, p0, scratchEdge1);
    var p = Cartesian3.cross(direction, edge1, scratchPVec);
    var det = Cartesian3.dot(edge0, p);
    var tvec;
    var q;
    var u;
    var v;
    var t;
    if (cullBackFaces) {
        if (det < CesiumMath.EPSILON6) {
            return undefined;
        }
        tvec = Cartesian3.subtract(origin, p0, scratchTVec);
        u = Cartesian3.dot(tvec, p);
        if (u < 0 || u > det) {
            return undefined;
        }
        q = Cartesian3.cross(tvec, edge0, scratchQVec);
        v = Cartesian3.dot(direction, q);
        if (v < 0 || u + v > det) {
            return undefined;
        }
        t = Cartesian3.dot(edge1, q) / det;
    } else {
        if (Math.abs(det) < CesiumMath.EPSILON6) {
            return undefined;
        }
        var invDet = 1 / det;
        tvec = Cartesian3.subtract(origin, p0, scratchTVec);
        u = Cartesian3.dot(tvec, p) * invDet;
        if (u < 0 || u > 1) {
            return undefined;
        }
        q = Cartesian3.cross(tvec, edge0, scratchQVec);
        v = Cartesian3.dot(direction, q) * invDet;
        if (v < 0 || u + v > 1) {
            return undefined;
        }
        t = Cartesian3.dot(edge1, q) * invDet;
    }
    return t;
}
IntersectionTests.rayTriangle = function (ray, p0, p1, p2, cullBackFaces, result) {
    var t = rayTriangle(ray, p0, p1, p2, cullBackFaces);
    if (!defined(t) || t < 0) {
        return undefined;
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    Cartesian3.multiplyByScalar(ray.direction, t, result);
    return Cartesian3.add(ray.origin, result, result);
};
var scratchLineSegmentTriangleRay = new Ray();
IntersectionTests.lineSegmentTriangle = function (v0, v1, p0, p1, p2, cullBackFaces, result) {
    if (!defined(v0)) {
        throw new DeveloperError('v0 is required.');
    }
    if (!defined(v1)) {
        throw new DeveloperError('v1 is required.');
    }
    var ray = scratchLineSegmentTriangleRay;
    Cartesian3.clone(v0, ray.origin);
    Cartesian3.subtract(v1, v0, ray.direction);
    Cartesian3.normalize(ray.direction, ray.direction);
    var t = rayTriangle(ray, p0, p1, p2, cullBackFaces);
    if (!defined(t) || t < 0 || t > Cartesian3.distance(v0, v1)) {
        return undefined;
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    Cartesian3.multiplyByScalar(ray.direction, t, result);
    return Cartesian3.add(ray.origin, result, result);
};
function solveQuadratic(a, b, c, result) {
    var det = b * b - 4 * a * c;
    if (det < 0) {
        return undefined;
    } else if (det > 0) {
        var denom = 1 / (2 * a);
        var disc = Math.sqrt(det);
        var root0 = (-b + disc) * denom;
        var root1 = (-b - disc) * denom;
        if (root0 < root1) {
            result.root0 = root0;
            result.root1 = root1;
        } else {
            result.root0 = root1;
            result.root1 = root0;
        }
        return result;
    }
    var root = -b / (2 * a);
    if (root === 0) {
        return undefined;
    }
    result.root0 = result.root1 = root;
    return result;
}
var raySphereRoots = {
        root0: 0,
        root1: 0
    };
function raySphere(ray, sphere, result) {
    if (!defined(result)) {
        result = {};
    }
    var origin = ray.origin;
    var direction = ray.direction;
    var center = sphere.center;
    var radiusSquared = sphere.radius * sphere.radius;
    var diff = Cartesian3.subtract(origin, center, scratchPVec);
    var a = Cartesian3.dot(direction, direction);
    var b = 2 * Cartesian3.dot(direction, diff);
    var c = Cartesian3.magnitudeSquared(diff) - radiusSquared;
    var roots = solveQuadratic(a, b, c, raySphereRoots);
    if (!defined(roots)) {
        return undefined;
    }
    result.start = roots.root0;
    result.stop = roots.root1;
    return result;
}
IntersectionTests.raySphere = function (ray, sphere, result) {
    if (!defined(ray)) {
        throw new DeveloperError('ray is required.');
    }
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    result = raySphere(ray, sphere, result);
    if (!defined(result) || result.stop < 0) {
        return undefined;
    }
    result.start = Math.max(result.start, 0);
    return result;
};
var scratchLineSegmentRay = new Ray();
IntersectionTests.lineSegmentSphere = function (p0, p1, sphere, result) {
    if (!defined(p0)) {
        throw new DeveloperError('p0 is required.');
    }
    if (!defined(p1)) {
        throw new DeveloperError('p1 is required.');
    }
    if (!defined(sphere)) {
        throw new DeveloperError('sphere is required.');
    }
    var ray = scratchLineSegmentRay;
    var origin = Cartesian3.clone(p0, ray.origin);
    var direction = Cartesian3.subtract(p1, p0, ray.direction);
    var maxT = Cartesian3.magnitude(direction);
    Cartesian3.normalize(direction, direction);
    result = raySphere(ray, sphere, result);
    if (!defined(result) || result.stop < 0 || result.start > maxT) {
        return undefined;
    }
    result.start = Math.max(result.start, 0);
    result.stop = Math.min(result.stop, maxT);
    return result;
};
var scratchQ = new Cartesian3();
var scratchW = new Cartesian3();
IntersectionTests.rayEllipsoid = function (ray, ellipsoid) {
    if (!defined(ray)) {
        throw new DeveloperError('ray is required.');
    }
    if (!defined(ellipsoid)) {
        throw new DeveloperError('ellipsoid is required.');
    }
    var inverseRadii = ellipsoid.oneOverRadii;
    var q = Cartesian3.multiplyComponents(inverseRadii, ray.origin, scratchQ);
    var w = Cartesian3.multiplyComponents(inverseRadii, ray.direction, scratchW);
    var q2 = Cartesian3.magnitudeSquared(q);
    var qw = Cartesian3.dot(q, w);
    var difference, w2, product, discriminant, temp;
    if (q2 > 1) {
        if (qw >= 0) {
            return undefined;
        }
        var qw2 = qw * qw;
        difference = q2 - 1;
        w2 = Cartesian3.magnitudeSquared(w);
        product = w2 * difference;
        if (qw2 < product) {
            return undefined;
        } else if (qw2 > product) {
            discriminant = qw * qw - product;
            temp = -qw + Math.sqrt(discriminant);
            var root0 = temp / w2;
            var root1 = difference / temp;
            if (root0 < root1) {
                return {
                    start: root0,
                    stop: root1
                };
            }
            return {
                start: root1,
                stop: root0
            };
        } else {
            var root = Math.sqrt(difference / w2);
            return {
                start: root,
                stop: root
            };
        }
    } else if (q2 < 1) {
        difference = q2 - 1;
        w2 = Cartesian3.magnitudeSquared(w);
        product = w2 * difference;
        discriminant = qw * qw - product;
        temp = -qw + Math.sqrt(discriminant);
        return {
            start: 0,
            stop: temp / w2
        };
    } else {
        if (qw < 0) {
            w2 = Cartesian3.magnitudeSquared(w);
            return {
                start: 0,
                stop: -qw / w2
            };
        }
        return undefined;
    }
};
function addWithCancellationCheck(left, right, tolerance) {
    var difference = left + right;
    if (CesiumMath.sign(left) !== CesiumMath.sign(right) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
        return 0;
    }
    return difference;
}
function quadraticVectorExpression(A, b, c, x, w) {
    var xSquared = x * x;
    var wSquared = w * w;
    var l2 = (A[Matrix3.COLUMN1ROW1] - A[Matrix3.COLUMN2ROW2]) * wSquared;
    var l1 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN1ROW0], A[Matrix3.COLUMN0ROW1], CesiumMath.EPSILON15) + b.y);
    var l0 = A[Matrix3.COLUMN0ROW0] * xSquared + A[Matrix3.COLUMN2ROW2] * wSquared + x * b.x + c;
    var r1 = wSquared * addWithCancellationCheck(A[Matrix3.COLUMN2ROW1], A[Matrix3.COLUMN1ROW2], CesiumMath.EPSILON15);
    var r0 = w * (x * addWithCancellationCheck(A[Matrix3.COLUMN2ROW0], A[Matrix3.COLUMN0ROW2]) + b.z);
    var cosines;
    var solutions = [];
    if (r0 === 0 && r1 === 0) {
        cosines = QuadraticRealPolynomial.computeRealRoots(l2, l1, l0);
        if (cosines.length === 0) {
            return solutions;
        }
        var cosine0 = cosines[0];
        var sine0 = Math.sqrt(Math.max(1 - cosine0 * cosine0, 0));
        solutions.push(new Cartesian3(x, w * cosine0, w * -sine0));
        solutions.push(new Cartesian3(x, w * cosine0, w * sine0));
        if (cosines.length === 2) {
            var cosine1 = cosines[1];
            var sine1 = Math.sqrt(Math.max(1 - cosine1 * cosine1, 0));
            solutions.push(new Cartesian3(x, w * cosine1, w * -sine1));
            solutions.push(new Cartesian3(x, w * cosine1, w * sine1));
        }
        return solutions;
    }
    var r0Squared = r0 * r0;
    var r1Squared = r1 * r1;
    var l2Squared = l2 * l2;
    var r0r1 = r0 * r1;
    var c4 = l2Squared + r1Squared;
    var c3 = 2 * (l1 * l2 + r0r1);
    var c2 = 2 * l0 * l2 + l1 * l1 - r1Squared + r0Squared;
    var c1 = 2 * (l0 * l1 - r0r1);
    var c0 = l0 * l0 - r0Squared;
    if (c4 === 0 && c3 === 0 && c2 === 0 && c1 === 0) {
        return solutions;
    }
    cosines = QuarticRealPolynomial.computeRealRoots(c4, c3, c2, c1, c0);
    var length = cosines.length;
    if (length === 0) {
        return solutions;
    }
    for (var i = 0; i < length; ++i) {
        var cosine = cosines[i];
        var cosineSquared = cosine * cosine;
        var sineSquared = Math.max(1 - cosineSquared, 0);
        var sine = Math.sqrt(sineSquared);
        var left;
        if (CesiumMath.sign(l2) === CesiumMath.sign(l0)) {
            left = addWithCancellationCheck(l2 * cosineSquared + l0, l1 * cosine, CesiumMath.EPSILON12);
        } else if (CesiumMath.sign(l0) === CesiumMath.sign(l1 * cosine)) {
            left = addWithCancellationCheck(l2 * cosineSquared, l1 * cosine + l0, CesiumMath.EPSILON12);
        } else {
            left = addWithCancellationCheck(l2 * cosineSquared + l1 * cosine, l0, CesiumMath.EPSILON12);
        }
        var right = addWithCancellationCheck(r1 * cosine, r0, CesiumMath.EPSILON15);
        var product = left * right;
        if (product < 0) {
            solutions.push(new Cartesian3(x, w * cosine, w * sine));
        } else if (product > 0) {
            solutions.push(new Cartesian3(x, w * cosine, w * -sine));
        } else if (sine !== 0) {
            solutions.push(new Cartesian3(x, w * cosine, w * -sine));
            solutions.push(new Cartesian3(x, w * cosine, w * sine));
            ++i;
        } else {
            solutions.push(new Cartesian3(x, w * cosine, w * sine));
        }
    }
    return solutions;
}
var firstAxisScratch = new Cartesian3();
var secondAxisScratch = new Cartesian3();
var thirdAxisScratch = new Cartesian3();
var referenceScratch = new Cartesian3();
var bCart = new Cartesian3();
var bScratch = new Matrix3();
var btScratch = new Matrix3();
var diScratch = new Matrix3();
var dScratch = new Matrix3();
var cScratch = new Matrix3();
var tempMatrix = new Matrix3();
var aScratch = new Matrix3();
var sScratch = new Cartesian3();
var closestScratch = new Cartesian3();
var surfPointScratch = new Cartographic();
IntersectionTests.grazingAltitudeLocation = function (ray, ellipsoid) {
    if (!defined(ray)) {
        throw new DeveloperError('ray is required.');
    }
    if (!defined(ellipsoid)) {
        throw new DeveloperError('ellipsoid is required.');
    }
    var position = ray.origin;
    var direction = ray.direction;
    var normal = ellipsoid.geodeticSurfaceNormal(position, firstAxisScratch);
    if (Cartesian3.dot(direction, normal) >= 0) {
        return position;
    }
    var intersects = defined(this.rayEllipsoid(ray, ellipsoid));
    var f = ellipsoid.transformPositionToScaledSpace(direction, firstAxisScratch);
    var firstAxis = Cartesian3.normalize(f, f);
    var reference = Cartesian3.mostOrthogonalAxis(f, referenceScratch);
    var secondAxis = Cartesian3.normalize(Cartesian3.cross(reference, firstAxis, secondAxisScratch), secondAxisScratch);
    var thirdAxis = Cartesian3.normalize(Cartesian3.cross(firstAxis, secondAxis, thirdAxisScratch), thirdAxisScratch);
    var B = bScratch;
    B[0] = firstAxis.x;
    B[1] = firstAxis.y;
    B[2] = firstAxis.z;
    B[3] = secondAxis.x;
    B[4] = secondAxis.y;
    B[5] = secondAxis.z;
    B[6] = thirdAxis.x;
    B[7] = thirdAxis.y;
    B[8] = thirdAxis.z;
    var B_T = Matrix3.transpose(B, btScratch);
    var D_I = Matrix3.fromScale(ellipsoid.radii, diScratch);
    var D = Matrix3.fromScale(ellipsoid.oneOverRadii, dScratch);
    var C = cScratch;
    C[0] = 0;
    C[1] = -direction.z;
    C[2] = direction.y;
    C[3] = direction.z;
    C[4] = 0;
    C[5] = -direction.x;
    C[6] = -direction.y;
    C[7] = direction.x;
    C[8] = 0;
    var temp = Matrix3.multiply(Matrix3.multiply(B_T, D, tempMatrix), C, tempMatrix);
    var A = Matrix3.multiply(Matrix3.multiply(temp, D_I, aScratch), B, aScratch);
    var b = Matrix3.multiplyByVector(temp, position, bCart);
    var solutions = quadraticVectorExpression(A, Cartesian3.negate(b, firstAxisScratch), 0, 0, 1);
    var s;
    var altitude;
    var length = solutions.length;
    if (length > 0) {
        var closest = Cartesian3.clone(Cartesian3.ZERO, closestScratch);
        var maximumValue = Number.NEGATIVE_INFINITY;
        for (var i = 0; i < length; ++i) {
            s = Matrix3.multiplyByVector(D_I, Matrix3.multiplyByVector(B, solutions[i], sScratch), sScratch);
            var v = Cartesian3.normalize(Cartesian3.subtract(s, position, referenceScratch), referenceScratch);
            var dotProduct = Cartesian3.dot(v, direction);
            if (dotProduct > maximumValue) {
                maximumValue = dotProduct;
                closest = Cartesian3.clone(s, closest);
            }
        }
        var surfacePoint = ellipsoid.cartesianToCartographic(closest, surfPointScratch);
        maximumValue = CesiumMath.clamp(maximumValue, 0, 1);
        altitude = Cartesian3.magnitude(Cartesian3.subtract(closest, position, referenceScratch)) * Math.sqrt(1 - maximumValue * maximumValue);
        altitude = intersects ? -altitude : altitude;
        surfacePoint.height = altitude;
        return ellipsoid.cartographicToCartesian(surfacePoint, new Cartesian3());
    }
    return undefined;
};
var lineSegmentPlaneDifference = new Cartesian3();
IntersectionTests.lineSegmentPlane = function (endPoint0, endPoint1, plane, result) {
    if (!defined(endPoint0)) {
        throw new DeveloperError('endPoint0 is required.');
    }
    if (!defined(endPoint1)) {
        throw new DeveloperError('endPoint1 is required.');
    }
    if (!defined(plane)) {
        throw new DeveloperError('plane is required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    var difference = Cartesian3.subtract(endPoint1, endPoint0, lineSegmentPlaneDifference);
    var normal = plane.normal;
    var nDotDiff = Cartesian3.dot(normal, difference);
    if (Math.abs(nDotDiff) < CesiumMath.EPSILON6) {
        return undefined;
    }
    var nDotP0 = Cartesian3.dot(normal, endPoint0);
    var t = -(plane.distance + nDotP0) / nDotDiff;
    if (t < 0 || t > 1) {
        return undefined;
    }
    Cartesian3.multiplyByScalar(difference, t, result);
    Cartesian3.add(endPoint0, result, result);
    return result;
};
IntersectionTests.trianglePlaneIntersection = function (p0, p1, p2, plane) {
    if (!defined(p0) || !defined(p1) || !defined(p2) || !defined(plane)) {
        throw new DeveloperError('p0, p1, p2, and plane are required.');
    }
    var planeNormal = plane.normal;
    var planeD = plane.distance;
    var p0Behind = Cartesian3.dot(planeNormal, p0) + planeD < 0;
    var p1Behind = Cartesian3.dot(planeNormal, p1) + planeD < 0;
    var p2Behind = Cartesian3.dot(planeNormal, p2) + planeD < 0;
    var numBehind = 0;
    numBehind += p0Behind ? 1 : 0;
    numBehind += p1Behind ? 1 : 0;
    numBehind += p2Behind ? 1 : 0;
    var u1, u2;
    if (numBehind === 1 || numBehind === 2) {
        u1 = new Cartesian3();
        u2 = new Cartesian3();
    }
    if (numBehind === 1) {
        if (p0Behind) {
            IntersectionTests.lineSegmentPlane(p0, p1, plane, u1);
            IntersectionTests.lineSegmentPlane(p0, p2, plane, u2);
            return {
                positions: [
                    p0,
                    p1,
                    p2,
                    u1,
                    u2
                ],
                indices: [
                    0,
                    3,
                    4,
                    1,
                    2,
                    4,
                    1,
                    4,
                    3
                ]
            };
        } else if (p1Behind) {
            IntersectionTests.lineSegmentPlane(p1, p2, plane, u1);
            IntersectionTests.lineSegmentPlane(p1, p0, plane, u2);
            return {
                positions: [
                    p0,
                    p1,
                    p2,
                    u1,
                    u2
                ],
                indices: [
                    1,
                    3,
                    4,
                    2,
                    0,
                    4,
                    2,
                    4,
                    3
                ]
            };
        } else if (p2Behind) {
            IntersectionTests.lineSegmentPlane(p2, p0, plane, u1);
            IntersectionTests.lineSegmentPlane(p2, p1, plane, u2);
            return {
                positions: [
                    p0,
                    p1,
                    p2,
                    u1,
                    u2
                ],
                indices: [
                    2,
                    3,
                    4,
                    0,
                    1,
                    4,
                    0,
                    4,
                    3
                ]
            };
        }
    } else if (numBehind === 2) {
        if (!p0Behind) {
            IntersectionTests.lineSegmentPlane(p1, p0, plane, u1);
            IntersectionTests.lineSegmentPlane(p2, p0, plane, u2);
            return {
                positions: [
                    p0,
                    p1,
                    p2,
                    u1,
                    u2
                ],
                indices: [
                    1,
                    2,
                    4,
                    1,
                    4,
                    3,
                    0,
                    3,
                    4
                ]
            };
        } else if (!p1Behind) {
            IntersectionTests.lineSegmentPlane(p2, p1, plane, u1);
            IntersectionTests.lineSegmentPlane(p0, p1, plane, u2);
            return {
                positions: [
                    p0,
                    p1,
                    p2,
                    u1,
                    u2
                ],
                indices: [
                    2,
                    0,
                    4,
                    2,
                    4,
                    3,
                    1,
                    3,
                    4
                ]
            };
        } else if (!p2Behind) {
            IntersectionTests.lineSegmentPlane(p0, p2, plane, u1);
            IntersectionTests.lineSegmentPlane(p1, p2, plane, u2);
            return {
                positions: [
                    p0,
                    p1,
                    p2,
                    u1,
                    u2
                ],
                indices: [
                    0,
                    1,
                    4,
                    0,
                    4,
                    3,
                    2,
                    3,
                    4
                ]
            };
        }
    }
    return undefined;
};
module.exports = IntersectionTests;
},{"./Cartesian3":102,"./Cartographic":104,"./DeveloperError":123,"./Math":174,"./Matrix3":176,"./QuadraticRealPolynomial":194,"./QuarticRealPolynomial":196,"./Ray":200,"./defaultValue":243,"./defined":245}],165:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var Intersections2D = {};
Intersections2D.clipTriangleAtAxisAlignedThreshold = function (threshold, keepAbove, u0, u1, u2, result) {
    if (!defined(threshold)) {
        throw new DeveloperError('threshold is required.');
    }
    if (!defined(keepAbove)) {
        throw new DeveloperError('keepAbove is required.');
    }
    if (!defined(u0)) {
        throw new DeveloperError('u0 is required.');
    }
    if (!defined(u1)) {
        throw new DeveloperError('u1 is required.');
    }
    if (!defined(u2)) {
        throw new DeveloperError('u2 is required.');
    }
    if (!defined(result)) {
        result = [];
    } else {
        result.length = 0;
    }
    var u0Behind;
    var u1Behind;
    var u2Behind;
    if (keepAbove) {
        u0Behind = u0 < threshold;
        u1Behind = u1 < threshold;
        u2Behind = u2 < threshold;
    } else {
        u0Behind = u0 > threshold;
        u1Behind = u1 > threshold;
        u2Behind = u2 > threshold;
    }
    var numBehind = u0Behind + u1Behind + u2Behind;
    var u01Ratio;
    var u02Ratio;
    var u12Ratio;
    var u10Ratio;
    var u20Ratio;
    var u21Ratio;
    if (numBehind === 1) {
        if (u0Behind) {
            u01Ratio = (threshold - u0) / (u1 - u0);
            u02Ratio = (threshold - u0) / (u2 - u0);
            result.push(1);
            result.push(2);
            if (u02Ratio !== 1) {
                result.push(-1);
                result.push(0);
                result.push(2);
                result.push(u02Ratio);
            }
            if (u01Ratio !== 1) {
                result.push(-1);
                result.push(0);
                result.push(1);
                result.push(u01Ratio);
            }
        } else if (u1Behind) {
            u12Ratio = (threshold - u1) / (u2 - u1);
            u10Ratio = (threshold - u1) / (u0 - u1);
            result.push(2);
            result.push(0);
            if (u10Ratio !== 1) {
                result.push(-1);
                result.push(1);
                result.push(0);
                result.push(u10Ratio);
            }
            if (u12Ratio !== 1) {
                result.push(-1);
                result.push(1);
                result.push(2);
                result.push(u12Ratio);
            }
        } else if (u2Behind) {
            u20Ratio = (threshold - u2) / (u0 - u2);
            u21Ratio = (threshold - u2) / (u1 - u2);
            result.push(0);
            result.push(1);
            if (u21Ratio !== 1) {
                result.push(-1);
                result.push(2);
                result.push(1);
                result.push(u21Ratio);
            }
            if (u20Ratio !== 1) {
                result.push(-1);
                result.push(2);
                result.push(0);
                result.push(u20Ratio);
            }
        }
    } else if (numBehind === 2) {
        if (!u0Behind && u0 !== threshold) {
            u10Ratio = (threshold - u1) / (u0 - u1);
            u20Ratio = (threshold - u2) / (u0 - u2);
            result.push(0);
            result.push(-1);
            result.push(1);
            result.push(0);
            result.push(u10Ratio);
            result.push(-1);
            result.push(2);
            result.push(0);
            result.push(u20Ratio);
        } else if (!u1Behind && u1 !== threshold) {
            u21Ratio = (threshold - u2) / (u1 - u2);
            u01Ratio = (threshold - u0) / (u1 - u0);
            result.push(1);
            result.push(-1);
            result.push(2);
            result.push(1);
            result.push(u21Ratio);
            result.push(-1);
            result.push(0);
            result.push(1);
            result.push(u01Ratio);
        } else if (!u2Behind && u2 !== threshold) {
            u02Ratio = (threshold - u0) / (u2 - u0);
            u12Ratio = (threshold - u1) / (u2 - u1);
            result.push(2);
            result.push(-1);
            result.push(0);
            result.push(2);
            result.push(u02Ratio);
            result.push(-1);
            result.push(1);
            result.push(2);
            result.push(u12Ratio);
        }
    } else if (numBehind === 3) {
    } else {
        result.push(0);
        result.push(1);
        result.push(2);
    }
    return result;
};
Intersections2D.computeBarycentricCoordinates = function (x, y, x1, y1, x2, y2, x3, y3, result) {
    if (!defined(x)) {
        throw new DeveloperError('x is required.');
    }
    if (!defined(y)) {
        throw new DeveloperError('y is required.');
    }
    if (!defined(x1)) {
        throw new DeveloperError('x1 is required.');
    }
    if (!defined(y1)) {
        throw new DeveloperError('y1 is required.');
    }
    if (!defined(x2)) {
        throw new DeveloperError('x2 is required.');
    }
    if (!defined(y2)) {
        throw new DeveloperError('y2 is required.');
    }
    if (!defined(x3)) {
        throw new DeveloperError('x3 is required.');
    }
    if (!defined(y3)) {
        throw new DeveloperError('y3 is required.');
    }
    var x1mx3 = x1 - x3;
    var x3mx2 = x3 - x2;
    var y2my3 = y2 - y3;
    var y1my3 = y1 - y3;
    var inverseDeterminant = 1 / (y2my3 * x1mx3 + x3mx2 * y1my3);
    var ymy3 = y - y3;
    var xmx3 = x - x3;
    var l1 = (y2my3 * xmx3 + x3mx2 * ymy3) * inverseDeterminant;
    var l2 = (-y1my3 * xmx3 + x1mx3 * ymy3) * inverseDeterminant;
    var l3 = 1 - l1 - l2;
    if (defined(result)) {
        result.x = l1;
        result.y = l2;
        result.z = l3;
        return result;
    } else {
        return new Cartesian3(l1, l2, l3);
    }
};
module.exports = Intersections2D;
},{"./Cartesian3":102,"./DeveloperError":123,"./defined":245}],166:[function(require,module,exports){
var defaultValue = require('./defaultValue');
'use strict';
var Interval = function (start, stop) {
    this.start = defaultValue(start, 0);
    this.stop = defaultValue(stop, 0);
};
module.exports = Interval;
},{"./defaultValue":243}],167:[function(require,module,exports){
var freezeObject = require('./freezeObject'), JulianDate = require('./JulianDate'), TimeInterval = require('./TimeInterval');
'use strict';
var MINIMUM_VALUE = freezeObject(JulianDate.fromIso8601('0000-01-01T00:00:00Z'));
var MAXIMUM_VALUE = freezeObject(JulianDate.fromIso8601('9999-12-31T24:00:00Z'));
var MAXIMUM_INTERVAL = freezeObject(new TimeInterval({
        start: MINIMUM_VALUE,
        stop: MAXIMUM_VALUE
    }));
var Iso8601 = {
        MINIMUM_VALUE: MINIMUM_VALUE,
        MAXIMUM_VALUE: MAXIMUM_VALUE,
        MAXIMUM_INTERVAL: MAXIMUM_INTERVAL
    };
module.exports = Iso8601;
},{"./JulianDate":168,"./TimeInterval":222,"./freezeObject":249}],168:[function(require,module,exports){
var sprintf = require('../ThirdParty/sprintf'), binarySearch = require('./binarySearch'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), GregorianDate = require('./GregorianDate'), isLeapYear = require('./isLeapYear'), LeapSecond = require('./LeapSecond'), TimeConstants = require('./TimeConstants'), TimeStandard = require('./TimeStandard');
'use strict';
var gregorianDateScratch = new GregorianDate();
var daysInMonth = [
        31,
        28,
        31,
        30,
        31,
        30,
        31,
        31,
        30,
        31,
        30,
        31
    ];
var daysInLeapFeburary = 29;
function compareLeapSecondDates(leapSecond, dateToFind) {
    return JulianDate.compare(leapSecond.julianDate, dateToFind.julianDate);
}
var binarySearchScratchLeapSecond = new LeapSecond();
function convertUtcToTai(julianDate) {
    binarySearchScratchLeapSecond.julianDate = julianDate;
    var leapSeconds = JulianDate.leapSeconds;
    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
    if (index < 0) {
        index = ~index;
    }
    if (index >= leapSeconds.length) {
        index = leapSeconds.length - 1;
    }
    var offset = leapSeconds[index].offset;
    if (index > 0) {
        var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);
        if (difference > offset) {
            index--;
            offset = leapSeconds[index].offset;
        }
    }
    JulianDate.addSeconds(julianDate, offset, julianDate);
}
function convertTaiToUtc(julianDate, result) {
    binarySearchScratchLeapSecond.julianDate = julianDate;
    var leapSeconds = JulianDate.leapSeconds;
    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
    if (index < 0) {
        index = ~index;
    }
    if (index === 0) {
        return JulianDate.addSeconds(julianDate, -leapSeconds[0].offset, result);
    }
    if (index >= leapSeconds.length) {
        return JulianDate.addSeconds(julianDate, -leapSeconds[index - 1].offset, result);
    }
    var difference = JulianDate.secondsDifference(leapSeconds[index].julianDate, julianDate);
    if (difference === 0) {
        return JulianDate.addSeconds(julianDate, -leapSeconds[index].offset, result);
    }
    if (difference <= 1) {
        return undefined;
    }
    return JulianDate.addSeconds(julianDate, -leapSeconds[--index].offset, result);
}
function setComponents(wholeDays, secondsOfDay, julianDate) {
    var extraDays = secondsOfDay / TimeConstants.SECONDS_PER_DAY | 0;
    wholeDays += extraDays;
    secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;
    if (secondsOfDay < 0) {
        wholeDays--;
        secondsOfDay += TimeConstants.SECONDS_PER_DAY;
    }
    julianDate.dayNumber = wholeDays;
    julianDate.secondsOfDay = secondsOfDay;
    return julianDate;
}
function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {
    var a = (month - 14) / 12 | 0;
    var b = year + 4800 + a;
    var dayNumber = (1461 * b / 4 | 0) + (367 * (month - 2 - 12 * a) / 12 | 0) - (3 * ((b + 100) / 100) / 4 | 0) + day - 32075;
    hour = hour - 12;
    if (hour < 0) {
        hour += 24;
    }
    var secondsOfDay = second + (hour * TimeConstants.SECONDS_PER_HOUR + minute * TimeConstants.SECONDS_PER_MINUTE + millisecond * TimeConstants.SECONDS_PER_MILLISECOND);
    if (secondsOfDay >= 43200) {
        dayNumber -= 1;
    }
    return [
        dayNumber,
        secondsOfDay
    ];
}
var matchCalendarYear = /^(\d{4})$/;
var matchCalendarMonth = /^(\d{4})-(\d{2})$/;
var matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
var matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
var matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
var utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
var matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
var matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
var matchHoursMinutesSeconds = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
var iso8601ErrorMessage = 'Invalid ISO 8601 date.';
var JulianDate = function (julianDayNumber, secondsOfDay, timeStandard) {
    this.dayNumber = undefined;
    this.secondsOfDay = undefined;
    julianDayNumber = defaultValue(julianDayNumber, 0);
    secondsOfDay = defaultValue(secondsOfDay, 0);
    timeStandard = defaultValue(timeStandard, TimeStandard.UTC);
    var wholeDays = julianDayNumber | 0;
    secondsOfDay = secondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;
    setComponents(wholeDays, secondsOfDay, this);
    if (timeStandard === TimeStandard.UTC) {
        convertUtcToTai(this);
    }
};
JulianDate.fromDate = function (date, result) {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
        throw new DeveloperError('date must be a valid JavaScript Date.');
    }
    var components = computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    if (!defined(result)) {
        return new JulianDate(components[0], components[1], TimeStandard.UTC);
    }
    setComponents(components[0], components[1], result);
    convertUtcToTai(result);
    return result;
};
JulianDate.fromIso8601 = function (iso8601String, result) {
    if (typeof iso8601String !== 'string') {
        throw new DeveloperError(iso8601ErrorMessage);
    }
    iso8601String = iso8601String.replace(',', '.');
    var tokens = iso8601String.split('T');
    var year;
    var month = 1;
    var day = 1;
    var hour = 0;
    var minute = 0;
    var second = 0;
    var millisecond = 0;
    var date = tokens[0];
    var time = tokens[1];
    var tmp;
    var inLeapYear;
    if (!defined(date)) {
        throw new DeveloperError(iso8601ErrorMessage);
    }
    var dashCount;
    tokens = date.match(matchCalendarDate);
    if (tokens !== null) {
        dashCount = date.split('-').length - 1;
        if (dashCount > 0 && dashCount !== 2) {
            throw new DeveloperError(iso8601ErrorMessage);
        }
        year = +tokens[1];
        month = +tokens[2];
        day = +tokens[3];
    } else {
        tokens = date.match(matchCalendarMonth);
        if (tokens !== null) {
            year = +tokens[1];
            month = +tokens[2];
        } else {
            tokens = date.match(matchCalendarYear);
            if (tokens !== null) {
                year = +tokens[1];
            } else {
                var dayOfYear;
                tokens = date.match(matchOrdinalDate);
                if (tokens !== null) {
                    year = +tokens[1];
                    dayOfYear = +tokens[2];
                    inLeapYear = isLeapYear(year);
                    if (dayOfYear < 1 || inLeapYear && dayOfYear > 366 || !inLeapYear && dayOfYear > 365) {
                        throw new DeveloperError(iso8601ErrorMessage);
                    }
                } else {
                    tokens = date.match(matchWeekDate);
                    if (tokens !== null) {
                        year = +tokens[1];
                        var weekNumber = +tokens[2];
                        var dayOfWeek = +tokens[3] || 0;
                        dashCount = date.split('-').length - 1;
                        if (dashCount > 0 && (!defined(tokens[3]) && dashCount !== 1 || defined(tokens[3]) && dashCount !== 2)) {
                            throw new DeveloperError(iso8601ErrorMessage);
                        }
                        var january4 = new Date(Date.UTC(year, 0, 4));
                        dayOfYear = weekNumber * 7 + dayOfWeek - january4.getUTCDay() - 3;
                    } else {
                        throw new DeveloperError(iso8601ErrorMessage);
                    }
                }
                tmp = new Date(Date.UTC(year, 0, 1));
                tmp.setUTCDate(dayOfYear);
                month = tmp.getUTCMonth() + 1;
                day = tmp.getUTCDate();
            }
        }
    }
    inLeapYear = isLeapYear(year);
    if (month < 1 || month > 12 || day < 1 || (month !== 2 || !inLeapYear) && day > daysInMonth[month - 1] || inLeapYear && month === 2 && day > daysInLeapFeburary) {
        throw new DeveloperError(iso8601ErrorMessage);
    }
    var offsetIndex;
    if (defined(time)) {
        tokens = time.match(matchHoursMinutesSeconds);
        if (tokens !== null) {
            dashCount = time.split(':').length - 1;
            if (dashCount > 0 && dashCount !== 2 && dashCount !== 3) {
                throw new DeveloperError(iso8601ErrorMessage);
            }
            hour = +tokens[1];
            minute = +tokens[2];
            second = +tokens[3];
            millisecond = +(tokens[4] || 0) * 1000;
            offsetIndex = 5;
        } else {
            tokens = time.match(matchHoursMinutes);
            if (tokens !== null) {
                dashCount = time.split(':').length - 1;
                if (dashCount > 0 && dashCount !== 1) {
                    throw new DeveloperError(iso8601ErrorMessage);
                }
                hour = +tokens[1];
                minute = +tokens[2];
                second = +(tokens[3] || 0) * 60;
                offsetIndex = 4;
            } else {
                tokens = time.match(matchHours);
                if (tokens !== null) {
                    hour = +tokens[1];
                    minute = +(tokens[2] || 0) * 60;
                    offsetIndex = 3;
                } else {
                    throw new DeveloperError(iso8601ErrorMessage);
                }
            }
        }
        if (minute >= 60 || second >= 61 || hour > 24 || hour === 24 && (minute > 0 || second > 0 || millisecond > 0)) {
            throw new DeveloperError(iso8601ErrorMessage);
        }
        var offset = tokens[offsetIndex];
        var offsetHours = +tokens[offsetIndex + 1];
        var offsetMinutes = +(tokens[offsetIndex + 2] || 0);
        switch (offset) {
        case '+':
            hour = hour - offsetHours;
            minute = minute - offsetMinutes;
            break;
        case '-':
            hour = hour + offsetHours;
            minute = minute + offsetMinutes;
            break;
        case 'Z':
            break;
        default:
            minute = minute + new Date(Date.UTC(year, month - 1, day, hour, minute)).getTimezoneOffset();
            break;
        }
    } else {
        minute = minute + new Date(year, month - 1, day).getTimezoneOffset();
    }
    var isLeapSecond = second === 60;
    if (isLeapSecond) {
        second--;
    }
    while (minute >= 60) {
        minute -= 60;
        hour++;
    }
    while (hour >= 24) {
        hour -= 24;
        day++;
    }
    tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
    while (day > tmp) {
        day -= tmp;
        month++;
        if (month > 12) {
            month -= 12;
            year++;
        }
        tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
    }
    while (minute < 0) {
        minute += 60;
        hour--;
    }
    while (hour < 0) {
        hour += 24;
        day--;
    }
    while (day < 1) {
        month--;
        if (month < 1) {
            month += 12;
            year--;
        }
        tmp = inLeapYear && month === 2 ? daysInLeapFeburary : daysInMonth[month - 1];
        day += tmp;
    }
    var components = computeJulianDateComponents(year, month, day, hour, minute, second, millisecond);
    if (!defined(result)) {
        result = new JulianDate(components[0], components[1], TimeStandard.UTC);
    } else {
        setComponents(components[0], components[1], result);
        convertUtcToTai(result);
    }
    if (isLeapSecond) {
        JulianDate.addSeconds(result, 1, result);
    }
    return result;
};
JulianDate.now = function (result) {
    return JulianDate.fromDate(new Date(), result);
};
var toGregorianDateScratch = new JulianDate(0, 0, TimeStandard.TAI);
JulianDate.toGregorianDate = function (julianDate, result) {
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    var isLeapSecond = false;
    var thisUtc = convertTaiToUtc(julianDate, toGregorianDateScratch);
    if (!defined(thisUtc)) {
        JulianDate.addSeconds(julianDate, -1, toGregorianDateScratch);
        thisUtc = convertTaiToUtc(toGregorianDateScratch, toGregorianDateScratch);
        isLeapSecond = true;
    }
    var julianDayNumber = thisUtc.dayNumber;
    var secondsOfDay = thisUtc.secondsOfDay;
    if (secondsOfDay >= 43200) {
        julianDayNumber += 1;
    }
    var L = julianDayNumber + 68569 | 0;
    var N = 4 * L / 146097 | 0;
    L = L - ((146097 * N + 3) / 4 | 0) | 0;
    var I = 4000 * (L + 1) / 1461001 | 0;
    L = L - (1461 * I / 4 | 0) + 31 | 0;
    var J = 80 * L / 2447 | 0;
    var day = L - (2447 * J / 80 | 0) | 0;
    L = J / 11 | 0;
    var month = J + 2 - 12 * L | 0;
    var year = 100 * (N - 49) + I + L | 0;
    var hour = secondsOfDay / TimeConstants.SECONDS_PER_HOUR | 0;
    var remainingSeconds = secondsOfDay - hour * TimeConstants.SECONDS_PER_HOUR;
    var minute = remainingSeconds / TimeConstants.SECONDS_PER_MINUTE | 0;
    remainingSeconds = remainingSeconds - minute * TimeConstants.SECONDS_PER_MINUTE;
    var second = remainingSeconds | 0;
    var millisecond = (remainingSeconds - second) / TimeConstants.SECONDS_PER_MILLISECOND;
    hour += 12;
    if (hour > 23) {
        hour -= 24;
    }
    if (isLeapSecond) {
        second += 1;
    }
    if (!defined(result)) {
        return new GregorianDate(year, month, day, hour, minute, second, millisecond, isLeapSecond);
    }
    result.year = year;
    result.month = month;
    result.day = day;
    result.hour = hour;
    result.minute = minute;
    result.second = second;
    result.millisecond = millisecond;
    result.isLeapSecond = isLeapSecond;
    return result;
};
JulianDate.toDate = function (julianDate) {
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    var gDate = JulianDate.toGregorianDate(julianDate, gregorianDateScratch);
    var second = gDate.second;
    if (gDate.isLeapSecond) {
        second -= 1;
    }
    return new Date(Date.UTC(gDate.year, gDate.month - 1, gDate.day, gDate.hour, gDate.minute, second, gDate.millisecond));
};
JulianDate.toIso8601 = function (julianDate, precision) {
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    var gDate = JulianDate.toGregorianDate(julianDate, gDate);
    var millisecondStr;
    if (!defined(precision) && gDate.millisecond !== 0) {
        millisecondStr = (gDate.millisecond * 0.01).toString().replace('.', '');
        return sprintf('%04d-%02d-%02dT%02d:%02d:%02d.%sZ', gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
    }
    if (!defined(precision) || precision === 0) {
        return sprintf('%04d-%02d-%02dT%02d:%02d:%02dZ', gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second);
    }
    millisecondStr = (gDate.millisecond * 0.01).toFixed(precision).replace('.', '').slice(0, precision);
    return sprintf('%04d-%02d-%02dT%02d:%02d:%02d.%sZ', gDate.year, gDate.month, gDate.day, gDate.hour, gDate.minute, gDate.second, millisecondStr);
};
JulianDate.clone = function (julianDate, result) {
    if (!defined(julianDate)) {
        return undefined;
    }
    if (!defined(result)) {
        return new JulianDate(julianDate.dayNumber, julianDate.secondsOfDay, TimeStandard.TAI);
    }
    result.dayNumber = julianDate.dayNumber;
    result.secondsOfDay = julianDate.secondsOfDay;
    return result;
};
JulianDate.compare = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    var julianDayNumberDifference = left.dayNumber - right.dayNumber;
    if (julianDayNumberDifference !== 0) {
        return julianDayNumberDifference;
    }
    return left.secondsOfDay - right.secondsOfDay;
};
JulianDate.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.dayNumber === right.dayNumber && left.secondsOfDay === right.secondsOfDay;
};
JulianDate.equalsEpsilon = function (left, right, epsilon) {
    if (!defined(epsilon)) {
        throw new DeveloperError('epsilon is required.');
    }
    return left === right || defined(left) && defined(right) && Math.abs(JulianDate.secondsDifference(left, right)) <= epsilon;
};
JulianDate.totalDays = function (julianDate) {
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    return julianDate.dayNumber + julianDate.secondsOfDay / TimeConstants.SECONDS_PER_DAY;
};
JulianDate.secondsDifference = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    var dayDifference = (left.dayNumber - right.dayNumber) * TimeConstants.SECONDS_PER_DAY;
    return dayDifference + (left.secondsOfDay - right.secondsOfDay);
};
JulianDate.daysDifference = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    var dayDifference = left.dayNumber - right.dayNumber;
    var secondDifference = (left.secondsOfDay - right.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
    return dayDifference + secondDifference;
};
JulianDate.computeTaiMinusUtc = function (julianDate) {
    binarySearchScratchLeapSecond.julianDate = julianDate;
    var leapSeconds = JulianDate.leapSeconds;
    var index = binarySearch(leapSeconds, binarySearchScratchLeapSecond, compareLeapSecondDates);
    if (index < 0) {
        index = ~index;
        --index;
        if (index < 0) {
            index = 0;
        }
    }
    return leapSeconds[index].offset;
};
JulianDate.addSeconds = function (julianDate, seconds, result) {
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    if (!defined(seconds)) {
        throw new DeveloperError('seconds is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    return setComponents(julianDate.dayNumber, julianDate.secondsOfDay + seconds, result);
};
JulianDate.addMinutes = function (julianDate, minutes, result) {
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    if (!defined(minutes)) {
        throw new DeveloperError('minutes is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var newSecondsOfDay = julianDate.secondsOfDay + minutes * TimeConstants.SECONDS_PER_MINUTE;
    return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
};
JulianDate.addHours = function (julianDate, hours, result) {
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    if (!defined(hours)) {
        throw new DeveloperError('hours is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var newSecondsOfDay = julianDate.secondsOfDay + hours * TimeConstants.SECONDS_PER_HOUR;
    return setComponents(julianDate.dayNumber, newSecondsOfDay, result);
};
JulianDate.addDays = function (julianDate, days, result) {
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    if (!defined(days)) {
        throw new DeveloperError('days is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    var newJulianDayNumber = julianDate.dayNumber + days;
    return setComponents(newJulianDayNumber, julianDate.secondsOfDay, result);
};
JulianDate.lessThan = function (left, right) {
    return JulianDate.compare(left, right) < 0;
};
JulianDate.lessThanOrEquals = function (left, right) {
    return JulianDate.compare(left, right) <= 0;
};
JulianDate.greaterThan = function (left, right) {
    return JulianDate.compare(left, right) > 0;
};
JulianDate.greaterThanOrEquals = function (left, right) {
    return JulianDate.compare(left, right) >= 0;
};
JulianDate.prototype.clone = function (result) {
    return JulianDate.clone(this, result);
};
JulianDate.prototype.equals = function (right) {
    return JulianDate.equals(this, right);
};
JulianDate.prototype.equalsEpsilon = function (right, epsilon) {
    return JulianDate.equalsEpsilon(this, right, epsilon);
};
JulianDate.prototype.toString = function () {
    return JulianDate.toIso8601(this);
};
JulianDate.leapSeconds = [
    new LeapSecond(new JulianDate(2441317, 43210, TimeStandard.TAI), 10),
    new LeapSecond(new JulianDate(2441499, 43211, TimeStandard.TAI), 11),
    new LeapSecond(new JulianDate(2441683, 43212, TimeStandard.TAI), 12),
    new LeapSecond(new JulianDate(2442048, 43213, TimeStandard.TAI), 13),
    new LeapSecond(new JulianDate(2442413, 43214, TimeStandard.TAI), 14),
    new LeapSecond(new JulianDate(2442778, 43215, TimeStandard.TAI), 15),
    new LeapSecond(new JulianDate(2443144, 43216, TimeStandard.TAI), 16),
    new LeapSecond(new JulianDate(2443509, 43217, TimeStandard.TAI), 17),
    new LeapSecond(new JulianDate(2443874, 43218, TimeStandard.TAI), 18),
    new LeapSecond(new JulianDate(2444239, 43219, TimeStandard.TAI), 19),
    new LeapSecond(new JulianDate(2444786, 43220, TimeStandard.TAI), 20),
    new LeapSecond(new JulianDate(2445151, 43221, TimeStandard.TAI), 21),
    new LeapSecond(new JulianDate(2445516, 43222, TimeStandard.TAI), 22),
    new LeapSecond(new JulianDate(2446247, 43223, TimeStandard.TAI), 23),
    new LeapSecond(new JulianDate(2447161, 43224, TimeStandard.TAI), 24),
    new LeapSecond(new JulianDate(2447892, 43225, TimeStandard.TAI), 25),
    new LeapSecond(new JulianDate(2448257, 43226, TimeStandard.TAI), 26),
    new LeapSecond(new JulianDate(2448804, 43227, TimeStandard.TAI), 27),
    new LeapSecond(new JulianDate(2449169, 43228, TimeStandard.TAI), 28),
    new LeapSecond(new JulianDate(2449534, 43229, TimeStandard.TAI), 29),
    new LeapSecond(new JulianDate(2450083, 43230, TimeStandard.TAI), 30),
    new LeapSecond(new JulianDate(2450630, 43231, TimeStandard.TAI), 31),
    new LeapSecond(new JulianDate(2451179, 43232, TimeStandard.TAI), 32),
    new LeapSecond(new JulianDate(2453736, 43233, TimeStandard.TAI), 33),
    new LeapSecond(new JulianDate(2454832, 43234, TimeStandard.TAI), 34),
    new LeapSecond(new JulianDate(2456109, 43235, TimeStandard.TAI), 35)
];
module.exports = JulianDate;
},{"../ThirdParty/sprintf":594,"./DeveloperError":123,"./GregorianDate":152,"./LeapSecond":171,"./TimeConstants":221,"./TimeStandard":224,"./binarySearch":238,"./defaultValue":243,"./defined":245,"./isLeapYear":255}],169:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var KeyboardEventModifier = {
        SHIFT: 0,
        CTRL: 1,
        ALT: 2
    };
module.exports = freezeObject(KeyboardEventModifier);
},{"./freezeObject":249}],170:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var LagrangePolynomialApproximation = { type: 'Lagrange' };
LagrangePolynomialApproximation.getRequiredDataPoints = function (degree) {
    return Math.max(degree + 1, 2);
};
LagrangePolynomialApproximation.interpolateOrderZero = function (x, xTable, yTable, yStride, result) {
    if (!defined(result)) {
        result = new Array(yStride);
    }
    var i;
    var j;
    var length = xTable.length;
    for (i = 0; i < yStride; i++) {
        result[i] = 0;
    }
    for (i = 0; i < length; i++) {
        var coefficient = 1;
        for (j = 0; j < length; j++) {
            if (j !== i) {
                var diffX = xTable[i] - xTable[j];
                coefficient *= (x - xTable[j]) / diffX;
            }
        }
        for (j = 0; j < yStride; j++) {
            result[j] += coefficient * yTable[i * yStride + j];
        }
    }
    return result;
};
module.exports = LagrangePolynomialApproximation;
},{"./defined":245}],171:[function(require,module,exports){
'use strict';
var LeapSecond = function (date, offset) {
    this.julianDate = date;
    this.offset = offset;
};
module.exports = LeapSecond;
},{}],172:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var LinearApproximation = { type: 'Linear' };
LinearApproximation.getRequiredDataPoints = function (degree) {
    return 2;
};
LinearApproximation.interpolateOrderZero = function (x, xTable, yTable, yStride, result) {
    if (xTable.length !== 2) {
        throw new DeveloperError('The xTable provided to the linear interpolator must have exactly two elements.');
    } else if (yStride <= 0) {
        throw new DeveloperError('There must be at least 1 dependent variable for each independent variable.');
    }
    if (!defined(result)) {
        result = new Array(yStride);
    }
    var i;
    var y0;
    var y1;
    var x0 = xTable[0];
    var x1 = xTable[1];
    if (x0 === x1) {
        throw new DeveloperError('Divide by zero error: xTable[0] and xTable[1] are equal');
    }
    for (i = 0; i < yStride; i++) {
        y0 = yTable[i];
        y1 = yTable[i + yStride];
        result[i] = ((y1 - y0) * x + x1 * y0 - x0 * y1) / (x1 - x0);
    }
    return result;
};
module.exports = LinearApproximation;
},{"./DeveloperError":123,"./defined":245}],173:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Spline = require('./Spline');
'use strict';
var LinearSpline = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var points = options.points;
    var times = options.times;
    if (!defined(points) || !defined(times)) {
        throw new DeveloperError('points and times are required.');
    }
    if (points.length < 2) {
        throw new DeveloperError('points.length must be greater than or equal to 2.');
    }
    if (times.length !== points.length) {
        throw new DeveloperError('times.length must be equal to points.length.');
    }
    this._times = times;
    this._points = points;
    this._lastTimeIndex = 0;
};
defineProperties(LinearSpline.prototype, {
    times: {
        get: function () {
            return this._times;
        }
    },
    points: {
        get: function () {
            return this._points;
        }
    }
});
LinearSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;
LinearSpline.prototype.evaluate = function (time, result) {
    var points = this.points;
    var times = this.times;
    var i = this._lastTimeIndex = this.findTimeInterval(time, this._lastTimeIndex);
    var u = (time - times[i]) / (times[i + 1] - times[i]);
    if (!defined(result)) {
        result = new Cartesian3();
    }
    return Cartesian3.lerp(points[i], points[i + 1], u, result);
};
module.exports = LinearSpline;
},{"./Cartesian3":102,"./DeveloperError":123,"./Spline":216,"./defaultValue":243,"./defineProperties":244,"./defined":245}],174:[function(require,module,exports){
var MersenneTwister = require('../ThirdParty/mersenne-twister'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var CesiumMath = {};
CesiumMath.EPSILON1 = 0.1;
CesiumMath.EPSILON2 = 0.01;
CesiumMath.EPSILON3 = 0.001;
CesiumMath.EPSILON4 = 0.0001;
CesiumMath.EPSILON5 = 0.00001;
CesiumMath.EPSILON6 = 0.000001;
CesiumMath.EPSILON7 = 1e-7;
CesiumMath.EPSILON8 = 1e-8;
CesiumMath.EPSILON9 = 1e-9;
CesiumMath.EPSILON10 = 1e-10;
CesiumMath.EPSILON11 = 1e-11;
CesiumMath.EPSILON12 = 1e-12;
CesiumMath.EPSILON13 = 1e-13;
CesiumMath.EPSILON14 = 1e-14;
CesiumMath.EPSILON15 = 1e-15;
CesiumMath.EPSILON16 = 1e-16;
CesiumMath.EPSILON17 = 1e-17;
CesiumMath.EPSILON18 = 1e-18;
CesiumMath.EPSILON19 = 1e-19;
CesiumMath.EPSILON20 = 1e-20;
CesiumMath.GRAVITATIONALPARAMETER = 398600441800000;
CesiumMath.SOLAR_RADIUS = 695500000;
CesiumMath.LUNAR_RADIUS = 1737400;
CesiumMath.SIXTY_FOUR_KILOBYTES = 64 * 1024;
CesiumMath.sign = function (value) {
    if (value > 0) {
        return 1;
    }
    if (value < 0) {
        return -1;
    }
    return 0;
};
CesiumMath.signNotZero = function (value) {
    return value < 0 ? -1 : 1;
};
CesiumMath.toSNorm = function (value) {
    return Math.round((CesiumMath.clamp(value, -1, 1) * 0.5 + 0.5) * 255);
};
CesiumMath.fromSNorm = function (value) {
    return CesiumMath.clamp(value, 0, 255) / 255 * 2 - 1;
};
CesiumMath.sinh = function (value) {
    var part1 = Math.pow(Math.E, value);
    var part2 = Math.pow(Math.E, -1 * value);
    return (part1 - part2) * 0.5;
};
CesiumMath.cosh = function (value) {
    var part1 = Math.pow(Math.E, value);
    var part2 = Math.pow(Math.E, -1 * value);
    return (part1 + part2) * 0.5;
};
CesiumMath.lerp = function (p, q, time) {
    return (1 - time) * p + time * q;
};
CesiumMath.PI = Math.PI;
CesiumMath.ONE_OVER_PI = 1 / Math.PI;
CesiumMath.PI_OVER_TWO = Math.PI * 0.5;
CesiumMath.PI_OVER_THREE = Math.PI / 3;
CesiumMath.PI_OVER_FOUR = Math.PI / 4;
CesiumMath.PI_OVER_SIX = Math.PI / 6;
CesiumMath.THREE_PI_OVER_TWO = 3 * Math.PI * 0.5;
CesiumMath.TWO_PI = 2 * Math.PI;
CesiumMath.ONE_OVER_TWO_PI = 1 / (2 * Math.PI);
CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180;
CesiumMath.DEGREES_PER_RADIAN = 180 / Math.PI;
CesiumMath.RADIANS_PER_ARCSECOND = CesiumMath.RADIANS_PER_DEGREE / 3600;
CesiumMath.toRadians = function (degrees) {
    if (!defined(degrees)) {
        throw new DeveloperError('degrees is required.');
    }
    return degrees * CesiumMath.RADIANS_PER_DEGREE;
};
CesiumMath.toDegrees = function (radians) {
    if (!defined(radians)) {
        throw new DeveloperError('radians is required.');
    }
    return radians * CesiumMath.DEGREES_PER_RADIAN;
};
CesiumMath.convertLongitudeRange = function (angle) {
    if (!defined(angle)) {
        throw new DeveloperError('angle is required.');
    }
    var twoPi = CesiumMath.TWO_PI;
    var simplified = angle - Math.floor(angle / twoPi) * twoPi;
    if (simplified < -Math.PI) {
        return simplified + twoPi;
    }
    if (simplified >= Math.PI) {
        return simplified - twoPi;
    }
    return simplified;
};
CesiumMath.negativePiToPi = function (x) {
    if (!defined(x)) {
        throw new DeveloperError('x is required.');
    }
    return CesiumMath.zeroToTwoPi(x + CesiumMath.PI) - CesiumMath.PI;
};
CesiumMath.zeroToTwoPi = function (x) {
    if (!defined(x)) {
        throw new DeveloperError('x is required.');
    }
    var mod = CesiumMath.mod(x, CesiumMath.TWO_PI);
    if (Math.abs(mod) < CesiumMath.EPSILON14 && Math.abs(x) > CesiumMath.EPSILON14) {
        return CesiumMath.TWO_PI;
    }
    return mod;
};
CesiumMath.mod = function (m, n) {
    if (!defined(m)) {
        throw new DeveloperError('m is required.');
    }
    if (!defined(n)) {
        throw new DeveloperError('n is required.');
    }
    return (m % n + n) % n;
};
CesiumMath.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    if (!defined(relativeEpsilon)) {
        throw new DeveloperError('relativeEpsilon is required.');
    }
    absoluteEpsilon = defaultValue(absoluteEpsilon, relativeEpsilon);
    var absDiff = Math.abs(left - right);
    return absDiff <= absoluteEpsilon || absDiff <= relativeEpsilon * Math.max(Math.abs(left), Math.abs(right));
};
var factorials = [1];
CesiumMath.factorial = function (n) {
    if (typeof n !== 'number' || n < 0) {
        throw new DeveloperError('A number greater than or equal to 0 is required.');
    }
    var length = factorials.length;
    if (n >= length) {
        var sum = factorials[length - 1];
        for (var i = length; i <= n; i++) {
            factorials.push(sum * i);
        }
    }
    return factorials[n];
};
CesiumMath.incrementWrap = function (n, maximumValue, minimumValue) {
    minimumValue = defaultValue(minimumValue, 0);
    if (!defined(n)) {
        throw new DeveloperError('n is required.');
    }
    if (maximumValue <= minimumValue) {
        throw new DeveloperError('maximumValue must be greater than minimumValue.');
    }
    ++n;
    if (n > maximumValue) {
        n = minimumValue;
    }
    return n;
};
CesiumMath.isPowerOfTwo = function (n) {
    if (typeof n !== 'number' || n < 0) {
        throw new DeveloperError('A number greater than or equal to 0 is required.');
    }
    return n !== 0 && (n & n - 1) === 0;
};
CesiumMath.nextPowerOfTwo = function (n) {
    if (typeof n !== 'number' || n < 0) {
        throw new DeveloperError('A number greater than or equal to 0 is required.');
    }
    --n;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    ++n;
    return n;
};
CesiumMath.clamp = function (value, min, max) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(min)) {
        throw new DeveloperError('min is required.');
    }
    if (!defined(max)) {
        throw new DeveloperError('max is required.');
    }
    return value < min ? min : value > max ? max : value;
};
var randomNumberGenerator = new MersenneTwister();
CesiumMath.setRandomNumberSeed = function (seed) {
    if (!defined(seed)) {
        throw new DeveloperError('seed is required.');
    }
    randomNumberGenerator = new MersenneTwister(seed);
};
CesiumMath.nextRandomNumber = function () {
    return randomNumberGenerator.random();
};
CesiumMath.acosClamped = function (value) {
    if (!defined(value)) {
        throw new DeveloperError('value is required.');
    }
    return Math.acos(CesiumMath.clamp(value, -1, 1));
};
CesiumMath.asinClamped = function (value) {
    if (!defined(value)) {
        throw new DeveloperError('value is required.');
    }
    return Math.asin(CesiumMath.clamp(value, -1, 1));
};
CesiumMath.chordLength = function (angle, radius) {
    if (!defined(angle)) {
        throw new DeveloperError('angle is required.');
    }
    if (!defined(radius)) {
        throw new DeveloperError('radius is required.');
    }
    return 2 * radius * Math.sin(angle * 0.5);
};
module.exports = CesiumMath;
},{"../ThirdParty/mersenne-twister":593,"./DeveloperError":123,"./defaultValue":243,"./defined":245}],175:[function(require,module,exports){
var Cartesian2 = require('./Cartesian2'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject');
'use strict';
var Matrix2 = function (column0Row0, column1Row0, column0Row1, column1Row1) {
    this[0] = defaultValue(column0Row0, 0);
    this[1] = defaultValue(column0Row1, 0);
    this[2] = defaultValue(column1Row0, 0);
    this[3] = defaultValue(column1Row1, 0);
};
Matrix2.clone = function (values, result) {
    if (!defined(values)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Matrix2(values[0], values[2], values[1], values[3]);
    }
    result[0] = values[0];
    result[1] = values[1];
    result[2] = values[2];
    result[3] = values[3];
    return result;
};
Matrix2.fromArray = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Matrix2();
    }
    result[0] = array[startingIndex];
    result[1] = array[startingIndex + 1];
    result[2] = array[startingIndex + 2];
    result[3] = array[startingIndex + 3];
    return result;
};
Matrix2.fromColumnMajorArray = function (values, result) {
    if (!defined(values)) {
        throw new DeveloperError('values parameter is required');
    }
    return Matrix2.clone(values, result);
};
Matrix2.fromRowMajorArray = function (values, result) {
    if (!defined(values)) {
        throw new DeveloperError('values is required.');
    }
    if (!defined(result)) {
        return new Matrix2(values[0], values[1], values[2], values[3]);
    }
    result[0] = values[0];
    result[1] = values[2];
    result[2] = values[1];
    result[3] = values[3];
    return result;
};
Matrix2.fromScale = function (scale, result) {
    if (!defined(scale)) {
        throw new DeveloperError('scale is required.');
    }
    if (!defined(result)) {
        return new Matrix2(scale.x, 0, 0, scale.y);
    }
    result[0] = scale.x;
    result[1] = 0;
    result[2] = 0;
    result[3] = scale.y;
    return result;
};
Matrix2.fromUniformScale = function (scale, result) {
    if (typeof scale !== 'number') {
        throw new DeveloperError('scale is required.');
    }
    if (!defined(result)) {
        return new Matrix2(scale, 0, 0, scale);
    }
    result[0] = scale;
    result[1] = 0;
    result[2] = 0;
    result[3] = scale;
    return result;
};
Matrix2.fromRotation = function (angle, result) {
    if (!defined(angle)) {
        throw new DeveloperError('angle is required.');
    }
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined(result)) {
        return new Matrix2(cosAngle, -sinAngle, sinAngle, cosAngle);
    }
    result[0] = cosAngle;
    result[1] = sinAngle;
    result[2] = -sinAngle;
    result[3] = cosAngle;
    return result;
};
Matrix2.toArray = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        return [
            matrix[0],
            matrix[1],
            matrix[2],
            matrix[3]
        ];
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    return result;
};
Matrix2.getElementIndex = function (column, row) {
    if (typeof row !== 'number' || row < 0 || row > 1) {
        throw new DeveloperError('row must be 0 or 1.');
    }
    if (typeof column !== 'number' || column < 0 || column > 1) {
        throw new DeveloperError('column must be 0 or 1.');
    }
    return column * 2 + row;
};
Matrix2.getColumn = function (matrix, index, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (typeof index !== 'number' || index < 0 || index > 1) {
        throw new DeveloperError('index must be 0 or 1.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var startIndex = index * 2;
    var x = matrix[startIndex];
    var y = matrix[startIndex + 1];
    result.x = x;
    result.y = y;
    return result;
};
Matrix2.setColumn = function (matrix, index, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof index !== 'number' || index < 0 || index > 1) {
        throw new DeveloperError('index must be 0 or 1.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result = Matrix2.clone(matrix, result);
    var startIndex = index * 2;
    result[startIndex] = cartesian.x;
    result[startIndex + 1] = cartesian.y;
    return result;
};
Matrix2.getRow = function (matrix, index, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (typeof index !== 'number' || index < 0 || index > 1) {
        throw new DeveloperError('index must be 0 or 1.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var x = matrix[index];
    var y = matrix[index + 2];
    result.x = x;
    result.y = y;
    return result;
};
Matrix2.setRow = function (matrix, index, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof index !== 'number' || index < 0 || index > 1) {
        throw new DeveloperError('index must be 0 or 1.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result = Matrix2.clone(matrix, result);
    result[index] = cartesian.x;
    result[index + 2] = cartesian.y;
    return result;
};
var scratchColumn = new Cartesian2();
Matrix2.getScale = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result.x = Cartesian2.magnitude(Cartesian2.fromElements(matrix[0], matrix[1], scratchColumn));
    result.y = Cartesian2.magnitude(Cartesian2.fromElements(matrix[2], matrix[3], scratchColumn));
    return result;
};
var scratchScale = new Cartesian2();
Matrix2.getMaximumScale = function (matrix) {
    Matrix2.getScale(matrix, scratchScale);
    return Cartesian2.maximumComponent(scratchScale);
};
Matrix2.multiply = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var column0Row0 = left[0] * right[0] + left[2] * right[1];
    var column1Row0 = left[0] * right[2] + left[2] * right[3];
    var column0Row1 = left[1] * right[0] + left[3] * right[1];
    var column1Row1 = left[1] * right[2] + left[3] * right[3];
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column1Row0;
    result[3] = column1Row1;
    return result;
};
Matrix2.add = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = left[0] + right[0];
    result[1] = left[1] + right[1];
    result[2] = left[2] + right[2];
    result[3] = left[3] + right[3];
    return result;
};
Matrix2.subtract = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = left[0] - right[0];
    result[1] = left[1] - right[1];
    result[2] = left[2] - right[2];
    result[3] = left[3] - right[3];
    return result;
};
Matrix2.multiplyByVector = function (matrix, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;
    var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;
    result.x = x;
    result.y = y;
    return result;
};
Matrix2.multiplyByScalar = function (matrix, scalar, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = matrix[0] * scalar;
    result[1] = matrix[1] * scalar;
    result[2] = matrix[2] * scalar;
    result[3] = matrix[3] * scalar;
    return result;
};
Matrix2.negate = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = -matrix[0];
    result[1] = -matrix[1];
    result[2] = -matrix[2];
    result[3] = -matrix[3];
    return result;
};
Matrix2.transpose = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var column0Row0 = matrix[0];
    var column0Row1 = matrix[2];
    var column1Row0 = matrix[1];
    var column1Row1 = matrix[3];
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column1Row0;
    result[3] = column1Row1;
    return result;
};
Matrix2.abs = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = Math.abs(matrix[0]);
    result[1] = Math.abs(matrix[1]);
    result[2] = Math.abs(matrix[2]);
    result[3] = Math.abs(matrix[3]);
    return result;
};
Matrix2.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3];
};
Matrix2.equalsEpsilon = function (left, right, epsilon) {
    if (typeof epsilon !== 'number') {
        throw new DeveloperError('epsilon must be a number');
    }
    return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon;
};
Matrix2.IDENTITY = freezeObject(new Matrix2(1, 0, 0, 1));
Matrix2.COLUMN0ROW0 = 0;
Matrix2.COLUMN0ROW1 = 1;
Matrix2.COLUMN1ROW0 = 2;
Matrix2.COLUMN1ROW1 = 3;
Matrix2.prototype.clone = function (result) {
    return Matrix2.clone(this, result);
};
Matrix2.prototype.equals = function (right) {
    return Matrix2.equals(this, right);
};
Matrix2.prototype.equalsEpsilon = function (right, epsilon) {
    return Matrix2.equalsEpsilon(this, right, epsilon);
};
Matrix2.prototype.toString = function () {
    return '(' + this[0] + ', ' + this[2] + ')\n' + '(' + this[1] + ', ' + this[3] + ')';
};
module.exports = Matrix2;
},{"./Cartesian2":101,"./DeveloperError":123,"./defaultValue":243,"./defined":245,"./freezeObject":249}],176:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
var Matrix3 = function (column0Row0, column1Row0, column2Row0, column0Row1, column1Row1, column2Row1, column0Row2, column1Row2, column2Row2) {
    this[0] = defaultValue(column0Row0, 0);
    this[1] = defaultValue(column0Row1, 0);
    this[2] = defaultValue(column0Row2, 0);
    this[3] = defaultValue(column1Row0, 0);
    this[4] = defaultValue(column1Row1, 0);
    this[5] = defaultValue(column1Row2, 0);
    this[6] = defaultValue(column2Row0, 0);
    this[7] = defaultValue(column2Row1, 0);
    this[8] = defaultValue(column2Row2, 0);
};
Matrix3.clone = function (values, result) {
    if (!defined(values)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Matrix3(values[0], values[3], values[6], values[1], values[4], values[7], values[2], values[5], values[8]);
    }
    result[0] = values[0];
    result[1] = values[1];
    result[2] = values[2];
    result[3] = values[3];
    result[4] = values[4];
    result[5] = values[5];
    result[6] = values[6];
    result[7] = values[7];
    result[8] = values[8];
    return result;
};
Matrix3.fromArray = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Matrix3();
    }
    result[0] = array[startingIndex];
    result[1] = array[startingIndex + 1];
    result[2] = array[startingIndex + 2];
    result[3] = array[startingIndex + 3];
    result[4] = array[startingIndex + 4];
    result[5] = array[startingIndex + 5];
    result[6] = array[startingIndex + 6];
    result[7] = array[startingIndex + 7];
    result[8] = array[startingIndex + 8];
    return result;
};
Matrix3.fromColumnMajorArray = function (values, result) {
    if (!defined(values)) {
        throw new DeveloperError('values parameter is required');
    }
    return Matrix3.clone(values, result);
};
Matrix3.fromRowMajorArray = function (values, result) {
    if (!defined(values)) {
        throw new DeveloperError('values is required.');
    }
    if (!defined(result)) {
        return new Matrix3(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8]);
    }
    result[0] = values[0];
    result[1] = values[3];
    result[2] = values[6];
    result[3] = values[1];
    result[4] = values[4];
    result[5] = values[7];
    result[6] = values[2];
    result[7] = values[5];
    result[8] = values[8];
    return result;
};
Matrix3.fromQuaternion = function (quaternion, result) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required');
    }
    var x2 = quaternion.x * quaternion.x;
    var xy = quaternion.x * quaternion.y;
    var xz = quaternion.x * quaternion.z;
    var xw = quaternion.x * quaternion.w;
    var y2 = quaternion.y * quaternion.y;
    var yz = quaternion.y * quaternion.z;
    var yw = quaternion.y * quaternion.w;
    var z2 = quaternion.z * quaternion.z;
    var zw = quaternion.z * quaternion.w;
    var w2 = quaternion.w * quaternion.w;
    var m00 = x2 - y2 - z2 + w2;
    var m01 = 2 * (xy - zw);
    var m02 = 2 * (xz + yw);
    var m10 = 2 * (xy + zw);
    var m11 = -x2 + y2 - z2 + w2;
    var m12 = 2 * (yz - xw);
    var m20 = 2 * (xz - yw);
    var m21 = 2 * (yz + xw);
    var m22 = -x2 - y2 + z2 + w2;
    if (!defined(result)) {
        return new Matrix3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    }
    result[0] = m00;
    result[1] = m10;
    result[2] = m20;
    result[3] = m01;
    result[4] = m11;
    result[5] = m21;
    result[6] = m02;
    result[7] = m12;
    result[8] = m22;
    return result;
};
Matrix3.fromScale = function (scale, result) {
    if (!defined(scale)) {
        throw new DeveloperError('scale is required.');
    }
    if (!defined(result)) {
        return new Matrix3(scale.x, 0, 0, 0, scale.y, 0, 0, 0, scale.z);
    }
    result[0] = scale.x;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = scale.y;
    result[5] = 0;
    result[6] = 0;
    result[7] = 0;
    result[8] = scale.z;
    return result;
};
Matrix3.fromUniformScale = function (scale, result) {
    if (typeof scale !== 'number') {
        throw new DeveloperError('scale is required.');
    }
    if (!defined(result)) {
        return new Matrix3(scale, 0, 0, 0, scale, 0, 0, 0, scale);
    }
    result[0] = scale;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = scale;
    result[5] = 0;
    result[6] = 0;
    result[7] = 0;
    result[8] = scale;
    return result;
};
Matrix3.fromCrossProduct = function (vector, result) {
    if (!defined(vector)) {
        throw new DeveloperError('vector is required.');
    }
    if (!defined(result)) {
        return new Matrix3(0, -vector.z, vector.y, vector.z, 0, -vector.x, -vector.y, vector.x, 0);
    }
    result[0] = 0;
    result[1] = vector.z;
    result[2] = -vector.y;
    result[3] = -vector.z;
    result[4] = 0;
    result[5] = vector.x;
    result[6] = vector.y;
    result[7] = -vector.x;
    result[8] = 0;
    return result;
};
Matrix3.fromRotationX = function (angle, result) {
    if (!defined(angle)) {
        throw new DeveloperError('angle is required.');
    }
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined(result)) {
        return new Matrix3(1, 0, 0, 0, cosAngle, -sinAngle, 0, sinAngle, cosAngle);
    }
    result[0] = 1;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = cosAngle;
    result[5] = sinAngle;
    result[6] = 0;
    result[7] = -sinAngle;
    result[8] = cosAngle;
    return result;
};
Matrix3.fromRotationY = function (angle, result) {
    if (!defined(angle)) {
        throw new DeveloperError('angle is required.');
    }
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined(result)) {
        return new Matrix3(cosAngle, 0, sinAngle, 0, 1, 0, -sinAngle, 0, cosAngle);
    }
    result[0] = cosAngle;
    result[1] = 0;
    result[2] = -sinAngle;
    result[3] = 0;
    result[4] = 1;
    result[5] = 0;
    result[6] = sinAngle;
    result[7] = 0;
    result[8] = cosAngle;
    return result;
};
Matrix3.fromRotationZ = function (angle, result) {
    if (!defined(angle)) {
        throw new DeveloperError('angle is required.');
    }
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    if (!defined(result)) {
        return new Matrix3(cosAngle, -sinAngle, 0, sinAngle, cosAngle, 0, 0, 0, 1);
    }
    result[0] = cosAngle;
    result[1] = sinAngle;
    result[2] = 0;
    result[3] = -sinAngle;
    result[4] = cosAngle;
    result[5] = 0;
    result[6] = 0;
    result[7] = 0;
    result[8] = 1;
    return result;
};
Matrix3.toArray = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        return [
            matrix[0],
            matrix[1],
            matrix[2],
            matrix[3],
            matrix[4],
            matrix[5],
            matrix[6],
            matrix[7],
            matrix[8]
        ];
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    return result;
};
Matrix3.getElementIndex = function (column, row) {
    if (typeof row !== 'number' || row < 0 || row > 2) {
        throw new DeveloperError('row must be 0, 1, or 2.');
    }
    if (typeof column !== 'number' || column < 0 || column > 2) {
        throw new DeveloperError('column must be 0, 1, or 2.');
    }
    return column * 3 + row;
};
Matrix3.getColumn = function (matrix, index, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (typeof index !== 'number' || index < 0 || index > 2) {
        throw new DeveloperError('index must be 0, 1, or 2.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var startIndex = index * 3;
    var x = matrix[startIndex];
    var y = matrix[startIndex + 1];
    var z = matrix[startIndex + 2];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
Matrix3.setColumn = function (matrix, index, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof index !== 'number' || index < 0 || index > 2) {
        throw new DeveloperError('index must be 0, 1, or 2.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result = Matrix3.clone(matrix, result);
    var startIndex = index * 3;
    result[startIndex] = cartesian.x;
    result[startIndex + 1] = cartesian.y;
    result[startIndex + 2] = cartesian.z;
    return result;
};
Matrix3.getRow = function (matrix, index, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (typeof index !== 'number' || index < 0 || index > 2) {
        throw new DeveloperError('index must be 0, 1, or 2.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var x = matrix[index];
    var y = matrix[index + 3];
    var z = matrix[index + 6];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
Matrix3.setRow = function (matrix, index, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof index !== 'number' || index < 0 || index > 2) {
        throw new DeveloperError('index must be 0, 1, or 2.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result = Matrix3.clone(matrix, result);
    result[index] = cartesian.x;
    result[index + 3] = cartesian.y;
    result[index + 6] = cartesian.z;
    return result;
};
var scratchColumn = new Cartesian3();
Matrix3.getScale = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
    result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[3], matrix[4], matrix[5], scratchColumn));
    result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[6], matrix[7], matrix[8], scratchColumn));
    return result;
};
var scratchScale = new Cartesian3();
Matrix3.getMaximumScale = function (matrix) {
    Matrix3.getScale(matrix, scratchScale);
    return Cartesian3.maximumComponent(scratchScale);
};
Matrix3.multiply = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
    var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
    var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];
    var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
    var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
    var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];
    var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
    var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
    var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column1Row0;
    result[4] = column1Row1;
    result[5] = column1Row2;
    result[6] = column2Row0;
    result[7] = column2Row1;
    result[8] = column2Row2;
    return result;
};
Matrix3.add = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = left[0] + right[0];
    result[1] = left[1] + right[1];
    result[2] = left[2] + right[2];
    result[3] = left[3] + right[3];
    result[4] = left[4] + right[4];
    result[5] = left[5] + right[5];
    result[6] = left[6] + right[6];
    result[7] = left[7] + right[7];
    result[8] = left[8] + right[8];
    return result;
};
Matrix3.subtract = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = left[0] - right[0];
    result[1] = left[1] - right[1];
    result[2] = left[2] - right[2];
    result[3] = left[3] - right[3];
    result[4] = left[4] - right[4];
    result[5] = left[5] - right[5];
    result[6] = left[6] - right[6];
    result[7] = left[7] - right[7];
    result[8] = left[8] - right[8];
    return result;
};
Matrix3.multiplyByVector = function (matrix, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
    var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
    var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
Matrix3.multiplyByScalar = function (matrix, scalar, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar must be a number');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = matrix[0] * scalar;
    result[1] = matrix[1] * scalar;
    result[2] = matrix[2] * scalar;
    result[3] = matrix[3] * scalar;
    result[4] = matrix[4] * scalar;
    result[5] = matrix[5] * scalar;
    result[6] = matrix[6] * scalar;
    result[7] = matrix[7] * scalar;
    result[8] = matrix[8] * scalar;
    return result;
};
Matrix3.negate = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = -matrix[0];
    result[1] = -matrix[1];
    result[2] = -matrix[2];
    result[3] = -matrix[3];
    result[4] = -matrix[4];
    result[5] = -matrix[5];
    result[6] = -matrix[6];
    result[7] = -matrix[7];
    result[8] = -matrix[8];
    return result;
};
Matrix3.transpose = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var column0Row0 = matrix[0];
    var column0Row1 = matrix[3];
    var column0Row2 = matrix[6];
    var column1Row0 = matrix[1];
    var column1Row1 = matrix[4];
    var column1Row2 = matrix[7];
    var column2Row0 = matrix[2];
    var column2Row1 = matrix[5];
    var column2Row2 = matrix[8];
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column1Row0;
    result[4] = column1Row1;
    result[5] = column1Row2;
    result[6] = column2Row0;
    result[7] = column2Row1;
    result[8] = column2Row2;
    return result;
};
function computeFrobeniusNorm(matrix) {
    var norm = 0;
    for (var i = 0; i < 9; ++i) {
        var temp = matrix[i];
        norm += temp * temp;
    }
    return Math.sqrt(norm);
}
var rowVal = [
        1,
        0,
        0
    ];
var colVal = [
        2,
        2,
        1
    ];
function offDiagonalFrobeniusNorm(matrix) {
    var norm = 0;
    for (var i = 0; i < 3; ++i) {
        var temp = matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])];
        norm += 2 * temp * temp;
    }
    return Math.sqrt(norm);
}
function shurDecomposition(matrix, result) {
    var tolerance = CesiumMath.EPSILON15;
    var maxDiagonal = 0;
    var rotAxis = 1;
    for (var i = 0; i < 3; ++i) {
        var temp = Math.abs(matrix[Matrix3.getElementIndex(colVal[i], rowVal[i])]);
        if (temp > maxDiagonal) {
            rotAxis = i;
            maxDiagonal = temp;
        }
    }
    var c = 1;
    var s = 0;
    var p = rowVal[rotAxis];
    var q = colVal[rotAxis];
    if (Math.abs(matrix[Matrix3.getElementIndex(q, p)]) > tolerance) {
        var qq = matrix[Matrix3.getElementIndex(q, q)];
        var pp = matrix[Matrix3.getElementIndex(p, p)];
        var qp = matrix[Matrix3.getElementIndex(q, p)];
        var tau = (qq - pp) / 2 / qp;
        var t;
        if (tau < 0) {
            t = -1 / (-tau + Math.sqrt(1 + tau * tau));
        } else {
            t = 1 / (tau + Math.sqrt(1 + tau * tau));
        }
        c = 1 / Math.sqrt(1 + t * t);
        s = t * c;
    }
    result = Matrix3.clone(Matrix3.IDENTITY, result);
    result[Matrix3.getElementIndex(p, p)] = result[Matrix3.getElementIndex(q, q)] = c;
    result[Matrix3.getElementIndex(q, p)] = s;
    result[Matrix3.getElementIndex(p, q)] = -s;
    return result;
}
var jMatrix = new Matrix3();
var jMatrixTranspose = new Matrix3();
Matrix3.computeEigenDecomposition = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    var tolerance = CesiumMath.EPSILON20;
    var maxSweeps = 10;
    var count = 0;
    var sweep = 0;
    if (!defined(result)) {
        result = {};
    }
    var unitaryMatrix = result.unitary = Matrix3.clone(Matrix3.IDENTITY, result.unitary);
    var diagMatrix = result.diagonal = Matrix3.clone(matrix, result.diagonal);
    var epsilon = tolerance * computeFrobeniusNorm(diagMatrix);
    while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagMatrix) > epsilon) {
        shurDecomposition(diagMatrix, jMatrix);
        Matrix3.transpose(jMatrix, jMatrixTranspose);
        Matrix3.multiply(diagMatrix, jMatrix, diagMatrix);
        Matrix3.multiply(jMatrixTranspose, diagMatrix, diagMatrix);
        Matrix3.multiply(unitaryMatrix, jMatrix, unitaryMatrix);
        if (++count > 2) {
            ++sweep;
            count = 0;
        }
    }
    return result;
};
Matrix3.abs = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = Math.abs(matrix[0]);
    result[1] = Math.abs(matrix[1]);
    result[2] = Math.abs(matrix[2]);
    result[3] = Math.abs(matrix[3]);
    result[4] = Math.abs(matrix[4]);
    result[5] = Math.abs(matrix[5]);
    result[6] = Math.abs(matrix[6]);
    result[7] = Math.abs(matrix[7]);
    result[8] = Math.abs(matrix[8]);
    return result;
};
Matrix3.determinant = function (matrix) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    var m11 = matrix[0];
    var m21 = matrix[3];
    var m31 = matrix[6];
    var m12 = matrix[1];
    var m22 = matrix[4];
    var m32 = matrix[7];
    var m13 = matrix[2];
    var m23 = matrix[5];
    var m33 = matrix[8];
    return m11 * (m22 * m33 - m23 * m32) + m12 * (m23 * m31 - m21 * m33) + m13 * (m21 * m32 - m22 * m31);
};
Matrix3.inverse = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var m11 = matrix[0];
    var m21 = matrix[1];
    var m31 = matrix[2];
    var m12 = matrix[3];
    var m22 = matrix[4];
    var m32 = matrix[5];
    var m13 = matrix[6];
    var m23 = matrix[7];
    var m33 = matrix[8];
    var determinant = Matrix3.determinant(matrix);
    if (Math.abs(determinant) <= CesiumMath.EPSILON15) {
        throw new DeveloperError('matrix is not invertible');
    }
    result[0] = m22 * m33 - m23 * m32;
    result[1] = m23 * m31 - m21 * m33;
    result[2] = m21 * m32 - m22 * m31;
    result[3] = m13 * m32 - m12 * m33;
    result[4] = m11 * m33 - m13 * m31;
    result[5] = m12 * m31 - m11 * m32;
    result[6] = m12 * m23 - m13 * m22;
    result[7] = m13 * m21 - m11 * m23;
    result[8] = m11 * m22 - m12 * m21;
    var scale = 1 / determinant;
    return Matrix3.multiplyByScalar(result, scale, result);
};
Matrix3.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[3] === right[3] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[7] === right[7] && left[8] === right[8];
};
Matrix3.equalsEpsilon = function (left, right, epsilon) {
    if (typeof epsilon !== 'number') {
        throw new DeveloperError('epsilon must be a number');
    }
    return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon;
};
Matrix3.IDENTITY = freezeObject(new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1));
Matrix3.COLUMN0ROW0 = 0;
Matrix3.COLUMN0ROW1 = 1;
Matrix3.COLUMN0ROW2 = 2;
Matrix3.COLUMN1ROW0 = 3;
Matrix3.COLUMN1ROW1 = 4;
Matrix3.COLUMN1ROW2 = 5;
Matrix3.COLUMN2ROW0 = 6;
Matrix3.COLUMN2ROW1 = 7;
Matrix3.COLUMN2ROW2 = 8;
Matrix3.prototype.clone = function (result) {
    return Matrix3.clone(this, result);
};
Matrix3.prototype.equals = function (right) {
    return Matrix3.equals(this, right);
};
Matrix3.prototype.equalsEpsilon = function (right, epsilon) {
    return Matrix3.equalsEpsilon(this, right, epsilon);
};
Matrix3.prototype.toString = function () {
    return '(' + this[0] + ', ' + this[3] + ', ' + this[6] + ')\n' + '(' + this[1] + ', ' + this[4] + ', ' + this[7] + ')\n' + '(' + this[2] + ', ' + this[5] + ', ' + this[8] + ')';
};
module.exports = Matrix3;
},{"./Cartesian3":102,"./DeveloperError":123,"./Math":174,"./defaultValue":243,"./defined":245,"./freezeObject":249}],177:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartesian4 = require('./Cartesian4'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), RuntimeError = require('./RuntimeError');
'use strict';
var Matrix4 = function (column0Row0, column1Row0, column2Row0, column3Row0, column0Row1, column1Row1, column2Row1, column3Row1, column0Row2, column1Row2, column2Row2, column3Row2, column0Row3, column1Row3, column2Row3, column3Row3) {
    this[0] = defaultValue(column0Row0, 0);
    this[1] = defaultValue(column0Row1, 0);
    this[2] = defaultValue(column0Row2, 0);
    this[3] = defaultValue(column0Row3, 0);
    this[4] = defaultValue(column1Row0, 0);
    this[5] = defaultValue(column1Row1, 0);
    this[6] = defaultValue(column1Row2, 0);
    this[7] = defaultValue(column1Row3, 0);
    this[8] = defaultValue(column2Row0, 0);
    this[9] = defaultValue(column2Row1, 0);
    this[10] = defaultValue(column2Row2, 0);
    this[11] = defaultValue(column2Row3, 0);
    this[12] = defaultValue(column3Row0, 0);
    this[13] = defaultValue(column3Row1, 0);
    this[14] = defaultValue(column3Row2, 0);
    this[15] = defaultValue(column3Row3, 0);
};
Matrix4.packedLength = 16;
Matrix4.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value[0];
    array[startingIndex++] = value[1];
    array[startingIndex++] = value[2];
    array[startingIndex++] = value[3];
    array[startingIndex++] = value[4];
    array[startingIndex++] = value[5];
    array[startingIndex++] = value[6];
    array[startingIndex++] = value[7];
    array[startingIndex++] = value[8];
    array[startingIndex++] = value[9];
    array[startingIndex++] = value[10];
    array[startingIndex++] = value[11];
    array[startingIndex++] = value[12];
    array[startingIndex++] = value[13];
    array[startingIndex++] = value[14];
    array[startingIndex] = value[15];
};
Matrix4.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Matrix4();
    }
    result[0] = array[startingIndex++];
    result[1] = array[startingIndex++];
    result[2] = array[startingIndex++];
    result[3] = array[startingIndex++];
    result[4] = array[startingIndex++];
    result[5] = array[startingIndex++];
    result[6] = array[startingIndex++];
    result[7] = array[startingIndex++];
    result[8] = array[startingIndex++];
    result[9] = array[startingIndex++];
    result[10] = array[startingIndex++];
    result[11] = array[startingIndex++];
    result[12] = array[startingIndex++];
    result[13] = array[startingIndex++];
    result[14] = array[startingIndex++];
    result[15] = array[startingIndex];
    return result;
};
Matrix4.clone = function (matrix, result) {
    if (!defined(matrix)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Matrix4(matrix[0], matrix[4], matrix[8], matrix[12], matrix[1], matrix[5], matrix[9], matrix[13], matrix[2], matrix[6], matrix[10], matrix[14], matrix[3], matrix[7], matrix[11], matrix[15]);
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
};
Matrix4.fromArray = Matrix4.unpack;
Matrix4.fromColumnMajorArray = function (values, result) {
    if (!defined(values)) {
        throw new DeveloperError('values is required');
    }
    return Matrix4.clone(values, result);
};
Matrix4.fromRowMajorArray = function (values, result) {
    if (!defined(values)) {
        throw new DeveloperError('values is required.');
    }
    if (!defined(result)) {
        return new Matrix4(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8], values[9], values[10], values[11], values[12], values[13], values[14], values[15]);
    }
    result[0] = values[0];
    result[1] = values[4];
    result[2] = values[8];
    result[3] = values[12];
    result[4] = values[1];
    result[5] = values[5];
    result[6] = values[9];
    result[7] = values[13];
    result[8] = values[2];
    result[9] = values[6];
    result[10] = values[10];
    result[11] = values[14];
    result[12] = values[3];
    result[13] = values[7];
    result[14] = values[11];
    result[15] = values[15];
    return result;
};
Matrix4.fromRotationTranslation = function (rotation, translation, result) {
    if (!defined(rotation)) {
        throw new DeveloperError('rotation is required.');
    }
    translation = defaultValue(translation, Cartesian3.ZERO);
    if (!defined(result)) {
        return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x, rotation[1], rotation[4], rotation[7], translation.y, rotation[2], rotation[5], rotation[8], translation.z, 0, 0, 0, 1);
    }
    result[0] = rotation[0];
    result[1] = rotation[1];
    result[2] = rotation[2];
    result[3] = 0;
    result[4] = rotation[3];
    result[5] = rotation[4];
    result[6] = rotation[5];
    result[7] = 0;
    result[8] = rotation[6];
    result[9] = rotation[7];
    result[10] = rotation[8];
    result[11] = 0;
    result[12] = translation.x;
    result[13] = translation.y;
    result[14] = translation.z;
    result[15] = 1;
    return result;
};
Matrix4.fromTranslationQuaternionRotationScale = function (translation, rotation, scale, result) {
    if (!defined(translation)) {
        throw new DeveloperError('translation is required.');
    }
    if (!defined(rotation)) {
        throw new DeveloperError('rotation is required.');
    }
    if (!defined(scale)) {
        throw new DeveloperError('scale is required.');
    }
    if (!defined(result)) {
        result = new Matrix4();
    }
    var scaleX = scale.x;
    var scaleY = scale.y;
    var scaleZ = scale.z;
    var x2 = rotation.x * rotation.x;
    var xy = rotation.x * rotation.y;
    var xz = rotation.x * rotation.z;
    var xw = rotation.x * rotation.w;
    var y2 = rotation.y * rotation.y;
    var yz = rotation.y * rotation.z;
    var yw = rotation.y * rotation.w;
    var z2 = rotation.z * rotation.z;
    var zw = rotation.z * rotation.w;
    var w2 = rotation.w * rotation.w;
    var m00 = x2 - y2 - z2 + w2;
    var m01 = 2 * (xy - zw);
    var m02 = 2 * (xz + yw);
    var m10 = 2 * (xy + zw);
    var m11 = -x2 + y2 - z2 + w2;
    var m12 = 2 * (yz - xw);
    var m20 = 2 * (xz - yw);
    var m21 = 2 * (yz + xw);
    var m22 = -x2 - y2 + z2 + w2;
    result[0] = m00 * scaleX;
    result[1] = m10 * scaleX;
    result[2] = m20 * scaleX;
    result[3] = 0;
    result[4] = m01 * scaleY;
    result[5] = m11 * scaleY;
    result[6] = m21 * scaleY;
    result[7] = 0;
    result[8] = m02 * scaleZ;
    result[9] = m12 * scaleZ;
    result[10] = m22 * scaleZ;
    result[11] = 0;
    result[12] = translation.x;
    result[13] = translation.y;
    result[14] = translation.z;
    result[15] = 1;
    return result;
};
Matrix4.fromTranslation = function (translation, result) {
    if (!defined(translation)) {
        throw new DeveloperError('translation is required.');
    }
    return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
};
Matrix4.fromScale = function (scale, result) {
    if (!defined(scale)) {
        throw new DeveloperError('scale is required.');
    }
    if (!defined(result)) {
        return new Matrix4(scale.x, 0, 0, 0, 0, scale.y, 0, 0, 0, 0, scale.z, 0, 0, 0, 0, 1);
    }
    result[0] = scale.x;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = scale.y;
    result[6] = 0;
    result[7] = 0;
    result[8] = 0;
    result[9] = 0;
    result[10] = scale.z;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
};
Matrix4.fromUniformScale = function (scale, result) {
    if (typeof scale !== 'number') {
        throw new DeveloperError('scale is required.');
    }
    if (!defined(result)) {
        return new Matrix4(scale, 0, 0, 0, 0, scale, 0, 0, 0, 0, scale, 0, 0, 0, 0, 1);
    }
    result[0] = scale;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = scale;
    result[6] = 0;
    result[7] = 0;
    result[8] = 0;
    result[9] = 0;
    result[10] = scale;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
};
var fromCameraF = new Cartesian3();
var fromCameraS = new Cartesian3();
var fromCameraU = new Cartesian3();
Matrix4.fromCamera = function (camera, result) {
    if (!defined(camera)) {
        throw new DeveloperError('camera is required.');
    }
    var eye = camera.eye;
    var target = camera.target;
    var up = camera.up;
    if (!defined(eye)) {
        throw new DeveloperError('camera.eye is required.');
    }
    if (!defined(target)) {
        throw new DeveloperError('camera.target is required.');
    }
    if (!defined(up)) {
        throw new DeveloperError('camera.up is required.');
    }
    Cartesian3.normalize(Cartesian3.subtract(target, eye, fromCameraF), fromCameraF);
    Cartesian3.normalize(Cartesian3.cross(fromCameraF, up, fromCameraS), fromCameraS);
    Cartesian3.normalize(Cartesian3.cross(fromCameraS, fromCameraF, fromCameraU), fromCameraU);
    var sX = fromCameraS.x;
    var sY = fromCameraS.y;
    var sZ = fromCameraS.z;
    var fX = fromCameraF.x;
    var fY = fromCameraF.y;
    var fZ = fromCameraF.z;
    var uX = fromCameraU.x;
    var uY = fromCameraU.y;
    var uZ = fromCameraU.z;
    var eyeX = eye.x;
    var eyeY = eye.y;
    var eyeZ = eye.z;
    var t0 = sX * -eyeX + sY * -eyeY + sZ * -eyeZ;
    var t1 = uX * -eyeX + uY * -eyeY + uZ * -eyeZ;
    var t2 = fX * eyeX + fY * eyeY + fZ * eyeZ;
    if (!defined(result)) {
        return new Matrix4(sX, sY, sZ, t0, uX, uY, uZ, t1, -fX, -fY, -fZ, t2, 0, 0, 0, 1);
    }
    result[0] = sX;
    result[1] = uX;
    result[2] = -fX;
    result[3] = 0;
    result[4] = sY;
    result[5] = uY;
    result[6] = -fY;
    result[7] = 0;
    result[8] = sZ;
    result[9] = uZ;
    result[10] = -fZ;
    result[11] = 0;
    result[12] = t0;
    result[13] = t1;
    result[14] = t2;
    result[15] = 1;
    return result;
};
Matrix4.computePerspectiveFieldOfView = function (fovY, aspectRatio, near, far, result) {
    if (fovY <= 0 || fovY > Math.PI) {
        throw new DeveloperError('fovY must be in [0, PI).');
    }
    if (aspectRatio <= 0) {
        throw new DeveloperError('aspectRatio must be greater than zero.');
    }
    if (near <= 0) {
        throw new DeveloperError('near must be greater than zero.');
    }
    if (far <= 0) {
        throw new DeveloperError('far must be greater than zero.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var bottom = Math.tan(fovY * 0.5);
    var column1Row1 = 1 / bottom;
    var column0Row0 = column1Row1 / aspectRatio;
    var column2Row2 = (far + near) / (near - far);
    var column3Row2 = 2 * far * near / (near - far);
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = 0;
    result[9] = 0;
    result[10] = column2Row2;
    result[11] = -1;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
};
Matrix4.computeOrthographicOffCenter = function (left, right, bottom, top, near, far, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    if (!defined(bottom)) {
        throw new DeveloperError('bottom is required.');
    }
    if (!defined(top)) {
        throw new DeveloperError('top is required.');
    }
    if (!defined(near)) {
        throw new DeveloperError('near is required.');
    }
    if (!defined(far)) {
        throw new DeveloperError('far is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var a = 1 / (right - left);
    var b = 1 / (top - bottom);
    var c = 1 / (far - near);
    var tx = -(right + left) * a;
    var ty = -(top + bottom) * b;
    var tz = -(far + near) * c;
    a *= 2;
    b *= 2;
    c *= -2;
    result[0] = a;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = b;
    result[6] = 0;
    result[7] = 0;
    result[8] = 0;
    result[9] = 0;
    result[10] = c;
    result[11] = 0;
    result[12] = tx;
    result[13] = ty;
    result[14] = tz;
    result[15] = 1;
    return result;
};
Matrix4.computePerspectiveOffCenter = function (left, right, bottom, top, near, far, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    if (!defined(bottom)) {
        throw new DeveloperError('bottom is required.');
    }
    if (!defined(top)) {
        throw new DeveloperError('top is required.');
    }
    if (!defined(near)) {
        throw new DeveloperError('near is required.');
    }
    if (!defined(far)) {
        throw new DeveloperError('far is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var column0Row0 = 2 * near / (right - left);
    var column1Row1 = 2 * near / (top - bottom);
    var column2Row0 = (right + left) / (right - left);
    var column2Row1 = (top + bottom) / (top - bottom);
    var column2Row2 = -(far + near) / (far - near);
    var column2Row3 = -1;
    var column3Row2 = -2 * far * near / (far - near);
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
};
Matrix4.computeInfinitePerspectiveOffCenter = function (left, right, bottom, top, near, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required.');
    }
    if (!defined(bottom)) {
        throw new DeveloperError('bottom is required.');
    }
    if (!defined(top)) {
        throw new DeveloperError('top is required.');
    }
    if (!defined(near)) {
        throw new DeveloperError('near is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var column0Row0 = 2 * near / (right - left);
    var column1Row1 = 2 * near / (top - bottom);
    var column2Row0 = (right + left) / (right - left);
    var column2Row1 = (top + bottom) / (top - bottom);
    var column2Row2 = -1;
    var column2Row3 = -1;
    var column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
};
Matrix4.computeViewportTransformation = function (viewport, nearDepthRange, farDepthRange, result) {
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    viewport = defaultValue(viewport, defaultValue.EMPTY_OBJECT);
    var x = defaultValue(viewport.x, 0);
    var y = defaultValue(viewport.y, 0);
    var width = defaultValue(viewport.width, 0);
    var height = defaultValue(viewport.height, 0);
    nearDepthRange = defaultValue(nearDepthRange, 0);
    farDepthRange = defaultValue(farDepthRange, 1);
    var halfWidth = width * 0.5;
    var halfHeight = height * 0.5;
    var halfDepth = (farDepthRange - nearDepthRange) * 0.5;
    var column0Row0 = halfWidth;
    var column1Row1 = halfHeight;
    var column2Row2 = halfDepth;
    var column3Row0 = x + halfWidth;
    var column3Row1 = y + halfHeight;
    var column3Row2 = nearDepthRange + halfDepth;
    var column3Row3 = 1;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = 0;
    result[9] = 0;
    result[10] = column2Row2;
    result[11] = 0;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = column3Row3;
    return result;
};
Matrix4.toArray = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        return [
            matrix[0],
            matrix[1],
            matrix[2],
            matrix[3],
            matrix[4],
            matrix[5],
            matrix[6],
            matrix[7],
            matrix[8],
            matrix[9],
            matrix[10],
            matrix[11],
            matrix[12],
            matrix[13],
            matrix[14],
            matrix[15]
        ];
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
};
Matrix4.getElementIndex = function (column, row) {
    if (typeof row !== 'number' || row < 0 || row > 3) {
        throw new DeveloperError('row must be 0, 1, 2, or 3.');
    }
    if (typeof column !== 'number' || column < 0 || column > 3) {
        throw new DeveloperError('column must be 0, 1, 2, or 3.');
    }
    return column * 4 + row;
};
Matrix4.getColumn = function (matrix, index, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (typeof index !== 'number' || index < 0 || index > 3) {
        throw new DeveloperError('index must be 0, 1, 2, or 3.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var startIndex = index * 4;
    var x = matrix[startIndex];
    var y = matrix[startIndex + 1];
    var z = matrix[startIndex + 2];
    var w = matrix[startIndex + 3];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
};
Matrix4.setColumn = function (matrix, index, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof index !== 'number' || index < 0 || index > 3) {
        throw new DeveloperError('index must be 0, 1, 2, or 3.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result = Matrix4.clone(matrix, result);
    var startIndex = index * 4;
    result[startIndex] = cartesian.x;
    result[startIndex + 1] = cartesian.y;
    result[startIndex + 2] = cartesian.z;
    result[startIndex + 3] = cartesian.w;
    return result;
};
Matrix4.getRow = function (matrix, index, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (typeof index !== 'number' || index < 0 || index > 3) {
        throw new DeveloperError('index must be 0, 1, 2, or 3.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var x = matrix[index];
    var y = matrix[index + 4];
    var z = matrix[index + 8];
    var w = matrix[index + 12];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
};
Matrix4.setRow = function (matrix, index, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (typeof index !== 'number' || index < 0 || index > 3) {
        throw new DeveloperError('index must be 0, 1, 2, or 3.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result = Matrix4.clone(matrix, result);
    result[index] = cartesian.x;
    result[index + 4] = cartesian.y;
    result[index + 8] = cartesian.z;
    result[index + 12] = cartesian.w;
    return result;
};
var scratchColumn = new Cartesian3();
Matrix4.getScale = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result.x = Cartesian3.magnitude(Cartesian3.fromElements(matrix[0], matrix[1], matrix[2], scratchColumn));
    result.y = Cartesian3.magnitude(Cartesian3.fromElements(matrix[4], matrix[5], matrix[6], scratchColumn));
    result.z = Cartesian3.magnitude(Cartesian3.fromElements(matrix[8], matrix[9], matrix[10], scratchColumn));
    return result;
};
var scratchScale = new Cartesian3();
Matrix4.getMaximumScale = function (matrix) {
    Matrix4.getScale(matrix, scratchScale);
    return Cartesian3.maximumComponent(scratchScale);
};
Matrix4.multiply = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var left0 = left[0];
    var left1 = left[1];
    var left2 = left[2];
    var left3 = left[3];
    var left4 = left[4];
    var left5 = left[5];
    var left6 = left[6];
    var left7 = left[7];
    var left8 = left[8];
    var left9 = left[9];
    var left10 = left[10];
    var left11 = left[11];
    var left12 = left[12];
    var left13 = left[13];
    var left14 = left[14];
    var left15 = left[15];
    var right0 = right[0];
    var right1 = right[1];
    var right2 = right[2];
    var right3 = right[3];
    var right4 = right[4];
    var right5 = right[5];
    var right6 = right[6];
    var right7 = right[7];
    var right8 = right[8];
    var right9 = right[9];
    var right10 = right[10];
    var right11 = right[11];
    var right12 = right[12];
    var right13 = right[13];
    var right14 = right[14];
    var right15 = right[15];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
    var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
    var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
    var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;
    var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
    var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
    var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
    var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = column0Row3;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = column1Row3;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = column3Row3;
    return result;
};
Matrix4.add = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = left[0] + right[0];
    result[1] = left[1] + right[1];
    result[2] = left[2] + right[2];
    result[3] = left[3] + right[3];
    result[4] = left[4] + right[4];
    result[5] = left[5] + right[5];
    result[6] = left[6] + right[6];
    result[7] = left[7] + right[7];
    result[8] = left[8] + right[8];
    result[9] = left[9] + right[9];
    result[10] = left[10] + right[10];
    result[11] = left[11] + right[11];
    result[12] = left[12] + right[12];
    result[13] = left[13] + right[13];
    result[14] = left[14] + right[14];
    result[15] = left[15] + right[15];
    return result;
};
Matrix4.subtract = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = left[0] - right[0];
    result[1] = left[1] - right[1];
    result[2] = left[2] - right[2];
    result[3] = left[3] - right[3];
    result[4] = left[4] - right[4];
    result[5] = left[5] - right[5];
    result[6] = left[6] - right[6];
    result[7] = left[7] - right[7];
    result[8] = left[8] - right[8];
    result[9] = left[9] - right[9];
    result[10] = left[10] - right[10];
    result[11] = left[11] - right[11];
    result[12] = left[12] - right[12];
    result[13] = left[13] - right[13];
    result[14] = left[14] - right[14];
    result[15] = left[15] - right[15];
    return result;
};
Matrix4.multiplyTransformation = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var left0 = left[0];
    var left1 = left[1];
    var left2 = left[2];
    var left4 = left[4];
    var left5 = left[5];
    var left6 = left[6];
    var left8 = left[8];
    var left9 = left[9];
    var left10 = left[10];
    var left12 = left[12];
    var left13 = left[13];
    var left14 = left[14];
    var right0 = right[0];
    var right1 = right[1];
    var right2 = right[2];
    var right4 = right[4];
    var right5 = right[5];
    var right6 = right[6];
    var right8 = right[8];
    var right9 = right[9];
    var right10 = right[10];
    var right12 = right[12];
    var right13 = right[13];
    var right14 = right[14];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
    var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12;
    var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13;
    var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = 0;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = 0;
    result[12] = column3Row0;
    result[13] = column3Row1;
    result[14] = column3Row2;
    result[15] = 1;
    return result;
};
Matrix4.multiplyByMatrix3 = function (matrix, rotation, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(rotation)) {
        throw new DeveloperError('rotation is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var left0 = matrix[0];
    var left1 = matrix[1];
    var left2 = matrix[2];
    var left4 = matrix[4];
    var left5 = matrix[5];
    var left6 = matrix[6];
    var left8 = matrix[8];
    var left9 = matrix[9];
    var left10 = matrix[10];
    var right0 = rotation[0];
    var right1 = rotation[1];
    var right2 = rotation[2];
    var right4 = rotation[3];
    var right5 = rotation[4];
    var right6 = rotation[5];
    var right8 = rotation[6];
    var right9 = rotation[7];
    var right10 = rotation[8];
    var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2;
    var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2;
    var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2;
    var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6;
    var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6;
    var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6;
    var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10;
    var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10;
    var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10;
    result[0] = column0Row0;
    result[1] = column0Row1;
    result[2] = column0Row2;
    result[3] = 0;
    result[4] = column1Row0;
    result[5] = column1Row1;
    result[6] = column1Row2;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = 0;
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = matrix[15];
    return result;
};
Matrix4.multiplyByTranslation = function (matrix, translation, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(translation)) {
        throw new DeveloperError('translation is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var x = translation.x;
    var y = translation.y;
    var z = translation.z;
    var tx = x * matrix[0] + y * matrix[4] + z * matrix[8] + matrix[12];
    var ty = x * matrix[1] + y * matrix[5] + z * matrix[9] + matrix[13];
    var tz = x * matrix[2] + y * matrix[6] + z * matrix[10] + matrix[14];
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[3];
    result[4] = matrix[4];
    result[5] = matrix[5];
    result[6] = matrix[6];
    result[7] = matrix[7];
    result[8] = matrix[8];
    result[9] = matrix[9];
    result[10] = matrix[10];
    result[11] = matrix[11];
    result[12] = tx;
    result[13] = ty;
    result[14] = tz;
    result[15] = matrix[15];
    return result;
};
var uniformScaleScratch = new Cartesian3();
Matrix4.multiplyByUniformScale = function (matrix, scale, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (typeof scale !== 'number') {
        throw new DeveloperError('scale is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    uniformScaleScratch.x = scale;
    uniformScaleScratch.y = scale;
    uniformScaleScratch.z = scale;
    return Matrix4.multiplyByScale(matrix, uniformScaleScratch, result);
};
Matrix4.multiplyByScale = function (matrix, scale, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(scale)) {
        throw new DeveloperError('scale is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var scaleX = scale.x;
    var scaleY = scale.y;
    var scaleZ = scale.z;
    if (scaleX === 1 && scaleY === 1 && scaleZ === 1) {
        return Matrix4.clone(matrix, result);
    }
    result[0] = scaleX * matrix[0];
    result[1] = scaleX * matrix[1];
    result[2] = scaleX * matrix[2];
    result[3] = 0;
    result[4] = scaleY * matrix[4];
    result[5] = scaleY * matrix[5];
    result[6] = scaleY * matrix[6];
    result[7] = 0;
    result[8] = scaleZ * matrix[8];
    result[9] = scaleZ * matrix[9];
    result[10] = scaleZ * matrix[10];
    result[11] = 0;
    result[12] = matrix[12];
    result[13] = matrix[13];
    result[14] = matrix[14];
    result[15] = 1;
    return result;
};
Matrix4.multiplyByVector = function (matrix, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var vW = cartesian.w;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
    var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
};
Matrix4.multiplyByPointAsVector = function (matrix, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ;
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ;
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ;
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
Matrix4.multiplyByPoint = function (matrix, cartesian, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var vX = cartesian.x;
    var vY = cartesian.y;
    var vZ = cartesian.z;
    var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12];
    var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13];
    var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14];
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
Matrix4.multiplyByScalar = function (matrix, scalar, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar must be a number');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = matrix[0] * scalar;
    result[1] = matrix[1] * scalar;
    result[2] = matrix[2] * scalar;
    result[3] = matrix[3] * scalar;
    result[4] = matrix[4] * scalar;
    result[5] = matrix[5] * scalar;
    result[6] = matrix[6] * scalar;
    result[7] = matrix[7] * scalar;
    result[8] = matrix[8] * scalar;
    result[9] = matrix[9] * scalar;
    result[10] = matrix[10] * scalar;
    result[11] = matrix[11] * scalar;
    result[12] = matrix[12] * scalar;
    result[13] = matrix[13] * scalar;
    result[14] = matrix[14] * scalar;
    result[15] = matrix[15] * scalar;
    return result;
};
Matrix4.negate = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = -matrix[0];
    result[1] = -matrix[1];
    result[2] = -matrix[2];
    result[3] = -matrix[3];
    result[4] = -matrix[4];
    result[5] = -matrix[5];
    result[6] = -matrix[6];
    result[7] = -matrix[7];
    result[8] = -matrix[8];
    result[9] = -matrix[9];
    result[10] = -matrix[10];
    result[11] = -matrix[11];
    result[12] = -matrix[12];
    result[13] = -matrix[13];
    result[14] = -matrix[14];
    result[15] = -matrix[15];
    return result;
};
Matrix4.transpose = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var matrix1 = matrix[1];
    var matrix2 = matrix[2];
    var matrix3 = matrix[3];
    var matrix6 = matrix[6];
    var matrix7 = matrix[7];
    var matrix11 = matrix[11];
    result[0] = matrix[0];
    result[1] = matrix[4];
    result[2] = matrix[8];
    result[3] = matrix[12];
    result[4] = matrix1;
    result[5] = matrix[5];
    result[6] = matrix[9];
    result[7] = matrix[13];
    result[8] = matrix2;
    result[9] = matrix6;
    result[10] = matrix[10];
    result[11] = matrix[14];
    result[12] = matrix3;
    result[13] = matrix7;
    result[14] = matrix11;
    result[15] = matrix[15];
    return result;
};
Matrix4.abs = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = Math.abs(matrix[0]);
    result[1] = Math.abs(matrix[1]);
    result[2] = Math.abs(matrix[2]);
    result[3] = Math.abs(matrix[3]);
    result[4] = Math.abs(matrix[4]);
    result[5] = Math.abs(matrix[5]);
    result[6] = Math.abs(matrix[6]);
    result[7] = Math.abs(matrix[7]);
    result[8] = Math.abs(matrix[8]);
    result[9] = Math.abs(matrix[9]);
    result[10] = Math.abs(matrix[10]);
    result[11] = Math.abs(matrix[11]);
    result[12] = Math.abs(matrix[12]);
    result[13] = Math.abs(matrix[13]);
    result[14] = Math.abs(matrix[14]);
    result[15] = Math.abs(matrix[15]);
    return result;
};
Matrix4.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left[12] === right[12] && left[13] === right[13] && left[14] === right[14] && left[0] === right[0] && left[1] === right[1] && left[2] === right[2] && left[4] === right[4] && left[5] === right[5] && left[6] === right[6] && left[8] === right[8] && left[9] === right[9] && left[10] === right[10] && left[3] === right[3] && left[7] === right[7] && left[11] === right[11] && left[15] === right[15];
};
Matrix4.equalsEpsilon = function (left, right, epsilon) {
    if (typeof epsilon !== 'number') {
        throw new DeveloperError('epsilon must be a number');
    }
    return left === right || defined(left) && defined(right) && Math.abs(left[0] - right[0]) <= epsilon && Math.abs(left[1] - right[1]) <= epsilon && Math.abs(left[2] - right[2]) <= epsilon && Math.abs(left[3] - right[3]) <= epsilon && Math.abs(left[4] - right[4]) <= epsilon && Math.abs(left[5] - right[5]) <= epsilon && Math.abs(left[6] - right[6]) <= epsilon && Math.abs(left[7] - right[7]) <= epsilon && Math.abs(left[8] - right[8]) <= epsilon && Math.abs(left[9] - right[9]) <= epsilon && Math.abs(left[10] - right[10]) <= epsilon && Math.abs(left[11] - right[11]) <= epsilon && Math.abs(left[12] - right[12]) <= epsilon && Math.abs(left[13] - right[13]) <= epsilon && Math.abs(left[14] - right[14]) <= epsilon && Math.abs(left[15] - right[15]) <= epsilon;
};
Matrix4.getTranslation = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result.x = matrix[12];
    result.y = matrix[13];
    result.z = matrix[14];
    return result;
};
Matrix4.getRotation = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    result[0] = matrix[0];
    result[1] = matrix[1];
    result[2] = matrix[2];
    result[3] = matrix[4];
    result[4] = matrix[5];
    result[5] = matrix[6];
    result[6] = matrix[8];
    result[7] = matrix[9];
    result[8] = matrix[10];
    return result;
};
var scratchInverseRotation = new Matrix3();
var scratchMatrix3Zero = new Matrix3();
var scratchBottomRow = new Cartesian4();
var scratchExpectedBottomRow = new Cartesian4(0, 0, 0, 1);
Matrix4.inverse = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    if (Matrix3.equalsEpsilon(Matrix4.getRotation(matrix, scratchInverseRotation), scratchMatrix3Zero, CesiumMath.EPSILON7) && Cartesian4.equals(Matrix4.getRow(matrix, 3, scratchBottomRow), scratchExpectedBottomRow)) {
        result[0] = 0;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 0;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = 0;
        result[11] = 0;
        result[12] = -matrix[12];
        result[13] = -matrix[13];
        result[14] = -matrix[14];
        result[15] = 1;
        return result;
    }
    var src0 = matrix[0];
    var src1 = matrix[4];
    var src2 = matrix[8];
    var src3 = matrix[12];
    var src4 = matrix[1];
    var src5 = matrix[5];
    var src6 = matrix[9];
    var src7 = matrix[13];
    var src8 = matrix[2];
    var src9 = matrix[6];
    var src10 = matrix[10];
    var src11 = matrix[14];
    var src12 = matrix[3];
    var src13 = matrix[7];
    var src14 = matrix[11];
    var src15 = matrix[15];
    var tmp0 = src10 * src15;
    var tmp1 = src11 * src14;
    var tmp2 = src9 * src15;
    var tmp3 = src11 * src13;
    var tmp4 = src9 * src14;
    var tmp5 = src10 * src13;
    var tmp6 = src8 * src15;
    var tmp7 = src11 * src12;
    var tmp8 = src8 * src14;
    var tmp9 = src10 * src12;
    var tmp10 = src8 * src13;
    var tmp11 = src9 * src12;
    var dst0 = tmp0 * src5 + tmp3 * src6 + tmp4 * src7 - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
    var dst1 = tmp1 * src4 + tmp6 * src6 + tmp9 * src7 - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
    var dst2 = tmp2 * src4 + tmp7 * src5 + tmp10 * src7 - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
    var dst3 = tmp5 * src4 + tmp8 * src5 + tmp11 * src6 - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
    var dst4 = tmp1 * src1 + tmp2 * src2 + tmp5 * src3 - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
    var dst5 = tmp0 * src0 + tmp7 * src2 + tmp8 * src3 - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
    var dst6 = tmp3 * src0 + tmp6 * src1 + tmp11 * src3 - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
    var dst7 = tmp4 * src0 + tmp9 * src1 + tmp10 * src2 - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);
    tmp0 = src2 * src7;
    tmp1 = src3 * src6;
    tmp2 = src1 * src7;
    tmp3 = src3 * src5;
    tmp4 = src1 * src6;
    tmp5 = src2 * src5;
    tmp6 = src0 * src7;
    tmp7 = src3 * src4;
    tmp8 = src0 * src6;
    tmp9 = src2 * src4;
    tmp10 = src0 * src5;
    tmp11 = src1 * src4;
    var dst8 = tmp0 * src13 + tmp3 * src14 + tmp4 * src15 - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
    var dst9 = tmp1 * src12 + tmp6 * src14 + tmp9 * src15 - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
    var dst10 = tmp2 * src12 + tmp7 * src13 + tmp10 * src15 - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
    var dst11 = tmp5 * src12 + tmp8 * src13 + tmp11 * src14 - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
    var dst12 = tmp2 * src10 + tmp5 * src11 + tmp1 * src9 - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
    var dst13 = tmp8 * src11 + tmp0 * src8 + tmp7 * src10 - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
    var dst14 = tmp6 * src9 + tmp11 * src11 + tmp3 * src8 - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
    var dst15 = tmp10 * src10 + tmp4 * src8 + tmp9 * src9 - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);
    var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;
    if (Math.abs(det) < CesiumMath.EPSILON20) {
        throw new RuntimeError('matrix is not invertible because its determinate is zero.');
    }
    det = 1 / det;
    result[0] = dst0 * det;
    result[1] = dst1 * det;
    result[2] = dst2 * det;
    result[3] = dst3 * det;
    result[4] = dst4 * det;
    result[5] = dst5 * det;
    result[6] = dst6 * det;
    result[7] = dst7 * det;
    result[8] = dst8 * det;
    result[9] = dst9 * det;
    result[10] = dst10 * det;
    result[11] = dst11 * det;
    result[12] = dst12 * det;
    result[13] = dst13 * det;
    result[14] = dst14 * det;
    result[15] = dst15 * det;
    return result;
};
Matrix4.inverseTransformation = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required,');
    }
    var matrix0 = matrix[0];
    var matrix1 = matrix[1];
    var matrix2 = matrix[2];
    var matrix4 = matrix[4];
    var matrix5 = matrix[5];
    var matrix6 = matrix[6];
    var matrix8 = matrix[8];
    var matrix9 = matrix[9];
    var matrix10 = matrix[10];
    var vX = matrix[12];
    var vY = matrix[13];
    var vZ = matrix[14];
    var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
    var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
    var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;
    result[0] = matrix0;
    result[1] = matrix4;
    result[2] = matrix8;
    result[3] = 0;
    result[4] = matrix1;
    result[5] = matrix5;
    result[6] = matrix9;
    result[7] = 0;
    result[8] = matrix2;
    result[9] = matrix6;
    result[10] = matrix10;
    result[11] = 0;
    result[12] = x;
    result[13] = y;
    result[14] = z;
    result[15] = 1;
    return result;
};
Matrix4.IDENTITY = freezeObject(new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
Matrix4.COLUMN0ROW0 = 0;
Matrix4.COLUMN0ROW1 = 1;
Matrix4.COLUMN0ROW2 = 2;
Matrix4.COLUMN0ROW3 = 3;
Matrix4.COLUMN1ROW0 = 4;
Matrix4.COLUMN1ROW1 = 5;
Matrix4.COLUMN1ROW2 = 6;
Matrix4.COLUMN1ROW3 = 7;
Matrix4.COLUMN2ROW0 = 8;
Matrix4.COLUMN2ROW1 = 9;
Matrix4.COLUMN2ROW2 = 10;
Matrix4.COLUMN2ROW3 = 11;
Matrix4.COLUMN3ROW0 = 12;
Matrix4.COLUMN3ROW1 = 13;
Matrix4.COLUMN3ROW2 = 14;
Matrix4.COLUMN3ROW3 = 15;
Matrix4.prototype.clone = function (result) {
    return Matrix4.clone(this, result);
};
Matrix4.prototype.equals = function (right) {
    return Matrix4.equals(this, right);
};
Matrix4.prototype.equalsEpsilon = function (right, epsilon) {
    return Matrix4.equalsEpsilon(this, right, epsilon);
};
Matrix4.prototype.toString = function () {
    return '(' + this[0] + ', ' + this[4] + ', ' + this[8] + ', ' + this[12] + ')\n' + '(' + this[1] + ', ' + this[5] + ', ' + this[9] + ', ' + this[13] + ')\n' + '(' + this[2] + ', ' + this[6] + ', ' + this[10] + ', ' + this[14] + ')\n' + '(' + this[3] + ', ' + this[7] + ', ' + this[11] + ', ' + this[15] + ')';
};
module.exports = Matrix4;
},{"./Cartesian3":102,"./Cartesian4":103,"./DeveloperError":123,"./Math":174,"./Matrix3":176,"./RuntimeError":207,"./defaultValue":243,"./defined":245,"./freezeObject":249}],178:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var NearFarScalar = function (near, nearValue, far, farValue) {
    this.near = defaultValue(near, 0);
    this.nearValue = defaultValue(nearValue, 0);
    this.far = defaultValue(far, 1);
    this.farValue = defaultValue(farValue, 0);
};
NearFarScalar.clone = function (nearFarScalar, result) {
    if (!defined(nearFarScalar)) {
        return undefined;
    }
    if (!defined(result)) {
        return new NearFarScalar(nearFarScalar.near, nearFarScalar.nearValue, nearFarScalar.far, nearFarScalar.farValue);
    }
    result.near = nearFarScalar.near;
    result.nearValue = nearFarScalar.nearValue;
    result.far = nearFarScalar.far;
    result.farValue = nearFarScalar.farValue;
    return result;
};
NearFarScalar.packedLength = 4;
NearFarScalar.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.near;
    array[startingIndex++] = value.nearValue;
    array[startingIndex++] = value.far;
    array[startingIndex] = value.farValue;
};
NearFarScalar.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new NearFarScalar();
    }
    result.near = array[startingIndex++];
    result.nearValue = array[startingIndex++];
    result.far = array[startingIndex++];
    result.farValue = array[startingIndex];
    return result;
};
NearFarScalar.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.near === right.near && left.nearValue === right.nearValue && left.far === right.far && left.farValue === right.farValue;
};
NearFarScalar.prototype.clone = function (result) {
    return NearFarScalar.clone(this, result);
};
NearFarScalar.prototype.equals = function (right) {
    return NearFarScalar.equals(this, right);
};
module.exports = NearFarScalar;
},{"./DeveloperError":123,"./defaultValue":243,"./defined":245}],179:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), CesiumMath = require('./Math'), Rectangle = require('./Rectangle'), Visibility = require('./Visibility');
'use strict';
var Occluder = function (occluderBoundingSphere, cameraPosition) {
    if (!defined(occluderBoundingSphere)) {
        throw new DeveloperError('occluderBoundingSphere is required.');
    }
    if (!defined(cameraPosition)) {
        throw new DeveloperError('camera position is required.');
    }
    this._occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);
    this._occluderRadius = occluderBoundingSphere.radius;
    this._horizonDistance = 0;
    this._horizonPlaneNormal = undefined;
    this._horizonPlanePosition = undefined;
    this._cameraPosition = undefined;
    this.cameraPosition = cameraPosition;
};
var scratchCartesian3 = new Cartesian3();
defineProperties(Occluder.prototype, {
    position: {
        get: function () {
            return this._occluderPosition;
        }
    },
    radius: {
        get: function () {
            return this._occluderRadius;
        }
    },
    cameraPosition: {
        set: function (cameraPosition) {
            if (!defined(cameraPosition)) {
                throw new DeveloperError('cameraPosition is required.');
            }
            cameraPosition = Cartesian3.clone(cameraPosition, this._cameraPosition);
            var cameraToOccluderVec = Cartesian3.subtract(this._occluderPosition, cameraPosition, scratchCartesian3);
            var invCameraToOccluderDistance = Cartesian3.magnitudeSquared(cameraToOccluderVec);
            var occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;
            var horizonDistance;
            var horizonPlaneNormal;
            var horizonPlanePosition;
            if (invCameraToOccluderDistance > occluderRadiusSqrd) {
                horizonDistance = Math.sqrt(invCameraToOccluderDistance - occluderRadiusSqrd);
                invCameraToOccluderDistance = 1 / Math.sqrt(invCameraToOccluderDistance);
                horizonPlaneNormal = Cartesian3.multiplyByScalar(cameraToOccluderVec, invCameraToOccluderDistance, scratchCartesian3);
                var nearPlaneDistance = horizonDistance * horizonDistance * invCameraToOccluderDistance;
                horizonPlanePosition = Cartesian3.add(cameraPosition, Cartesian3.multiplyByScalar(horizonPlaneNormal, nearPlaneDistance, scratchCartesian3), scratchCartesian3);
            } else {
                horizonDistance = Number.MAX_VALUE;
            }
            this._horizonDistance = horizonDistance;
            this._horizonPlaneNormal = horizonPlaneNormal;
            this._horizonPlanePosition = horizonPlanePosition;
            this._cameraPosition = cameraPosition;
        }
    }
});
Occluder.fromBoundingSphere = function (occluderBoundingSphere, cameraPosition, result) {
    if (!defined(occluderBoundingSphere)) {
        throw new DeveloperError('occluderBoundingSphere is required.');
    }
    if (!defined(cameraPosition)) {
        throw new DeveloperError('camera position is required.');
    }
    if (!defined(result)) {
        return new Occluder(occluderBoundingSphere, cameraPosition);
    }
    Cartesian3.clone(occluderBoundingSphere.center, result._occluderPosition);
    result._occluderRadius = occluderBoundingSphere.radius;
    result.cameraPosition = cameraPosition;
    return result;
};
var tempVecScratch = new Cartesian3();
Occluder.prototype.isPointVisible = function (occludee) {
    if (this._horizonDistance !== Number.MAX_VALUE) {
        var tempVec = Cartesian3.subtract(occludee, this._occluderPosition, tempVecScratch);
        var temp = this._occluderRadius;
        temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;
        if (temp > 0) {
            temp = Math.sqrt(temp) + this._horizonDistance;
            tempVec = Cartesian3.subtract(occludee, this._cameraPosition, tempVec);
            return temp * temp > Cartesian3.magnitudeSquared(tempVec);
        }
    }
    return false;
};
var occludeePositionScratch = new Cartesian3();
Occluder.prototype.isBoundingSphereVisible = function (occludee) {
    var occludeePosition = Cartesian3.clone(occludee.center, occludeePositionScratch);
    var occludeeRadius = occludee.radius;
    if (this._horizonDistance !== Number.MAX_VALUE) {
        var tempVec = Cartesian3.subtract(occludeePosition, this._occluderPosition, tempVecScratch);
        var temp = this._occluderRadius - occludeeRadius;
        temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;
        if (occludeeRadius < this._occluderRadius) {
            if (temp > 0) {
                temp = Math.sqrt(temp) + this._horizonDistance;
                tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);
                return temp * temp + occludeeRadius * occludeeRadius > Cartesian3.magnitudeSquared(tempVec);
            }
            return false;
        }
        if (temp > 0) {
            tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);
            var tempVecMagnitudeSquared = Cartesian3.magnitudeSquared(tempVec);
            var occluderRadiusSquared = this._occluderRadius * this._occluderRadius;
            var occludeeRadiusSquared = occludeeRadius * occludeeRadius;
            if ((this._horizonDistance * this._horizonDistance + occluderRadiusSquared) * occludeeRadiusSquared > tempVecMagnitudeSquared * occluderRadiusSquared) {
                return true;
            }
            temp = Math.sqrt(temp) + this._horizonDistance;
            return temp * temp + occludeeRadiusSquared > tempVecMagnitudeSquared;
        }
        return true;
    }
    return false;
};
var tempScratch = new Cartesian3();
Occluder.prototype.computeVisibility = function (occludeeBS) {
    if (!defined(occludeeBS)) {
        throw new DeveloperError('occludeeBS is required.');
    }
    var occludeePosition = Cartesian3.clone(occludeeBS.center);
    var occludeeRadius = occludeeBS.radius;
    if (occludeeRadius > this._occluderRadius) {
        return Visibility.FULL;
    }
    if (this._horizonDistance !== Number.MAX_VALUE) {
        var tempVec = Cartesian3.subtract(occludeePosition, this._occluderPosition, tempScratch);
        var temp = this._occluderRadius - occludeeRadius;
        var occluderToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);
        temp = occluderToOccludeeDistSqrd - temp * temp;
        if (temp > 0) {
            temp = Math.sqrt(temp) + this._horizonDistance;
            tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);
            var cameraToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);
            if (temp * temp + occludeeRadius * occludeeRadius < cameraToOccludeeDistSqrd) {
                return Visibility.NONE;
            }
            temp = this._occluderRadius + occludeeRadius;
            temp = occluderToOccludeeDistSqrd - temp * temp;
            if (temp > 0) {
                temp = Math.sqrt(temp) + this._horizonDistance;
                return cameraToOccludeeDistSqrd < temp * temp + occludeeRadius * occludeeRadius ? Visibility.FULL : Visibility.PARTIAL;
            }
            tempVec = Cartesian3.subtract(occludeePosition, this._horizonPlanePosition, tempVec);
            return Cartesian3.dot(tempVec, this._horizonPlaneNormal) > -occludeeRadius ? Visibility.PARTIAL : Visibility.FULL;
        }
    }
    return Visibility.NONE;
};
var occludeePointScratch = new Cartesian3();
Occluder.computeOccludeePoint = function (occluderBoundingSphere, occludeePosition, positions) {
    if (!defined(occluderBoundingSphere)) {
        throw new DeveloperError('occluderBoundingSphere is required.');
    }
    if (!defined(positions)) {
        throw new DeveloperError('positions is required.');
    }
    if (positions.length === 0) {
        throw new DeveloperError('positions must contain at least one element');
    }
    var occludeePos = Cartesian3.clone(occludeePosition);
    var occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);
    var occluderRadius = occluderBoundingSphere.radius;
    var numPositions = positions.length;
    if (Cartesian3.equals(occluderPosition, occludeePosition)) {
        throw new DeveloperError('occludeePosition must be different than occluderBoundingSphere.center');
    }
    var occluderPlaneNormal = Cartesian3.normalize(Cartesian3.subtract(occludeePos, occluderPosition, occludeePointScratch), occludeePointScratch);
    var occluderPlaneD = -Cartesian3.dot(occluderPlaneNormal, occluderPosition);
    var aRotationVector = Occluder._anyRotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD);
    var dot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[0]);
    if (!dot) {
        return undefined;
    }
    var tempDot;
    for (var i = 1; i < numPositions; ++i) {
        tempDot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[i]);
        if (!tempDot) {
            return undefined;
        }
        if (tempDot < dot) {
            dot = tempDot;
        }
    }
    if (dot < 0.0017453283658983088) {
        return undefined;
    }
    var distance = occluderRadius / dot;
    return Cartesian3.add(occluderPosition, Cartesian3.multiplyByScalar(occluderPlaneNormal, distance, occludeePointScratch), occludeePointScratch);
};
var computeOccludeePointFromRectangleScratch = [];
Occluder.computeOccludeePointFromRectangle = function (rectangle, ellipsoid) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    var positions = Rectangle.subsample(rectangle, ellipsoid, 0, computeOccludeePointFromRectangleScratch);
    var bs = BoundingSphere.fromPoints(positions);
    var ellipsoidCenter = Cartesian3.ZERO;
    if (!Cartesian3.equals(ellipsoidCenter, bs.center)) {
        return Occluder.computeOccludeePoint(new BoundingSphere(ellipsoidCenter, ellipsoid.minimumRadius), bs.center, positions);
    }
    return undefined;
};
var tempVec0Scratch = new Cartesian3();
Occluder._anyRotationVector = function (occluderPosition, occluderPlaneNormal, occluderPlaneD) {
    var tempVec0 = Cartesian3.abs(occluderPlaneNormal, tempVec0Scratch);
    var majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;
    if (majorAxis === 0 && tempVec0.z > tempVec0.x || majorAxis === 1 && tempVec0.z > tempVec0.y) {
        majorAxis = 2;
    }
    var tempVec = new Cartesian3();
    var tempVec1;
    if (majorAxis === 0) {
        tempVec0.x = occluderPosition.x;
        tempVec0.y = occluderPosition.y + 1;
        tempVec0.z = occluderPosition.z + 1;
        tempVec1 = Cartesian3.UNIT_X;
    } else if (majorAxis === 1) {
        tempVec0.x = occluderPosition.x + 1;
        tempVec0.y = occluderPosition.y;
        tempVec0.z = occluderPosition.z + 1;
        tempVec1 = Cartesian3.UNIT_Y;
    } else {
        tempVec0.x = occluderPosition.x + 1;
        tempVec0.y = occluderPosition.y + 1;
        tempVec0.z = occluderPosition.z;
        tempVec1 = Cartesian3.UNIT_Z;
    }
    var u = (Cartesian3.dot(occluderPlaneNormal, tempVec0) + occluderPlaneD) / -Cartesian3.dot(occluderPlaneNormal, tempVec1);
    return Cartesian3.normalize(Cartesian3.subtract(Cartesian3.add(tempVec0, Cartesian3.multiplyByScalar(tempVec1, u, tempVec), tempVec0), occluderPosition, tempVec0), tempVec0);
};
var posDirectionScratch = new Cartesian3();
Occluder._rotationVector = function (occluderPosition, occluderPlaneNormal, occluderPlaneD, position, anyRotationVector) {
    var positionDirection = Cartesian3.subtract(position, occluderPosition, posDirectionScratch);
    positionDirection = Cartesian3.normalize(positionDirection, positionDirection);
    if (Cartesian3.dot(occluderPlaneNormal, positionDirection) < 0.9999999847691291) {
        var crossProduct = Cartesian3.cross(occluderPlaneNormal, positionDirection, positionDirection);
        var length = Cartesian3.magnitude(crossProduct);
        if (length > CesiumMath.EPSILON13) {
            return Cartesian3.normalize(crossProduct, new Cartesian3());
        }
    }
    return anyRotationVector;
};
var posScratch1 = new Cartesian3();
var occluerPosScratch = new Cartesian3();
var posScratch2 = new Cartesian3();
var horizonPlanePosScratch = new Cartesian3();
Occluder._horizonToPlaneNormalDotProduct = function (occluderBS, occluderPlaneNormal, occluderPlaneD, anyRotationVector, position) {
    var pos = Cartesian3.clone(position, posScratch1);
    var occluderPosition = Cartesian3.clone(occluderBS.center, occluerPosScratch);
    var occluderRadius = occluderBS.radius;
    var positionToOccluder = Cartesian3.subtract(occluderPosition, pos, posScratch2);
    var occluderToPositionDistanceSquared = Cartesian3.magnitudeSquared(positionToOccluder);
    var occluderRadiusSquared = occluderRadius * occluderRadius;
    if (occluderToPositionDistanceSquared < occluderRadiusSquared) {
        return false;
    }
    var horizonDistanceSquared = occluderToPositionDistanceSquared - occluderRadiusSquared;
    var horizonDistance = Math.sqrt(horizonDistanceSquared);
    var occluderToPositionDistance = Math.sqrt(occluderToPositionDistanceSquared);
    var invOccluderToPositionDistance = 1 / occluderToPositionDistance;
    var cosTheta = horizonDistance * invOccluderToPositionDistance;
    var horizonPlaneDistance = cosTheta * horizonDistance;
    positionToOccluder = Cartesian3.normalize(positionToOccluder, positionToOccluder);
    var horizonPlanePosition = Cartesian3.add(pos, Cartesian3.multiplyByScalar(positionToOccluder, horizonPlaneDistance, horizonPlanePosScratch), horizonPlanePosScratch);
    var horizonCrossDistance = Math.sqrt(horizonDistanceSquared - horizonPlaneDistance * horizonPlaneDistance);
    var tempVec = this._rotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD, pos, anyRotationVector);
    var horizonCrossDirection = Cartesian3.fromElements(tempVec.x * tempVec.x * positionToOccluder.x + (tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y + (tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z, (tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x + tempVec.y * tempVec.y * positionToOccluder.y + (tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z, (tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x + (tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y + tempVec.z * tempVec.z * positionToOccluder.z, posScratch1);
    horizonCrossDirection = Cartesian3.normalize(horizonCrossDirection, horizonCrossDirection);
    var offset = Cartesian3.multiplyByScalar(horizonCrossDirection, horizonCrossDistance, posScratch1);
    tempVec = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.add(horizonPlanePosition, offset, posScratch2), occluderPosition, posScratch2), posScratch2);
    var dot0 = Cartesian3.dot(occluderPlaneNormal, tempVec);
    tempVec = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.subtract(horizonPlanePosition, offset, tempVec), occluderPosition, tempVec), tempVec);
    var dot1 = Cartesian3.dot(occluderPlaneNormal, tempVec);
    return dot0 < dot1 ? dot0 : dot1;
};
module.exports = Occluder;
},{"./BoundingSphere":98,"./Cartesian3":102,"./DeveloperError":123,"./Ellipsoid":130,"./Math":174,"./Rectangle":201,"./Visibility":229,"./defaultValue":243,"./defineProperties":244,"./defined":245}],180:[function(require,module,exports){
var buildModuleUrl = require('./buildModuleUrl'), Color = require('./Color'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), loadImage = require('./loadImage'), writeTextToCanvas = require('./writeTextToCanvas');
'use strict';
var PinBuilder = function () {
    this._cache = {};
};
PinBuilder.prototype.fromColor = function (color, size) {
    if (!defined(color)) {
        throw new DeveloperError('color is required');
    }
    if (!defined(size)) {
        throw new DeveloperError('size is required');
    }
    return createPin(undefined, undefined, color, size, this._cache);
};
PinBuilder.prototype.fromUrl = function (url, color, size) {
    if (!defined(url)) {
        throw new DeveloperError('url is required');
    }
    if (!defined(color)) {
        throw new DeveloperError('color is required');
    }
    if (!defined(size)) {
        throw new DeveloperError('size is required');
    }
    return createPin(url, undefined, color, size, this._cache);
};
PinBuilder.prototype.fromMakiIconId = function (id, color, size) {
    if (!defined(id)) {
        throw new DeveloperError('id is required');
    }
    if (!defined(color)) {
        throw new DeveloperError('color is required');
    }
    if (!defined(size)) {
        throw new DeveloperError('size is required');
    }
    return createPin(buildModuleUrl('Assets/Textures/maki/' + encodeURIComponent(id) + '.png'), undefined, color, size, this._cache);
};
PinBuilder.prototype.fromText = function (text, color, size) {
    if (!defined(text)) {
        throw new DeveloperError('text is required');
    }
    if (!defined(color)) {
        throw new DeveloperError('color is required');
    }
    if (!defined(size)) {
        throw new DeveloperError('size is required');
    }
    return createPin(undefined, text, color, size, this._cache);
};
var colorScratch = new Color();
function drawPin(context2D, color, size) {
    context2D.save();
    context2D.scale(size / 24, size / 24);
    context2D.fillStyle = color.toCssColorString();
    context2D.strokeStyle = color.brighten(0.6, colorScratch).toCssColorString();
    context2D.lineWidth = 0.846;
    context2D.beginPath();
    context2D.moveTo(6.72, 0.422);
    context2D.lineTo(17.28, 0.422);
    context2D.bezierCurveTo(18.553, 0.422, 19.577, 1.758, 19.577, 3.415);
    context2D.lineTo(19.577, 10.973);
    context2D.bezierCurveTo(19.577, 12.63, 18.553, 13.966, 17.282, 13.966);
    context2D.lineTo(14.386, 14.008);
    context2D.lineTo(11.826, 23.578);
    context2D.lineTo(9.614, 14.008);
    context2D.lineTo(6.719, 13.965);
    context2D.bezierCurveTo(5.446, 13.983, 4.422, 12.629, 4.422, 10.972);
    context2D.lineTo(4.422, 3.416);
    context2D.bezierCurveTo(4.423, 1.76, 5.447, 0.423, 6.718, 0.423);
    context2D.closePath();
    context2D.fill();
    context2D.stroke();
    context2D.restore();
}
function drawIcon(context2D, image, size) {
    var imageSize = size / 2.5;
    var sizeX = imageSize;
    var sizeY = imageSize;
    if (image.width > image.height) {
        sizeY = imageSize * (image.height / image.width);
    } else if (image.width < image.height) {
        sizeX = imageSize * (image.width / image.height);
    }
    var x = (size - sizeX) / 2;
    var y = 7 / 24 * size - sizeY / 2;
    context2D.globalCompositeOperation = 'destination-out';
    context2D.drawImage(image, x - 1, y, sizeX, sizeY);
    context2D.drawImage(image, x, y - 1, sizeX, sizeY);
    context2D.drawImage(image, x + 1, y, sizeX, sizeY);
    context2D.drawImage(image, x, y + 1, sizeX, sizeY);
    context2D.globalCompositeOperation = 'destination-over';
    context2D.fillStyle = Color.BLACK.toCssColorString();
    context2D.fillRect(x - 1, y - 1, sizeX + 1, sizeY + 1);
    context2D.globalCompositeOperation = 'destination-out';
    context2D.drawImage(image, x, y, sizeX, sizeY);
    context2D.globalCompositeOperation = 'destination-over';
    context2D.fillStyle = Color.WHITE.toCssColorString();
    context2D.fillRect(x, y, sizeX, sizeY);
}
var stringifyScratch = new Array(4);
function createPin(url, label, color, size, cache) {
    stringifyScratch[0] = url;
    stringifyScratch[1] = label;
    stringifyScratch[2] = color;
    stringifyScratch[3] = size;
    var id = JSON.stringify(stringifyScratch);
    var item = cache[id];
    if (defined(item)) {
        return item;
    }
    var canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    var context2D = canvas.getContext('2d');
    drawPin(context2D, color, size);
    if (defined(url)) {
        var promise = loadImage(url).then(function (image) {
                drawIcon(context2D, image, size);
                cache[id] = canvas;
                return canvas;
            });
        cache[id] = promise;
        return promise;
    } else if (defined(label)) {
        var image = writeTextToCanvas(label, { font: 'bold ' + size + 'px sans-serif' });
        drawIcon(context2D, image, size);
    }
    cache[id] = canvas;
    return canvas;
}
module.exports = PinBuilder;
},{"./Color":111,"./DeveloperError":123,"./buildModuleUrl":239,"./defined":245,"./loadImage":259,"./writeTextToCanvas":273}],181:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var PixelFormat = {
        DEPTH_COMPONENT: 6402,
        DEPTH_STENCIL: 34041,
        ALPHA: 6406,
        RGB: 6407,
        RGBA: 6408,
        LUMINANCE: 6409,
        LUMINANCE_ALPHA: 6410,
        validate: function (pixelFormat) {
            return pixelFormat === PixelFormat.DEPTH_COMPONENT || pixelFormat === PixelFormat.DEPTH_STENCIL || pixelFormat === PixelFormat.ALPHA || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.RGBA || pixelFormat === PixelFormat.LUMINANCE || pixelFormat === PixelFormat.LUMINANCE_ALPHA;
        },
        isColorFormat: function (pixelFormat) {
            return pixelFormat === PixelFormat.ALPHA || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.RGBA || pixelFormat === PixelFormat.LUMINANCE || pixelFormat === PixelFormat.LUMINANCE_ALPHA;
        },
        isDepthFormat: function (pixelFormat) {
            return pixelFormat === PixelFormat.DEPTH_COMPONENT || pixelFormat === PixelFormat.DEPTH_STENCIL;
        }
    };
module.exports = freezeObject(PixelFormat);
},{"./freezeObject":249}],182:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var Plane = function (normal, distance) {
    if (!defined(normal)) {
        throw new DeveloperError('normal is required.');
    }
    if (!defined(distance)) {
        throw new DeveloperError('distance is required.');
    }
    this.normal = Cartesian3.clone(normal);
    this.distance = distance;
};
Plane.fromPointNormal = function (point, normal, result) {
    if (!defined(point)) {
        throw new DeveloperError('point is required.');
    }
    if (!defined(normal)) {
        throw new DeveloperError('normal is required.');
    }
    var distance = -Cartesian3.dot(normal, point);
    if (!defined(result)) {
        return new Plane(normal, distance);
    }
    Cartesian3.clone(normal, result.normal);
    result.distance = distance;
    return result;
};
Plane.getPointDistance = function (plane, point) {
    if (!defined(plane)) {
        throw new DeveloperError('plane is required.');
    }
    if (!defined(point)) {
        throw new DeveloperError('point is required.');
    }
    return Cartesian3.dot(plane.normal, point) + plane.distance;
};
module.exports = Plane;
},{"./Cartesian3":102,"./DeveloperError":123,"./defined":245}],183:[function(require,module,exports){
var BoundingRectangle = require('./BoundingRectangle'), BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), EllipsoidTangentPlane = require('./EllipsoidTangentPlane'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), GeometryInstance = require('./GeometryInstance'), GeometryPipeline = require('./GeometryPipeline'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), PolygonGeometryLibrary = require('./PolygonGeometryLibrary'), PolygonPipeline = require('./PolygonPipeline'), PrimitiveType = require('./PrimitiveType'), Quaternion = require('./Quaternion'), Queue = require('./Queue'), VertexFormat = require('./VertexFormat'), WindingOrder = require('./WindingOrder');
'use strict';
var computeBoundingRectangleCartesian2 = new Cartesian2();
var computeBoundingRectangleCartesian3 = new Cartesian3();
var computeBoundingRectangleQuaternion = new Quaternion();
var computeBoundingRectangleMatrix3 = new Matrix3();
function computeBoundingRectangle(tangentPlane, positions, angle, result) {
    var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, angle, computeBoundingRectangleQuaternion);
    var textureMatrix = Matrix3.fromQuaternion(rotation, computeBoundingRectangleMatrix3);
    var minX = Number.POSITIVE_INFINITY;
    var maxX = Number.NEGATIVE_INFINITY;
    var minY = Number.POSITIVE_INFINITY;
    var maxY = Number.NEGATIVE_INFINITY;
    var length = positions.length;
    for (var i = 0; i < length; ++i) {
        var p = Cartesian3.clone(positions[i], computeBoundingRectangleCartesian3);
        Matrix3.multiplyByVector(textureMatrix, p, p);
        var st = tangentPlane.projectPointOntoPlane(p, computeBoundingRectangleCartesian2);
        if (defined(st)) {
            minX = Math.min(minX, st.x);
            maxX = Math.max(maxX, st.x);
            minY = Math.min(minY, st.y);
            maxY = Math.max(maxY, st.y);
        }
    }
    result.x = minX;
    result.y = minY;
    result.width = maxX - minX;
    result.height = maxY - minY;
    return result;
}
var createGeometryFromPositionsPositions = [];
function createGeometryFromPositions(ellipsoid, positions, granularity, perPositionHeight) {
    var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);
    var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);
    var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
    if (originalWindingOrder === WindingOrder.CLOCKWISE) {
        positions2D.reverse();
        positions.reverse();
    }
    var indices = PolygonPipeline.triangulate(positions2D);
    if (indices.length < 3) {
        indices = [
            0,
            1,
            2
        ];
    }
    var geo;
    if (!perPositionHeight) {
        geo = PolygonPipeline.computeSubdivision(ellipsoid, positions, indices, granularity);
    } else {
        var length = positions.length;
        var flattenedPositions = new Array(length * 3);
        var index = 0;
        for (var i = 0; i < length; i++) {
            var p = positions[i];
            flattenedPositions[index++] = p.x;
            flattenedPositions[index++] = p.y;
            flattenedPositions[index++] = p.z;
        }
        geo = new Geometry({
            attributes: {
                position: new GeometryAttribute({
                    componentDatatype: ComponentDatatype.DOUBLE,
                    componentsPerAttribute: 3,
                    values: flattenedPositions
                })
            },
            indices: indices,
            primitiveType: PrimitiveType.TRIANGLES
        });
    }
    return new GeometryInstance({ geometry: geo });
}
var scratchBoundingRectangle = new BoundingRectangle();
var scratchPosition = new Cartesian3();
var scratchNormal = new Cartesian3();
var scratchTangent = new Cartesian3();
var scratchBinormal = new Cartesian3();
var p1Scratch = new Cartesian3();
var p2Scratch = new Cartesian3();
var appendTextureCoordinatesOrigin = new Cartesian2();
var appendTextureCoordinatesCartesian2 = new Cartesian2();
var appendTextureCoordinatesCartesian3 = new Cartesian3();
var appendTextureCoordinatesQuaternion = new Quaternion();
var appendTextureCoordinatesMatrix3 = new Matrix3();
function computeAttributes(vertexFormat, geometry, outerPositions, ellipsoid, stRotation, bottom, wall) {
    if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {
        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);
        var boundingRectangle = computeBoundingRectangle(tangentPlane, outerPositions, stRotation, scratchBoundingRectangle);
        var origin = appendTextureCoordinatesOrigin;
        origin.x = boundingRectangle.x;
        origin.y = boundingRectangle.y;
        var flatPositions = geometry.attributes.position.values;
        var length = flatPositions.length;
        var textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;
        var normals = vertexFormat.normal ? new Float32Array(length) : undefined;
        var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;
        var binormals = vertexFormat.binormal ? new Float32Array(length) : undefined;
        var textureCoordIndex = 0;
        var attrIndex = 0;
        var normal = scratchNormal;
        var tangent = scratchTangent;
        var binormal = scratchBinormal;
        var recomputeNormal = true;
        var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, stRotation, appendTextureCoordinatesQuaternion);
        var textureMatrix = Matrix3.fromQuaternion(rotation, appendTextureCoordinatesMatrix3);
        var bottomOffset = length / 2;
        var bottomOffset2 = length / 3;
        if (bottom) {
            length /= 2;
        }
        for (var i = 0; i < length; i += 3) {
            var position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);
            if (vertexFormat.st) {
                var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);
                var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);
                Cartesian2.subtract(st, origin, st);
                if (bottom) {
                    textureCoordinates[textureCoordIndex + bottomOffset2] = st.x / boundingRectangle.width;
                    textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = st.y / boundingRectangle.height;
                }
                textureCoordinates[textureCoordIndex] = st.x / boundingRectangle.width;
                textureCoordinates[textureCoordIndex + 1] = st.y / boundingRectangle.height;
                textureCoordIndex += 2;
            }
            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {
                var attrIndex1 = attrIndex + 1;
                var attrIndex2 = attrIndex + 2;
                if (wall) {
                    if (i + 3 < length) {
                        var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);
                        if (recomputeNormal) {
                            var p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);
                            Cartesian3.subtract(p1, position, p1);
                            Cartesian3.subtract(p2, position, p2);
                            normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);
                            recomputeNormal = false;
                        }
                        if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {
                            recomputeNormal = true;
                        }
                    }
                    if (vertexFormat.tangent || vertexFormat.binormal) {
                        binormal = ellipsoid.geodeticSurfaceNormal(position, binormal);
                        if (vertexFormat.tangent) {
                            tangent = Cartesian3.normalize(Cartesian3.cross(binormal, normal, tangent), tangent);
                        }
                    }
                } else {
                    normal = ellipsoid.geodeticSurfaceNormal(position, normal);
                    if (vertexFormat.tangent || vertexFormat.binormal) {
                        tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);
                        tangent = Cartesian3.normalize(Matrix3.multiplyByVector(textureMatrix, tangent, tangent), tangent);
                        if (vertexFormat.binormal) {
                            binormal = Cartesian3.normalize(Cartesian3.cross(normal, tangent, binormal), binormal);
                        }
                    }
                }
                if (vertexFormat.normal) {
                    if (bottom && !wall) {
                        normals[attrIndex + bottomOffset] = -normal.x;
                        normals[attrIndex1 + bottomOffset] = -normal.y;
                        normals[attrIndex2 + bottomOffset] = -normal.z;
                    } else {
                        normals[attrIndex + bottomOffset] = normal.x;
                        normals[attrIndex1 + bottomOffset] = normal.y;
                        normals[attrIndex2 + bottomOffset] = normal.z;
                    }
                    normals[attrIndex] = normal.x;
                    normals[attrIndex1] = normal.y;
                    normals[attrIndex2] = normal.z;
                }
                if (vertexFormat.tangent) {
                    if (bottom && !wall) {
                        tangents[attrIndex + bottomOffset] = -tangent.x;
                        tangents[attrIndex1 + bottomOffset] = -tangent.y;
                        tangents[attrIndex2 + bottomOffset] = -tangent.z;
                    } else {
                        tangents[attrIndex + bottomOffset] = tangent.x;
                        tangents[attrIndex1 + bottomOffset] = tangent.y;
                        tangents[attrIndex2 + bottomOffset] = tangent.z;
                    }
                    tangents[attrIndex] = tangent.x;
                    tangents[attrIndex1] = tangent.y;
                    tangents[attrIndex2] = tangent.z;
                }
                if (vertexFormat.binormal) {
                    if (bottom) {
                        binormals[attrIndex + bottomOffset] = binormal.x;
                        binormals[attrIndex1 + bottomOffset] = binormal.y;
                        binormals[attrIndex2 + bottomOffset] = binormal.z;
                    }
                    binormals[attrIndex] = binormal.x;
                    binormals[attrIndex1] = binormal.y;
                    binormals[attrIndex2] = binormal.z;
                }
                attrIndex += 3;
            }
        }
        if (vertexFormat.st) {
            geometry.attributes.st = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 2,
                values: textureCoordinates
            });
        }
        if (vertexFormat.normal) {
            geometry.attributes.normal = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: normals
            });
        }
        if (vertexFormat.tangent) {
            geometry.attributes.tangent = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: tangents
            });
        }
        if (vertexFormat.binormal) {
            geometry.attributes.binormal = new GeometryAttribute({
                componentDatatype: ComponentDatatype.FLOAT,
                componentsPerAttribute: 3,
                values: binormals
            });
        }
    }
    return geometry;
}
var computeWallIndicesSubdivided = [];
function computeWallIndices(positions, ellipsoid, granularity, perPositionHeight) {
    var edgePositions;
    var topEdgeLength;
    var i;
    var p1;
    var p2;
    var length = positions.length;
    var index = 0;
    if (!perPositionHeight) {
        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
        var numVertices = 0;
        for (i = 0; i < length; i++) {
            numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);
        }
        topEdgeLength = (numVertices + length) * 3;
        edgePositions = new Array(topEdgeLength * 2);
        for (i = 0; i < length; i++) {
            p1 = positions[i];
            p2 = positions[(i + 1) % length];
            var tempPositions = PolygonGeometryLibrary.subdivideLine(p1, p2, minDistance, computeWallIndicesSubdivided);
            var tempPositionsLength = tempPositions.length;
            for (var j = 0; j < tempPositionsLength; ++j, ++index) {
                edgePositions[index] = tempPositions[j];
                edgePositions[index + topEdgeLength] = tempPositions[j];
            }
            edgePositions[index] = p2.x;
            edgePositions[index + topEdgeLength] = p2.x;
            ++index;
            edgePositions[index] = p2.y;
            edgePositions[index + topEdgeLength] = p2.y;
            ++index;
            edgePositions[index] = p2.z;
            edgePositions[index + topEdgeLength] = p2.z;
            ++index;
        }
    } else {
        topEdgeLength = length * 3 * 2;
        edgePositions = new Array(topEdgeLength * 2);
        for (i = 0; i < length; i++) {
            p1 = positions[i];
            p2 = positions[(i + 1) % length];
            edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;
            ++index;
            edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;
            ++index;
            edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;
            ++index;
            edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;
            ++index;
            edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;
            ++index;
            edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;
            ++index;
        }
    }
    length = edgePositions.length;
    var indices = IndexDatatype.createTypedArray(length / 3, length - positions.length * 6);
    var edgeIndex = 0;
    length /= 6;
    for (i = 0; i < length; i++) {
        var UL = i;
        var UR = UL + 1;
        var LL = UL + length;
        var LR = LL + 1;
        p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);
        p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);
        if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON14)) {
            continue;
        }
        indices[edgeIndex++] = UL;
        indices[edgeIndex++] = LL;
        indices[edgeIndex++] = UR;
        indices[edgeIndex++] = UR;
        indices[edgeIndex++] = LL;
        indices[edgeIndex++] = LR;
    }
    return new Geometry({
        attributes: new GeometryAttributes({
            position: new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: edgePositions
            })
        }),
        indices: indices,
        primitiveType: PrimitiveType.TRIANGLES
    });
}
var createGeometryFromPositionsExtrudedPositions = [];
function createGeometryFromPositionsExtruded(ellipsoid, positions, granularity, hierarchy, perPositionHeight) {
    var topGeo = createGeometryFromPositions(ellipsoid, positions, granularity, perPositionHeight).geometry;
    var edgePoints = topGeo.attributes.position.values;
    var indices = topGeo.indices;
    var topBottomPositions = edgePoints.concat(edgePoints);
    var numPositions = topBottomPositions.length / 3;
    var newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);
    newIndices.set(indices);
    var ilength = indices.length;
    var i;
    var length = numPositions / 2;
    for (i = 0; i < ilength; i += 3) {
        var i0 = newIndices[i] + length;
        var i1 = newIndices[i + 1] + length;
        var i2 = newIndices[i + 2] + length;
        newIndices[i + ilength] = i2;
        newIndices[i + 1 + ilength] = i1;
        newIndices[i + 2 + ilength] = i0;
    }
    var topAndBottomGeo = new Geometry({
            attributes: new GeometryAttributes({
                position: new GeometryAttribute({
                    componentDatatype: ComponentDatatype.DOUBLE,
                    componentsPerAttribute: 3,
                    values: topBottomPositions
                })
            }),
            indices: newIndices,
            primitiveType: topGeo.primitiveType
        });
    var geos = {
            topAndBottom: new GeometryInstance({ geometry: topAndBottomGeo }),
            walls: []
        };
    var outerRing = hierarchy.outerRing;
    var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);
    var positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);
    var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
    if (windingOrder === WindingOrder.CLOCKWISE) {
        outerRing.reverse();
    }
    var wallGeo = computeWallIndices(outerRing, ellipsoid, granularity, perPositionHeight);
    geos.walls.push(new GeometryInstance({ geometry: wallGeo }));
    var holes = hierarchy.holes;
    for (i = 0; i < holes.length; i++) {
        var hole = holes[i];
        tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);
        positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);
        windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
        if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {
            hole.reverse();
        }
        wallGeo = computeWallIndices(hole, ellipsoid, granularity);
        geos.walls.push(new GeometryInstance({ geometry: wallGeo }));
    }
    return geos;
}
var PolygonGeometry = function (options) {
    if (!defined(options) || !defined(options.polygonHierarchy)) {
        throw new DeveloperError('options.polygonHierarchy is required.');
    }
    var polygonHierarchy = options.polygonHierarchy;
    var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    var stRotation = defaultValue(options.stRotation, 0);
    var height = defaultValue(options.height, 0);
    var perPositionHeight = defaultValue(options.perPositionHeight, false);
    var extrudedHeight = options.extrudedHeight;
    var extrude = defined(extrudedHeight) && (!CesiumMath.equalsEpsilon(height, extrudedHeight, CesiumMath.EPSILON6) || perPositionHeight);
    if (extrude) {
        var h = extrudedHeight;
        extrudedHeight = Math.min(h, height);
        height = Math.max(h, height);
    }
    this._vertexFormat = VertexFormat.clone(vertexFormat);
    this._ellipsoid = Ellipsoid.clone(ellipsoid);
    this._granularity = granularity;
    this._stRotation = stRotation;
    this._height = height;
    this._extrudedHeight = defaultValue(extrudedHeight, 0);
    this._extrude = extrude;
    this._polygonHierarchy = polygonHierarchy;
    this._perPositionHeight = perPositionHeight;
    this._workerName = 'createPolygonGeometry';
    this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + VertexFormat.packedLength + 7;
};
PolygonGeometry.fromPositions = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.positions)) {
        throw new DeveloperError('options.positions is required.');
    }
    var newOptions = {
            polygonHierarchy: { positions: options.positions },
            height: options.height,
            extrudedHeight: options.extrudedHeight,
            vertexFormat: options.vertexFormat,
            stRotation: options.stRotation,
            ellipsoid: options.ellipsoid,
            granularity: options.granularity,
            perPositionHeight: options.perPositionHeight
        };
    return new PolygonGeometry(newOptions);
};
PolygonGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex++] = value._height;
    array[startingIndex++] = value._extrudedHeight;
    array[startingIndex++] = value._granularity;
    array[startingIndex++] = value._stRotation;
    array[startingIndex++] = value._extrude ? 1 : 0;
    array[startingIndex++] = value._perPositionHeight ? 1 : 0;
    array[startingIndex] = value.packedLength;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchVertexFormat = new VertexFormat();
var dummyOptions = { polygonHierarchy: {} };
PolygonGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);
    startingIndex = polygonHierarchy.startingIndex;
    delete polygonHierarchy.startingIndex;
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var height = array[startingIndex++];
    var extrudedHeight = array[startingIndex++];
    var granularity = array[startingIndex++];
    var stRotation = array[startingIndex++];
    var extrude = array[startingIndex++] === 1;
    var perPositionHeight = array[startingIndex++] === 1;
    var packedLength = array[startingIndex];
    if (!defined(result)) {
        result = new PolygonGeometry(dummyOptions);
    }
    result._polygonHierarchy = polygonHierarchy;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._height = height;
    result._extrudedHeight = extrudedHeight;
    result._granularity = granularity;
    result._stRotation = stRotation;
    result._extrude = extrude;
    result._perPositionHeight = perPositionHeight;
    result.packedLength = packedLength;
    return result;
};
PolygonGeometry.createGeometry = function (polygonGeometry) {
    var vertexFormat = polygonGeometry._vertexFormat;
    var ellipsoid = polygonGeometry._ellipsoid;
    var granularity = polygonGeometry._granularity;
    var stRotation = polygonGeometry._stRotation;
    var height = polygonGeometry._height;
    var extrudedHeight = polygonGeometry._extrudedHeight;
    var extrude = polygonGeometry._extrude;
    var polygonHierarchy = polygonGeometry._polygonHierarchy;
    var perPositionHeight = polygonGeometry._perPositionHeight;
    var walls;
    var topAndBottom;
    var outerPositions;
    var polygons = [];
    var queue = new Queue();
    queue.enqueue(polygonHierarchy);
    polygonHierarchy = [];
    var i;
    while (queue.length !== 0) {
        var outerNode = queue.dequeue();
        var outerRing = outerNode.positions;
        var holes = outerNode.holes;
        outerRing = PolygonPipeline.removeDuplicates(outerRing);
        if (outerRing.length < 3) {
            continue;
        }
        var numChildren = defined(holes) ? holes.length : 0;
        var polygonHoles = [];
        for (i = 0; i < numChildren; i++) {
            var hole = holes[i];
            hole.positions = PolygonPipeline.removeDuplicates(hole.positions);
            if (hole.positions.length < 3) {
                continue;
            }
            polygonHoles.push(hole.positions);
            var numGrandchildren = 0;
            if (defined(hole.holes)) {
                numGrandchildren = hole.holes.length;
            }
            for (var j = 0; j < numGrandchildren; j++) {
                queue.enqueue(hole.holes[j]);
            }
        }
        polygonHierarchy.push({
            outerRing: outerRing,
            holes: polygonHoles
        });
        var combinedPolygon = polygonHoles.length > 0 ? PolygonPipeline.eliminateHoles(outerRing, polygonHoles) : outerRing;
        polygons.push(combinedPolygon);
    }
    if (polygons.length === 0) {
        return undefined;
    }
    outerPositions = polygons[0];
    var geometry;
    var geometries = [];
    if (extrude) {
        for (i = 0; i < polygons.length; i++) {
            geometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], granularity, polygonHierarchy[i], perPositionHeight);
            topAndBottom = geometry.topAndBottom;
            topAndBottom.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);
            topAndBottom.geometry = computeAttributes(vertexFormat, topAndBottom.geometry, outerPositions, ellipsoid, stRotation, true, false);
            geometries.push(topAndBottom);
            walls = geometry.walls;
            for (var k = 0; k < walls.length; k++) {
                var wall = walls[k];
                wall.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);
                wall.geometry = computeAttributes(vertexFormat, wall.geometry, outerPositions, ellipsoid, stRotation, true, true);
                geometries.push(wall);
            }
        }
    } else {
        for (i = 0; i < polygons.length; i++) {
            geometry = createGeometryFromPositions(ellipsoid, polygons[i], granularity, perPositionHeight);
            geometry.geometry = PolygonPipeline.scaleToGeodeticHeight(geometry.geometry, height, ellipsoid, !perPositionHeight);
            geometry.geometry = computeAttributes(vertexFormat, geometry.geometry, outerPositions, ellipsoid, stRotation, false, false);
            geometries.push(geometry);
        }
    }
    geometry = GeometryPipeline.combineInstances(geometries)[0];
    geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);
    geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);
    var attributes = geometry.attributes;
    var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);
    if (!vertexFormat.position) {
        delete attributes.position;
    }
    return new Geometry({
        attributes: attributes,
        indices: geometry.indices,
        primitiveType: geometry.primitiveType,
        boundingSphere: boundingSphere
    });
};
module.exports = PolygonGeometry;
},{"./BoundingRectangle":97,"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./EllipsoidTangentPlane":134,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./GeometryInstance":148,"./GeometryPipeline":150,"./IndexDatatype":162,"./Math":174,"./Matrix3":176,"./PolygonGeometryLibrary":184,"./PolygonPipeline":187,"./PrimitiveType":193,"./Quaternion":197,"./Queue":199,"./VertexFormat":228,"./WindingOrder":235,"./defaultValue":243,"./defined":245}],184:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), Ellipsoid = require('./Ellipsoid');
'use strict';
var PolygonGeometryLibrary = {};
PolygonGeometryLibrary.computeHierarchyPackedLength = function (polygonHierarchy) {
    var numComponents = 0;
    var stack = [polygonHierarchy];
    while (stack.length > 0) {
        var hierarchy = stack.pop();
        if (!defined(hierarchy)) {
            continue;
        }
        numComponents += 2;
        var positions = hierarchy.positions;
        var holes = hierarchy.holes;
        if (defined(positions)) {
            numComponents += positions.length * Cartesian3.packedLength;
        }
        if (defined(holes)) {
            var length = holes.length;
            for (var i = 0; i < length; ++i) {
                stack.push(holes[i]);
            }
        }
    }
    return numComponents;
};
PolygonGeometryLibrary.packPolygonHierarchy = function (polygonHierarchy, array, startingIndex) {
    var stack = [polygonHierarchy];
    while (stack.length > 0) {
        var hierarchy = stack.pop();
        if (!defined(hierarchy)) {
            continue;
        }
        var positions = hierarchy.positions;
        var holes = hierarchy.holes;
        array[startingIndex++] = defined(positions) ? positions.length : 0;
        array[startingIndex++] = defined(holes) ? holes.length : 0;
        if (defined(positions)) {
            var positionsLength = positions.length;
            for (var i = 0; i < positionsLength; ++i, startingIndex += 3) {
                Cartesian3.pack(positions[i], array, startingIndex);
            }
        }
        if (defined(holes)) {
            var holesLength = holes.length;
            for (var j = 0; j < holesLength; ++j) {
                stack.push(holes[j]);
            }
        }
    }
    return startingIndex;
};
PolygonGeometryLibrary.unpackPolygonHierarchy = function (array, startingIndex) {
    var positionsLength = array[startingIndex++];
    var holesLength = array[startingIndex++];
    var positions = new Array(positionsLength);
    var holes = holesLength > 0 ? new Array(holesLength) : undefined;
    for (var i = 0; i < positionsLength; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    for (var j = 0; j < holesLength; ++j) {
        holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);
        startingIndex = holes[j].startingIndex;
        delete holes[j].startingIndex;
    }
    return {
        positions: positions,
        holes: holes,
        startingIndex: startingIndex
    };
};
var distanceScratch = new Cartesian3();
function getPointAtDistance(p0, p1, distance, length) {
    Cartesian3.subtract(p1, p0, distanceScratch);
    Cartesian3.multiplyByScalar(distanceScratch, distance / length, distanceScratch);
    Cartesian3.add(p0, distanceScratch, distanceScratch);
    return [
        distanceScratch.x,
        distanceScratch.y,
        distanceScratch.z
    ];
}
PolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {
    var distance = Cartesian3.distance(p0, p1);
    var n = distance / minDistance;
    var countDivide = Math.max(0, Math.ceil(Math.log(n) / Math.log(2)));
    return Math.pow(2, countDivide);
};
PolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {
    var numVertices = PolygonGeometryLibrary.subdivideLineCount(p0, p1, minDistance);
    var length = Cartesian3.distance(p0, p1);
    var distanceBetweenVertices = length / numVertices;
    if (!defined(result)) {
        result = [];
    }
    var positions = result;
    positions.length = numVertices * 3;
    var index = 0;
    for (var i = 0; i < numVertices; i++) {
        var p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);
        positions[index++] = p[0];
        positions[index++] = p[1];
        positions[index++] = p[2];
    }
    return positions;
};
var scaleToGeodeticHeightN1 = new Cartesian3();
var scaleToGeodeticHeightN2 = new Cartesian3();
var scaleToGeodeticHeightP1 = new Cartesian3();
var scaleToGeodeticHeightP2 = new Cartesian3();
PolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (geometry, maxHeight, minHeight, ellipsoid, perPositionHeight) {
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    var n1 = scaleToGeodeticHeightN1;
    var n2 = scaleToGeodeticHeightN2;
    var p = scaleToGeodeticHeightP1;
    var p2 = scaleToGeodeticHeightP2;
    if (defined(geometry) && defined(geometry.attributes) && defined(geometry.attributes.position)) {
        var positions = geometry.attributes.position.values;
        var length = positions.length / 2;
        for (var i = 0; i < length; i += 3) {
            Cartesian3.fromArray(positions, i, p);
            ellipsoid.geodeticSurfaceNormal(p, n1);
            p2 = ellipsoid.scaleToGeodeticSurface(p, p2);
            n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);
            n2 = Cartesian3.add(p2, n2, n2);
            positions[i + length] = n2.x;
            positions[i + 1 + length] = n2.y;
            positions[i + 2 + length] = n2.z;
            if (perPositionHeight) {
                p2 = Cartesian3.clone(p, p2);
            }
            n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);
            n2 = Cartesian3.add(p2, n2, n2);
            positions[i] = n2.x;
            positions[i + 1] = n2.y;
            positions[i + 2] = n2.z;
        }
    }
    return geometry;
};
module.exports = PolygonGeometryLibrary;
},{"./Cartesian3":102,"./Ellipsoid":130,"./defaultValue":243,"./defined":245}],185:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var PolygonHierarchy = function (positions, holes) {
    this.positions = defined(positions) ? positions : [];
    this.holes = defined(holes) ? holes : [];
};
module.exports = PolygonHierarchy;
},{"./defined":245}],186:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), EllipsoidTangentPlane = require('./EllipsoidTangentPlane'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), GeometryInstance = require('./GeometryInstance'), GeometryPipeline = require('./GeometryPipeline'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PolygonGeometryLibrary = require('./PolygonGeometryLibrary'), PolygonPipeline = require('./PolygonPipeline'), PrimitiveType = require('./PrimitiveType'), Queue = require('./Queue'), WindingOrder = require('./WindingOrder');
'use strict';
var createGeometryFromPositionsPositions = [];
var createGeometryFromPositionsSubdivided = [];
function createGeometryFromPositions(ellipsoid, positions, minDistance, perPositionHeight) {
    var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);
    var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);
    var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
    if (originalWindingOrder === WindingOrder.CLOCKWISE) {
        positions2D.reverse();
        positions.reverse();
    }
    var subdividedPositions;
    var i;
    var length = positions.length;
    var index = 0;
    if (!perPositionHeight) {
        var numVertices = 0;
        for (i = 0; i < length; i++) {
            numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);
        }
        subdividedPositions = new Float64Array(numVertices * 3);
        for (i = 0; i < length; i++) {
            var tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);
            var tempPositionsLength = tempPositions.length;
            for (var j = 0; j < tempPositionsLength; ++j) {
                subdividedPositions[index++] = tempPositions[j];
            }
        }
    } else {
        subdividedPositions = new Float64Array(length * 2 * 3);
        for (i = 0; i < length; i++) {
            var p0 = positions[i];
            var p1 = positions[(i + 1) % length];
            subdividedPositions[index++] = p0.x;
            subdividedPositions[index++] = p0.y;
            subdividedPositions[index++] = p0.z;
            subdividedPositions[index++] = p1.x;
            subdividedPositions[index++] = p1.y;
            subdividedPositions[index++] = p1.z;
        }
    }
    length = subdividedPositions.length / 3;
    var indicesSize = length * 2;
    var indices = IndexDatatype.createTypedArray(length, indicesSize);
    index = 0;
    for (i = 0; i < length - 1; i++) {
        indices[index++] = i;
        indices[index++] = i + 1;
    }
    indices[index++] = length - 1;
    indices[index++] = 0;
    return new GeometryInstance({
        geometry: new Geometry({
            attributes: new GeometryAttributes({
                position: new GeometryAttribute({
                    componentDatatype: ComponentDatatype.DOUBLE,
                    componentsPerAttribute: 3,
                    values: subdividedPositions
                })
            }),
            indices: indices,
            primitiveType: PrimitiveType.LINES
        })
    });
}
function createGeometryFromPositionsExtruded(ellipsoid, positions, minDistance, perPositionHeight) {
    var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);
    var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);
    var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
    if (originalWindingOrder === WindingOrder.CLOCKWISE) {
        positions2D.reverse();
        positions.reverse();
    }
    var subdividedPositions;
    var i;
    var length = positions.length;
    var corners = new Array(length);
    var index = 0;
    if (!perPositionHeight) {
        var numVertices = 0;
        for (i = 0; i < length; i++) {
            numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);
        }
        subdividedPositions = new Float64Array(numVertices * 3 * 2);
        for (i = 0; i < length; ++i) {
            corners[i] = index / 3;
            var tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);
            var tempPositionsLength = tempPositions.length;
            for (var j = 0; j < tempPositionsLength; ++j) {
                subdividedPositions[index++] = tempPositions[j];
            }
        }
    } else {
        subdividedPositions = new Float64Array(length * 2 * 3 * 2);
        for (i = 0; i < length; ++i) {
            corners[i] = index / 3;
            var p0 = positions[i];
            var p1 = positions[(i + 1) % length];
            subdividedPositions[index++] = p0.x;
            subdividedPositions[index++] = p0.y;
            subdividedPositions[index++] = p0.z;
            subdividedPositions[index++] = p1.x;
            subdividedPositions[index++] = p1.y;
            subdividedPositions[index++] = p1.z;
        }
    }
    length = subdividedPositions.length / (3 * 2);
    var cornersLength = corners.length;
    var indicesSize = (length * 2 + cornersLength) * 2;
    var indices = IndexDatatype.createTypedArray(length, indicesSize);
    index = 0;
    for (i = 0; i < length; ++i) {
        indices[index++] = i;
        indices[index++] = (i + 1) % length;
        indices[index++] = i + length;
        indices[index++] = (i + 1) % length + length;
    }
    for (i = 0; i < cornersLength; i++) {
        var corner = corners[i];
        indices[index++] = corner;
        indices[index++] = corner + length;
    }
    return new GeometryInstance({
        geometry: new Geometry({
            attributes: new GeometryAttributes({
                position: new GeometryAttribute({
                    componentDatatype: ComponentDatatype.DOUBLE,
                    componentsPerAttribute: 3,
                    values: subdividedPositions
                })
            }),
            indices: indices,
            primitiveType: PrimitiveType.LINES
        })
    });
}
var PolygonOutlineGeometry = function (options) {
    if (!defined(options) || !defined(options.polygonHierarchy)) {
        throw new DeveloperError('options.polygonHierarchy is required.');
    }
    var polygonHierarchy = options.polygonHierarchy;
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    var height = defaultValue(options.height, 0);
    var perPositionHeight = defaultValue(options.perPositionHeight, false);
    var extrudedHeight = options.extrudedHeight;
    var extrude = defined(extrudedHeight) && (!CesiumMath.equalsEpsilon(height, extrudedHeight, CesiumMath.EPSILON6) || perPositionHeight);
    if (extrude) {
        var h = extrudedHeight;
        extrudedHeight = Math.min(h, height);
        height = Math.max(h, height);
    }
    this._ellipsoid = Ellipsoid.clone(ellipsoid);
    this._granularity = granularity;
    this._height = height;
    this._extrudedHeight = defaultValue(extrudedHeight, 0);
    this._extrude = extrude;
    this._polygonHierarchy = polygonHierarchy;
    this._perPositionHeight = perPositionHeight;
    this._workerName = 'createPolygonOutlineGeometry';
    this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + 6;
};
PolygonOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    array[startingIndex++] = value._height;
    array[startingIndex++] = value._extrudedHeight;
    array[startingIndex++] = value._granularity;
    array[startingIndex++] = value._extrude ? 1 : 0;
    array[startingIndex++] = value._perPositionHeight ? 1 : 0;
    array[startingIndex++] = value.packedLength;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var dummyOptions = { polygonHierarchy: {} };
PolygonOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);
    startingIndex = polygonHierarchy.startingIndex;
    delete polygonHierarchy.startingIndex;
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var height = array[startingIndex++];
    var extrudedHeight = array[startingIndex++];
    var granularity = array[startingIndex++];
    var extrude = array[startingIndex++] === 1;
    var perPositionHeight = array[startingIndex++] === 1;
    var packedLength = array[startingIndex++];
    if (!defined(result)) {
        result = new PolygonOutlineGeometry(dummyOptions);
    }
    result._polygonHierarchy = polygonHierarchy;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._height = height;
    result._extrudedHeight = extrudedHeight;
    result._granularity = granularity;
    result._extrude = extrude;
    result._perPositionHeight = perPositionHeight;
    result.packedLength = packedLength;
    return result;
};
PolygonOutlineGeometry.fromPositions = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.positions)) {
        throw new DeveloperError('options.positions is required.');
    }
    var newOptions = {
            polygonHierarchy: { positions: options.positions },
            height: options.height,
            extrudedHeight: options.extrudedHeight,
            ellipsoid: options.ellipsoid,
            granularity: options.granularity,
            perPositionHeight: options.perPositionHeight
        };
    return new PolygonOutlineGeometry(newOptions);
};
PolygonOutlineGeometry.createGeometry = function (polygonGeometry) {
    var ellipsoid = polygonGeometry._ellipsoid;
    var granularity = polygonGeometry._granularity;
    var height = polygonGeometry._height;
    var extrudedHeight = polygonGeometry._extrudedHeight;
    var extrude = polygonGeometry._extrude;
    var polygonHierarchy = polygonGeometry._polygonHierarchy;
    var perPositionHeight = polygonGeometry._perPositionHeight;
    var polygons = [];
    var queue = new Queue();
    queue.enqueue(polygonHierarchy);
    var i;
    while (queue.length !== 0) {
        var outerNode = queue.dequeue();
        var outerRing = outerNode.positions;
        outerRing = PolygonPipeline.removeDuplicates(outerRing);
        if (outerRing.length < 3) {
            continue;
        }
        var numChildren = outerNode.holes ? outerNode.holes.length : 0;
        for (i = 0; i < numChildren; i++) {
            var hole = outerNode.holes[i];
            hole.positions = PolygonPipeline.removeDuplicates(hole.positions);
            if (hole.positions.length < 3) {
                continue;
            }
            polygons.push(hole.positions);
            var numGrandchildren = 0;
            if (defined(hole.holes)) {
                numGrandchildren = hole.holes.length;
            }
            for (var j = 0; j < numGrandchildren; j++) {
                queue.enqueue(hole.holes[j]);
            }
        }
        polygons.push(outerRing);
    }
    if (polygons.length === 0) {
        return undefined;
    }
    var geometry;
    var geometries = [];
    var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
    if (extrude) {
        for (i = 0; i < polygons.length; i++) {
            geometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], minDistance, perPositionHeight);
            geometry.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(geometry.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);
            geometries.push(geometry);
        }
    } else {
        for (i = 0; i < polygons.length; i++) {
            geometry = createGeometryFromPositions(ellipsoid, polygons[i], minDistance, perPositionHeight);
            geometry.geometry = PolygonPipeline.scaleToGeodeticHeight(geometry.geometry, height, ellipsoid, !perPositionHeight);
            geometries.push(geometry);
        }
    }
    geometry = GeometryPipeline.combineInstances(geometries)[0];
    var boundingSphere = BoundingSphere.fromVertices(geometry.attributes.position.values);
    return new Geometry({
        attributes: geometry.attributes,
        indices: geometry.indices,
        primitiveType: geometry.primitiveType,
        boundingSphere: boundingSphere
    });
};
module.exports = PolygonOutlineGeometry;
},{"./BoundingSphere":98,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./EllipsoidTangentPlane":134,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./GeometryInstance":148,"./GeometryPipeline":150,"./IndexDatatype":162,"./Math":174,"./PolygonGeometryLibrary":184,"./PolygonPipeline":187,"./PrimitiveType":193,"./Queue":199,"./WindingOrder":235,"./defaultValue":243,"./defined":245}],187:[function(require,module,exports){
var Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), EllipsoidTangentPlane = require('./EllipsoidTangentPlane'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), CesiumMath = require('./Math'), pointInsideTriangle = require('./pointInsideTriangle'), PrimitiveType = require('./PrimitiveType'), Queue = require('./Queue'), WindingOrder = require('./WindingOrder');
'use strict';
var uScratch = new Cartesian2();
var vScratch = new Cartesian2();
function isTipConvex(p0, p1, p2) {
    var u = Cartesian2.subtract(p1, p0, uScratch);
    var v = Cartesian2.subtract(p2, p1, vScratch);
    return u.x * v.y - u.y * v.x >= 0;
}
function getRightmostPositionIndex(positions) {
    var maximumX = positions[0].x;
    var rightmostPositionIndex = 0;
    for (var i = 0; i < positions.length; i++) {
        if (positions[i].x > maximumX) {
            maximumX = positions[i].x;
            rightmostPositionIndex = i;
        }
    }
    return rightmostPositionIndex;
}
function getRightmostRingIndex(rings) {
    var rightmostX = rings[0][0].x;
    var rightmostRingIndex = 0;
    for (var ring = 0; ring < rings.length; ring++) {
        var maximumX = rings[ring][getRightmostPositionIndex(rings[ring])].x;
        if (maximumX > rightmostX) {
            rightmostX = maximumX;
            rightmostRingIndex = ring;
        }
    }
    return rightmostRingIndex;
}
function getReflexVertices(polygon) {
    var reflexVertices = [];
    for (var i = 0; i < polygon.length; i++) {
        var p0 = polygon[(i - 1 + polygon.length) % polygon.length];
        var p1 = polygon[i];
        var p2 = polygon[(i + 1) % polygon.length];
        if (!isTipConvex(p0, p1, p2)) {
            reflexVertices.push(p1);
        }
    }
    return reflexVertices;
}
function isVertex(positions, point) {
    for (var i = 0; i < positions.length; i++) {
        if (Cartesian2.equals(point, positions[i])) {
            return i;
        }
    }
    return -1;
}
var distScratch = new Cartesian2();
function intersectPointWithRing(point, ring, edgeIndices) {
    edgeIndices = defaultValue(edgeIndices, []);
    var minDistance = Number.MAX_VALUE;
    var rightmostVertexIndex = getRightmostPositionIndex(ring);
    var intersection = new Cartesian2(ring[rightmostVertexIndex].x, point.y);
    edgeIndices.push(rightmostVertexIndex);
    edgeIndices.push((rightmostVertexIndex + 1) % ring.length);
    var boundaryMinX = ring[0].x;
    var boundaryMaxX = boundaryMinX;
    for (var i = 1; i < ring.length; ++i) {
        if (ring[i].x < boundaryMinX) {
            boundaryMinX = ring[i].x;
        } else if (ring[i].x > boundaryMaxX) {
            boundaryMaxX = ring[i].x;
        }
    }
    boundaryMaxX += boundaryMaxX - boundaryMinX;
    var point2 = new Cartesian3(boundaryMaxX, point.y, 0);
    for (i = 0; i < ring.length; i++) {
        var v1 = ring[i];
        var v2 = ring[(i + 1) % ring.length];
        if ((v1.x >= point.x || v2.x >= point.x) && (v1.y >= point.y && v2.y <= point.y || v1.y <= point.y && v2.y >= point.y)) {
            var temp = (v2.y - v1.y) * (point2.x - point.x) - (v2.x - v1.x) * (point2.y - point.y);
            if (temp !== 0) {
                temp = 1 / temp;
                var ua = ((v2.x - v1.x) * (point.y - v1.y) - (v2.y - v1.y) * (point.x - v1.x)) * temp;
                var ub = ((point2.x - point.x) * (point.y - v1.y) - (point2.y - point.y) * (point.x - v1.x)) * temp;
                if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                    var tempIntersection = new Cartesian2(point.x + ua * (point2.x - point.x), point.y + ua * (point2.y - point.y));
                    var dist = Cartesian2.subtract(tempIntersection, point, distScratch);
                    temp = Cartesian2.magnitudeSquared(dist);
                    if (temp < minDistance) {
                        intersection = tempIntersection;
                        minDistance = temp;
                        edgeIndices[0] = i;
                        edgeIndices[1] = (i + 1) % ring.length;
                    }
                }
            }
        }
    }
    return intersection;
}
var v1Scratch = new Cartesian2(1, 0);
var v2Scratch = new Cartesian2();
function getMutuallyVisibleVertexIndex(outerRing, innerRings) {
    var innerRingIndex = getRightmostRingIndex(innerRings);
    var innerRing = innerRings[innerRingIndex];
    var innerRingVertexIndex = getRightmostPositionIndex(innerRing);
    var innerRingVertex = innerRing[innerRingVertexIndex];
    var edgeIndices = [];
    var intersection = intersectPointWithRing(innerRingVertex, outerRing, edgeIndices);
    var visibleVertex = isVertex(outerRing, intersection);
    if (visibleVertex !== -1) {
        return visibleVertex;
    }
    var d1 = Cartesian2.magnitudeSquared(Cartesian2.subtract(outerRing[edgeIndices[0]], innerRingVertex, v1Scratch));
    var d2 = Cartesian2.magnitudeSquared(Cartesian2.subtract(outerRing[edgeIndices[1]], innerRingVertex, v1Scratch));
    var p = d1 < d2 ? outerRing[edgeIndices[0]] : outerRing[edgeIndices[1]];
    var reflexVertices = getReflexVertices(outerRing);
    var reflexIndex = reflexVertices.indexOf(p);
    if (reflexIndex !== -1) {
        reflexVertices.splice(reflexIndex, 1);
    }
    var pointsInside = [];
    for (var i = 0; i < reflexVertices.length; i++) {
        var vertex = reflexVertices[i];
        if (pointInsideTriangle(vertex, innerRingVertex, intersection, p)) {
            pointsInside.push(vertex);
        }
    }
    var minAngle = Number.MAX_VALUE;
    if (pointsInside.length > 0) {
        var v1 = Cartesian2.fromElements(1, 0, v1Scratch);
        for (i = 0; i < pointsInside.length; i++) {
            var v2 = Cartesian2.subtract(pointsInside[i], innerRingVertex, v2Scratch);
            var denominator = Cartesian2.magnitude(v1) * Cartesian2.magnitudeSquared(v2);
            if (denominator !== 0) {
                var angle = Math.abs(CesiumMath.acosClamped(Cartesian2.dot(v1, v2) / denominator));
                if (angle < minAngle) {
                    minAngle = angle;
                    p = pointsInside[i];
                }
            }
        }
    }
    return outerRing.indexOf(p);
}
function eliminateHole(outerRing, innerRings, ellipsoid) {
    var windingOrder = PolygonPipeline.computeWindingOrder2D(outerRing);
    for (var i = 0; i < innerRings.length; i++) {
        var ring = innerRings[i];
        if (!Cartesian3.equals(ring[0], ring[ring.length - 1])) {
            ring.push(ring[0]);
        }
        var innerWindingOrder = PolygonPipeline.computeWindingOrder2D(ring);
        if (innerWindingOrder === windingOrder) {
            ring.reverse();
        }
    }
    var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);
    var tangentOuterRing = tangentPlane.projectPointsOntoPlane(outerRing);
    var tangentInnerRings = [];
    for (i = 0; i < innerRings.length; i++) {
        tangentInnerRings.push(tangentPlane.projectPointsOntoPlane(innerRings[i]));
    }
    var visibleVertexIndex = getMutuallyVisibleVertexIndex(tangentOuterRing, tangentInnerRings);
    var innerRingIndex = getRightmostRingIndex(tangentInnerRings);
    var innerRingVertexIndex = getRightmostPositionIndex(tangentInnerRings[innerRingIndex]);
    var innerRing = innerRings[innerRingIndex];
    var newPolygonVertices = [];
    for (i = 0; i < outerRing.length; i++) {
        newPolygonVertices.push(outerRing[i]);
    }
    var j;
    var holeVerticesToAdd = [];
    if (innerRingVertexIndex !== 0) {
        for (j = 0; j <= innerRing.length; j++) {
            var index = (j + innerRingVertexIndex) % innerRing.length;
            if (index !== 0) {
                holeVerticesToAdd.push(innerRing[index]);
            }
        }
    } else {
        for (j = 0; j < innerRing.length; j++) {
            holeVerticesToAdd.push(innerRing[(j + innerRingVertexIndex) % innerRing.length]);
        }
    }
    var lastVisibleVertexIndex = newPolygonVertices.lastIndexOf(outerRing[visibleVertexIndex]);
    holeVerticesToAdd.push(outerRing[lastVisibleVertexIndex]);
    var front = newPolygonVertices.slice(0, lastVisibleVertexIndex + 1);
    var back = newPolygonVertices.slice(lastVisibleVertexIndex + 1);
    newPolygonVertices = front.concat(holeVerticesToAdd, back);
    innerRings.splice(innerRingIndex, 1);
    return newPolygonVertices;
}
function getRandomIndex(length) {
    var random = CesiumMath.nextRandomNumber();
    var i = Math.floor(random * length);
    if (i === length) {
        i--;
    }
    return i;
}
function indexedEdgeCrossZ(p0Index, p1Index, vertexIndex, array) {
    var p0 = array[p0Index].position;
    var p1 = array[p1Index].position;
    var v = array[vertexIndex].position;
    var vx = v.x;
    var vy = v.y;
    var leftX = p0.x - vx;
    var leftY = p0.y - vy;
    var rightX = p1.x - vx;
    var rightY = p1.y - vy;
    return leftX * rightY - leftY * rightX;
}
function crossZ(p0, p1) {
    return p0.x * p1.y - p0.y * p1.x;
}
function validateVertex(index, pArray) {
    var length = pArray.length;
    var before = CesiumMath.mod(index - 1, length);
    var after = CesiumMath.mod(index + 1, length);
    if (indexedEdgeCrossZ(before, after, index, pArray) === 0) {
        return false;
    }
    return true;
}
function isInternalToParallelSide(side, cut) {
    return Cartesian2.magnitudeSquared(cut) < Cartesian2.magnitudeSquared(side);
}
var INTERNAL = -1;
var EXTERNAL = -2;
var s1Scratch = new Cartesian3();
var s2Scratch = new Cartesian3();
var cutScratch = new Cartesian3();
function internalCut(a1i, a2i, pArray) {
    if (!validateVertex(a1i, pArray)) {
        return a1i;
    }
    var a1Position = pArray[a1i].position;
    var a2Position = pArray[a2i].position;
    var length = pArray.length;
    var before = CesiumMath.mod(a1i - 1, length);
    if (!validateVertex(before, pArray)) {
        return before;
    }
    var after = CesiumMath.mod(a1i + 1, length);
    if (!validateVertex(after, pArray)) {
        return after;
    }
    var s1 = Cartesian2.subtract(pArray[before].position, a1Position, s1Scratch);
    var s2 = Cartesian2.subtract(pArray[after].position, a1Position, s2Scratch);
    var cut = Cartesian2.subtract(a2Position, a1Position, cutScratch);
    var leftEdgeCutZ = crossZ(s1, cut);
    var rightEdgeCutZ = crossZ(s2, cut);
    if (leftEdgeCutZ === 0) {
        return isInternalToParallelSide(s1, cut) ? INTERNAL : EXTERNAL;
    } else if (rightEdgeCutZ === 0) {
        return isInternalToParallelSide(s2, cut) ? INTERNAL : EXTERNAL;
    } else {
        var z = crossZ(s1, s2);
        if (z < 0) {
            return leftEdgeCutZ < 0 && rightEdgeCutZ > 0 ? INTERNAL : EXTERNAL;
        } else if (z > 0) {
            return leftEdgeCutZ > 0 && rightEdgeCutZ < 0 ? EXTERNAL : INTERNAL;
        }
    }
}
function isBetween(number, n1, n2) {
    return (number > n1 || number > n2) && (number < n1 || number < n2) || n1 === n2 && n1 === number;
}
var sqrEpsilon = CesiumMath.EPSILON14;
var eScratch = new Cartesian2();
function linesIntersection(p0, d0, p1, d1) {
    var e = Cartesian2.subtract(p1, p0, eScratch);
    var cross = d0.x * d1.y - d0.y * d1.x;
    var sqrCross = cross * cross;
    var sqrLen0 = Cartesian2.magnitudeSquared(d0);
    var sqrLen1 = Cartesian2.magnitudeSquared(d1);
    if (sqrCross > sqrEpsilon * sqrLen0 * sqrLen1) {
        var s = (e.x * d1.y - e.y * d1.x) / cross;
        return Cartesian2.add(p0, Cartesian2.multiplyByScalar(d0, s, eScratch), eScratch);
    }
    return undefined;
}
var intersectionScratch = new Cartesian2();
var aDirectionScratch = new Cartesian2();
var bDirectionScratch = new Cartesian2();
function intersectsSide(a1, a2, pArray) {
    var aDirection = Cartesian2.subtract(a2, a1, aDirectionScratch);
    var length = pArray.length;
    for (var i = 0; i < length; i++) {
        var b1 = pArray[i].position;
        var b2 = pArray[CesiumMath.mod(i + 1, length)].position;
        if (Cartesian2.equals(a1, b1) || Cartesian2.equals(a2, b2) || Cartesian2.equals(a1, b2) || Cartesian2.equals(a2, b1)) {
            continue;
        }
        var bDirection = Cartesian2.subtract(b2, b1, bDirectionScratch);
        var intersection = linesIntersection(a1, aDirection, b1, bDirection);
        if (!defined(intersection)) {
            continue;
        }
        if (Cartesian2.equals(intersection, a1) || Cartesian2.equals(intersection, a2) || Cartesian2.equals(intersection, b1) || Cartesian2.equals(intersection, b2)) {
            continue;
        }
        var intX = intersection.x;
        var intY = intersection.y;
        var intersects = isBetween(intX, a1.x, a2.x) && isBetween(intY, a1.y, a2.y) && isBetween(intX, b1.x, b2.x) && isBetween(intY, b1.y, b2.y);
        if (intersects) {
            return true;
        }
    }
    return false;
}
var CLEAN_CUT = -1;
var INVALID_CUT = -2;
function cleanCut(a1i, a2i, pArray) {
    var internalCut12 = internalCut(a1i, a2i, pArray);
    if (internalCut12 >= 0) {
        return internalCut12;
    }
    var internalCut21 = internalCut(a2i, a1i, pArray);
    if (internalCut21 >= 0) {
        return internalCut21;
    }
    if (internalCut12 === INTERNAL && internalCut21 === INTERNAL && !intersectsSide(pArray[a1i].position, pArray[a2i].position, pArray) && !Cartesian2.equals(pArray[a1i].position, pArray[a2i].position)) {
        return CLEAN_CUT;
    }
    return INVALID_CUT;
}
function triangleInLine(pArray) {
    return indexedEdgeCrossZ(1, 2, 0, pArray) === 0;
}
function randomChop(nodeArray) {
    var numVertices = nodeArray.length;
    if (numVertices === 3) {
        if (!triangleInLine(nodeArray)) {
            return [
                nodeArray[0].index,
                nodeArray[1].index,
                nodeArray[2].index
            ];
        }
        return [];
    } else if (nodeArray.length < 3) {
        throw new DeveloperError('Invalid polygon: must have at least three vertices.');
    }
    var tries = 0;
    var maxTries = nodeArray.length * 10;
    var cutResult = INVALID_CUT;
    var index1;
    var index2;
    while (cutResult < CLEAN_CUT && tries++ < maxTries) {
        index1 = getRandomIndex(nodeArray.length);
        index2 = index1 + 1;
        while (Math.abs(index1 - index2) < 2 || Math.abs(index1 - index2) > nodeArray.length - 2) {
            index2 = getRandomIndex(nodeArray.length);
        }
        if (index1 > index2) {
            var index = index1;
            index1 = index2;
            index2 = index;
        }
        cutResult = cleanCut(index1, index2, nodeArray);
    }
    if (cutResult === CLEAN_CUT) {
        var nodeArray2 = nodeArray.splice(index1, index2 - index1 + 1, nodeArray[index1], nodeArray[index2]);
        return randomChop(nodeArray).concat(randomChop(nodeArray2));
    } else if (cutResult >= 0) {
        nodeArray.splice(cutResult, 1);
        return randomChop(nodeArray);
    }
    return [];
}
var scaleToGeodeticHeightN = new Cartesian3();
var scaleToGeodeticHeightP = new Cartesian3();
var PolygonPipeline = {};
PolygonPipeline.removeDuplicates = function (positions) {
    if (!defined(positions)) {
        throw new DeveloperError('positions is required.');
    }
    if (positions.length < 3) {
        throw new DeveloperError('At least three positions are required.');
    }
    var length = positions.length;
    var cleanedPositions = [];
    for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
        var v0 = positions[i0];
        var v1 = positions[i1];
        if (!Cartesian3.equals(v0, v1)) {
            cleanedPositions.push(v1);
        }
    }
    return cleanedPositions;
};
PolygonPipeline.computeArea2D = function (positions) {
    if (!defined(positions)) {
        throw new DeveloperError('positions is required.');
    }
    if (positions.length < 3) {
        throw new DeveloperError('At least three positions are required.');
    }
    var length = positions.length;
    var area = 0;
    for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
        var v0 = positions[i0];
        var v1 = positions[i1];
        area += v0.x * v1.y - v1.x * v0.y;
    }
    return area * 0.5;
};
PolygonPipeline.computeWindingOrder2D = function (positions) {
    var area = PolygonPipeline.computeArea2D(positions);
    return area > 0 ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;
};
PolygonPipeline.triangulate = function (positions) {
    if (!defined(positions)) {
        throw new DeveloperError('positions is required.');
    }
    if (positions.length < 3) {
        throw new DeveloperError('At least three positions are required.');
    }
    var length = positions.length;
    var nodeArray = [];
    for (var i = 0; i < length; ++i) {
        nodeArray[i] = {
            position: positions[i],
            index: i
        };
    }
    return randomChop(nodeArray);
};
var subdivisionV0Scratch = new Cartesian3();
var subdivisionV1Scratch = new Cartesian3();
var subdivisionV2Scratch = new Cartesian3();
var subdivisionS0Scratch = new Cartesian3();
var subdivisionS1Scratch = new Cartesian3();
var subdivisionS2Scratch = new Cartesian3();
var subdivisionMidScratch = new Cartesian3();
PolygonPipeline.computeSubdivision = function (ellipsoid, positions, indices, granularity) {
    granularity = defaultValue(granularity, CesiumMath.RADIANS_PER_DEGREE);
    if (!defined(ellipsoid)) {
        throw new DeveloperError('ellipsoid is required.');
    }
    if (!defined(positions)) {
        throw new DeveloperError('positions is required.');
    }
    if (!defined(indices)) {
        throw new DeveloperError('indices is required.');
    }
    if (indices.length < 3) {
        throw new DeveloperError('At least three indices are required.');
    }
    if (indices.length % 3 !== 0) {
        throw new DeveloperError('The number of indices must be divisable by three.');
    }
    if (granularity <= 0) {
        throw new DeveloperError('granularity must be greater than zero.');
    }
    var triangles = indices.slice(0);
    var i;
    var length = positions.length;
    var subdividedPositions = new Array(length * 3);
    var q = 0;
    for (i = 0; i < length; i++) {
        var item = positions[i];
        subdividedPositions[q++] = item.x;
        subdividedPositions[q++] = item.y;
        subdividedPositions[q++] = item.z;
    }
    var subdividedIndices = [];
    var edges = {};
    var radius = ellipsoid.maximumRadius;
    var minDistance = CesiumMath.chordLength(granularity, radius);
    var minDistanceSqrd = minDistance * minDistance;
    while (triangles.length > 0) {
        var i2 = triangles.pop();
        var i1 = triangles.pop();
        var i0 = triangles.pop();
        var v0 = Cartesian3.fromArray(subdividedPositions, i0 * 3, subdivisionV0Scratch);
        var v1 = Cartesian3.fromArray(subdividedPositions, i1 * 3, subdivisionV1Scratch);
        var v2 = Cartesian3.fromArray(subdividedPositions, i2 * 3, subdivisionV2Scratch);
        var s0 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v0, subdivisionS0Scratch), radius, subdivisionS0Scratch);
        var s1 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v1, subdivisionS1Scratch), radius, subdivisionS1Scratch);
        var s2 = Cartesian3.multiplyByScalar(Cartesian3.normalize(v2, subdivisionS2Scratch), radius, subdivisionS2Scratch);
        var g0 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s0, s1, subdivisionMidScratch));
        var g1 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s1, s2, subdivisionMidScratch));
        var g2 = Cartesian3.magnitudeSquared(Cartesian3.subtract(s2, s0, subdivisionMidScratch));
        var max = Math.max(g0, g1, g2);
        var edge;
        var mid;
        if (max > minDistanceSqrd) {
            if (g0 === max) {
                edge = Math.min(i0, i1) + ' ' + Math.max(i0, i1);
                i = edges[edge];
                if (!defined(i)) {
                    mid = Cartesian3.add(v0, v1, subdivisionMidScratch);
                    Cartesian3.multiplyByScalar(mid, 0.5, mid);
                    subdividedPositions.push(mid.x, mid.y, mid.z);
                    i = subdividedPositions.length / 3 - 1;
                    edges[edge] = i;
                }
                triangles.push(i0, i, i2);
                triangles.push(i, i1, i2);
            } else if (g1 === max) {
                edge = Math.min(i1, i2) + ' ' + Math.max(i1, i2);
                i = edges[edge];
                if (!defined(i)) {
                    mid = Cartesian3.add(v1, v2, subdivisionMidScratch);
                    Cartesian3.multiplyByScalar(mid, 0.5, mid);
                    subdividedPositions.push(mid.x, mid.y, mid.z);
                    i = subdividedPositions.length / 3 - 1;
                    edges[edge] = i;
                }
                triangles.push(i1, i, i0);
                triangles.push(i, i2, i0);
            } else if (g2 === max) {
                edge = Math.min(i2, i0) + ' ' + Math.max(i2, i0);
                i = edges[edge];
                if (!defined(i)) {
                    mid = Cartesian3.add(v2, v0, subdivisionMidScratch);
                    Cartesian3.multiplyByScalar(mid, 0.5, mid);
                    subdividedPositions.push(mid.x, mid.y, mid.z);
                    i = subdividedPositions.length / 3 - 1;
                    edges[edge] = i;
                }
                triangles.push(i2, i, i1);
                triangles.push(i, i0, i1);
            }
        } else {
            subdividedIndices.push(i0);
            subdividedIndices.push(i1);
            subdividedIndices.push(i2);
        }
    }
    return new Geometry({
        attributes: {
            position: new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: subdividedPositions
            })
        },
        indices: subdividedIndices,
        primitiveType: PrimitiveType.TRIANGLES
    });
};
PolygonPipeline.scaleToGeodeticHeight = function (geometry, height, ellipsoid, scaleToSurface) {
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    var n = scaleToGeodeticHeightN;
    var p = scaleToGeodeticHeightP;
    height = defaultValue(height, 0);
    scaleToSurface = defaultValue(scaleToSurface, true);
    if (defined(geometry) && defined(geometry.attributes) && defined(geometry.attributes.position)) {
        var positions = geometry.attributes.position.values;
        var length = positions.length;
        for (var i = 0; i < length; i += 3) {
            Cartesian3.fromArray(positions, i, p);
            if (scaleToSurface) {
                p = ellipsoid.scaleToGeodeticSurface(p, p);
            }
            n = ellipsoid.geodeticSurfaceNormal(p, n);
            Cartesian3.multiplyByScalar(n, height, n);
            Cartesian3.add(p, n, p);
            positions[i] = p.x;
            positions[i + 1] = p.y;
            positions[i + 2] = p.z;
        }
    }
    return geometry;
};
PolygonPipeline.eliminateHoles = function (outerRing, innerRings, ellipsoid) {
    if (!defined(outerRing)) {
        throw new DeveloperError('outerRing is required.');
    }
    if (outerRing.length === 0) {
        throw new DeveloperError('outerRing must not be empty.');
    }
    if (!defined(innerRings)) {
        throw new DeveloperError('innerRings is required.');
    }
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    var innerRingsCopy = [];
    for (var i = 0; i < innerRings.length; i++) {
        var innerRing = [];
        for (var j = 0; j < innerRings[i].length; j++) {
            innerRing.push(Cartesian3.clone(innerRings[i][j]));
        }
        innerRingsCopy.push(innerRing);
    }
    var newPolygonVertices = outerRing;
    while (innerRingsCopy.length > 0) {
        newPolygonVertices = eliminateHole(newPolygonVertices, innerRingsCopy, ellipsoid);
    }
    return newPolygonVertices;
};
module.exports = PolygonPipeline;
},{"./Cartesian2":101,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./EllipsoidTangentPlane":134,"./Geometry":145,"./GeometryAttribute":146,"./Math":174,"./PrimitiveType":193,"./Queue":199,"./WindingOrder":235,"./defaultValue":243,"./defined":245,"./pointInsideTriangle":268}],188:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), Color = require('./Color'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), GeometryType = require('./GeometryType'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PolylinePipeline = require('./PolylinePipeline'), PrimitiveType = require('./PrimitiveType'), VertexFormat = require('./VertexFormat');
'use strict';
var scratchInterpolateColorsArray = [];
function interpolateColors(p0, p1, color0, color1, numPoints) {
    var colors = scratchInterpolateColorsArray;
    colors.length = numPoints;
    var i;
    var r0 = color0.red;
    var g0 = color0.green;
    var b0 = color0.blue;
    var a0 = color0.alpha;
    var r1 = color1.red;
    var g1 = color1.green;
    var b1 = color1.blue;
    var a1 = color1.alpha;
    if (Color.equals(color0, color1)) {
        for (i = 0; i < numPoints; i++) {
            colors[i] = Color.clone(color0);
        }
        return colors;
    }
    var redPerVertex = (r1 - r0) / numPoints;
    var greenPerVertex = (g1 - g0) / numPoints;
    var bluePerVertex = (b1 - b0) / numPoints;
    var alphaPerVertex = (a1 - a0) / numPoints;
    for (i = 0; i < numPoints; i++) {
        colors[i] = new Color(r0 + i * redPerVertex, g0 + i * greenPerVertex, b0 + i * bluePerVertex, a0 + i * alphaPerVertex);
    }
    return colors;
}
var PolylineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var positions = options.positions;
    var colors = options.colors;
    var width = defaultValue(options.width, 1);
    var perVertex = defaultValue(options.colorsPerVertex, false);
    if (!defined(positions) || positions.length < 2) {
        throw new DeveloperError('At least two positions are required.');
    }
    if (width < 1) {
        throw new DeveloperError('width must be greater than or equal to one.');
    }
    if (defined(colors) && (perVertex && colors.length < positions.length || !perVertex && colors.length < positions.length - 1)) {
        throw new DeveloperError('colors has an invalid length.');
    }
    this._positions = positions;
    this._colors = colors;
    this._width = width;
    this._perVertex = perVertex;
    this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));
    this._followSurface = defaultValue(options.followSurface, true);
    this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
    this._workerName = 'createPolylineGeometry';
    var numComponents = 1 + positions.length * Cartesian3.packedLength;
    numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;
    this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;
};
PolylineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var positions = value._positions;
    var length = positions.length;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        Cartesian3.pack(positions[i], array, startingIndex);
    }
    var colors = value._colors;
    length = defined(colors) ? colors.length : 0;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {
        Color.pack(colors[i], array, startingIndex);
    }
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex++] = value._width;
    array[startingIndex++] = value._perVertex ? 1 : 0;
    array[startingIndex++] = value._followSurface ? 1 : 0;
    array[startingIndex] = value._granularity;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        positions: undefined,
        colors: undefined,
        ellipsoid: scratchEllipsoid,
        vertexFormat: scratchVertexFormat,
        width: undefined,
        perVertex: undefined,
        followSurface: undefined,
        granularity: undefined
    };
PolylineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var length = array[startingIndex++];
    var positions = new Array(length);
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    length = array[startingIndex++];
    var colors = length > 0 ? new Array(length) : undefined;
    for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {
        colors[i] = Color.unpack(array, startingIndex);
    }
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var width = array[startingIndex++];
    var perVertex = array[startingIndex++] === 1;
    var followSurface = array[startingIndex++] === 1;
    var granularity = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.positions = positions;
        scratchOptions.colors = colors;
        scratchOptions.width = width;
        scratchOptions.perVertex = perVertex;
        scratchOptions.followSurface = followSurface;
        scratchOptions.granularity = granularity;
        return new PolylineGeometry(scratchOptions);
    }
    result._positions = positions;
    result._colors = colors;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._width = width;
    result._perVertex = perVertex;
    result._followSurface = followSurface;
    result._granularity = granularity;
    return result;
};
var scratchCartesian3 = new Cartesian3();
var scratchPosition = new Cartesian3();
var scratchPrevPosition = new Cartesian3();
var scratchNextPosition = new Cartesian3();
PolylineGeometry.createGeometry = function (polylineGeometry) {
    var width = polylineGeometry._width;
    var vertexFormat = polylineGeometry._vertexFormat;
    var colors = polylineGeometry._colors;
    var perVertex = polylineGeometry._perVertex;
    var followSurface = polylineGeometry._followSurface;
    var granularity = polylineGeometry._granularity;
    var ellipsoid = polylineGeometry._ellipsoid;
    var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
    var i;
    var j;
    var k;
    var positions = PolylinePipeline.removeDuplicates(polylineGeometry._positions);
    if (!defined(positions)) {
        positions = polylineGeometry._positions;
    }
    var positionsLength = positions.length;
    if (positionsLength < 2) {
        return undefined;
    }
    if (followSurface) {
        var heights = PolylinePipeline.extractHeights(positions, ellipsoid);
        if (defined(colors)) {
            var colorLength = 1;
            for (i = 0; i < positionsLength - 1; ++i) {
                colorLength += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance);
            }
            var newColors = new Array(colorLength);
            var newColorIndex = 0;
            for (i = 0; i < positionsLength - 1; ++i) {
                var p0 = positions[i];
                var p1 = positions[i + 1];
                var c0 = colors[i];
                var numColors = PolylinePipeline.numberOfPoints(p0, p1, minDistance);
                if (perVertex && i < colorLength) {
                    var c1 = colors[i + 1];
                    var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);
                    var interpolatedColorsLength = interpolatedColors.length;
                    for (j = 0; j < interpolatedColorsLength; ++j) {
                        newColors[newColorIndex++] = interpolatedColors[j];
                    }
                } else {
                    for (j = 0; j < numColors; ++j) {
                        newColors[newColorIndex++] = Color.clone(c0);
                    }
                }
            }
            newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);
            colors = newColors;
            scratchInterpolateColorsArray.length = 0;
        }
        positions = PolylinePipeline.generateCartesianArc({
            positions: positions,
            minDistance: minDistance,
            ellipsoid: ellipsoid,
            height: heights
        });
    }
    positionsLength = positions.length;
    var size = positionsLength * 4 - 4;
    var finalPositions = new Float64Array(size * 3);
    var prevPositions = new Float64Array(size * 3);
    var nextPositions = new Float64Array(size * 3);
    var expandAndWidth = new Float32Array(size * 2);
    var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;
    var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;
    var positionIndex = 0;
    var expandAndWidthIndex = 0;
    var stIndex = 0;
    var colorIndex = 0;
    var segmentLength;
    var segmentIndex = 0;
    var count = 0;
    var position;
    for (j = 0; j < positionsLength; ++j) {
        if (j === 0) {
            position = scratchCartesian3;
            Cartesian3.subtract(positions[0], positions[1], position);
            Cartesian3.add(positions[0], position, position);
        } else {
            position = positions[j - 1];
        }
        Cartesian3.clone(position, scratchPrevPosition);
        Cartesian3.clone(positions[j], scratchPosition);
        if (j === positionsLength - 1) {
            position = scratchCartesian3;
            Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);
            Cartesian3.add(positions[positionsLength - 1], position, position);
        } else {
            position = positions[j + 1];
        }
        Cartesian3.clone(position, scratchNextPosition);
        var color0, color1;
        if (defined(finalColors)) {
            if (j !== 0 && !perVertex) {
                color0 = colors[j - 1];
            } else {
                color0 = colors[j];
            }
            if (j !== positionsLength - 1) {
                color1 = colors[j];
            }
        }
        var startK = j === 0 ? 2 : 0;
        var endK = j === positionsLength - 1 ? 2 : 4;
        for (k = startK; k < endK; ++k) {
            Cartesian3.pack(scratchPosition, finalPositions, positionIndex);
            Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);
            Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);
            positionIndex += 3;
            var direction = k - 2 < 0 ? -1 : 1;
            expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1;
            expandAndWidth[expandAndWidthIndex++] = direction * width;
            if (vertexFormat.st) {
                st[stIndex++] = j / (positionsLength - 1);
                st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0);
            }
            if (defined(finalColors)) {
                var color = k < 2 ? color0 : color1;
                finalColors[colorIndex++] = Color.floatToByte(color.red);
                finalColors[colorIndex++] = Color.floatToByte(color.green);
                finalColors[colorIndex++] = Color.floatToByte(color.blue);
                finalColors[colorIndex++] = Color.floatToByte(color.alpha);
            }
        }
    }
    var attributes = new GeometryAttributes();
    attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: finalPositions
    });
    attributes.prevPosition = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: prevPositions
    });
    attributes.nextPosition = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: nextPositions
    });
    attributes.expandAndWidth = new GeometryAttribute({
        componentDatatype: ComponentDatatype.FLOAT,
        componentsPerAttribute: 2,
        values: expandAndWidth
    });
    if (vertexFormat.st) {
        attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: st
        });
    }
    if (defined(finalColors)) {
        attributes.color = new GeometryAttribute({
            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,
            componentsPerAttribute: 4,
            values: finalColors,
            normalize: true
        });
    }
    var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);
    var index = 0;
    var indicesIndex = 0;
    var length = positionsLength - 1;
    for (j = 0; j < length; ++j) {
        indices[indicesIndex++] = index;
        indices[indicesIndex++] = index + 2;
        indices[indicesIndex++] = index + 1;
        indices[indicesIndex++] = index + 1;
        indices[indicesIndex++] = index + 2;
        indices[indicesIndex++] = index + 3;
        index += 4;
    }
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingSphere: BoundingSphere.fromPoints(positions),
        geometryType: GeometryType.POLYLINES
    });
};
module.exports = PolylineGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./Color":111,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./GeometryType":151,"./IndexDatatype":162,"./Math":174,"./PolylinePipeline":189,"./PrimitiveType":193,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],189:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), EllipsoidGeodesic = require('./EllipsoidGeodesic'), IntersectionTests = require('./IntersectionTests'), isArray = require('./isArray'), CesiumMath = require('./Math'), Matrix4 = require('./Matrix4'), Plane = require('./Plane');
'use strict';
var PolylinePipeline = {};
PolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {
    var distance = Cartesian3.distance(p0, p1);
    return Math.ceil(distance / minDistance);
};
var cartoScratch = new Cartographic();
PolylinePipeline.extractHeights = function (positions, ellipsoid) {
    var length = positions.length;
    var heights = new Array(length);
    for (var i = 0; i < length; i++) {
        var p = positions[i];
        heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;
    }
    return heights;
};
var wrapLongitudeInversMatrix = new Matrix4();
var wrapLongitudeOrigin = new Cartesian3();
var wrapLongitudeXZNormal = new Cartesian3();
var wrapLongitudeXZPlane = new Plane(Cartesian3.ZERO, 0);
var wrapLongitudeYZNormal = new Cartesian3();
var wrapLongitudeYZPlane = new Plane(Cartesian3.ZERO, 0);
var wrapLongitudeIntersection = new Cartesian3();
var wrapLongitudeOffset = new Cartesian3();
var subdivideHeightsScratchArray = [];
function subdivideHeights(numPoints, h0, h1) {
    var heights = subdivideHeightsScratchArray;
    heights.length = numPoints;
    var i;
    if (h0 === h1) {
        for (i = 0; i < numPoints; i++) {
            heights[i] = h0;
        }
        return heights;
    }
    var dHeight = h1 - h0;
    var heightPerVertex = dHeight / numPoints;
    for (i = 0; i < numPoints; i++) {
        var h = h0 + i * heightPerVertex;
        heights[i] = h;
    }
    return heights;
}
var carto1 = new Cartographic();
var carto2 = new Cartographic();
var cartesian = new Cartesian3();
var scaleFirst = new Cartesian3();
var scaleLast = new Cartesian3();
var ellipsoidGeodesic = new EllipsoidGeodesic();
function generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {
    var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);
    var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);
    var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);
    var start = ellipsoid.cartesianToCartographic(first, carto1);
    var end = ellipsoid.cartesianToCartographic(last, carto2);
    var heights = subdivideHeights(numPoints, h0, h1);
    ellipsoidGeodesic.setEndPoints(start, end);
    var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;
    var index = offset;
    start.height = h0;
    var cart = ellipsoid.cartographicToCartesian(start, cartesian);
    Cartesian3.pack(cart, array, index);
    index += 3;
    for (var i = 1; i < numPoints; i++) {
        var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);
        carto.height = heights[i];
        cart = ellipsoid.cartographicToCartesian(carto, cartesian);
        Cartesian3.pack(cart, array, index);
        index += 3;
    }
    return index;
}
PolylinePipeline.wrapLongitude = function (positions, modelMatrix) {
    var cartesians = [];
    var segments = [];
    if (defined(positions) && positions.length > 0) {
        modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);
        var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);
        var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);
        var xzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal);
        var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);
        var yzNormal = Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal);
        var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);
        var count = 1;
        cartesians.push(Cartesian3.clone(positions[0]));
        var prev = cartesians[0];
        var length = positions.length;
        for (var i = 1; i < length; ++i) {
            var cur = positions[i];
            if (Plane.getPointDistance(yzPlane, prev) < 0 || Plane.getPointDistance(yzPlane, cur) < 0) {
                var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);
                if (defined(intersection)) {
                    var offset = Cartesian3.multiplyByScalar(xzNormal, 5e-9, wrapLongitudeOffset);
                    if (Plane.getPointDistance(xzPlane, prev) < 0) {
                        Cartesian3.negate(offset, offset);
                    }
                    cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));
                    segments.push(count + 1);
                    Cartesian3.negate(offset, offset);
                    cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));
                    count = 1;
                }
            }
            cartesians.push(Cartesian3.clone(positions[i]));
            count++;
            prev = cur;
        }
        segments.push(count);
    }
    return {
        positions: cartesians,
        lengths: segments
    };
};
var removeDuplicatesEpsilon = CesiumMath.EPSILON7;
PolylinePipeline.removeDuplicates = function (positions) {
    if (!defined(positions)) {
        throw new DeveloperError('positions is required.');
    }
    var length = positions.length;
    if (length < 2) {
        return undefined;
    }
    var i;
    var v0;
    var v1;
    for (i = 1; i < length; ++i) {
        v0 = positions[i - 1];
        v1 = positions[i];
        if (Cartesian3.equalsEpsilon(v0, v1, removeDuplicatesEpsilon)) {
            break;
        }
    }
    if (i === length) {
        return undefined;
    }
    var cleanedPositions = positions.slice(0, i);
    for (; i < length; ++i) {
        v0 = positions[i - 1];
        v1 = positions[i];
        if (!Cartesian3.equalsEpsilon(v0, v1, removeDuplicatesEpsilon)) {
            cleanedPositions.push(Cartesian3.clone(v1));
        }
    }
    return cleanedPositions;
};
PolylinePipeline.generateArc = function (options) {
    if (!defined(options)) {
        options = {};
    }
    var positions = options.positions;
    if (!defined(positions)) {
        throw new DeveloperError('options.positions is required.');
    }
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var height = defaultValue(options.height, 0);
    var minDistance = options.minDistance;
    if (!defined(minDistance)) {
        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
    }
    var length = positions.length;
    var numPoints = 0;
    var i;
    for (i = 0; i < length - 1; i++) {
        numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance);
    }
    var arrayLength = (numPoints + 1) * 3;
    var newPositions = new Array(arrayLength);
    var offset = 0;
    var hasHeightArray = isArray(height);
    for (i = 0; i < length - 1; i++) {
        var p0 = positions[i];
        var p1 = positions[i + 1];
        var h0 = hasHeightArray ? height[i] : height;
        var h1 = hasHeightArray ? height[i + 1] : height;
        offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);
    }
    subdivideHeightsScratchArray.length = 0;
    var lastPoint = positions[length - 1];
    var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);
    carto.height = hasHeightArray ? height[length - 1] : height;
    var cart = ellipsoid.cartographicToCartesian(carto, cartesian);
    Cartesian3.pack(cart, newPositions, arrayLength - 3);
    return newPositions;
};
PolylinePipeline.generateCartesianArc = function (options) {
    var numberArray = PolylinePipeline.generateArc(options);
    var size = numberArray.length / 3;
    var newPositions = new Array(size);
    for (var i = 0; i < size; i++) {
        newPositions[i] = Cartesian3.unpack(numberArray, i * 3);
    }
    return newPositions;
};
module.exports = PolylinePipeline;
},{"./Cartesian3":102,"./Cartographic":104,"./DeveloperError":123,"./Ellipsoid":130,"./EllipsoidGeodesic":131,"./IntersectionTests":164,"./Math":174,"./Matrix4":177,"./Plane":182,"./defaultValue":243,"./defined":245,"./isArray":253}],190:[function(require,module,exports){
var BoundingRectangle = require('./BoundingRectangle'), BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), CornerType = require('./CornerType'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), GeometryPipeline = require('./GeometryPipeline'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PolygonPipeline = require('./PolygonPipeline'), PolylineVolumeGeometryLibrary = require('./PolylineVolumeGeometryLibrary'), PrimitiveType = require('./PrimitiveType'), VertexFormat = require('./VertexFormat'), WindingOrder = require('./WindingOrder');
'use strict';
function computeAttributes(combinedPositions, shape, boundingRectangle, vertexFormat) {
    var attributes = new GeometryAttributes();
    if (vertexFormat.position) {
        attributes.position = new GeometryAttribute({
            componentDatatype: ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: combinedPositions
        });
    }
    var shapeLength = shape.length;
    var vertexCount = combinedPositions.length / 3;
    var length = (vertexCount - shapeLength * 2) / (shapeLength * 2);
    var firstEndIndices = PolygonPipeline.triangulate(shape);
    var indicesCount = (length - 1) * shapeLength * 6 + firstEndIndices.length * 2;
    var indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);
    var i, j;
    var ll, ul, ur, lr;
    var offset = shapeLength * 2;
    var index = 0;
    for (i = 0; i < length - 1; i++) {
        for (j = 0; j < shapeLength - 1; j++) {
            ll = j * 2 + i * shapeLength * 2;
            lr = ll + offset;
            ul = ll + 1;
            ur = ul + offset;
            indices[index++] = ul;
            indices[index++] = ll;
            indices[index++] = ur;
            indices[index++] = ur;
            indices[index++] = ll;
            indices[index++] = lr;
        }
        ll = shapeLength * 2 - 2 + i * shapeLength * 2;
        ul = ll + 1;
        ur = ul + offset;
        lr = ll + offset;
        indices[index++] = ul;
        indices[index++] = ll;
        indices[index++] = ur;
        indices[index++] = ur;
        indices[index++] = ll;
        indices[index++] = lr;
    }
    if (vertexFormat.st || vertexFormat.tangent || vertexFormat.binormal) {
        var st = new Float32Array(vertexCount * 2);
        var lengthSt = 1 / (length - 1);
        var heightSt = 1 / boundingRectangle.height;
        var heightOffset = boundingRectangle.height / 2;
        var s, t;
        var stindex = 0;
        for (i = 0; i < length; i++) {
            s = i * lengthSt;
            t = heightSt * (shape[0].y + heightOffset);
            st[stindex++] = s;
            st[stindex++] = t;
            for (j = 1; j < shapeLength; j++) {
                t = heightSt * (shape[j].y + heightOffset);
                st[stindex++] = s;
                st[stindex++] = t;
                st[stindex++] = s;
                st[stindex++] = t;
            }
            t = heightSt * (shape[0].y + heightOffset);
            st[stindex++] = s;
            st[stindex++] = t;
        }
        for (j = 0; j < shapeLength; j++) {
            s = 0;
            t = heightSt * (shape[j].y + heightOffset);
            st[stindex++] = s;
            st[stindex++] = t;
        }
        for (j = 0; j < shapeLength; j++) {
            s = (length - 1) * lengthSt;
            t = heightSt * (shape[j].y + heightOffset);
            st[stindex++] = s;
            st[stindex++] = t;
        }
        attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: new Float32Array(st)
        });
    }
    var endOffset = vertexCount - shapeLength * 2;
    for (i = 0; i < firstEndIndices.length; i += 3) {
        var v0 = firstEndIndices[i] + endOffset;
        var v1 = firstEndIndices[i + 1] + endOffset;
        var v2 = firstEndIndices[i + 2] + endOffset;
        indices[index++] = v0;
        indices[index++] = v1;
        indices[index++] = v2;
        indices[index++] = v2 + shapeLength;
        indices[index++] = v1 + shapeLength;
        indices[index++] = v0 + shapeLength;
    }
    var geometry = new Geometry({
            attributes: attributes,
            indices: indices,
            boundingSphere: BoundingSphere.fromVertices(combinedPositions),
            primitiveType: PrimitiveType.TRIANGLES
        });
    if (vertexFormat.normal) {
        geometry = GeometryPipeline.computeNormal(geometry);
    }
    if (vertexFormat.tangent || vertexFormat.binormal) {
        geometry = GeometryPipeline.computeBinormalAndTangent(geometry);
        if (!vertexFormat.tangent) {
            geometry.attributes.tangent = undefined;
        }
        if (!vertexFormat.binormal) {
            geometry.attributes.binormal = undefined;
        }
        if (!vertexFormat.st) {
            geometry.attributes.st = undefined;
        }
    }
    return geometry;
}
var PolylineVolumeGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var positions = options.polylinePositions;
    var shape = options.shapePositions;
    if (!defined(positions)) {
        throw new DeveloperError('options.polylinePositions is required.');
    }
    if (!defined(shape)) {
        throw new DeveloperError('options.shapePositions is required.');
    }
    this._positions = positions;
    this._shape = shape;
    this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
    this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);
    this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));
    this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    this._workerName = 'createPolylineVolumeGeometry';
    var numComponents = 1 + positions.length * Cartesian3.packedLength;
    numComponents += 1 + shape.length * Cartesian2.packedLength;
    this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;
};
PolylineVolumeGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var positions = value._positions;
    var length = positions.length;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        Cartesian3.pack(positions[i], array, startingIndex);
    }
    var shape = value._shape;
    length = shape.length;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {
        Cartesian2.pack(shape[i], array, startingIndex);
    }
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex++] = value._cornerType;
    array[startingIndex] = value._granularity;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        polylinePositions: undefined,
        shapePositions: undefined,
        ellipsoid: scratchEllipsoid,
        vertexFormat: scratchVertexFormat,
        cornerType: undefined,
        granularity: undefined
    };
PolylineVolumeGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var length = array[startingIndex++];
    var positions = new Array(length);
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    length = array[startingIndex++];
    var shape = new Array(length);
    for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {
        shape[i] = Cartesian2.unpack(array, startingIndex);
    }
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var cornerType = array[startingIndex++];
    var granularity = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.polylinePositions = positions;
        scratchOptions.shapePositions = shape;
        scratchOptions.cornerType = cornerType;
        scratchOptions.granularity = granularity;
        return new PolylineVolumeGeometry(scratchOptions);
    }
    result._positions = positions;
    result._shape = shape;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._cornerType = cornerType;
    result._granularity = granularity;
    return result;
};
var brScratch = new BoundingRectangle();
PolylineVolumeGeometry.createGeometry = function (polylineVolumeGeometry) {
    var positions = polylineVolumeGeometry._positions;
    var cleanPositions = PolylineVolumeGeometryLibrary.removeDuplicatesFromPositions(positions, polylineVolumeGeometry._ellipsoid);
    var shape2D = polylineVolumeGeometry._shape;
    shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);
    if (cleanPositions.length < 2 || shape2D.length < 3) {
        return undefined;
    }
    if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {
        shape2D.reverse();
    }
    var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);
    var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeGeometry, true);
    return computeAttributes(computedPositions, shape2D, boundingRectangle, polylineVolumeGeometry._vertexFormat);
};
module.exports = PolylineVolumeGeometry;
},{"./BoundingRectangle":97,"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./ComponentDatatype":113,"./CornerType":114,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./GeometryPipeline":150,"./IndexDatatype":162,"./Math":174,"./PolygonPipeline":187,"./PolylineVolumeGeometryLibrary":191,"./PrimitiveType":193,"./VertexFormat":228,"./WindingOrder":235,"./defaultValue":243,"./defined":245}],191:[function(require,module,exports){
var Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), Cartesian4 = require('./Cartesian4'), Cartographic = require('./Cartographic'), CornerType = require('./CornerType'), EllipsoidTangentPlane = require('./EllipsoidTangentPlane'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), Matrix4 = require('./Matrix4'), PolylinePipeline = require('./PolylinePipeline'), Quaternion = require('./Quaternion'), Transforms = require('./Transforms');
'use strict';
var scratch2Array = [
        new Cartesian3(),
        new Cartesian3()
    ];
var scratchCartesian1 = new Cartesian3();
var scratchCartesian2 = new Cartesian3();
var scratchCartesian3 = new Cartesian3();
var scratchCartesian4 = new Cartesian3();
var scratchCartesian5 = new Cartesian3();
var scratchCartesian6 = new Cartesian3();
var scratchCartesian7 = new Cartesian3();
var scratchCartesian8 = new Cartesian3();
var scratchCartesian9 = new Cartesian3();
var scratch1 = new Cartesian3();
var scratch2 = new Cartesian3();
var PolylineVolumeGeometryLibrary = {};
var cartographic = new Cartographic();
function scaleToSurface(positions, ellipsoid) {
    var heights = new Array(positions.length);
    for (var i = 0; i < positions.length; i++) {
        var pos = positions[i];
        cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);
        heights[i] = cartographic.height;
        positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);
    }
    return heights;
}
function subdivideHeights(points, h0, h1, granularity) {
    var p0 = points[0];
    var p1 = points[1];
    var angleBetween = Cartesian3.angleBetween(p0, p1);
    var numPoints = Math.ceil(angleBetween / granularity);
    var heights = new Array(numPoints);
    var i;
    if (h0 === h1) {
        for (i = 0; i < numPoints; i++) {
            heights[i] = h0;
        }
        heights.push(h1);
        return heights;
    }
    var dHeight = h1 - h0;
    var heightPerVertex = dHeight / numPoints;
    for (i = 1; i < numPoints; i++) {
        var h = h0 + i * heightPerVertex;
        heights[i] = h;
    }
    heights[0] = h0;
    heights.push(h1);
    return heights;
}
function computeRotationAngle(start, end, position, ellipsoid) {
    var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);
    var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);
    var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);
    var angle = Cartesian2.angleBetween(next, prev);
    return prev.x * next.y - prev.y * next.x >= 0 ? -angle : angle;
}
var negativeX = new Cartesian3(-1, 0, 0);
var transform = new Matrix4();
var translation = new Matrix4();
var rotationZ = new Matrix3();
var scaleMatrix = Matrix3.IDENTITY.clone();
var westScratch = new Cartesian3();
var finalPosScratch = new Cartesian4();
var heightCartesian = new Cartesian3();
function addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {
    var west = westScratch;
    var finalPosition = finalPosScratch;
    transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);
    west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);
    west = Cartesian3.normalize(west, west);
    var angle = computeRotationAngle(west, left, center, ellipsoid);
    rotationZ = Matrix3.fromRotationZ(angle, rotationZ);
    heightCartesian.z = height;
    transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);
    var scale = scaleMatrix;
    scale[0] = xScalar;
    for (var j = 0; j < repeat; j++) {
        for (var i = 0; i < shape.length; i += 3) {
            finalPosition = Cartesian3.fromArray(shape, i, finalPosition);
            finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);
            finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);
            finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);
        }
    }
    return finalPositions;
}
var centerScratch = new Cartesian3();
function addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {
    for (var i = 0; i < centers.length; i += 3) {
        var center = Cartesian3.fromArray(centers, i, centerScratch);
        finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);
    }
    return finalPositions;
}
function convertShapeTo3DDuplicate(shape2D, boundingRectangle) {
    var length = shape2D.length;
    var shape = new Array(length * 6);
    var index = 0;
    var xOffset = boundingRectangle.x + boundingRectangle.width / 2;
    var yOffset = boundingRectangle.y + boundingRectangle.height / 2;
    var point = shape2D[0];
    shape[index++] = point.x - xOffset;
    shape[index++] = 0;
    shape[index++] = point.y - yOffset;
    for (var i = 1; i < length; i++) {
        point = shape2D[i];
        var x = point.x - xOffset;
        var z = point.y - yOffset;
        shape[index++] = x;
        shape[index++] = 0;
        shape[index++] = z;
        shape[index++] = x;
        shape[index++] = 0;
        shape[index++] = z;
    }
    point = shape2D[0];
    shape[index++] = point.x - xOffset;
    shape[index++] = 0;
    shape[index++] = point.y - yOffset;
    return shape;
}
function convertShapeTo3D(shape2D, boundingRectangle) {
    var length = shape2D.length;
    var shape = new Array(length * 3);
    var index = 0;
    var xOffset = boundingRectangle.x + boundingRectangle.width / 2;
    var yOffset = boundingRectangle.y + boundingRectangle.height / 2;
    for (var i = 0; i < length; i++) {
        shape[index++] = shape2D[i].x - xOffset;
        shape[index++] = 0;
        shape[index++] = shape2D[i].y - yOffset;
    }
    return shape;
}
var quaterion = new Quaternion();
var startPointScratch = new Cartesian3();
var rotMatrix = new Matrix3();
function computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {
    var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));
    var granularity = cornerType === CornerType.BEVELED ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));
    var m;
    if (leftIsOutside) {
        m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);
    } else {
        m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);
    }
    var left;
    var surfacePoint;
    startPoint = Cartesian3.clone(startPoint, startPointScratch);
    if (granularity > 0) {
        var repeat = duplicatePoints ? 2 : 1;
        for (var i = 0; i < granularity; i++) {
            startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);
            left = Cartesian3.subtract(startPoint, pivot, scratch1);
            left = Cartesian3.normalize(left, left);
            if (!leftIsOutside) {
                left = Cartesian3.negate(left, left);
            }
            surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);
            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);
        }
    } else {
        left = Cartesian3.subtract(startPoint, pivot, scratch1);
        left = Cartesian3.normalize(left, left);
        if (!leftIsOutside) {
            left = Cartesian3.negate(left, left);
        }
        surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);
        finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);
        endPoint = Cartesian3.clone(endPoint, startPointScratch);
        left = Cartesian3.subtract(endPoint, pivot, scratch1);
        left = Cartesian3.normalize(left, left);
        if (!leftIsOutside) {
            left = Cartesian3.negate(left, left);
        }
        surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);
        finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);
    }
    return finalPositions;
}
PolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function (shapePositions) {
    var length = shapePositions.length;
    var cleanedPositions = [];
    for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
        var v0 = shapePositions[i0];
        var v1 = shapePositions[i1];
        if (!Cartesian2.equals(v0, v1)) {
            cleanedPositions.push(v1);
        }
    }
    return cleanedPositions;
};
var nextScratch = new Cartesian3();
var prevScratch = new Cartesian3();
PolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function (forward, backward, position, ellipsoid) {
    var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);
    var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);
    var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);
    return prev.x * next.y - prev.y * next.x >= 0;
};
function latLonEquals(c0, c1) {
    return CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON6) && CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON6);
}
var carto0 = new Cartographic();
var carto1 = new Cartographic();
PolylineVolumeGeometryLibrary.removeDuplicatesFromPositions = function (positions, ellipsoid) {
    var length = positions.length;
    if (length < 2) {
        return positions.slice(0);
    }
    var cleanedPositions = [];
    cleanedPositions.push(positions[0]);
    for (var i = 1; i < length; ++i) {
        var v0 = positions[i - 1];
        var v1 = positions[i];
        var c0 = ellipsoid.cartesianToCartographic(v0, carto0);
        var c1 = ellipsoid.cartesianToCartographic(v1, carto1);
        if (!latLonEquals(c0, c1)) {
            cleanedPositions.push(v1);
        }
    }
    return cleanedPositions;
};
PolylineVolumeGeometryLibrary.computePositions = function (positions, shape2D, boundingRectangle, geometry, duplicatePoints) {
    var ellipsoid = geometry._ellipsoid;
    var heights = scaleToSurface(positions, ellipsoid);
    var granularity = geometry._granularity;
    var cornerType = geometry._cornerType;
    var shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);
    var shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;
    var heightOffset = boundingRectangle.height / 2;
    var width = boundingRectangle.width / 2;
    var length = positions.length;
    var finalPositions = [];
    var ends = duplicatePoints ? [] : undefined;
    var forward = scratchCartesian1;
    var backward = scratchCartesian2;
    var cornerDirection = scratchCartesian3;
    var surfaceNormal = scratchCartesian4;
    var pivot = scratchCartesian5;
    var start = scratchCartesian6;
    var end = scratchCartesian7;
    var left = scratchCartesian8;
    var previousPosition = scratchCartesian9;
    var position = positions[0];
    var nextPosition = positions[1];
    surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);
    forward = Cartesian3.subtract(nextPosition, position, forward);
    forward = Cartesian3.normalize(forward, forward);
    left = Cartesian3.cross(surfaceNormal, forward, left);
    left = Cartesian3.normalize(left, left);
    var h0 = heights[0];
    var h1 = heights[1];
    if (duplicatePoints) {
        ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);
    }
    previousPosition = Cartesian3.clone(position, previousPosition);
    position = nextPosition;
    backward = Cartesian3.negate(forward, backward);
    var subdividedHeights;
    var subdividedPositions;
    for (var i = 1; i < length - 1; i++) {
        var repeat = duplicatePoints ? 2 : 1;
        nextPosition = positions[i + 1];
        forward = Cartesian3.subtract(nextPosition, position, forward);
        forward = Cartesian3.normalize(forward, forward);
        cornerDirection = Cartesian3.add(forward, backward, cornerDirection);
        cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);
        surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);
        var doCorner = !Cartesian3.equalsEpsilon(Cartesian3.negate(cornerDirection, scratch1), surfaceNormal, CesiumMath.EPSILON2);
        if (doCorner) {
            cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);
            cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);
            cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);
            var scalar = 1 / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));
            var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);
            if (leftIsOutside) {
                pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);
                start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);
                scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);
                scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);
                subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);
                subdividedPositions = PolylinePipeline.generateArc({
                    positions: scratch2Array,
                    granularity: granularity,
                    ellipsoid: ellipsoid
                });
                finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);
                left = Cartesian3.cross(surfaceNormal, forward, left);
                left = Cartesian3.normalize(left, left);
                end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);
                if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {
                    computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);
                } else {
                    cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);
                    finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);
                }
                previousPosition = Cartesian3.clone(end, previousPosition);
            } else {
                pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);
                start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);
                scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);
                scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);
                subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);
                subdividedPositions = PolylinePipeline.generateArc({
                    positions: scratch2Array,
                    granularity: granularity,
                    ellipsoid: ellipsoid
                });
                finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);
                left = Cartesian3.cross(surfaceNormal, forward, left);
                left = Cartesian3.normalize(left, left);
                end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);
                if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {
                    computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);
                } else {
                    finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);
                }
                previousPosition = Cartesian3.clone(end, previousPosition);
            }
            backward = Cartesian3.negate(forward, backward);
        } else {
            finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);
            previousPosition = position;
        }
        h0 = h1;
        h1 = heights[i + 1];
        position = nextPosition;
    }
    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);
    scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);
    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);
    subdividedPositions = PolylinePipeline.generateArc({
        positions: scratch2Array,
        granularity: granularity,
        ellipsoid: ellipsoid
    });
    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);
    if (duplicatePoints) {
        ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);
    }
    length = finalPositions.length;
    var posLength = duplicatePoints ? length + ends.length : length;
    var combinedPositions = new Float64Array(posLength);
    combinedPositions.set(finalPositions);
    if (duplicatePoints) {
        combinedPositions.set(ends, length);
    }
    return combinedPositions;
};
module.exports = PolylineVolumeGeometryLibrary;
},{"./Cartesian2":101,"./Cartesian3":102,"./Cartesian4":103,"./Cartographic":104,"./CornerType":114,"./EllipsoidTangentPlane":134,"./Math":174,"./Matrix3":176,"./Matrix4":177,"./PolylinePipeline":189,"./Quaternion":197,"./Transforms":226}],192:[function(require,module,exports){
var BoundingRectangle = require('./BoundingRectangle'), BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), CornerType = require('./CornerType'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PolygonPipeline = require('./PolygonPipeline'), PolylineVolumeGeometryLibrary = require('./PolylineVolumeGeometryLibrary'), PrimitiveType = require('./PrimitiveType'), WindingOrder = require('./WindingOrder');
'use strict';
function computeAttributes(positions, shape) {
    var attributes = new GeometryAttributes();
    attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: positions
    });
    var shapeLength = shape.length;
    var vertexCount = attributes.position.values.length / 3;
    var positionLength = positions.length / 3;
    var shapeCount = positionLength / shapeLength;
    var indices = IndexDatatype.createTypedArray(vertexCount, 2 * shapeLength * (shapeCount + 1));
    var i, j;
    var index = 0;
    i = 0;
    var offset = i * shapeLength;
    for (j = 0; j < shapeLength - 1; j++) {
        indices[index++] = j + offset;
        indices[index++] = j + offset + 1;
    }
    indices[index++] = shapeLength - 1 + offset;
    indices[index++] = offset;
    i = shapeCount - 1;
    offset = i * shapeLength;
    for (j = 0; j < shapeLength - 1; j++) {
        indices[index++] = j + offset;
        indices[index++] = j + offset + 1;
    }
    indices[index++] = shapeLength - 1 + offset;
    indices[index++] = offset;
    for (i = 0; i < shapeCount - 1; i++) {
        var firstOffset = shapeLength * i;
        var secondOffset = firstOffset + shapeLength;
        for (j = 0; j < shapeLength; j++) {
            indices[index++] = j + firstOffset;
            indices[index++] = j + secondOffset;
        }
    }
    var geometry = new Geometry({
            attributes: attributes,
            indices: IndexDatatype.createTypedArray(vertexCount, indices),
            boundingSphere: BoundingSphere.fromVertices(positions),
            primitiveType: PrimitiveType.LINES
        });
    return geometry;
}
var PolylineVolumeOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var positions = options.polylinePositions;
    var shape = options.shapePositions;
    if (!defined(positions)) {
        throw new DeveloperError('options.polylinePositions is required.');
    }
    if (!defined(shape)) {
        throw new DeveloperError('options.shapePositions is required.');
    }
    this._positions = positions;
    this._shape = shape;
    this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
    this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);
    this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    this._workerName = 'createPolylineVolumeOutlineGeometry';
    var numComponents = 1 + positions.length * Cartesian3.packedLength;
    numComponents += 1 + shape.length * Cartesian2.packedLength;
    this.packedLength = numComponents + Ellipsoid.packedLength + 2;
};
PolylineVolumeOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var positions = value._positions;
    var length = positions.length;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        Cartesian3.pack(positions[i], array, startingIndex);
    }
    var shape = value._shape;
    length = shape.length;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {
        Cartesian2.pack(shape[i], array, startingIndex);
    }
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    array[startingIndex++] = value._cornerType;
    array[startingIndex] = value._granularity;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchOptions = {
        polylinePositions: undefined,
        shapePositions: undefined,
        ellipsoid: scratchEllipsoid,
        height: undefined,
        cornerType: undefined,
        granularity: undefined
    };
PolylineVolumeOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var length = array[startingIndex++];
    var positions = new Array(length);
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    length = array[startingIndex++];
    var shape = new Array(length);
    for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {
        shape[i] = Cartesian2.unpack(array, startingIndex);
    }
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var cornerType = array[startingIndex++];
    var granularity = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.polylinePositions = positions;
        scratchOptions.shapePositions = shape;
        scratchOptions.cornerType = cornerType;
        scratchOptions.granularity = granularity;
        return new PolylineVolumeOutlineGeometry(scratchOptions);
    }
    result._positions = positions;
    result._shape = shape;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._cornerType = cornerType;
    result._granularity = granularity;
    return result;
};
var brScratch = new BoundingRectangle();
PolylineVolumeOutlineGeometry.createGeometry = function (polylineVolumeOutlineGeometry) {
    var positions = polylineVolumeOutlineGeometry._positions;
    var cleanPositions = PolylineVolumeGeometryLibrary.removeDuplicatesFromPositions(positions, polylineVolumeOutlineGeometry._ellipsoid);
    var shape2D = polylineVolumeOutlineGeometry._shape;
    shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);
    if (cleanPositions.length < 2 || shape2D.length < 3) {
        return undefined;
    }
    if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {
        shape2D.reverse();
    }
    var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);
    var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeOutlineGeometry, false);
    return computeAttributes(computedPositions, shape2D);
};
module.exports = PolylineVolumeOutlineGeometry;
},{"./BoundingRectangle":97,"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./ComponentDatatype":113,"./CornerType":114,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PolygonPipeline":187,"./PolylineVolumeGeometryLibrary":191,"./PrimitiveType":193,"./WindingOrder":235,"./defaultValue":243,"./defined":245}],193:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var PrimitiveType = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        validate: function (primitiveType) {
            return primitiveType === PrimitiveType.POINTS || primitiveType === PrimitiveType.LINES || primitiveType === PrimitiveType.LINE_LOOP || primitiveType === PrimitiveType.LINE_STRIP || primitiveType === PrimitiveType.TRIANGLES || primitiveType === PrimitiveType.TRIANGLE_STRIP || primitiveType === PrimitiveType.TRIANGLE_FAN;
        }
    };
module.exports = freezeObject(PrimitiveType);
},{"./freezeObject":249}],194:[function(require,module,exports){
var DeveloperError = require('./DeveloperError'), CesiumMath = require('./Math');
'use strict';
var QuadraticRealPolynomial = {};
QuadraticRealPolynomial.computeDiscriminant = function (a, b, c) {
    if (typeof a !== 'number') {
        throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
        throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
        throw new DeveloperError('c is a required number.');
    }
    var discriminant = b * b - 4 * a * c;
    return discriminant;
};
function addWithCancellationCheck(left, right, tolerance) {
    var difference = left + right;
    if (CesiumMath.sign(left) !== CesiumMath.sign(right) && Math.abs(difference / Math.max(Math.abs(left), Math.abs(right))) < tolerance) {
        return 0;
    }
    return difference;
}
QuadraticRealPolynomial.computeRealRoots = function (a, b, c) {
    if (typeof a !== 'number') {
        throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
        throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
        throw new DeveloperError('c is a required number.');
    }
    var ratio;
    if (a === 0) {
        if (b === 0) {
            return [];
        }
        return [-c / b];
    } else if (b === 0) {
        if (c === 0) {
            return [
                0,
                0
            ];
        }
        var cMagnitude = Math.abs(c);
        var aMagnitude = Math.abs(a);
        if (cMagnitude < aMagnitude && cMagnitude / aMagnitude < CesiumMath.EPSILON14) {
            return [
                0,
                0
            ];
        } else if (cMagnitude > aMagnitude && aMagnitude / cMagnitude < CesiumMath.EPSILON14) {
            return [];
        }
        ratio = -c / a;
        if (ratio < 0) {
            return [];
        }
        var root = Math.sqrt(ratio);
        return [
            -root,
            root
        ];
    } else if (c === 0) {
        ratio = -b / a;
        if (ratio < 0) {
            return [
                ratio,
                0
            ];
        }
        return [
            0,
            ratio
        ];
    }
    var b2 = b * b;
    var four_ac = 4 * a * c;
    var radicand = addWithCancellationCheck(b2, -four_ac, CesiumMath.EPSILON14);
    if (radicand < 0) {
        return [];
    }
    var q = -0.5 * addWithCancellationCheck(b, CesiumMath.sign(b) * Math.sqrt(radicand), CesiumMath.EPSILON14);
    if (b > 0) {
        return [
            q / a,
            c / q
        ];
    }
    return [
        c / q,
        q / a
    ];
};
module.exports = QuadraticRealPolynomial;
},{"./DeveloperError":123,"./Math":174}],195:[function(require,module,exports){
var when = require('../ThirdParty/when'), BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), IndexDatatype = require('./IndexDatatype'), Intersections2D = require('./Intersections2D'), CesiumMath = require('./Math'), TaskProcessor = require('./TaskProcessor'), TerrainMesh = require('./TerrainMesh');
'use strict';
var QuantizedMeshTerrainData = function QuantizedMeshTerrainData(options) {
    if (!defined(options) || !defined(options.quantizedVertices)) {
        throw new DeveloperError('options.quantizedVertices is required.');
    }
    if (!defined(options.indices)) {
        throw new DeveloperError('options.indices is required.');
    }
    if (!defined(options.minimumHeight)) {
        throw new DeveloperError('options.minimumHeight is required.');
    }
    if (!defined(options.maximumHeight)) {
        throw new DeveloperError('options.maximumHeight is required.');
    }
    if (!defined(options.maximumHeight)) {
        throw new DeveloperError('options.maximumHeight is required.');
    }
    if (!defined(options.boundingSphere)) {
        throw new DeveloperError('options.boundingSphere is required.');
    }
    if (!defined(options.horizonOcclusionPoint)) {
        throw new DeveloperError('options.horizonOcclusionPoint is required.');
    }
    if (!defined(options.westIndices)) {
        throw new DeveloperError('options.westIndices is required.');
    }
    if (!defined(options.southIndices)) {
        throw new DeveloperError('options.southIndices is required.');
    }
    if (!defined(options.eastIndices)) {
        throw new DeveloperError('options.eastIndices is required.');
    }
    if (!defined(options.northIndices)) {
        throw new DeveloperError('options.northIndices is required.');
    }
    if (!defined(options.westSkirtHeight)) {
        throw new DeveloperError('options.westSkirtHeight is required.');
    }
    if (!defined(options.southSkirtHeight)) {
        throw new DeveloperError('options.southSkirtHeight is required.');
    }
    if (!defined(options.eastSkirtHeight)) {
        throw new DeveloperError('options.eastSkirtHeight is required.');
    }
    if (!defined(options.northSkirtHeight)) {
        throw new DeveloperError('options.northSkirtHeight is required.');
    }
    this._quantizedVertices = options.quantizedVertices;
    this._encodedNormals = options.encodedNormals;
    this._indices = options.indices;
    this._minimumHeight = options.minimumHeight;
    this._maximumHeight = options.maximumHeight;
    this._boundingSphere = options.boundingSphere;
    this._horizonOcclusionPoint = options.horizonOcclusionPoint;
    var vertexCount = this._quantizedVertices.length / 3;
    var uValues = this._uValues = this._quantizedVertices.subarray(0, vertexCount);
    var vValues = this._vValues = this._quantizedVertices.subarray(vertexCount, 2 * vertexCount);
    this._heightValues = this._quantizedVertices.subarray(2 * vertexCount, 3 * vertexCount);
    function sortByV(a, b) {
        return vValues[a] - vValues[b];
    }
    function sortByU(a, b) {
        return uValues[a] - uValues[b];
    }
    var requires32BitIndices = vertexCount > 64 * 1024;
    this._westIndices = sortIndicesIfNecessary(options.westIndices, sortByV, vertexCount);
    this._southIndices = sortIndicesIfNecessary(options.southIndices, sortByU, vertexCount);
    this._eastIndices = sortIndicesIfNecessary(options.eastIndices, sortByV, vertexCount);
    this._northIndices = sortIndicesIfNecessary(options.northIndices, sortByU, vertexCount);
    this._westSkirtHeight = options.westSkirtHeight;
    this._southSkirtHeight = options.southSkirtHeight;
    this._eastSkirtHeight = options.eastSkirtHeight;
    this._northSkirtHeight = options.northSkirtHeight;
    this._childTileMask = defaultValue(options.childTileMask, 15);
    this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);
    this._waterMask = options.waterMask;
};
defineProperties(QuantizedMeshTerrainData.prototype, {
    waterMask: {
        get: function () {
            return this._waterMask;
        }
    }
});
var arrayScratch = [];
function sortIndicesIfNecessary(indices, sortFunction, vertexCount) {
    arrayScratch.length = indices.length;
    var needsSort = false;
    for (var i = 0, len = indices.length; i < len; ++i) {
        arrayScratch[i] = indices[i];
        needsSort = needsSort || i > 0 && sortFunction(indices[i - 1], indices[i]) > 0;
    }
    if (needsSort) {
        arrayScratch.sort(sortFunction);
        return IndexDatatype.createTypedArray(vertexCount, arrayScratch);
    } else {
        return indices;
    }
}
var createMeshTaskProcessor = new TaskProcessor('createVerticesFromQuantizedTerrainMesh');
QuantizedMeshTerrainData.prototype.createMesh = function (tilingScheme, x, y, level) {
    if (!defined(tilingScheme)) {
        throw new DeveloperError('tilingScheme is required.');
    }
    if (!defined(x)) {
        throw new DeveloperError('x is required.');
    }
    if (!defined(y)) {
        throw new DeveloperError('y is required.');
    }
    if (!defined(level)) {
        throw new DeveloperError('level is required.');
    }
    var ellipsoid = tilingScheme.ellipsoid;
    var rectangle = tilingScheme.tileXYToRectangle(x, y, level);
    var verticesPromise = createMeshTaskProcessor.scheduleTask({
            minimumHeight: this._minimumHeight,
            maximumHeight: this._maximumHeight,
            quantizedVertices: this._quantizedVertices,
            octEncodedNormals: this._encodedNormals,
            indices: this._indices,
            westIndices: this._westIndices,
            southIndices: this._southIndices,
            eastIndices: this._eastIndices,
            northIndices: this._northIndices,
            westSkirtHeight: this._westSkirtHeight,
            southSkirtHeight: this._southSkirtHeight,
            eastSkirtHeight: this._eastSkirtHeight,
            northSkirtHeight: this._northSkirtHeight,
            rectangle: rectangle,
            relativeToCenter: this._boundingSphere.center,
            ellipsoid: ellipsoid
        });
    if (!defined(verticesPromise)) {
        return undefined;
    }
    var that = this;
    return when(verticesPromise, function (result) {
        var vertexCount = that._quantizedVertices.length / 3;
        vertexCount += that._westIndices.length + that._southIndices.length + that._eastIndices.length + that._northIndices.length;
        var indicesTypedArray = IndexDatatype.createTypedArray(vertexCount, result.indices);
        return new TerrainMesh(that._boundingSphere.center, new Float32Array(result.vertices), indicesTypedArray, that._minimumHeight, that._maximumHeight, that._boundingSphere, that._horizonOcclusionPoint, defined(that._encodedNormals) ? 7 : 6);
    });
};
var upsampleTaskProcessor = new TaskProcessor('upsampleQuantizedTerrainMesh');
QuantizedMeshTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {
    if (!defined(tilingScheme)) {
        throw new DeveloperError('tilingScheme is required.');
    }
    if (!defined(thisX)) {
        throw new DeveloperError('thisX is required.');
    }
    if (!defined(thisY)) {
        throw new DeveloperError('thisY is required.');
    }
    if (!defined(thisLevel)) {
        throw new DeveloperError('thisLevel is required.');
    }
    if (!defined(descendantX)) {
        throw new DeveloperError('descendantX is required.');
    }
    if (!defined(descendantY)) {
        throw new DeveloperError('descendantY is required.');
    }
    if (!defined(descendantLevel)) {
        throw new DeveloperError('descendantLevel is required.');
    }
    var levelDifference = descendantLevel - thisLevel;
    if (levelDifference > 1) {
        throw new DeveloperError('Upsampling through more than one level at a time is not currently supported.');
    }
    var isEastChild = thisX * 2 !== descendantX;
    var isNorthChild = thisY * 2 === descendantY;
    var ellipsoid = tilingScheme.ellipsoid;
    var childRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);
    var upsamplePromise = upsampleTaskProcessor.scheduleTask({
            vertices: this._quantizedVertices,
            indices: this._indices,
            encodedNormals: this._encodedNormals,
            minimumHeight: this._minimumHeight,
            maximumHeight: this._maximumHeight,
            isEastChild: isEastChild,
            isNorthChild: isNorthChild,
            childRectangle: childRectangle,
            ellipsoid: ellipsoid
        });
    if (!defined(upsamplePromise)) {
        return undefined;
    }
    var shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);
    shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);
    shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);
    var westSkirtHeight = isEastChild ? shortestSkirt * 0.5 : this._westSkirtHeight;
    var southSkirtHeight = isNorthChild ? shortestSkirt * 0.5 : this._southSkirtHeight;
    var eastSkirtHeight = isEastChild ? this._eastSkirtHeight : shortestSkirt * 0.5;
    var northSkirtHeight = isNorthChild ? this._northSkirtHeight : shortestSkirt * 0.5;
    return when(upsamplePromise, function (result) {
        var quantizedVertices = new Uint16Array(result.vertices);
        var indicesTypedArray = IndexDatatype.createTypedArray(quantizedVertices.length / 3, result.indices);
        var encodedNormals;
        if (defined(result.encodedNormals)) {
            encodedNormals = new Uint8Array(result.encodedNormals);
        }
        return new QuantizedMeshTerrainData({
            quantizedVertices: quantizedVertices,
            indices: indicesTypedArray,
            encodedNormals: encodedNormals,
            minimumHeight: result.minimumHeight,
            maximumHeight: result.maximumHeight,
            boundingSphere: BoundingSphere.clone(result.boundingSphere),
            horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),
            westIndices: result.westIndices,
            southIndices: result.southIndices,
            eastIndices: result.eastIndices,
            northIndices: result.northIndices,
            westSkirtHeight: westSkirtHeight,
            southSkirtHeight: southSkirtHeight,
            eastSkirtHeight: eastSkirtHeight,
            northSkirtHeight: northSkirtHeight,
            childTileMask: 0,
            createdByUpsampling: true
        });
    });
};
var maxShort = 32767;
var barycentricCoordinateScratch = new Cartesian3();
QuantizedMeshTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {
    var u = CesiumMath.clamp((longitude - rectangle.west) / rectangle.width, 0, 1);
    u *= maxShort;
    var v = CesiumMath.clamp((latitude - rectangle.south) / rectangle.height, 0, 1);
    v *= maxShort;
    var uBuffer = this._uValues;
    var vBuffer = this._vValues;
    var heightBuffer = this._heightValues;
    var indices = this._indices;
    for (var i = 0, len = indices.length; i < len; i += 3) {
        var i0 = indices[i];
        var i1 = indices[i + 1];
        var i2 = indices[i + 2];
        var u0 = uBuffer[i0];
        var u1 = uBuffer[i1];
        var u2 = uBuffer[i2];
        var v0 = vBuffer[i0];
        var v1 = vBuffer[i1];
        var v2 = vBuffer[i2];
        var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, u0, v0, u1, v1, u2, v2, barycentricCoordinateScratch);
        if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {
            var quantizedHeight = barycentric.x * heightBuffer[i0] + barycentric.y * heightBuffer[i1] + barycentric.z * heightBuffer[i2];
            return CesiumMath.lerp(this._minimumHeight, this._maximumHeight, quantizedHeight / maxShort);
        }
    }
    return undefined;
};
QuantizedMeshTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {
    if (!defined(thisX)) {
        throw new DeveloperError('thisX is required.');
    }
    if (!defined(thisY)) {
        throw new DeveloperError('thisY is required.');
    }
    if (!defined(childX)) {
        throw new DeveloperError('childX is required.');
    }
    if (!defined(childY)) {
        throw new DeveloperError('childY is required.');
    }
    var bitNumber = 2;
    if (childX !== thisX * 2) {
        ++bitNumber;
    }
    if (childY !== thisY * 2) {
        bitNumber -= 2;
    }
    return (this._childTileMask & 1 << bitNumber) !== 0;
};
QuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {
    return this._createdByUpsampling;
};
module.exports = QuantizedMeshTerrainData;
},{"../ThirdParty/when":596,"./BoundingSphere":98,"./Cartesian3":102,"./DeveloperError":123,"./IndexDatatype":162,"./Intersections2D":165,"./Math":174,"./TaskProcessor":217,"./TerrainMesh":218,"./defaultValue":243,"./defineProperties":244,"./defined":245}],196:[function(require,module,exports){
var CubicRealPolynomial = require('./CubicRealPolynomial'), DeveloperError = require('./DeveloperError'), CesiumMath = require('./Math'), QuadraticRealPolynomial = require('./QuadraticRealPolynomial');
'use strict';
var QuarticRealPolynomial = {};
QuarticRealPolynomial.computeDiscriminant = function (a, b, c, d, e) {
    if (typeof a !== 'number') {
        throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
        throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
        throw new DeveloperError('c is a required number.');
    }
    if (typeof d !== 'number') {
        throw new DeveloperError('d is a required number.');
    }
    if (typeof e !== 'number') {
        throw new DeveloperError('e is a required number.');
    }
    var a2 = a * a;
    var a3 = a2 * a;
    var b2 = b * b;
    var b3 = b2 * b;
    var c2 = c * c;
    var c3 = c2 * c;
    var d2 = d * d;
    var d3 = d2 * d;
    var e2 = e * e;
    var e3 = e2 * e;
    var discriminant = b2 * c2 * d2 - 4 * b3 * d3 - 4 * a * c3 * d2 + 18 * a * b * c * d3 - 27 * a2 * d2 * d2 + 256 * a3 * e3 + e * (18 * b3 * c * d - 4 * b2 * c3 + 16 * a * c2 * c2 - 80 * a * b * c2 * d - 6 * a * b2 * d2 + 144 * a2 * c * d2) + e2 * (144 * a * b2 * c - 27 * b2 * b2 - 128 * a2 * c2 - 192 * a2 * b * d);
    return discriminant;
};
function original(a3, a2, a1, a0) {
    var a3Squared = a3 * a3;
    var p = a2 - 3 * a3Squared / 8;
    var q = a1 - a2 * a3 / 2 + a3Squared * a3 / 8;
    var r = a0 - a1 * a3 / 4 + a2 * a3Squared / 16 - 3 * a3Squared * a3Squared / 256;
    var cubicRoots = CubicRealPolynomial.computeRealRoots(1, 2 * p, p * p - 4 * r, -q * q);
    if (cubicRoots.length > 0) {
        var temp = -a3 / 4;
        var hSquared = cubicRoots[cubicRoots.length - 1];
        if (Math.abs(hSquared) < CesiumMath.EPSILON14) {
            var roots = QuadraticRealPolynomial.computeRealRoots(1, p, r);
            if (roots.length === 2) {
                var root0 = roots[0];
                var root1 = roots[1];
                var y;
                if (root0 >= 0 && root1 >= 0) {
                    var y0 = Math.sqrt(root0);
                    var y1 = Math.sqrt(root1);
                    return [
                        temp - y1,
                        temp - y0,
                        temp + y0,
                        temp + y1
                    ];
                } else if (root0 >= 0 && root1 < 0) {
                    y = Math.sqrt(root0);
                    return [
                        temp - y,
                        temp + y
                    ];
                } else if (root0 < 0 && root1 >= 0) {
                    y = Math.sqrt(root1);
                    return [
                        temp - y,
                        temp + y
                    ];
                }
            }
            return [];
        } else if (hSquared > 0) {
            var h = Math.sqrt(hSquared);
            var m = (p + hSquared - q / h) / 2;
            var n = (p + hSquared + q / h) / 2;
            var roots1 = QuadraticRealPolynomial.computeRealRoots(1, h, m);
            var roots2 = QuadraticRealPolynomial.computeRealRoots(1, -h, n);
            if (roots1.length !== 0) {
                roots1[0] += temp;
                roots1[1] += temp;
                if (roots2.length !== 0) {
                    roots2[0] += temp;
                    roots2[1] += temp;
                    if (roots1[1] <= roots2[0]) {
                        return [
                            roots1[0],
                            roots1[1],
                            roots2[0],
                            roots2[1]
                        ];
                    } else if (roots2[1] <= roots1[0]) {
                        return [
                            roots2[0],
                            roots2[1],
                            roots1[0],
                            roots1[1]
                        ];
                    } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
                        return [
                            roots2[0],
                            roots1[0],
                            roots1[1],
                            roots2[1]
                        ];
                    } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
                        return [
                            roots1[0],
                            roots2[0],
                            roots2[1],
                            roots1[1]
                        ];
                    } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
                        return [
                            roots2[0],
                            roots1[0],
                            roots2[1],
                            roots1[1]
                        ];
                    }
                    return [
                        roots1[0],
                        roots2[0],
                        roots1[1],
                        roots2[1]
                    ];
                }
                return roots1;
            }
            if (roots2.length !== 0) {
                roots2[0] += temp;
                roots2[1] += temp;
                return roots2;
            }
            return [];
        }
    }
    return [];
}
function neumark(a3, a2, a1, a0) {
    var a1Squared = a1 * a1;
    var a2Squared = a2 * a2;
    var a3Squared = a3 * a3;
    var p = -2 * a2;
    var q = a1 * a3 + a2Squared - 4 * a0;
    var r = a3Squared * a0 - a1 * a2 * a3 + a1Squared;
    var cubicRoots = CubicRealPolynomial.computeRealRoots(1, p, q, r);
    if (cubicRoots.length > 0) {
        var y = cubicRoots[0];
        var temp = a2 - y;
        var tempSquared = temp * temp;
        var g1 = a3 / 2;
        var h1 = temp / 2;
        var m = tempSquared - 4 * a0;
        var mError = tempSquared + 4 * Math.abs(a0);
        var n = a3Squared - 4 * y;
        var nError = a3Squared + 4 * Math.abs(y);
        var g2;
        var h2;
        if (y < 0 || m * nError < n * mError) {
            var squareRootOfN = Math.sqrt(n);
            g2 = squareRootOfN / 2;
            h2 = squareRootOfN === 0 ? 0 : (a3 * h1 - a1) / squareRootOfN;
        } else {
            var squareRootOfM = Math.sqrt(m);
            g2 = squareRootOfM === 0 ? 0 : (a3 * h1 - a1) / squareRootOfM;
            h2 = squareRootOfM / 2;
        }
        var G;
        var g;
        if (g1 === 0 && g2 === 0) {
            G = 0;
            g = 0;
        } else if (CesiumMath.sign(g1) === CesiumMath.sign(g2)) {
            G = g1 + g2;
            g = y / G;
        } else {
            g = g1 - g2;
            G = y / g;
        }
        var H;
        var h;
        if (h1 === 0 && h2 === 0) {
            H = 0;
            h = 0;
        } else if (CesiumMath.sign(h1) === CesiumMath.sign(h2)) {
            H = h1 + h2;
            h = a0 / H;
        } else {
            h = h1 - h2;
            H = a0 / h;
        }
        var roots1 = QuadraticRealPolynomial.computeRealRoots(1, G, H);
        var roots2 = QuadraticRealPolynomial.computeRealRoots(1, g, h);
        if (roots1.length !== 0) {
            if (roots2.length !== 0) {
                if (roots1[1] <= roots2[0]) {
                    return [
                        roots1[0],
                        roots1[1],
                        roots2[0],
                        roots2[1]
                    ];
                } else if (roots2[1] <= roots1[0]) {
                    return [
                        roots2[0],
                        roots2[1],
                        roots1[0],
                        roots1[1]
                    ];
                } else if (roots1[0] >= roots2[0] && roots1[1] <= roots2[1]) {
                    return [
                        roots2[0],
                        roots1[0],
                        roots1[1],
                        roots2[1]
                    ];
                } else if (roots2[0] >= roots1[0] && roots2[1] <= roots1[1]) {
                    return [
                        roots1[0],
                        roots2[0],
                        roots2[1],
                        roots1[1]
                    ];
                } else if (roots1[0] > roots2[0] && roots1[0] < roots2[1]) {
                    return [
                        roots2[0],
                        roots1[0],
                        roots2[1],
                        roots1[1]
                    ];
                } else {
                    return [
                        roots1[0],
                        roots2[0],
                        roots1[1],
                        roots2[1]
                    ];
                }
            }
            return roots1;
        }
        if (roots2.length !== 0) {
            return roots2;
        }
    }
    return [];
}
QuarticRealPolynomial.computeRealRoots = function (a, b, c, d, e) {
    if (typeof a !== 'number') {
        throw new DeveloperError('a is a required number.');
    }
    if (typeof b !== 'number') {
        throw new DeveloperError('b is a required number.');
    }
    if (typeof c !== 'number') {
        throw new DeveloperError('c is a required number.');
    }
    if (typeof d !== 'number') {
        throw new DeveloperError('d is a required number.');
    }
    if (typeof e !== 'number') {
        throw new DeveloperError('e is a required number.');
    }
    if (Math.abs(a) < CesiumMath.EPSILON15) {
        return CubicRealPolynomial.computeRealRoots(b, c, d, e);
    }
    var a3 = b / a;
    var a2 = c / a;
    var a1 = d / a;
    var a0 = e / a;
    var k = a3 < 0 ? 1 : 0;
    k += a2 < 0 ? k + 1 : k;
    k += a1 < 0 ? k + 1 : k;
    k += a0 < 0 ? k + 1 : k;
    switch (k) {
    case 0:
        return original(a3, a2, a1, a0);
    case 1:
        return neumark(a3, a2, a1, a0);
    case 2:
        return neumark(a3, a2, a1, a0);
    case 3:
        return original(a3, a2, a1, a0);
    case 4:
        return original(a3, a2, a1, a0);
    case 5:
        return neumark(a3, a2, a1, a0);
    case 6:
        return original(a3, a2, a1, a0);
    case 7:
        return original(a3, a2, a1, a0);
    case 8:
        return neumark(a3, a2, a1, a0);
    case 9:
        return original(a3, a2, a1, a0);
    case 10:
        return original(a3, a2, a1, a0);
    case 11:
        return neumark(a3, a2, a1, a0);
    case 12:
        return original(a3, a2, a1, a0);
    case 13:
        return original(a3, a2, a1, a0);
    case 14:
        return original(a3, a2, a1, a0);
    case 15:
        return original(a3, a2, a1, a0);
    default:
        return undefined;
    }
};
module.exports = QuarticRealPolynomial;
},{"./CubicRealPolynomial":119,"./DeveloperError":123,"./Math":174,"./QuadraticRealPolynomial":194}],197:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), FeatureDetection = require('./FeatureDetection'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3');
'use strict';
var Quaternion = function (x, y, z, w) {
    this.x = defaultValue(x, 0);
    this.y = defaultValue(y, 0);
    this.z = defaultValue(z, 0);
    this.w = defaultValue(w, 0);
};
var fromAxisAngleScratch = new Cartesian3();
Quaternion.fromAxisAngle = function (axis, angle, result) {
    if (!defined(axis)) {
        throw new DeveloperError('axis is required.');
    }
    if (typeof angle !== 'number') {
        throw new DeveloperError('angle is required and must be a number.');
    }
    var halfAngle = angle / 2;
    var s = Math.sin(halfAngle);
    fromAxisAngleScratch = Cartesian3.normalize(axis, fromAxisAngleScratch);
    var x = fromAxisAngleScratch.x * s;
    var y = fromAxisAngleScratch.y * s;
    var z = fromAxisAngleScratch.z * s;
    var w = Math.cos(halfAngle);
    if (!defined(result)) {
        return new Quaternion(x, y, z, w);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
};
var fromRotationMatrixNext = [
        1,
        2,
        0
    ];
var fromRotationMatrixQuat = new Array(3);
Quaternion.fromRotationMatrix = function (matrix, result) {
    if (!defined(matrix)) {
        throw new DeveloperError('matrix is required.');
    }
    var root;
    var x;
    var y;
    var z;
    var w;
    var m00 = matrix[Matrix3.COLUMN0ROW0];
    var m11 = matrix[Matrix3.COLUMN1ROW1];
    var m22 = matrix[Matrix3.COLUMN2ROW2];
    var trace = m00 + m11 + m22;
    if (trace > 0) {
        root = Math.sqrt(trace + 1);
        w = 0.5 * root;
        root = 0.5 / root;
        x = (matrix[Matrix3.COLUMN1ROW2] - matrix[Matrix3.COLUMN2ROW1]) * root;
        y = (matrix[Matrix3.COLUMN2ROW0] - matrix[Matrix3.COLUMN0ROW2]) * root;
        z = (matrix[Matrix3.COLUMN0ROW1] - matrix[Matrix3.COLUMN1ROW0]) * root;
    } else {
        var next = fromRotationMatrixNext;
        var i = 0;
        if (m11 > m00) {
            i = 1;
        }
        if (m22 > m00 && m22 > m11) {
            i = 2;
        }
        var j = next[i];
        var k = next[j];
        root = Math.sqrt(matrix[Matrix3.getElementIndex(i, i)] - matrix[Matrix3.getElementIndex(j, j)] - matrix[Matrix3.getElementIndex(k, k)] + 1);
        var quat = fromRotationMatrixQuat;
        quat[i] = 0.5 * root;
        root = 0.5 / root;
        w = (matrix[Matrix3.getElementIndex(k, j)] - matrix[Matrix3.getElementIndex(j, k)]) * root;
        quat[j] = (matrix[Matrix3.getElementIndex(j, i)] + matrix[Matrix3.getElementIndex(i, j)]) * root;
        quat[k] = (matrix[Matrix3.getElementIndex(k, i)] + matrix[Matrix3.getElementIndex(i, k)]) * root;
        x = -quat[0];
        y = -quat[1];
        z = -quat[2];
    }
    if (!defined(result)) {
        return new Quaternion(x, y, z, w);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
};
var scratchHPRQuaternion = new Quaternion();
Quaternion.fromHeadingPitchRoll = function (heading, pitch, roll, result) {
    if (!defined(heading)) {
        throw new DeveloperError('heading is required.');
    }
    if (!defined(pitch)) {
        throw new DeveloperError('pitch is required.');
    }
    if (!defined(roll)) {
        throw new DeveloperError('roll is required.');
    }
    var headingQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -heading, result);
    var pitchQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -pitch, scratchHPRQuaternion);
    result = Quaternion.multiply(headingQuaternion, pitchQuaternion, headingQuaternion);
    var rollQuaternion = Quaternion.fromAxisAngle(Cartesian3.UNIT_X, roll, scratchHPRQuaternion);
    return Quaternion.multiply(rollQuaternion, result, result);
};
var sampledQuaternionAxis = new Cartesian3();
var sampledQuaternionRotation = new Cartesian3();
var sampledQuaternionTempQuaternion = new Quaternion();
var sampledQuaternionQuaternion0 = new Quaternion();
var sampledQuaternionQuaternion0Conjugate = new Quaternion();
Quaternion.packedLength = 4;
Quaternion.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.x;
    array[startingIndex++] = value.y;
    array[startingIndex++] = value.z;
    array[startingIndex] = value.w;
};
Quaternion.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Quaternion();
    }
    result.x = array[startingIndex];
    result.y = array[startingIndex + 1];
    result.z = array[startingIndex + 2];
    result.w = array[startingIndex + 3];
    return result;
};
Quaternion.packedInterpolationLength = 3;
Quaternion.convertPackedArrayForInterpolation = function (packedArray, startingIndex, lastIndex, result) {
    Quaternion.unpack(packedArray, lastIndex * 4, sampledQuaternionQuaternion0Conjugate);
    Quaternion.conjugate(sampledQuaternionQuaternion0Conjugate, sampledQuaternionQuaternion0Conjugate);
    for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {
        var offset = i * 3;
        Quaternion.unpack(packedArray, (startingIndex + i) * 4, sampledQuaternionTempQuaternion);
        Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0Conjugate, sampledQuaternionTempQuaternion);
        if (sampledQuaternionTempQuaternion.w < 0) {
            Quaternion.negate(sampledQuaternionTempQuaternion, sampledQuaternionTempQuaternion);
        }
        Quaternion.computeAxis(sampledQuaternionTempQuaternion, sampledQuaternionAxis);
        var angle = Quaternion.computeAngle(sampledQuaternionTempQuaternion);
        result[offset] = sampledQuaternionAxis.x * angle;
        result[offset + 1] = sampledQuaternionAxis.y * angle;
        result[offset + 2] = sampledQuaternionAxis.z * angle;
    }
};
Quaternion.unpackInterpolationResult = function (array, sourceArray, firstIndex, lastIndex, result) {
    if (!defined(result)) {
        result = new Quaternion();
    }
    Cartesian3.fromArray(array, 0, sampledQuaternionRotation);
    var magnitude = Cartesian3.magnitude(sampledQuaternionRotation);
    Quaternion.unpack(sourceArray, lastIndex * 4, sampledQuaternionQuaternion0);
    if (magnitude === 0) {
        Quaternion.clone(Quaternion.IDENTITY, sampledQuaternionTempQuaternion);
    } else {
        Quaternion.fromAxisAngle(sampledQuaternionRotation, magnitude, sampledQuaternionTempQuaternion);
    }
    return Quaternion.multiply(sampledQuaternionTempQuaternion, sampledQuaternionQuaternion0, result);
};
Quaternion.clone = function (quaternion, result) {
    if (!defined(quaternion)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
    }
    result.x = quaternion.x;
    result.y = quaternion.y;
    result.z = quaternion.z;
    result.w = quaternion.w;
    return result;
};
Quaternion.conjugate = function (quaternion, result) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = -quaternion.x;
    result.y = -quaternion.y;
    result.z = -quaternion.z;
    result.w = quaternion.w;
    return result;
};
Quaternion.magnitudeSquared = function (quaternion) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required');
    }
    return quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
};
Quaternion.magnitude = function (quaternion) {
    return Math.sqrt(Quaternion.magnitudeSquared(quaternion));
};
Quaternion.normalize = function (quaternion, result) {
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var inverseMagnitude = 1 / Quaternion.magnitude(quaternion);
    var x = quaternion.x * inverseMagnitude;
    var y = quaternion.y * inverseMagnitude;
    var z = quaternion.z * inverseMagnitude;
    var w = quaternion.w * inverseMagnitude;
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
};
Quaternion.inverse = function (quaternion, result) {
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var magnitudeSquared = Quaternion.magnitudeSquared(quaternion);
    result = Quaternion.conjugate(quaternion, result);
    return Quaternion.multiplyByScalar(result, 1 / magnitudeSquared, result);
};
Quaternion.add = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x + right.x;
    result.y = left.y + right.y;
    result.z = left.z + right.z;
    result.w = left.w + right.w;
    return result;
};
Quaternion.subtract = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = left.x - right.x;
    result.y = left.y - right.y;
    result.z = left.z - right.z;
    result.w = left.w - right.w;
    return result;
};
Quaternion.negate = function (quaternion, result) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = -quaternion.x;
    result.y = -quaternion.y;
    result.z = -quaternion.z;
    result.w = -quaternion.w;
    return result;
};
Quaternion.dot = function (left, right) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
};
Quaternion.multiply = function (left, right, result) {
    if (!defined(left)) {
        throw new DeveloperError('left is required');
    }
    if (!defined(right)) {
        throw new DeveloperError('right is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var leftX = left.x;
    var leftY = left.y;
    var leftZ = left.z;
    var leftW = left.w;
    var rightX = right.x;
    var rightY = right.y;
    var rightZ = right.z;
    var rightW = right.w;
    var x = leftW * rightX + leftX * rightW + leftY * rightZ - leftZ * rightY;
    var y = leftW * rightY - leftX * rightZ + leftY * rightW + leftZ * rightX;
    var z = leftW * rightZ + leftX * rightY - leftY * rightX + leftZ * rightW;
    var w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
};
Quaternion.multiplyByScalar = function (quaternion, scalar, result) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = quaternion.x * scalar;
    result.y = quaternion.y * scalar;
    result.z = quaternion.z * scalar;
    result.w = quaternion.w * scalar;
    return result;
};
Quaternion.divideByScalar = function (quaternion, scalar, result) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required');
    }
    if (typeof scalar !== 'number') {
        throw new DeveloperError('scalar is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    result.x = quaternion.x / scalar;
    result.y = quaternion.y / scalar;
    result.z = quaternion.z / scalar;
    result.w = quaternion.w / scalar;
    return result;
};
Quaternion.computeAxis = function (quaternion, result) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var w = quaternion.w;
    if (Math.abs(w - 1) < CesiumMath.EPSILON6) {
        result.x = result.y = result.z = 0;
        return result;
    }
    var scalar = 1 / Math.sqrt(1 - w * w);
    result.x = quaternion.x * scalar;
    result.y = quaternion.y * scalar;
    result.z = quaternion.z * scalar;
    return result;
};
Quaternion.computeAngle = function (quaternion) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required');
    }
    if (Math.abs(quaternion.w - 1) < CesiumMath.EPSILON6) {
        return 0;
    }
    return 2 * Math.acos(quaternion.w);
};
var lerpScratch = new Quaternion();
Quaternion.lerp = function (start, end, t, result) {
    if (!defined(start)) {
        throw new DeveloperError('start is required.');
    }
    if (!defined(end)) {
        throw new DeveloperError('end is required.');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    lerpScratch = Quaternion.multiplyByScalar(end, t, lerpScratch);
    result = Quaternion.multiplyByScalar(start, 1 - t, result);
    return Quaternion.add(lerpScratch, result, result);
};
var slerpEndNegated = new Quaternion();
var slerpScaledP = new Quaternion();
var slerpScaledR = new Quaternion();
Quaternion.slerp = function (start, end, t, result) {
    if (!defined(start)) {
        throw new DeveloperError('start is required.');
    }
    if (!defined(end)) {
        throw new DeveloperError('end is required.');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var dot = Quaternion.dot(start, end);
    var r = end;
    if (dot < 0) {
        dot = -dot;
        r = slerpEndNegated = Quaternion.negate(end, slerpEndNegated);
    }
    if (1 - dot < CesiumMath.EPSILON6) {
        return Quaternion.lerp(start, r, t, result);
    }
    var theta = Math.acos(dot);
    slerpScaledP = Quaternion.multiplyByScalar(start, Math.sin((1 - t) * theta), slerpScaledP);
    slerpScaledR = Quaternion.multiplyByScalar(r, Math.sin(t * theta), slerpScaledR);
    result = Quaternion.add(slerpScaledP, slerpScaledR, result);
    return Quaternion.multiplyByScalar(result, 1 / Math.sin(theta), result);
};
Quaternion.log = function (quaternion, result) {
    if (!defined(quaternion)) {
        throw new DeveloperError('quaternion is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var theta = CesiumMath.acosClamped(quaternion.w);
    var thetaOverSinTheta = 0;
    if (theta !== 0) {
        thetaOverSinTheta = theta / Math.sin(theta);
    }
    return Cartesian3.multiplyByScalar(quaternion, thetaOverSinTheta, result);
};
Quaternion.exp = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var theta = Cartesian3.magnitude(cartesian);
    var sinThetaOverTheta = 0;
    if (theta !== 0) {
        sinThetaOverTheta = Math.sin(theta) / theta;
    }
    result.x = cartesian.x * sinThetaOverTheta;
    result.y = cartesian.y * sinThetaOverTheta;
    result.z = cartesian.z * sinThetaOverTheta;
    result.w = Math.cos(theta);
    return result;
};
var squadScratchCartesian0 = new Cartesian3();
var squadScratchCartesian1 = new Cartesian3();
var squadScratchQuaternion0 = new Quaternion();
var squadScratchQuaternion1 = new Quaternion();
Quaternion.computeInnerQuadrangle = function (q0, q1, q2, result) {
    if (!defined(q0) || !defined(q1) || !defined(q2)) {
        throw new DeveloperError('q0, q1, and q2 are required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var qInv = Quaternion.conjugate(q1, squadScratchQuaternion0);
    Quaternion.multiply(qInv, q2, squadScratchQuaternion1);
    var cart0 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian0);
    Quaternion.multiply(qInv, q0, squadScratchQuaternion1);
    var cart1 = Quaternion.log(squadScratchQuaternion1, squadScratchCartesian1);
    Cartesian3.add(cart0, cart1, cart0);
    Cartesian3.multiplyByScalar(cart0, 0.25, cart0);
    Cartesian3.negate(cart0, cart0);
    Quaternion.exp(cart0, squadScratchQuaternion0);
    return Quaternion.multiply(q1, squadScratchQuaternion0, result);
};
Quaternion.squad = function (q0, q1, s0, s1, t, result) {
    if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {
        throw new DeveloperError('q0, q1, s0, and s1 are required.');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var slerp0 = Quaternion.slerp(q0, q1, t, squadScratchQuaternion0);
    var slerp1 = Quaternion.slerp(s0, s1, t, squadScratchQuaternion1);
    return Quaternion.slerp(slerp0, slerp1, 2 * t * (1 - t), result);
};
var fastSlerpScratchQuaternion = new Quaternion();
var opmu = 1.9011074535173003;
var u = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
var v = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
var bT = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
var bD = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
for (var i = 0; i < 7; ++i) {
    var s = i + 1;
    var t = 2 * s + 1;
    u[i] = 1 / (s * t);
    v[i] = s / t;
}
u[7] = opmu / (8 * 17);
v[7] = opmu * 8 / 17;
Quaternion.fastSlerp = function (start, end, t, result) {
    if (!defined(start)) {
        throw new DeveloperError('start is required.');
    }
    if (!defined(end)) {
        throw new DeveloperError('end is required.');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var x = Quaternion.dot(start, end);
    var sign;
    if (x >= 0) {
        sign = 1;
    } else {
        sign = -1;
        x = -x;
    }
    var xm1 = x - 1;
    var d = 1 - t;
    var sqrT = t * t;
    var sqrD = d * d;
    for (var i = 7; i >= 0; --i) {
        bT[i] = (u[i] * sqrT - v[i]) * xm1;
        bD[i] = (u[i] * sqrD - v[i]) * xm1;
    }
    var cT = sign * t * (1 + bT[0] * (1 + bT[1] * (1 + bT[2] * (1 + bT[3] * (1 + bT[4] * (1 + bT[5] * (1 + bT[6] * (1 + bT[7]))))))));
    var cD = d * (1 + bD[0] * (1 + bD[1] * (1 + bD[2] * (1 + bD[3] * (1 + bD[4] * (1 + bD[5] * (1 + bD[6] * (1 + bD[7]))))))));
    var temp = Quaternion.multiplyByScalar(start, cD, fastSlerpScratchQuaternion);
    Quaternion.multiplyByScalar(end, cT, result);
    return Quaternion.add(temp, result, result);
};
Quaternion.fastSquad = function (q0, q1, s0, s1, t, result) {
    if (!defined(q0) || !defined(q1) || !defined(s0) || !defined(s1)) {
        throw new DeveloperError('q0, q1, s0, and s1 are required.');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is required and must be a number.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required');
    }
    var slerp0 = Quaternion.fastSlerp(q0, q1, t, squadScratchQuaternion0);
    var slerp1 = Quaternion.fastSlerp(s0, s1, t, squadScratchQuaternion1);
    return Quaternion.fastSlerp(slerp0, slerp1, 2 * t * (1 - t), result);
};
Quaternion.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;
};
Quaternion.equalsEpsilon = function (left, right, epsilon) {
    if (typeof epsilon !== 'number') {
        throw new DeveloperError('epsilon is required and must be a number.');
    }
    return left === right || defined(left) && defined(right) && Math.abs(left.x - right.x) <= epsilon && Math.abs(left.y - right.y) <= epsilon && Math.abs(left.z - right.z) <= epsilon && Math.abs(left.w - right.w) <= epsilon;
};
Quaternion.ZERO = freezeObject(new Quaternion(0, 0, 0, 0));
Quaternion.IDENTITY = freezeObject(new Quaternion(0, 0, 0, 1));
Quaternion.prototype.clone = function (result) {
    return Quaternion.clone(this, result);
};
Quaternion.prototype.equals = function (right) {
    return Quaternion.equals(this, right);
};
Quaternion.prototype.equalsEpsilon = function (right, epsilon) {
    return Quaternion.equalsEpsilon(this, right, epsilon);
};
Quaternion.prototype.toString = function () {
    return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
};
module.exports = Quaternion;
},{"./Cartesian3":102,"./DeveloperError":123,"./FeatureDetection":141,"./Math":174,"./Matrix3":176,"./defaultValue":243,"./defined":245,"./freezeObject":249}],198:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Quaternion = require('./Quaternion'), Spline = require('./Spline');
'use strict';
function computeInnerQuadrangles(points, firstInnerQuadrangle, lastInnerQuadrangle) {
    var length = points.length;
    var quads = new Array(length);
    quads[0] = defined(firstInnerQuadrangle) ? firstInnerQuadrangle : points[0];
    quads[length - 1] = defined(lastInnerQuadrangle) ? lastInnerQuadrangle : points[length - 1];
    for (var i = 1; i < length - 1; ++i) {
        quads[i] = Quaternion.computeInnerQuadrangle(points[i - 1], points[i], points[i + 1], new Quaternion());
    }
    return quads;
}
function createEvaluateFunction(spline) {
    var points = spline.points;
    var quads = spline.innerQuadrangles;
    var times = spline.times;
    if (points.length < 3) {
        var t0 = times[0];
        var invSpan = 1 / (times[1] - t0);
        var q0 = points[0];
        var q1 = points[1];
        return function (time, result) {
            if (!defined(result)) {
                result = new Quaternion();
            }
            var u = (time - t0) * invSpan;
            return Quaternion.fastSlerp(q0, q1, u, result);
        };
    }
    return function (time, result) {
        if (!defined(result)) {
            result = new Quaternion();
        }
        var i = spline._lastTimeIndex = spline.findTimeInterval(time, spline._lastTimeIndex);
        var u = (time - times[i]) / (times[i + 1] - times[i]);
        var q0 = points[i];
        var q1 = points[i + 1];
        var s0 = quads[i];
        var s1 = quads[i + 1];
        return Quaternion.fastSquad(q0, q1, s0, s1, u, result);
    };
}
var QuaternionSpline = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var points = options.points;
    var times = options.times;
    var firstInnerQuadrangle = options.firstInnerQuadrangle;
    var lastInnerQuadrangle = options.lastInnerQuadrangle;
    if (!defined(points) || !defined(times)) {
        throw new DeveloperError('points and times are required.');
    }
    if (points.length < 2) {
        throw new DeveloperError('points.length must be greater than or equal to 2.');
    }
    if (times.length !== points.length) {
        throw new DeveloperError('times.length must be equal to points.length.');
    }
    var innerQuadrangles = computeInnerQuadrangles(points, firstInnerQuadrangle, lastInnerQuadrangle);
    this._times = times;
    this._points = points;
    this._innerQuadrangles = innerQuadrangles;
    this._evaluateFunction = createEvaluateFunction(this);
    this._lastTimeIndex = 0;
};
defineProperties(QuaternionSpline.prototype, {
    times: {
        get: function () {
            return this._times;
        }
    },
    points: {
        get: function () {
            return this._points;
        }
    },
    innerQuadrangles: {
        get: function () {
            return this._innerQuadrangles;
        }
    }
});
QuaternionSpline.prototype.findTimeInterval = Spline.prototype.findTimeInterval;
QuaternionSpline.prototype.evaluate = function (time, result) {
    return this._evaluateFunction(time, result);
};
module.exports = QuaternionSpline;
},{"./DeveloperError":123,"./Quaternion":197,"./Spline":216,"./defaultValue":243,"./defineProperties":244,"./defined":245}],199:[function(require,module,exports){
'use strict';
var Queue = function () {
    this._array = [];
    this._offset = 0;
    this.length = 0;
};
Queue.prototype.enqueue = function (item) {
    this._array.push(item);
    this.length++;
};
Queue.prototype.dequeue = function () {
    if (this.length === 0) {
        return undefined;
    }
    var array = this._array;
    var offset = this._offset;
    var item = array[offset];
    array[offset] = undefined;
    offset++;
    if (offset > 10 && offset * 2 > array.length) {
        this._array = array.slice(offset);
        offset = 0;
    }
    this._offset = offset;
    this.length--;
    return item;
};
Queue.prototype.contains = function (item) {
    return this._array.indexOf(item) !== -1;
};
Queue.prototype.clear = function () {
    this._array.length = this._offset = this.length = 0;
};
Queue.prototype.sort = function (compareFunction) {
    if (this._offset > 0) {
        this._array = this._array.slice(this._offset);
        this._offset = 0;
    }
    this._array.sort(compareFunction);
};
module.exports = Queue;
},{}],200:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var Ray = function (origin, direction) {
    direction = Cartesian3.clone(defaultValue(direction, Cartesian3.ZERO));
    if (!Cartesian3.equals(direction, Cartesian3.ZERO)) {
        Cartesian3.normalize(direction, direction);
    }
    this.origin = Cartesian3.clone(defaultValue(origin, Cartesian3.ZERO));
    this.direction = direction;
};
Ray.getPoint = function (ray, t, result) {
    if (!defined(ray)) {
        throw new DeveloperError('ray is requred');
    }
    if (typeof t !== 'number') {
        throw new DeveloperError('t is a required number');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    result = Cartesian3.multiplyByScalar(ray.direction, t, result);
    return Cartesian3.add(ray.origin, result, result);
};
module.exports = Ray;
},{"./Cartesian3":102,"./DeveloperError":123,"./defaultValue":243,"./defined":245}],201:[function(require,module,exports){
var Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), freezeObject = require('./freezeObject'), CesiumMath = require('./Math');
'use strict';
var Rectangle = function (west, south, east, north) {
    this.west = defaultValue(west, 0);
    this.south = defaultValue(south, 0);
    this.east = defaultValue(east, 0);
    this.north = defaultValue(north, 0);
};
defineProperties(Rectangle.prototype, {
    width: {
        get: function () {
            return Rectangle.computeWidth(this);
        }
    },
    height: {
        get: function () {
            return Rectangle.computeHeight(this);
        }
    }
});
Rectangle.packedLength = 4;
Rectangle.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.west;
    array[startingIndex++] = value.south;
    array[startingIndex++] = value.east;
    array[startingIndex] = value.north;
};
Rectangle.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Rectangle();
    }
    result.west = array[startingIndex++];
    result.south = array[startingIndex++];
    result.east = array[startingIndex++];
    result.north = array[startingIndex];
    return result;
};
Rectangle.computeWidth = function (rectangle) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    var east = rectangle.east;
    var west = rectangle.west;
    if (east < west) {
        east += CesiumMath.TWO_PI;
    }
    return east - west;
};
Rectangle.computeHeight = function (rectangle) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    return rectangle.north - rectangle.south;
};
Rectangle.fromDegrees = function (west, south, east, north, result) {
    west = CesiumMath.toRadians(defaultValue(west, 0));
    south = CesiumMath.toRadians(defaultValue(south, 0));
    east = CesiumMath.toRadians(defaultValue(east, 0));
    north = CesiumMath.toRadians(defaultValue(north, 0));
    if (!defined(result)) {
        return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
};
Rectangle.fromCartographicArray = function (cartographics, result) {
    if (!defined(cartographics)) {
        throw new DeveloperError('cartographics is required.');
    }
    var minLon = Number.MAX_VALUE;
    var maxLon = -Number.MAX_VALUE;
    var minLat = Number.MAX_VALUE;
    var maxLat = -Number.MAX_VALUE;
    for (var i = 0, len = cartographics.length; i < len; i++) {
        var position = cartographics[i];
        minLon = Math.min(minLon, position.longitude);
        maxLon = Math.max(maxLon, position.longitude);
        minLat = Math.min(minLat, position.latitude);
        maxLat = Math.max(maxLat, position.latitude);
    }
    if (!defined(result)) {
        return new Rectangle(minLon, minLat, maxLon, maxLat);
    }
    result.west = minLon;
    result.south = minLat;
    result.east = maxLon;
    result.north = maxLat;
    return result;
};
Rectangle.packedLength = 4;
Rectangle.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.west;
    array[startingIndex++] = value.south;
    array[startingIndex++] = value.east;
    array[startingIndex] = value.north;
};
Rectangle.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new Rectangle();
    }
    result.west = array[startingIndex++];
    result.south = array[startingIndex++];
    result.east = array[startingIndex++];
    result.north = array[startingIndex];
    return result;
};
Rectangle.clone = function (rectangle, result) {
    if (!defined(rectangle)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Rectangle(rectangle.west, rectangle.south, rectangle.east, rectangle.north);
    }
    result.west = rectangle.west;
    result.south = rectangle.south;
    result.east = rectangle.east;
    result.north = rectangle.north;
    return result;
};
Rectangle.prototype.clone = function (result) {
    return Rectangle.clone(this, result);
};
Rectangle.prototype.equals = function (other) {
    return Rectangle.equals(this, other);
};
Rectangle.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.west === right.west && left.south === right.south && left.east === right.east && left.north === right.north;
};
Rectangle.prototype.equalsEpsilon = function (other, epsilon) {
    if (typeof epsilon !== 'number') {
        throw new DeveloperError('epsilon is required and must be a number.');
    }
    return defined(other) && Math.abs(this.west - other.west) <= epsilon && Math.abs(this.south - other.south) <= epsilon && Math.abs(this.east - other.east) <= epsilon && Math.abs(this.north - other.north) <= epsilon;
};
Rectangle.validate = function (rectangle) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    var north = rectangle.north;
    if (typeof north !== 'number') {
        throw new DeveloperError('north is required to be a number.');
    }
    if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO) {
        throw new DeveloperError('north must be in the interval [-Pi/2, Pi/2].');
    }
    var south = rectangle.south;
    if (typeof south !== 'number') {
        throw new DeveloperError('south is required to be a number.');
    }
    if (south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {
        throw new DeveloperError('south must be in the interval [-Pi/2, Pi/2].');
    }
    var west = rectangle.west;
    if (typeof west !== 'number') {
        throw new DeveloperError('west is required to be a number.');
    }
    if (west < -Math.PI || west > Math.PI) {
        throw new DeveloperError('west must be in the interval [-Pi, Pi].');
    }
    var east = rectangle.east;
    if (typeof east !== 'number') {
        throw new DeveloperError('east is required to be a number.');
    }
    if (east < -Math.PI || east > Math.PI) {
        throw new DeveloperError('east must be in the interval [-Pi, Pi].');
    }
};
Rectangle.southwest = function (rectangle, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    if (!defined(result)) {
        return new Cartographic(rectangle.west, rectangle.south);
    }
    result.longitude = rectangle.west;
    result.latitude = rectangle.south;
    result.height = 0;
    return result;
};
Rectangle.northwest = function (rectangle, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    if (!defined(result)) {
        return new Cartographic(rectangle.west, rectangle.north);
    }
    result.longitude = rectangle.west;
    result.latitude = rectangle.north;
    result.height = 0;
    return result;
};
Rectangle.northeast = function (rectangle, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    if (!defined(result)) {
        return new Cartographic(rectangle.east, rectangle.north);
    }
    result.longitude = rectangle.east;
    result.latitude = rectangle.north;
    result.height = 0;
    return result;
};
Rectangle.southeast = function (rectangle, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    if (!defined(result)) {
        return new Cartographic(rectangle.east, rectangle.south);
    }
    result.longitude = rectangle.east;
    result.latitude = rectangle.south;
    result.height = 0;
    return result;
};
Rectangle.center = function (rectangle, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    var east = rectangle.east;
    var west = rectangle.west;
    if (east < west) {
        east += CesiumMath.TWO_PI;
    }
    var longitude = CesiumMath.negativePiToPi((west + east) * 0.5);
    var latitude = (rectangle.south + rectangle.north) * 0.5;
    if (!defined(result)) {
        return new Cartographic(longitude, latitude);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = 0;
    return result;
};
Rectangle.intersection = function (rectangle, otherRectangle, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    if (!defined(otherRectangle)) {
        throw new DeveloperError('otherRectangle is required.');
    }
    var rectangleEast = rectangle.east;
    var rectangleWest = rectangle.west;
    var otherRectangleEast = otherRectangle.east;
    var otherRectangleWest = otherRectangle.west;
    if (rectangleEast < rectangleWest && otherRectangleEast > 0) {
        rectangleEast += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleEast > 0) {
        otherRectangleEast += CesiumMath.TWO_PI;
    }
    if (rectangleEast < rectangleWest && otherRectangleWest < 0) {
        otherRectangleWest += CesiumMath.TWO_PI;
    } else if (otherRectangleEast < otherRectangleWest && rectangleWest < 0) {
        rectangleWest += CesiumMath.TWO_PI;
    }
    var west = CesiumMath.negativePiToPi(Math.max(rectangleWest, otherRectangleWest));
    var east = CesiumMath.negativePiToPi(Math.min(rectangleEast, otherRectangleEast));
    if ((rectangle.west < rectangle.east || otherRectangle.west < otherRectangle.east) && east <= west) {
        return undefined;
    }
    var south = Math.max(rectangle.south, otherRectangle.south);
    var north = Math.min(rectangle.north, otherRectangle.north);
    if (south >= north) {
        return undefined;
    }
    if (!defined(result)) {
        return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
};
Rectangle.contains = function (rectangle, cartographic) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    if (!defined(cartographic)) {
        throw new DeveloperError('cartographic is required.');
    }
    var longitude = cartographic.longitude;
    var latitude = cartographic.latitude;
    var west = rectangle.west;
    var east = rectangle.east;
    if (east < west) {
        east += CesiumMath.TWO_PI;
        if (longitude < 0) {
            longitude += CesiumMath.TWO_PI;
        }
    }
    return (longitude > west || CesiumMath.equalsEpsilon(longitude, west, CesiumMath.EPSILON14)) && (longitude < east || CesiumMath.equalsEpsilon(longitude, east, CesiumMath.EPSILON14)) && latitude >= rectangle.south && latitude <= rectangle.north;
};
var subsampleLlaScratch = new Cartographic();
Rectangle.subsample = function (rectangle, ellipsoid, surfaceHeight, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    surfaceHeight = defaultValue(surfaceHeight, 0);
    if (!defined(result)) {
        result = [];
    }
    var length = 0;
    var north = rectangle.north;
    var south = rectangle.south;
    var east = rectangle.east;
    var west = rectangle.west;
    var lla = subsampleLlaScratch;
    lla.height = surfaceHeight;
    lla.longitude = west;
    lla.latitude = north;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.longitude = east;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.latitude = south;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    lla.longitude = west;
    result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
    length++;
    if (north < 0) {
        lla.latitude = north;
    } else if (south > 0) {
        lla.latitude = south;
    } else {
        lla.latitude = 0;
    }
    for (var i = 1; i < 8; ++i) {
        lla.longitude = -Math.PI + i * CesiumMath.PI_OVER_TWO;
        if (Rectangle.contains(rectangle, lla)) {
            result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
            length++;
        }
    }
    if (lla.latitude === 0) {
        lla.longitude = west;
        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
        length++;
        lla.longitude = east;
        result[length] = ellipsoid.cartographicToCartesian(lla, result[length]);
        length++;
    }
    result.length = length;
    return result;
};
Rectangle.MAX_VALUE = freezeObject(new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));
module.exports = Rectangle;
},{"./Cartographic":104,"./DeveloperError":123,"./Ellipsoid":130,"./Math":174,"./defaultValue":243,"./defineProperties":244,"./defined":245,"./freezeObject":249}],202:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), GeometryInstance = require('./GeometryInstance'), GeometryPipeline = require('./GeometryPipeline'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), Matrix2 = require('./Matrix2'), Matrix3 = require('./Matrix3'), PolygonPipeline = require('./PolygonPipeline'), PrimitiveType = require('./PrimitiveType'), Quaternion = require('./Quaternion'), Rectangle = require('./Rectangle'), RectangleGeometryLibrary = require('./RectangleGeometryLibrary'), VertexFormat = require('./VertexFormat');
'use strict';
var positionScratch = new Cartesian3();
var normalScratch = new Cartesian3();
var tangentScratch = new Cartesian3();
var binormalScratch = new Cartesian3();
var rectangleScratch = new Rectangle();
var stScratch = new Cartesian2();
var bottomBoundingSphere = new BoundingSphere();
var topBoundingSphere = new BoundingSphere();
function createAttributes(vertexFormat, attributes) {
    var geo = new Geometry({
            attributes: new GeometryAttributes(),
            primitiveType: PrimitiveType.TRIANGLES
        });
    geo.attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: attributes.positions
    });
    if (vertexFormat.normal) {
        geo.attributes.normal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: attributes.normals
        });
    }
    if (vertexFormat.tangent) {
        geo.attributes.tangent = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: attributes.tangents
        });
    }
    if (vertexFormat.binormal) {
        geo.attributes.binormal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: attributes.binormals
        });
    }
    return geo;
}
function calculateAttributes(positions, vertexFormat, ellipsoid, tangentRotationMatrix) {
    var length = positions.length;
    var normals = vertexFormat.normal ? new Float32Array(length) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(length) : undefined;
    var attrIndex = 0;
    var binormal = binormalScratch;
    var tangent = tangentScratch;
    var normal = normalScratch;
    for (var i = 0; i < length; i += 3) {
        var p = Cartesian3.fromArray(positions, i, positionScratch);
        var attrIndex1 = attrIndex + 1;
        var attrIndex2 = attrIndex + 2;
        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {
            normal = ellipsoid.geodeticSurfaceNormal(p, normal);
            if (vertexFormat.tangent || vertexFormat.binormal) {
                Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);
                Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent);
                Cartesian3.normalize(tangent, tangent);
                if (vertexFormat.binormal) {
                    Cartesian3.normalize(Cartesian3.cross(normal, tangent, binormal), binormal);
                }
            }
            if (vertexFormat.normal) {
                normals[attrIndex] = normal.x;
                normals[attrIndex1] = normal.y;
                normals[attrIndex2] = normal.z;
            }
            if (vertexFormat.tangent) {
                tangents[attrIndex] = tangent.x;
                tangents[attrIndex1] = tangent.y;
                tangents[attrIndex2] = tangent.z;
            }
            if (vertexFormat.binormal) {
                binormals[attrIndex] = binormal.x;
                binormals[attrIndex1] = binormal.y;
                binormals[attrIndex2] = binormal.z;
            }
        }
        attrIndex += 3;
    }
    return createAttributes(vertexFormat, {
        positions: positions,
        normals: normals,
        tangents: tangents,
        binormals: binormals
    });
}
var v1Scratch = new Cartesian3();
var v2Scratch = new Cartesian3();
function calculateAttributesWall(positions, vertexFormat, ellipsoid) {
    var length = positions.length;
    var normals = vertexFormat.normal ? new Float32Array(length) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(length) : undefined;
    var normalIndex = 0;
    var tangentIndex = 0;
    var binormalIndex = 0;
    var recomputeNormal = true;
    var binormal = binormalScratch;
    var tangent = tangentScratch;
    var normal = normalScratch;
    for (var i = 0; i < length; i += 6) {
        var p = Cartesian3.fromArray(positions, i, positionScratch);
        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {
            var p1 = Cartesian3.fromArray(positions, (i + 6) % length, v1Scratch);
            if (recomputeNormal) {
                var p2 = Cartesian3.fromArray(positions, (i + 3) % length, v2Scratch);
                Cartesian3.subtract(p1, p, p1);
                Cartesian3.subtract(p2, p, p2);
                normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);
                recomputeNormal = false;
            }
            if (Cartesian3.equalsEpsilon(p1, p, CesiumMath.EPSILON10)) {
                recomputeNormal = true;
            }
            if (vertexFormat.tangent || vertexFormat.binormal) {
                binormal = ellipsoid.geodeticSurfaceNormal(p, binormal);
                if (vertexFormat.tangent) {
                    tangent = Cartesian3.normalize(Cartesian3.cross(binormal, normal, tangent), tangent);
                }
            }
            if (vertexFormat.normal) {
                normals[normalIndex++] = normal.x;
                normals[normalIndex++] = normal.y;
                normals[normalIndex++] = normal.z;
                normals[normalIndex++] = normal.x;
                normals[normalIndex++] = normal.y;
                normals[normalIndex++] = normal.z;
            }
            if (vertexFormat.tangent) {
                tangents[tangentIndex++] = tangent.x;
                tangents[tangentIndex++] = tangent.y;
                tangents[tangentIndex++] = tangent.z;
                tangents[tangentIndex++] = tangent.x;
                tangents[tangentIndex++] = tangent.y;
                tangents[tangentIndex++] = tangent.z;
            }
            if (vertexFormat.binormal) {
                binormals[binormalIndex++] = binormal.x;
                binormals[binormalIndex++] = binormal.y;
                binormals[binormalIndex++] = binormal.z;
                binormals[binormalIndex++] = binormal.x;
                binormals[binormalIndex++] = binormal.y;
                binormals[binormalIndex++] = binormal.z;
            }
        }
    }
    return createAttributes(vertexFormat, {
        positions: positions,
        normals: normals,
        tangents: tangents,
        binormals: binormals
    });
}
function constructRectangle(options) {
    var vertexFormat = options.vertexFormat;
    var ellipsoid = options.ellipsoid;
    var size = options.size;
    var height = options.height;
    var width = options.width;
    var positions = vertexFormat.position ? new Float64Array(size * 3) : undefined;
    var textureCoordinates = vertexFormat.st ? new Float32Array(size * 2) : undefined;
    var posIndex = 0;
    var stIndex = 0;
    var position = positionScratch;
    var st = stScratch;
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = Number.MIN_VALUE;
    var maxY = Number.MIN_VALUE;
    for (var row = 0; row < height; ++row) {
        for (var col = 0; col < width; ++col) {
            RectangleGeometryLibrary.computePosition(options, row, col, position, st);
            positions[posIndex++] = position.x;
            positions[posIndex++] = position.y;
            positions[posIndex++] = position.z;
            if (vertexFormat.st) {
                textureCoordinates[stIndex++] = st.x;
                textureCoordinates[stIndex++] = st.y;
                minX = Math.min(minX, st.x);
                minY = Math.min(minY, st.y);
                maxX = Math.max(maxX, st.x);
                maxY = Math.max(maxY, st.y);
            }
        }
    }
    if (vertexFormat.st && (minX < 0 || minY < 0 || maxX > 1 || maxY > 1)) {
        for (var k = 0; k < textureCoordinates.length; k += 2) {
            textureCoordinates[k] = (textureCoordinates[k] - minX) / (maxX - minX);
            textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minY) / (maxY - minY);
        }
    }
    var geo = calculateAttributes(positions, vertexFormat, ellipsoid, options.tangentRotationMatrix);
    var indicesSize = 6 * (width - 1) * (height - 1);
    var indices = IndexDatatype.createTypedArray(size, indicesSize);
    var index = 0;
    var indicesIndex = 0;
    for (var i = 0; i < height - 1; ++i) {
        for (var j = 0; j < width - 1; ++j) {
            var upperLeft = index;
            var lowerLeft = upperLeft + width;
            var lowerRight = lowerLeft + 1;
            var upperRight = upperLeft + 1;
            indices[indicesIndex++] = upperLeft;
            indices[indicesIndex++] = lowerLeft;
            indices[indicesIndex++] = upperRight;
            indices[indicesIndex++] = upperRight;
            indices[indicesIndex++] = lowerLeft;
            indices[indicesIndex++] = lowerRight;
            ++index;
        }
        ++index;
    }
    geo.indices = indices;
    if (vertexFormat.st) {
        geo.attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: textureCoordinates
        });
    }
    return geo;
}
function addWallPositions(wallPositions, posIndex, i, topPositions, bottomPositions) {
    wallPositions[posIndex++] = topPositions[i];
    wallPositions[posIndex++] = topPositions[i + 1];
    wallPositions[posIndex++] = topPositions[i + 2];
    wallPositions[posIndex++] = bottomPositions[i];
    wallPositions[posIndex++] = bottomPositions[i + 1];
    wallPositions[posIndex++] = bottomPositions[i + 2];
    return wallPositions;
}
function addWallTextureCoordinates(wallTextures, stIndex, i, st) {
    wallTextures[stIndex++] = st[i];
    wallTextures[stIndex++] = st[i + 1];
    wallTextures[stIndex++] = st[i];
    wallTextures[stIndex++] = st[i + 1];
    return wallTextures;
}
function constructExtrudedRectangle(options) {
    var vertexFormat = options.vertexFormat;
    var surfaceHeight = options.surfaceHeight;
    var extrudedHeight = options.extrudedHeight;
    var minHeight = Math.min(extrudedHeight, surfaceHeight);
    var maxHeight = Math.max(extrudedHeight, surfaceHeight);
    var height = options.height;
    var width = options.width;
    var ellipsoid = options.ellipsoid;
    var i;
    var topBottomGeo = constructRectangle(options);
    if (CesiumMath.equalsEpsilon(minHeight, maxHeight, 0.1)) {
        return topBottomGeo;
    }
    topBottomGeo = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo, maxHeight, ellipsoid, false);
    var topPositions = new Float64Array(topBottomGeo.attributes.position.values);
    var length = topPositions.length;
    var newLength = length * 2;
    var positions = new Float64Array(newLength);
    positions.set(topPositions);
    topBottomGeo = PolygonPipeline.scaleToGeodeticHeight(topBottomGeo, minHeight, ellipsoid);
    var bottomPositions = topBottomGeo.attributes.position.values;
    positions.set(bottomPositions, length);
    topBottomGeo.attributes.position.values = positions;
    var normals = vertexFormat.normal ? new Float32Array(newLength) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(newLength) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(newLength) : undefined;
    var textures = vertexFormat.st ? new Float32Array(newLength / 3 * 2) : undefined;
    var topSt;
    if (vertexFormat.normal) {
        var topNormals = topBottomGeo.attributes.normal.values;
        normals.set(topNormals);
        for (i = 0; i < length; i++) {
            topNormals[i] = -topNormals[i];
        }
        normals.set(topNormals, length);
        topBottomGeo.attributes.normal.values = normals;
    }
    if (vertexFormat.tangent) {
        var topTangents = topBottomGeo.attributes.tangent.values;
        tangents.set(topTangents);
        for (i = 0; i < length; i++) {
            topTangents[i] = -topTangents[i];
        }
        tangents.set(topTangents, length);
        topBottomGeo.attributes.tangent.values = tangents;
    }
    if (vertexFormat.binormal) {
        var topBinormals = topBottomGeo.attributes.binormal.values;
        binormals.set(topBinormals);
        binormals.set(topBinormals, length);
        topBottomGeo.attributes.binormal.values = binormals;
    }
    if (vertexFormat.st) {
        topSt = topBottomGeo.attributes.st.values;
        textures.set(topSt);
        textures.set(topSt, length / 3 * 2);
        topBottomGeo.attributes.st.values = textures;
    }
    var indices = topBottomGeo.indices;
    var indicesLength = indices.length;
    var posLength = length / 3;
    var newIndices = IndexDatatype.createTypedArray(newLength / 3, indicesLength * 2);
    newIndices.set(indices);
    for (i = 0; i < indicesLength; i += 3) {
        newIndices[i + indicesLength] = indices[i + 2] + posLength;
        newIndices[i + 1 + indicesLength] = indices[i + 1] + posLength;
        newIndices[i + 2 + indicesLength] = indices[i] + posLength;
    }
    topBottomGeo.indices = newIndices;
    var perimeterPositions = 2 * width + 2 * height - 4;
    var wallCount = (perimeterPositions + 4) * 2;
    var wallPositions = new Float64Array(wallCount * 3);
    var wallTextures = vertexFormat.st ? new Float32Array(wallCount * 2) : undefined;
    var posIndex = 0;
    var stIndex = 0;
    var area = width * height;
    for (i = 0; i < area; i += width) {
        wallPositions = addWallPositions(wallPositions, posIndex, i * 3, topPositions, bottomPositions);
        posIndex += 6;
        if (vertexFormat.st) {
            wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);
            stIndex += 4;
        }
    }
    for (i = area - width; i < area; i++) {
        wallPositions = addWallPositions(wallPositions, posIndex, i * 3, topPositions, bottomPositions);
        posIndex += 6;
        if (vertexFormat.st) {
            wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);
            stIndex += 4;
        }
    }
    for (i = area - 1; i > 0; i -= width) {
        wallPositions = addWallPositions(wallPositions, posIndex, i * 3, topPositions, bottomPositions);
        posIndex += 6;
        if (vertexFormat.st) {
            wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);
            stIndex += 4;
        }
    }
    for (i = width - 1; i >= 0; i--) {
        wallPositions = addWallPositions(wallPositions, posIndex, i * 3, topPositions, bottomPositions);
        posIndex += 6;
        if (vertexFormat.st) {
            wallTextures = addWallTextureCoordinates(wallTextures, stIndex, i * 2, topSt);
            stIndex += 4;
        }
    }
    var geo = calculateAttributesWall(wallPositions, vertexFormat, ellipsoid);
    if (vertexFormat.st) {
        geo.attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: wallTextures
        });
    }
    var wallIndices = IndexDatatype.createTypedArray(wallCount, perimeterPositions * 6);
    var upperLeft;
    var lowerLeft;
    var lowerRight;
    var upperRight;
    length = wallPositions.length / 3;
    var index = 0;
    for (i = 0; i < length - 1; i += 2) {
        upperLeft = i;
        upperRight = (upperLeft + 2) % length;
        var p1 = Cartesian3.fromArray(wallPositions, upperLeft * 3, v1Scratch);
        var p2 = Cartesian3.fromArray(wallPositions, upperRight * 3, v2Scratch);
        if (Cartesian3.equalsEpsilon(p1, p2, CesiumMath.EPSILON10)) {
            continue;
        }
        lowerLeft = (upperLeft + 1) % length;
        lowerRight = (lowerLeft + 2) % length;
        wallIndices[index++] = upperLeft;
        wallIndices[index++] = lowerLeft;
        wallIndices[index++] = upperRight;
        wallIndices[index++] = upperRight;
        wallIndices[index++] = lowerLeft;
        wallIndices[index++] = lowerRight;
    }
    geo.indices = wallIndices;
    geo = GeometryPipeline.combineInstances([
        new GeometryInstance({ geometry: topBottomGeo }),
        new GeometryInstance({ geometry: geo })
    ]);
    return geo[0];
}
var RectangleGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var rectangle = options.rectangle;
    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var surfaceHeight = defaultValue(options.height, 0);
    var rotation = defaultValue(options.rotation, 0);
    var stRotation = defaultValue(options.stRotation, 0);
    var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
    var extrudedHeight = options.extrudedHeight;
    var extrude = defined(extrudedHeight) && Math.abs(surfaceHeight - extrudedHeight) > 1;
    var closeTop = defaultValue(options.closeTop, true);
    var closeBottom = defaultValue(options.closeBottom, true);
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    Rectangle.validate(rectangle);
    if (rectangle.north < rectangle.south) {
        throw new DeveloperError('options.rectangle.north must be greater than options.rectangle.south');
    }
    this._rectangle = rectangle;
    this._granularity = granularity;
    this._ellipsoid = Ellipsoid.clone(ellipsoid);
    this._surfaceHeight = surfaceHeight;
    this._rotation = rotation;
    this._stRotation = stRotation;
    this._vertexFormat = VertexFormat.clone(vertexFormat);
    this._extrudedHeight = defaultValue(extrudedHeight, 0);
    this._extrude = extrude;
    this._closeTop = closeTop;
    this._closeBottom = closeBottom;
    this._workerName = 'createRectangleGeometry';
};
RectangleGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 8;
RectangleGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Rectangle.pack(value._rectangle, array, startingIndex);
    startingIndex += Rectangle.packedLength;
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex++] = value._granularity;
    array[startingIndex++] = value._surfaceHeight;
    array[startingIndex++] = value._rotation;
    array[startingIndex++] = value._stRotation;
    array[startingIndex++] = value._extrudedHeight;
    array[startingIndex++] = value._extrude ? 1 : 0;
    array[startingIndex++] = value._closeTop ? 1 : 0;
    array[startingIndex] = value._closeBottom ? 1 : 0;
};
var scratchRectangle = new Rectangle();
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        rectangle: scratchRectangle,
        ellipsoid: scratchEllipsoid,
        vertexFormat: scratchVertexFormat,
        granularity: undefined,
        height: undefined,
        rotation: undefined,
        stRotation: undefined,
        extrudedHeight: undefined,
        closeTop: undefined,
        closeBottom: undefined
    };
RectangleGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);
    startingIndex += Rectangle.packedLength;
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var granularity = array[startingIndex++];
    var surfaceHeight = array[startingIndex++];
    var rotation = array[startingIndex++];
    var stRotation = array[startingIndex++];
    var extrudedHeight = array[startingIndex++];
    var extrude = array[startingIndex++] === 1;
    var closeTop = array[startingIndex++] === 1;
    var closeBottom = array[startingIndex] === 1;
    if (!defined(result)) {
        scratchOptions.granularity = granularity;
        scratchOptions.height = surfaceHeight;
        scratchOptions.rotation = rotation;
        scratchOptions.stRotation = stRotation;
        scratchOptions.extrudedHeight = extrude ? extrudedHeight : undefined;
        scratchOptions.closeTop = closeTop;
        scratchOptions.closeBottom = closeBottom;
        return new RectangleGeometry(scratchOptions);
    }
    result._rectangle = Rectangle.clone(rectangle, result._rectangle);
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._granularity = granularity;
    result._surfaceHeight = surfaceHeight;
    result._rotation = rotation;
    result._stRotation = stRotation;
    result._extrudedHeight = extrude ? extrudedHeight : undefined;
    result._extrude = extrude;
    result._closeTop = closeTop;
    result._closeBottom = closeBottom;
    return result;
};
var textureMatrixScratch = new Matrix2();
var tangentRotationMatrixScratch = new Matrix3();
var nwScratch = new Cartographic();
var quaternionScratch = new Quaternion();
var centerScratch = new Cartographic();
RectangleGeometry.createGeometry = function (rectangleGeometry) {
    var rectangle = Rectangle.clone(rectangleGeometry._rectangle, rectangleScratch);
    var ellipsoid = rectangleGeometry._ellipsoid;
    var surfaceHeight = rectangleGeometry._surfaceHeight;
    var extrude = rectangleGeometry._extrude;
    var extrudedHeight = rectangleGeometry._extrudedHeight;
    var stRotation = rectangleGeometry._stRotation;
    var vertexFormat = rectangleGeometry._vertexFormat;
    var options = RectangleGeometryLibrary.computeOptions(rectangleGeometry, rectangle, nwScratch);
    var textureMatrix = textureMatrixScratch;
    var tangentRotationMatrix = tangentRotationMatrixScratch;
    if (defined(stRotation)) {
        Matrix2.fromRotation(-stRotation, textureMatrix);
        var center = Rectangle.center(rectangle, centerScratch);
        var axis = ellipsoid.cartographicToCartesian(center, v1Scratch);
        Cartesian3.normalize(axis, axis);
        Quaternion.fromAxisAngle(axis, -stRotation, quaternionScratch);
        Matrix3.fromQuaternion(quaternionScratch, tangentRotationMatrix);
    } else {
        Matrix2.clone(Matrix2.IDENTITY, textureMatrix);
        Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);
    }
    options.lonScalar = 1 / rectangle.width;
    options.latScalar = 1 / rectangle.height;
    options.vertexFormat = vertexFormat;
    options.textureMatrix = textureMatrix;
    options.tangentRotationMatrix = tangentRotationMatrix;
    options.size = options.width * options.height;
    var geometry;
    var boundingSphere;
    rectangle = rectangleGeometry._rectangle;
    if (extrude) {
        geometry = constructExtrudedRectangle(options);
        var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);
        var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);
        boundingSphere = BoundingSphere.union(topBS, bottomBS);
    } else {
        geometry = constructRectangle(options);
        geometry = PolygonPipeline.scaleToGeodeticHeight(geometry, surfaceHeight, ellipsoid, false);
        boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);
    }
    if (!vertexFormat.position) {
        delete geometry.attributes.position;
    }
    return new Geometry({
        attributes: new GeometryAttributes(geometry.attributes),
        indices: geometry.indices,
        primitiveType: geometry.primitiveType,
        boundingSphere: boundingSphere
    });
};
module.exports = RectangleGeometry;
},{"./BoundingSphere":98,"./Cartesian2":101,"./Cartesian3":102,"./Cartographic":104,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./GeometryInstance":148,"./GeometryPipeline":150,"./IndexDatatype":162,"./Math":174,"./Matrix2":175,"./Matrix3":176,"./PolygonPipeline":187,"./PrimitiveType":193,"./Quaternion":197,"./Rectangle":201,"./RectangleGeometryLibrary":203,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],203:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), GeographicProjection = require('./GeographicProjection'), CesiumMath = require('./Math'), Matrix2 = require('./Matrix2'), Rectangle = require('./Rectangle');
'use strict';
var cos = Math.cos;
var sin = Math.sin;
var sqrt = Math.sqrt;
var RectangleGeometryLibrary = {};
RectangleGeometryLibrary.computePosition = function (options, row, col, position, st) {
    var radiiSquared = options.ellipsoid.radiiSquared;
    var nwCorner = options.nwCorner;
    var rectangle = options.rectangle;
    var stLatitude = nwCorner.latitude - options.granYCos * row + col * options.granXSin;
    var cosLatitude = cos(stLatitude);
    var nZ = sin(stLatitude);
    var kZ = radiiSquared.z * nZ;
    var stLongitude = nwCorner.longitude + row * options.granYSin + col * options.granXCos;
    var nX = cosLatitude * cos(stLongitude);
    var nY = cosLatitude * sin(stLongitude);
    var kX = radiiSquared.x * nX;
    var kY = radiiSquared.y * nY;
    var gamma = sqrt(kX * nX + kY * nY + kZ * nZ);
    position.x = kX / gamma;
    position.y = kY / gamma;
    position.z = kZ / gamma;
    if (defined(options.vertexFormat) && options.vertexFormat.st) {
        st.x = (stLongitude - rectangle.west) * options.lonScalar - 0.5;
        st.y = (stLatitude - rectangle.south) * options.latScalar - 0.5;
        Matrix2.multiplyByVector(options.textureMatrix, st, st);
        st.x += 0.5;
        st.y += 0.5;
    }
};
var rotationMatrixScratch = new Matrix2();
var nwCartesian = new Cartesian3();
var centerScratch = new Cartographic();
var centerCartesian = new Cartesian3();
var proj = new GeographicProjection();
RectangleGeometryLibrary.computeOptions = function (geometry, rectangle, nwCorner) {
    var granularity = geometry._granularity;
    var ellipsoid = geometry._ellipsoid;
    var surfaceHeight = geometry._surfaceHeight;
    var rotation = geometry._rotation;
    var extrudedHeight = geometry._extrudedHeight;
    var east = rectangle.east;
    var west = rectangle.west;
    var north = rectangle.north;
    var south = rectangle.south;
    var width;
    var height;
    var granularityX;
    var granularityY;
    var dx;
    var dy = north - south;
    if (west > east) {
        dx = CesiumMath.TWO_PI - west + east;
        width = Math.ceil(dx / granularity) + 1;
        height = Math.ceil(dy / granularity) + 1;
        granularityX = dx / (width - 1);
        granularityY = dy / (height - 1);
    } else {
        dx = east - west;
        width = Math.ceil(dx / granularity) + 1;
        height = Math.ceil(dy / granularity) + 1;
        granularityX = dx / (width - 1);
        granularityY = dy / (height - 1);
    }
    nwCorner = Rectangle.northwest(rectangle, nwCorner);
    var center = Rectangle.center(rectangle, centerScratch);
    var granYCos = granularityY;
    var granXCos = granularityX;
    var granYSin = 0;
    var granXSin = 0;
    if (defined(rotation)) {
        var cosRotation = Math.cos(rotation);
        granYCos *= cosRotation;
        granXCos *= cosRotation;
        var sinRotation = Math.sin(rotation);
        granYSin = granularityY * sinRotation;
        granXSin = granularityX * sinRotation;
        nwCartesian = proj.project(nwCorner, nwCartesian);
        centerCartesian = proj.project(center, centerCartesian);
        nwCartesian = Cartesian3.subtract(nwCartesian, centerCartesian, nwCartesian);
        var rotationMatrix = Matrix2.fromRotation(rotation, rotationMatrixScratch);
        nwCartesian = Matrix2.multiplyByVector(rotationMatrix, nwCartesian, nwCartesian);
        nwCartesian = Cartesian3.add(nwCartesian, centerCartesian, nwCartesian);
        nwCorner = proj.unproject(nwCartesian, nwCorner);
        var latitude = nwCorner.latitude;
        var latitude0 = latitude + (width - 1) * granXSin;
        var latitude1 = latitude - granYCos * (height - 1);
        var latitude2 = latitude - granYCos * (height - 1) + (width - 1) * granXSin;
        north = Math.max(latitude, latitude0, latitude1, latitude2);
        south = Math.min(latitude, latitude0, latitude1, latitude2);
        var longitude = nwCorner.longitude;
        var longitude0 = longitude + (width - 1) * granXCos;
        var longitude1 = longitude + (height - 1) * granYSin;
        var longitude2 = longitude + (height - 1) * granYSin + (width - 1) * granXCos;
        east = Math.max(longitude, longitude0, longitude1, longitude2);
        west = Math.min(longitude, longitude0, longitude1, longitude2);
        if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO || south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {
            throw new DeveloperError('Rotated extent is invalid.');
        }
        rectangle.north = north;
        rectangle.south = south;
        rectangle.east = east;
        rectangle.west = west;
    }
    return {
        granYCos: granYCos,
        granYSin: granYSin,
        granXCos: granXCos,
        granXSin: granXSin,
        ellipsoid: ellipsoid,
        width: width,
        height: height,
        surfaceHeight: surfaceHeight,
        extrudedHeight: extrudedHeight,
        nwCorner: nwCorner,
        rectangle: rectangle
    };
};
module.exports = RectangleGeometryLibrary;
},{"./Cartesian3":102,"./Cartographic":104,"./DeveloperError":123,"./GeographicProjection":143,"./Math":174,"./Matrix2":175,"./Rectangle":201,"./defined":245}],204:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PolygonPipeline = require('./PolygonPipeline'), PrimitiveType = require('./PrimitiveType'), Rectangle = require('./Rectangle'), RectangleGeometryLibrary = require('./RectangleGeometryLibrary');
'use strict';
var bottomBoundingSphere = new BoundingSphere();
var topBoundingSphere = new BoundingSphere();
var positionScratch = new Cartesian3();
var rectangleScratch = new Rectangle();
function constructRectangle(options) {
    var size = options.size;
    var height = options.height;
    var width = options.width;
    var positions = new Float64Array(size * 3);
    var posIndex = 0;
    var row = 0;
    var col;
    var position = positionScratch;
    for (col = 0; col < width; col++) {
        RectangleGeometryLibrary.computePosition(options, row, col, position);
        positions[posIndex++] = position.x;
        positions[posIndex++] = position.y;
        positions[posIndex++] = position.z;
    }
    col = width - 1;
    for (row = 1; row < height; row++) {
        RectangleGeometryLibrary.computePosition(options, row, col, position);
        positions[posIndex++] = position.x;
        positions[posIndex++] = position.y;
        positions[posIndex++] = position.z;
    }
    row = height - 1;
    for (col = width - 2; col >= 0; col--) {
        RectangleGeometryLibrary.computePosition(options, row, col, position);
        positions[posIndex++] = position.x;
        positions[posIndex++] = position.y;
        positions[posIndex++] = position.z;
    }
    col = 0;
    for (row = height - 2; row > 0; row--) {
        RectangleGeometryLibrary.computePosition(options, row, col, position);
        positions[posIndex++] = position.x;
        positions[posIndex++] = position.y;
        positions[posIndex++] = position.z;
    }
    var indicesSize = positions.length / 3 * 2;
    var indices = IndexDatatype.createTypedArray(positions.length / 3, indicesSize);
    var index = 0;
    for (var i = 0; i < positions.length / 3 - 1; i++) {
        indices[index++] = i;
        indices[index++] = i + 1;
    }
    indices[index++] = positions.length / 3 - 1;
    indices[index++] = 0;
    var geo = new Geometry({
            attributes: new GeometryAttributes(),
            primitiveType: PrimitiveType.LINES
        });
    geo.attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: positions
    });
    geo.indices = indices;
    return geo;
}
function constructExtrudedRectangle(options) {
    var surfaceHeight = options.surfaceHeight;
    var extrudedHeight = options.extrudedHeight;
    var ellipsoid = options.ellipsoid;
    var minHeight = Math.min(extrudedHeight, surfaceHeight);
    var maxHeight = Math.max(extrudedHeight, surfaceHeight);
    var geo = constructRectangle(options);
    if (CesiumMath.equalsEpsilon(minHeight, maxHeight, 0.1)) {
        return geo;
    }
    var height = options.height;
    var width = options.width;
    geo = PolygonPipeline.scaleToGeodeticHeight(geo, maxHeight, ellipsoid, false);
    var topPositions = geo.attributes.position.values;
    var length = topPositions.length;
    var positions = new Float64Array(length * 2);
    positions.set(topPositions);
    geo = PolygonPipeline.scaleToGeodeticHeight(geo, minHeight, ellipsoid);
    var bottomPositions = geo.attributes.position.values;
    positions.set(bottomPositions, length);
    geo.attributes.position.values = positions;
    var indicesSize = positions.length / 3 * 2 + 8;
    var indices = IndexDatatype.createTypedArray(positions.length / 3, indicesSize);
    length = positions.length / 6;
    var index = 0;
    for (var i = 0; i < length - 1; i++) {
        indices[index++] = i;
        indices[index++] = i + 1;
        indices[index++] = i + length;
        indices[index++] = i + length + 1;
    }
    indices[index++] = length - 1;
    indices[index++] = 0;
    indices[index++] = length + length - 1;
    indices[index++] = length;
    indices[index++] = 0;
    indices[index++] = length;
    indices[index++] = width - 1;
    indices[index++] = length + width - 1;
    indices[index++] = width + height - 2;
    indices[index++] = width + height - 2 + length;
    indices[index++] = 2 * width + height - 3;
    indices[index++] = 2 * width + height - 3 + length;
    geo.indices = indices;
    return geo;
}
var RectangleOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var rectangle = options.rectangle;
    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    var surfaceHeight = defaultValue(options.height, 0);
    var rotation = defaultValue(options.rotation, 0);
    var extrudedHeight = defaultValue(options.extrudedHeight, surfaceHeight);
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    Rectangle.validate(rectangle);
    if (rectangle.north < rectangle.south) {
        throw new DeveloperError('options.rectangle.north must be greater than options.rectangle.south');
    }
    this._rectangle = rectangle;
    this._granularity = granularity;
    this._ellipsoid = ellipsoid;
    this._surfaceHeight = surfaceHeight;
    this._rotation = rotation;
    this._extrudedHeight = extrudedHeight;
    this._workerName = 'createRectangleOutlineGeometry';
};
RectangleOutlineGeometry.packedLength = Rectangle.packedLength + Ellipsoid.packedLength + 4;
RectangleOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    Rectangle.pack(value._rectangle, array, startingIndex);
    startingIndex += Rectangle.packedLength;
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    array[startingIndex++] = value._granularity;
    array[startingIndex++] = value._surfaceHeight;
    array[startingIndex++] = value._rotation;
    array[startingIndex] = value._extrudedHeight;
};
var scratchRectangle = new Rectangle();
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchOptions = {
        rectangle: scratchRectangle,
        ellipsoid: scratchEllipsoid,
        granularity: undefined,
        height: undefined,
        rotation: undefined,
        extrudedHeight: undefined
    };
RectangleOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var rectangle = Rectangle.unpack(array, startingIndex, scratchRectangle);
    startingIndex += Rectangle.packedLength;
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var granularity = array[startingIndex++];
    var height = array[startingIndex++];
    var rotation = array[startingIndex++];
    var extrudedHeight = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.granularity = granularity;
        scratchOptions.height = height;
        scratchOptions.rotation = rotation;
        scratchOptions.extrudedHeight = extrudedHeight;
        return new RectangleOutlineGeometry(scratchOptions);
    }
    result._rectangle = Rectangle.clone(rectangle, result._rectangle);
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._surfaceHeight = height;
    result._rotation = rotation;
    result._extrudedHeight = extrudedHeight;
    return result;
};
var nwScratch = new Cartographic();
RectangleOutlineGeometry.createGeometry = function (rectangleGeometry) {
    var rectangle = Rectangle.clone(rectangleGeometry._rectangle, rectangleScratch);
    var ellipsoid = rectangleGeometry._ellipsoid;
    var surfaceHeight = rectangleGeometry._surfaceHeight;
    var extrudedHeight = rectangleGeometry._extrudedHeight;
    var options = RectangleGeometryLibrary.computeOptions(rectangleGeometry, rectangle, nwScratch);
    options.size = 2 * options.width + 2 * options.height - 4;
    var geometry;
    var boundingSphere;
    rectangle = rectangleGeometry._rectangle;
    if (defined(extrudedHeight)) {
        geometry = constructExtrudedRectangle(options);
        var topBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight, topBoundingSphere);
        var bottomBS = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, extrudedHeight, bottomBoundingSphere);
        boundingSphere = BoundingSphere.union(topBS, bottomBS);
    } else {
        geometry = constructRectangle(options);
        geometry = PolygonPipeline.scaleToGeodeticHeight(geometry, surfaceHeight, ellipsoid, false);
        boundingSphere = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, surfaceHeight);
    }
    return new Geometry({
        attributes: geometry.attributes,
        indices: geometry.indices,
        primitiveType: PrimitiveType.LINES,
        boundingSphere: boundingSphere
    });
};
module.exports = RectangleOutlineGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./Cartographic":104,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PolygonPipeline":187,"./PrimitiveType":193,"./Rectangle":201,"./RectangleGeometryLibrary":203,"./defaultValue":243,"./defined":245}],205:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var ReferenceFrame = {
        FIXED: 0,
        INERTIAL: 1
    };
module.exports = freezeObject(ReferenceFrame);
},{"./freezeObject":249}],206:[function(require,module,exports){
var defined = require('./defined'), parseResponseHeaders = require('./parseResponseHeaders');
'use strict';
var RequestErrorEvent = function RequestErrorEvent(statusCode, response, responseHeaders) {
    this.statusCode = statusCode;
    this.response = response;
    this.responseHeaders = responseHeaders;
    if (typeof this.responseHeaders === 'string') {
        this.responseHeaders = parseResponseHeaders(this.responseHeaders);
    }
};
RequestErrorEvent.prototype.toString = function () {
    var str = 'Request has failed.';
    if (defined(this.statusCode)) {
        str += ' Status Code: ' + this.statusCode;
    }
    return str;
};
module.exports = RequestErrorEvent;
},{"./defined":245,"./parseResponseHeaders":267}],207:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var RuntimeError = function (message) {
    this.name = 'RuntimeError';
    this.message = message;
    var stack;
    try {
        throw new Error();
    } catch (e) {
        stack = e.stack;
    }
    this.stack = stack;
};
RuntimeError.prototype.toString = function () {
    var str = this.name + ': ' + this.message;
    if (defined(this.stack)) {
        str += '\n' + this.stack.toString();
    }
    return str;
};
module.exports = RuntimeError;
},{"./defined":245}],208:[function(require,module,exports){
var AssociativeArray = require('./AssociativeArray'), Cartesian2 = require('./Cartesian2'), defaultValue = require('./defaultValue'), defined = require('./defined'), deprecationWarning = require('./deprecationWarning'), destroyObject = require('./destroyObject'), DeveloperError = require('./DeveloperError'), KeyboardEventModifier = require('./KeyboardEventModifier'), ScreenSpaceEventType = require('./ScreenSpaceEventType');
'use strict';
function getPosition(screenSpaceEventHandler, event, result) {
    var element = screenSpaceEventHandler._element;
    if (element === document) {
        result.x = event.clientX;
        result.y = event.clientY;
        return result;
    }
    var rect = element.getBoundingClientRect();
    result.x = event.clientX - rect.left;
    result.y = event.clientY - rect.top;
    return result;
}
function getInputEventKey(type, modifier) {
    var key = type;
    if (defined(modifier)) {
        key += '+' + modifier;
    }
    return key;
}
function getModifier(event) {
    if (event.shiftKey) {
        return KeyboardEventModifier.SHIFT;
    } else if (event.ctrlKey) {
        return KeyboardEventModifier.CTRL;
    } else if (event.altKey) {
        return KeyboardEventModifier.ALT;
    }
    return undefined;
}
var MouseButton = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    };
function registerListener(screenSpaceEventHandler, domType, element, callback) {
    var listener = function (e) {
        callback(screenSpaceEventHandler, e);
    };
    element.addEventListener(domType, listener, false);
    screenSpaceEventHandler._removalFunctions.push(function () {
        element.removeEventListener(domType, listener, false);
    });
}
function registerListeners(screenSpaceEventHandler) {
    var element = screenSpaceEventHandler._element;
    var alternateElement = !defined(element.disableRootEvents) && screenSpaceEventHandler._mouseMoveOnDocument ? document : element;
    if (defined(window.PointerEvent)) {
        registerListener(screenSpaceEventHandler, 'pointerdown', element, handlePointerDown);
        registerListener(screenSpaceEventHandler, 'pointerup', element, handlePointerUp);
        registerListener(screenSpaceEventHandler, 'pointermove', element, handlePointerMove);
    } else {
        registerListener(screenSpaceEventHandler, 'mousedown', element, handleMouseDown);
        registerListener(screenSpaceEventHandler, 'mouseup', alternateElement, handleMouseUp);
        registerListener(screenSpaceEventHandler, 'mousemove', alternateElement, handleMouseMove);
        registerListener(screenSpaceEventHandler, 'touchstart', element, handleTouchStart);
        registerListener(screenSpaceEventHandler, 'touchend', alternateElement, handleTouchEnd);
        registerListener(screenSpaceEventHandler, 'touchmove', alternateElement, handleTouchMove);
    }
    registerListener(screenSpaceEventHandler, 'dblclick', element, handleDblClick);
    var wheelEvent;
    if ('onwheel' in element) {
        wheelEvent = 'wheel';
    } else if (defined(document.onmousewheel)) {
        wheelEvent = 'mousewheel';
    } else {
        wheelEvent = 'DOMMouseScroll';
    }
    registerListener(screenSpaceEventHandler, wheelEvent, element, handleWheel);
}
function unregisterListeners(screenSpaceEventHandler) {
    var removalFunctions = screenSpaceEventHandler._removalFunctions;
    for (var i = 0; i < removalFunctions.length; ++i) {
        removalFunctions[i]();
    }
}
var mouseDownEvent = { position: new Cartesian2() };
function handleMouseDown(screenSpaceEventHandler, event) {
    if (screenSpaceEventHandler._seenAnyTouchEvents) {
        return;
    }
    var button = event.button;
    screenSpaceEventHandler._buttonDown = button;
    var screenSpaceEventType;
    if (button === MouseButton.LEFT) {
        screenSpaceEventType = ScreenSpaceEventType.LEFT_DOWN;
    } else if (button === MouseButton.MIDDLE) {
        screenSpaceEventType = ScreenSpaceEventType.MIDDLE_DOWN;
    } else if (button === MouseButton.RIGHT) {
        screenSpaceEventType = ScreenSpaceEventType.RIGHT_DOWN;
    } else {
        return;
    }
    var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
    Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);
    Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    if (defined(action)) {
        Cartesian2.clone(position, mouseDownEvent.position);
        action(mouseDownEvent);
        event.preventDefault();
    }
}
var mouseUpEvent = { position: new Cartesian2() };
var mouseClickEvent = { position: new Cartesian2() };
function handleMouseUp(screenSpaceEventHandler, event) {
    if (screenSpaceEventHandler._seenAnyTouchEvents) {
        return;
    }
    var button = event.button;
    screenSpaceEventHandler._buttonDown = undefined;
    var screenSpaceEventType;
    var clickScreenSpaceEventType;
    if (button === MouseButton.LEFT) {
        screenSpaceEventType = ScreenSpaceEventType.LEFT_UP;
        clickScreenSpaceEventType = ScreenSpaceEventType.LEFT_CLICK;
    } else if (button === MouseButton.MIDDLE) {
        screenSpaceEventType = ScreenSpaceEventType.MIDDLE_UP;
        clickScreenSpaceEventType = ScreenSpaceEventType.MIDDLE_CLICK;
    } else if (button === MouseButton.RIGHT) {
        screenSpaceEventType = ScreenSpaceEventType.RIGHT_UP;
        clickScreenSpaceEventType = ScreenSpaceEventType.RIGHT_CLICK;
    } else {
        return;
    }
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    var clickAction = screenSpaceEventHandler.getInputAction(clickScreenSpaceEventType, modifier);
    if (defined(action) || defined(clickAction)) {
        var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
        if (defined(action)) {
            Cartesian2.clone(position, mouseUpEvent.position);
            action(mouseUpEvent);
        }
        if (defined(clickAction)) {
            var startPosition = screenSpaceEventHandler._primaryStartPosition;
            var xDiff = startPosition.x - position.x;
            var yDiff = startPosition.y - position.y;
            var totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
            if (totalPixels < screenSpaceEventHandler._clickPixelTolerance) {
                Cartesian2.clone(position, mouseClickEvent.position);
                clickAction(mouseClickEvent);
            }
        }
    }
}
var mouseMoveEvent = {
        startPosition: new Cartesian2(),
        endPosition: new Cartesian2()
    };
function handleMouseMove(screenSpaceEventHandler, event) {
    if (screenSpaceEventHandler._seenAnyTouchEvents) {
        return;
    }
    var modifier = getModifier(event);
    var position = getPosition(screenSpaceEventHandler, event, screenSpaceEventHandler._primaryPosition);
    var previousPosition = screenSpaceEventHandler._primaryPreviousPosition;
    var action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.MOUSE_MOVE, modifier);
    if (defined(action)) {
        Cartesian2.clone(previousPosition, mouseMoveEvent.startPosition);
        Cartesian2.clone(position, mouseMoveEvent.endPosition);
        action(mouseMoveEvent);
    }
    Cartesian2.clone(position, previousPosition);
}
var mouseDblClickEvent = { position: new Cartesian2() };
function handleDblClick(screenSpaceEventHandler, event) {
    var button = event.button;
    var screenSpaceEventType;
    if (button === MouseButton.LEFT) {
        screenSpaceEventType = ScreenSpaceEventType.LEFT_DOUBLE_CLICK;
    } else if (button === MouseButton.MIDDLE) {
        screenSpaceEventType = ScreenSpaceEventType.MIDDLE_DOUBLE_CLICK;
    } else if (button === MouseButton.RIGHT) {
        screenSpaceEventType = ScreenSpaceEventType.RIGHT_DOUBLE_CLICK;
    } else {
        return;
    }
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(screenSpaceEventType, modifier);
    if (defined(action)) {
        getPosition(screenSpaceEventHandler, event, mouseDblClickEvent.position);
        action(mouseDblClickEvent);
    }
}
function handleWheel(screenSpaceEventHandler, event) {
    var delta;
    if (defined(event.deltaY)) {
        var deltaMode = event.deltaMode;
        if (deltaMode === event.DOM_DELTA_PIXEL) {
            delta = -event.deltaY;
        } else if (deltaMode === event.DOM_DELTA_LINE) {
            delta = -event.deltaY * 40;
        } else {
            delta = -event.deltaY * 120;
        }
    } else if (event.detail > 0) {
        delta = event.detail * -120;
    } else {
        delta = event.wheelDelta;
    }
    if (!defined(delta)) {
        return;
    }
    var modifier = getModifier(event);
    var action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.WHEEL, modifier);
    if (defined(action)) {
        action(delta);
        event.preventDefault();
    }
}
function handleTouchStart(screenSpaceEventHandler, event) {
    screenSpaceEventHandler._seenAnyTouchEvents = true;
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
        touch = changedTouches[i];
        identifier = touch.identifier;
        positions.set(identifier, getPosition(screenSpaceEventHandler, touch, new Cartesian2()));
    }
    fireTouchEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
        touch = changedTouches[i];
        identifier = touch.identifier;
        previousPositions.set(identifier, Cartesian2.clone(positions.get(identifier)));
    }
}
function handleTouchEnd(screenSpaceEventHandler, event) {
    screenSpaceEventHandler._seenAnyTouchEvents = true;
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
        touch = changedTouches[i];
        identifier = touch.identifier;
        positions.remove(identifier);
    }
    fireTouchEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
        touch = changedTouches[i];
        identifier = touch.identifier;
        previousPositions.remove(identifier);
    }
}
var touchStartEvent = { position: new Cartesian2() };
var touch2StartEvent = {
        position1: new Cartesian2(),
        position2: new Cartesian2()
    };
var touchEndEvent = { position: new Cartesian2() };
var touchClickEvent = { position: new Cartesian2() };
function fireTouchEvents(screenSpaceEventHandler, event) {
    var modifier = getModifier(event);
    var positions = screenSpaceEventHandler._positions;
    var previousPositions = screenSpaceEventHandler._previousPositions;
    var numberOfTouches = positions.length;
    var action;
    var clickAction;
    if (numberOfTouches !== 1 && screenSpaceEventHandler._buttonDown === MouseButton.LEFT) {
        screenSpaceEventHandler._buttonDown = undefined;
        action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_UP, modifier);
        if (defined(action)) {
            Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchEndEvent.position);
            action(touchEndEvent);
        }
        if (numberOfTouches === 0) {
            clickAction = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_CLICK, modifier);
            if (defined(clickAction)) {
                var startPosition = screenSpaceEventHandler._primaryStartPosition;
                var endPosition = previousPositions.values[0];
                var xDiff = startPosition.x - endPosition.x;
                var yDiff = startPosition.y - endPosition.y;
                var totalPixels = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
                if (totalPixels < screenSpaceEventHandler._clickPixelTolerance) {
                    Cartesian2.clone(screenSpaceEventHandler._primaryPosition, touchClickEvent.position);
                    clickAction(touchClickEvent);
                }
            }
        }
    }
    if (numberOfTouches !== 2 && screenSpaceEventHandler._isPinching) {
        screenSpaceEventHandler._isPinching = false;
        action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_END, modifier);
        if (defined(action)) {
            action();
        }
    }
    if (numberOfTouches === 1) {
        var position = positions.values[0];
        Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);
        Cartesian2.clone(position, screenSpaceEventHandler._primaryStartPosition);
        Cartesian2.clone(position, screenSpaceEventHandler._primaryPreviousPosition);
        screenSpaceEventHandler._buttonDown = MouseButton.LEFT;
        action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.LEFT_DOWN, modifier);
        if (defined(action)) {
            Cartesian2.clone(position, touchStartEvent.position);
            action(touchStartEvent);
        }
        event.preventDefault();
    }
    if (numberOfTouches === 2) {
        screenSpaceEventHandler._isPinching = true;
        action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_START, modifier);
        if (defined(action)) {
            Cartesian2.clone(positions.values[0], touch2StartEvent.position1);
            Cartesian2.clone(positions.values[1], touch2StartEvent.position2);
            action(touch2StartEvent);
        }
    }
}
function handleTouchMove(screenSpaceEventHandler, event) {
    screenSpaceEventHandler._seenAnyTouchEvents = true;
    var changedTouches = event.changedTouches;
    var i;
    var length = changedTouches.length;
    var touch;
    var identifier;
    var positions = screenSpaceEventHandler._positions;
    for (i = 0; i < length; ++i) {
        touch = changedTouches[i];
        identifier = touch.identifier;
        var position = positions.get(identifier);
        if (defined(position)) {
            getPosition(screenSpaceEventHandler, touch, position);
        }
    }
    fireTouchMoveEvents(screenSpaceEventHandler, event);
    var previousPositions = screenSpaceEventHandler._previousPositions;
    for (i = 0; i < length; ++i) {
        touch = changedTouches[i];
        identifier = touch.identifier;
        Cartesian2.clone(positions.get(identifier), previousPositions.get(identifier));
    }
}
var touchMoveEvent = {
        startPosition: new Cartesian2(),
        endPosition: new Cartesian2()
    };
var touchPinchMovementEvent = {
        distance: {
            startPosition: new Cartesian2(),
            endPosition: new Cartesian2()
        },
        angleAndHeight: {
            startPosition: new Cartesian2(),
            endPosition: new Cartesian2()
        }
    };
function fireTouchMoveEvents(screenSpaceEventHandler, event) {
    var modifier = getModifier(event);
    var positions = screenSpaceEventHandler._positions;
    var previousPositions = screenSpaceEventHandler._previousPositions;
    var numberOfTouches = positions.length;
    var action;
    if (numberOfTouches === 1 && screenSpaceEventHandler._buttonDown === MouseButton.LEFT) {
        var position = positions.values[0];
        Cartesian2.clone(position, screenSpaceEventHandler._primaryPosition);
        var previousPosition = screenSpaceEventHandler._primaryPreviousPosition;
        action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.MOUSE_MOVE, modifier);
        if (defined(action)) {
            Cartesian2.clone(previousPosition, touchMoveEvent.startPosition);
            Cartesian2.clone(position, touchMoveEvent.endPosition);
            action(touchMoveEvent);
        }
        Cartesian2.clone(position, previousPosition);
        event.preventDefault();
    } else if (numberOfTouches === 2 && screenSpaceEventHandler._isPinching) {
        action = screenSpaceEventHandler.getInputAction(ScreenSpaceEventType.PINCH_MOVE, modifier);
        if (defined(action)) {
            var position1 = positions.values[0];
            var position2 = positions.values[1];
            var previousPosition1 = previousPositions.values[0];
            var previousPosition2 = previousPositions.values[1];
            var dX = position2.x - position1.x;
            var dY = position2.y - position1.y;
            var dist = Math.sqrt(dX * dX + dY * dY) * 0.25;
            var prevDX = previousPosition2.x - previousPosition1.x;
            var prevDY = previousPosition2.y - previousPosition1.y;
            var prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY) * 0.25;
            var cY = (position2.y + position1.y) * 0.125;
            var prevCY = (previousPosition2.y + previousPosition1.y) * 0.125;
            var angle = Math.atan2(dY, dX);
            var prevAngle = Math.atan2(prevDY, prevDX);
            Cartesian2.fromElements(0, prevDist, touchPinchMovementEvent.distance.startPosition);
            Cartesian2.fromElements(0, dist, touchPinchMovementEvent.distance.endPosition);
            Cartesian2.fromElements(prevAngle, prevCY, touchPinchMovementEvent.angleAndHeight.startPosition);
            Cartesian2.fromElements(angle, cY, touchPinchMovementEvent.angleAndHeight.endPosition);
            action(touchPinchMovementEvent);
        }
    }
}
function handlePointerDown(screenSpaceEventHandler, event) {
    event.target.setPointerCapture(event.pointerId);
    if (event.pointerType === 'touch') {
        var positions = screenSpaceEventHandler._positions;
        var identifier = event.pointerId;
        positions.set(identifier, getPosition(screenSpaceEventHandler, event, new Cartesian2()));
        fireTouchEvents(screenSpaceEventHandler, event);
        var previousPositions = screenSpaceEventHandler._previousPositions;
        previousPositions.set(identifier, Cartesian2.clone(positions.get(identifier)));
    } else {
        handleMouseDown(screenSpaceEventHandler, event);
    }
}
function handlePointerUp(screenSpaceEventHandler, event) {
    if (event.pointerType === 'touch') {
        var positions = screenSpaceEventHandler._positions;
        var identifier = event.pointerId;
        positions.remove(identifier);
        fireTouchEvents(screenSpaceEventHandler, event);
        var previousPositions = screenSpaceEventHandler._previousPositions;
        previousPositions.remove(identifier);
    } else {
        handleMouseUp(screenSpaceEventHandler, event);
    }
}
function handlePointerMove(screenSpaceEventHandler, event) {
    if (event.pointerType === 'touch') {
        var positions = screenSpaceEventHandler._positions;
        var identifier = event.pointerId;
        getPosition(screenSpaceEventHandler, event, positions.get(identifier));
        fireTouchMoveEvents(screenSpaceEventHandler, event);
        var previousPositions = screenSpaceEventHandler._previousPositions;
        Cartesian2.clone(positions.get(identifier), previousPositions.get(identifier));
    } else {
        handleMouseMove(screenSpaceEventHandler, event);
    }
}
var ScreenSpaceEventHandler = function (element, mouseMoveOnDocument) {
    this._inputEvents = {};
    this._buttonDown = undefined;
    this._isPinching = false;
    this._seenAnyTouchEvents = false;
    this._primaryStartPosition = new Cartesian2();
    this._primaryPosition = new Cartesian2();
    this._primaryPreviousPosition = new Cartesian2();
    this._positions = new AssociativeArray();
    this._previousPositions = new AssociativeArray();
    this._removalFunctions = [];
    this._clickPixelTolerance = 5;
    this._element = defaultValue(element, document);
    this._mouseMoveOnDocument = defaultValue(mouseMoveOnDocument, true);
    if (this._mouseMoveOnDocument) {
        deprecationWarning('ScreenSpaceEventHandler', 'The mouseMoveOnDocument parameter to the ScreenSpaceEventHandler constructor was deprecated in Cesium 1.6. It will be removed in Cesium 1.7. ScreenSpaceEventHandler will be constructed as if mouseMoveOnDocument is false.');
    }
    registerListeners(this);
};
ScreenSpaceEventHandler.prototype.setInputAction = function (action, type, modifier) {
    if (!defined(action)) {
        throw new DeveloperError('action is required.');
    }
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getInputEventKey(type, modifier);
    this._inputEvents[key] = action;
};
ScreenSpaceEventHandler.prototype.getInputAction = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getInputEventKey(type, modifier);
    return this._inputEvents[key];
};
ScreenSpaceEventHandler.prototype.removeInputAction = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getInputEventKey(type, modifier);
    delete this._inputEvents[key];
};
ScreenSpaceEventHandler.prototype.isDestroyed = function () {
    return false;
};
ScreenSpaceEventHandler.prototype.destroy = function () {
    unregisterListeners(this);
    return destroyObject(this);
};
module.exports = ScreenSpaceEventHandler;
},{"./AssociativeArray":93,"./Cartesian2":101,"./DeveloperError":123,"./KeyboardEventModifier":169,"./ScreenSpaceEventType":209,"./defaultValue":243,"./defined":245,"./deprecationWarning":246,"./destroyObject":247}],209:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var ScreenSpaceEventType = {
        LEFT_DOWN: 0,
        LEFT_UP: 1,
        LEFT_CLICK: 2,
        LEFT_DOUBLE_CLICK: 3,
        RIGHT_DOWN: 5,
        RIGHT_UP: 6,
        RIGHT_CLICK: 7,
        RIGHT_DOUBLE_CLICK: 8,
        MIDDLE_DOWN: 10,
        MIDDLE_UP: 11,
        MIDDLE_CLICK: 12,
        MIDDLE_DOUBLE_CLICK: 13,
        MOUSE_MOVE: 15,
        WHEEL: 16,
        PINCH_START: 17,
        PINCH_END: 18,
        PINCH_MOVE: 19
    };
module.exports = freezeObject(ScreenSpaceEventType);
},{"./freezeObject":249}],210:[function(require,module,exports){
var ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError');
'use strict';
var ShowGeometryInstanceAttribute = function (show) {
    show = defaultValue(show, true);
    this.value = ShowGeometryInstanceAttribute.toValue(show);
};
defineProperties(ShowGeometryInstanceAttribute.prototype, {
    componentDatatype: {
        get: function () {
            return ComponentDatatype.UNSIGNED_BYTE;
        }
    },
    componentsPerAttribute: {
        get: function () {
            return 1;
        }
    },
    normalize: {
        get: function () {
            return true;
        }
    }
});
ShowGeometryInstanceAttribute.toValue = function (show, result) {
    if (!defined(show)) {
        throw new DeveloperError('show is required.');
    }
    if (!defined(result)) {
        return new Uint8Array([show]);
    }
    result[0] = show;
    return result;
};
module.exports = ShowGeometryInstanceAttribute;
},{"./ComponentDatatype":113,"./DeveloperError":123,"./defaultValue":243,"./defineProperties":244,"./defined":245}],211:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), JulianDate = require('./JulianDate'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), TimeConstants = require('./TimeConstants'), TimeStandard = require('./TimeStandard');
'use strict';
var Simon1994PlanetaryPositions = {};
function computeTdbMinusTtSpice(daysSinceJ2000InTerrestrialTime) {
    var g = 6.239996 + 0.0172019696544 * daysSinceJ2000InTerrestrialTime;
    return 0.001657 * Math.sin(g + 0.01671 * Math.sin(g));
}
var TdtMinusTai = 32.184;
var J2000d = 2451545;
function taiToTdb(date, result) {
    result = JulianDate.addSeconds(date, TdtMinusTai, result);
    var days = JulianDate.totalDays(result) - J2000d;
    result = JulianDate.addSeconds(result, computeTdbMinusTtSpice(days), result);
    return result;
}
var epoch = new JulianDate(2451545, 0, TimeStandard.TAI);
var GravitationalParameterOfEarth = 398600435000000;
var GravitationalParameterOfSun = GravitationalParameterOfEarth * (1 + 0.012300034) * 328900.56;
var MetersPerKilometer = 1000;
var RadiansPerDegree = CesiumMath.RADIANS_PER_DEGREE;
var RadiansPerArcSecond = CesiumMath.RADIANS_PER_ARCSECOND;
var MetersPerAstronomicalUnit = 149597870000;
var perifocalToEquatorial = new Matrix3();
function elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, gravitationalParameter, result) {
    if (inclination < 0) {
        inclination = -inclination;
        longitudeOfNode += CesiumMath.PI;
    }
    if (inclination < 0 || inclination > CesiumMath.PI) {
        throw new DeveloperError('The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.');
    }
    var radiusOfPeriapsis = semimajorAxis * (1 - eccentricity);
    var argumentOfPeriapsis = longitudeOfPerigee - longitudeOfNode;
    var rightAscensionOfAscendingNode = longitudeOfNode;
    var trueAnomaly = meanAnomalyToTrueAnomaly(meanLongitude - longitudeOfPerigee, eccentricity);
    var type = chooseOrbit(eccentricity, 0);
    if (type === 'Hyperbolic' && Math.abs(CesiumMath.NegativePiToPi(trueAnomaly)) >= Math.acos(-1 / eccentricity)) {
        throw new DeveloperError('The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.');
    }
    perifocalToCartesianMatrix(argumentOfPeriapsis, inclination, rightAscensionOfAscendingNode, perifocalToEquatorial);
    var semilatus = radiusOfPeriapsis * (1 + eccentricity);
    var costheta = Math.cos(trueAnomaly);
    var sintheta = Math.sin(trueAnomaly);
    var denom = 1 + eccentricity * costheta;
    if (denom <= CesiumMath.Epsilon10) {
        throw new DeveloperError('elements cannot be converted to cartesian');
    }
    var radius = semilatus / denom;
    if (!defined(result)) {
        result = new Cartesian3(radius * costheta, radius * sintheta, 0);
    } else {
        result.x = radius * costheta;
        result.y = radius * sintheta;
        result.z = 0;
    }
    return Matrix3.multiplyByVector(perifocalToEquatorial, result, result);
}
function chooseOrbit(eccentricity, tolerance) {
    if (eccentricity < 0) {
        throw new DeveloperError('eccentricity cannot be negative.');
    } else if (eccentricity <= tolerance) {
        return 'Circular';
    } else if (eccentricity < 1 - tolerance) {
        return 'Elliptical';
    } else if (eccentricity <= 1 + tolerance) {
        return 'Parabolic';
    } else {
        return 'Hyperbolic';
    }
}
function meanAnomalyToTrueAnomaly(meanAnomaly, eccentricity) {
    if (eccentricity < 0 || eccentricity >= 1) {
        throw new DeveloperError('eccentricity out of range.');
    }
    var eccentricAnomaly = meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity);
    return eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity);
}
var maxIterationCount = 50;
var keplerEqConvergence = CesiumMath.EPSILON8;
function meanAnomalyToEccentricAnomaly(meanAnomaly, eccentricity) {
    if (eccentricity < 0 || eccentricity >= 1) {
        throw new DeveloperError('eccentricity out of range.');
    }
    var revs = Math.floor(meanAnomaly / CesiumMath.TWO_PI);
    meanAnomaly -= revs * CesiumMath.TWO_PI;
    var iterationValue = meanAnomaly + eccentricity * Math.sin(meanAnomaly) / (1 - Math.sin(meanAnomaly + eccentricity) + Math.sin(meanAnomaly));
    var eccentricAnomaly = Number.MAX_VALUE;
    var count;
    for (count = 0; count < maxIterationCount && Math.abs(eccentricAnomaly - iterationValue) > keplerEqConvergence; ++count) {
        eccentricAnomaly = iterationValue;
        var NRfunction = eccentricAnomaly - eccentricity * Math.sin(eccentricAnomaly) - meanAnomaly;
        var dNRfunction = 1 - eccentricity * Math.cos(eccentricAnomaly);
        iterationValue = eccentricAnomaly - NRfunction / dNRfunction;
    }
    if (count >= maxIterationCount) {
        throw new DeveloperError('Kepler equation did not converge');
    }
    eccentricAnomaly = iterationValue + revs * CesiumMath.TWO_PI;
    return eccentricAnomaly;
}
function eccentricAnomalyToTrueAnomaly(eccentricAnomaly, eccentricity) {
    if (eccentricity < 0 || eccentricity >= 1) {
        throw new DeveloperError('eccentricity out of range.');
    }
    var revs = Math.floor(eccentricAnomaly / CesiumMath.TWO_PI);
    eccentricAnomaly -= revs * CesiumMath.TWO_PI;
    var trueAnomalyX = Math.cos(eccentricAnomaly) - eccentricity;
    var trueAnomalyY = Math.sin(eccentricAnomaly) * Math.sqrt(1 - eccentricity * eccentricity);
    var trueAnomaly = Math.atan2(trueAnomalyY, trueAnomalyX);
    trueAnomaly = CesiumMath.zeroToTwoPi(trueAnomaly);
    if (eccentricAnomaly < 0) {
        trueAnomaly -= CesiumMath.TWO_PI;
    }
    trueAnomaly += revs * CesiumMath.TWO_PI;
    return trueAnomaly;
}
function perifocalToCartesianMatrix(argumentOfPeriapsis, inclination, rightAscension, result) {
    if (inclination < 0 || inclination > CesiumMath.PI) {
        throw new DeveloperError('inclination out of range');
    }
    var cosap = Math.cos(argumentOfPeriapsis);
    var sinap = Math.sin(argumentOfPeriapsis);
    var cosi = Math.cos(inclination);
    var sini = Math.sin(inclination);
    var cosraan = Math.cos(rightAscension);
    var sinraan = Math.sin(rightAscension);
    if (!defined(result)) {
        result = new Matrix3(cosraan * cosap - sinraan * sinap * cosi, -cosraan * sinap - sinraan * cosap * cosi, sinraan * sini, sinraan * cosap + cosraan * sinap * cosi, -sinraan * sinap + cosraan * cosap * cosi, -cosraan * sini, sinap * sini, cosap * sini, cosi);
    } else {
        result[0] = cosraan * cosap - sinraan * sinap * cosi;
        result[1] = sinraan * cosap + cosraan * sinap * cosi;
        result[2] = sinap * sini;
        result[3] = -cosraan * sinap - sinraan * cosap * cosi;
        result[4] = -sinraan * sinap + cosraan * cosap * cosi;
        result[5] = cosap * sini;
        result[6] = sinraan * sini;
        result[7] = -cosraan * sini;
        result[8] = cosi;
    }
    return result;
}
var semiMajorAxis0 = 1.0000010178 * MetersPerAstronomicalUnit;
var meanLongitude0 = 100.46645683 * RadiansPerDegree;
var meanLongitude1 = 1295977422.83429 * RadiansPerArcSecond;
var p1u = 16002;
var p2u = 21863;
var p3u = 32004;
var p4u = 10931;
var p5u = 14529;
var p6u = 16368;
var p7u = 15318;
var p8u = 32794;
var Ca1 = 64 * 1e-7 * MetersPerAstronomicalUnit;
var Ca2 = -152 * 1e-7 * MetersPerAstronomicalUnit;
var Ca3 = 62 * 1e-7 * MetersPerAstronomicalUnit;
var Ca4 = -8 * 1e-7 * MetersPerAstronomicalUnit;
var Ca5 = 32 * 1e-7 * MetersPerAstronomicalUnit;
var Ca6 = -41 * 1e-7 * MetersPerAstronomicalUnit;
var Ca7 = 19 * 1e-7 * MetersPerAstronomicalUnit;
var Ca8 = -11 * 1e-7 * MetersPerAstronomicalUnit;
var Sa1 = -150 * 1e-7 * MetersPerAstronomicalUnit;
var Sa2 = -46 * 1e-7 * MetersPerAstronomicalUnit;
var Sa3 = 68 * 1e-7 * MetersPerAstronomicalUnit;
var Sa4 = 54 * 1e-7 * MetersPerAstronomicalUnit;
var Sa5 = 14 * 1e-7 * MetersPerAstronomicalUnit;
var Sa6 = 24 * 1e-7 * MetersPerAstronomicalUnit;
var Sa7 = -28 * 1e-7 * MetersPerAstronomicalUnit;
var Sa8 = 22 * 1e-7 * MetersPerAstronomicalUnit;
var q1u = 10;
var q2u = 16002;
var q3u = 21863;
var q4u = 10931;
var q5u = 1473;
var q6u = 32004;
var q7u = 4387;
var q8u = 73;
var Cl1 = -325 * 1e-7;
var Cl2 = -322 * 1e-7;
var Cl3 = -79 * 1e-7;
var Cl4 = 232 * 1e-7;
var Cl5 = -52 * 1e-7;
var Cl6 = 97 * 1e-7;
var Cl7 = 55 * 1e-7;
var Cl8 = -41 * 1e-7;
var Sl1 = -105 * 1e-7;
var Sl2 = -137 * 1e-7;
var Sl3 = 258 * 1e-7;
var Sl4 = 35 * 1e-7;
var Sl5 = -116 * 1e-7;
var Sl6 = -88 * 1e-7;
var Sl7 = -112 * 1e-7;
var Sl8 = -80 * 1e-7;
var scratchDate = new JulianDate(0, 0, TimeStandard.TAI);
function computeSimonEarthMoonBarycenter(date, result) {
    taiToTdb(date, scratchDate);
    var x = scratchDate.dayNumber - epoch.dayNumber + (scratchDate.secondsOfDay - epoch.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
    var t = x / (TimeConstants.DAYS_PER_JULIAN_CENTURY * 10);
    var u = 0.3595362 * t;
    var semimajorAxis = semiMajorAxis0 + Ca1 * Math.cos(p1u * u) + Sa1 * Math.sin(p1u * u) + Ca2 * Math.cos(p2u * u) + Sa2 * Math.sin(p2u * u) + Ca3 * Math.cos(p3u * u) + Sa3 * Math.sin(p3u * u) + Ca4 * Math.cos(p4u * u) + Sa4 * Math.sin(p4u * u) + Ca5 * Math.cos(p5u * u) + Sa5 * Math.sin(p5u * u) + Ca6 * Math.cos(p6u * u) + Sa6 * Math.sin(p6u * u) + Ca7 * Math.cos(p7u * u) + Sa7 * Math.sin(p7u * u) + Ca8 * Math.cos(p8u * u) + Sa8 * Math.sin(p8u * u);
    var meanLongitude = meanLongitude0 + meanLongitude1 * t + Cl1 * Math.cos(q1u * u) + Sl1 * Math.sin(q1u * u) + Cl2 * Math.cos(q2u * u) + Sl2 * Math.sin(q2u * u) + Cl3 * Math.cos(q3u * u) + Sl3 * Math.sin(q3u * u) + Cl4 * Math.cos(q4u * u) + Sl4 * Math.sin(q4u * u) + Cl5 * Math.cos(q5u * u) + Sl5 * Math.sin(q5u * u) + Cl6 * Math.cos(q6u * u) + Sl6 * Math.sin(q6u * u) + Cl7 * Math.cos(q7u * u) + Sl7 * Math.sin(q7u * u) + Cl8 * Math.cos(q8u * u) + Sl8 * Math.sin(q8u * u);
    var eccentricity = 0.0167086342 - 0.0004203654 * t;
    var longitudeOfPerigee = 102.93734808 * RadiansPerDegree + 11612.3529 * RadiansPerArcSecond * t;
    var inclination = 469.97289 * RadiansPerArcSecond * t;
    var longitudeOfNode = 174.87317577 * RadiansPerDegree - 8679.27034 * RadiansPerArcSecond * t;
    return elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, GravitationalParameterOfSun, result);
}
function computeSimonMoon(date, result) {
    taiToTdb(date, scratchDate);
    var x = scratchDate.dayNumber - epoch.dayNumber + (scratchDate.secondsOfDay - epoch.secondsOfDay) / TimeConstants.SECONDS_PER_DAY;
    var t = x / TimeConstants.DAYS_PER_JULIAN_CENTURY;
    var t2 = t * t;
    var t3 = t2 * t;
    var t4 = t3 * t;
    var semimajorAxis = 383397.7725 + 0.004 * t;
    var eccentricity = 0.055545526 - 1.6e-8 * t;
    var inclinationConstant = 5.15668983 * RadiansPerDegree;
    var inclinationSecPart = -0.00008 * t + 0.02966 * t2 - 0.000042 * t3 - 1.3e-7 * t4;
    var longitudeOfPerigeeConstant = 83.35324312 * RadiansPerDegree;
    var longitudeOfPerigeeSecPart = 14643420.2669 * t - 38.2702 * t2 - 0.045047 * t3 + 0.00021301 * t4;
    var longitudeOfNodeConstant = 125.04455501 * RadiansPerDegree;
    var longitudeOfNodeSecPart = -6967919.3631 * t + 6.3602 * t2 + 0.007625 * t3 - 0.00003586 * t4;
    var meanLongitudeConstant = 218.31664563 * RadiansPerDegree;
    var meanLongitudeSecPart = 1732559343.4847 * t - 6.391 * t2 + 0.006588 * t3 - 0.00003169 * t4;
    var D = 297.85019547 * RadiansPerDegree + RadiansPerArcSecond * (1602961601.209 * t - 6.3706 * t2 + 0.006593 * t3 - 0.00003169 * t4);
    var F = 93.27209062 * RadiansPerDegree + RadiansPerArcSecond * (1739527262.8478 * t - 12.7512 * t2 - 0.001037 * t3 + 0.00000417 * t4);
    var l = 134.96340251 * RadiansPerDegree + RadiansPerArcSecond * (1717915923.2178 * t + 31.8792 * t2 + 0.051635 * t3 - 0.0002447 * t4);
    var lprime = 357.52910918 * RadiansPerDegree + RadiansPerArcSecond * (129596581.0481 * t - 0.5532 * t2 + 0.000136 * t3 - 0.00001149 * t4);
    var psi = 310.17137918 * RadiansPerDegree - RadiansPerArcSecond * (6967051.436 * t + 6.2068 * t2 + 0.007618 * t3 - 0.00003219 * t4);
    var twoD = 2 * D;
    var fourD = 4 * D;
    var sixD = 6 * D;
    var twol = 2 * l;
    var threel = 3 * l;
    var fourl = 4 * l;
    var twoF = 2 * F;
    semimajorAxis += 3400.4 * Math.cos(twoD) - 635.6 * Math.cos(twoD - l) - 235.6 * Math.cos(l) + 218.1 * Math.cos(twoD - lprime) + 181 * Math.cos(twoD + l);
    eccentricity += 0.014216 * Math.cos(twoD - l) + 0.008551 * Math.cos(twoD - twol) - 0.001383 * Math.cos(l) + 0.001356 * Math.cos(twoD + l) - 0.001147 * Math.cos(fourD - threel) - 0.000914 * Math.cos(fourD - twol) + 0.000869 * Math.cos(twoD - lprime - l) - 0.000627 * Math.cos(twoD) - 0.000394 * Math.cos(fourD - fourl) + 0.000282 * Math.cos(twoD - lprime - twol) - 0.000279 * Math.cos(D - l) - 0.000236 * Math.cos(twol) + 0.000231 * Math.cos(fourD) + 0.000229 * Math.cos(sixD - fourl) - 0.000201 * Math.cos(twol - twoF);
    inclinationSecPart += 486.26 * Math.cos(twoD - twoF) - 40.13 * Math.cos(twoD) + 37.51 * Math.cos(twoF) + 25.73 * Math.cos(twol - twoF) + 19.97 * Math.cos(twoD - lprime - twoF);
    longitudeOfPerigeeSecPart += -55609 * Math.sin(twoD - l) - 34711 * Math.sin(twoD - twol) - 9792 * Math.sin(l) + 9385 * Math.sin(fourD - threel) + 7505 * Math.sin(fourD - twol) + 5318 * Math.sin(twoD + l) + 3484 * Math.sin(fourD - fourl) - 3417 * Math.sin(twoD - lprime - l) - 2530 * Math.sin(sixD - fourl) - 2376 * Math.sin(twoD) - 2075 * Math.sin(twoD - threel) - 1883 * Math.sin(twol) - 1736 * Math.sin(sixD - 5 * l) + 1626 * Math.sin(lprime) - 1370 * Math.sin(sixD - threel);
    longitudeOfNodeSecPart += -5392 * Math.sin(twoD - twoF) - 540 * Math.sin(lprime) - 441 * Math.sin(twoD) + 423 * Math.sin(twoF) - 288 * Math.sin(twol - twoF);
    meanLongitudeSecPart += -3332.9 * Math.sin(twoD) + 1197.4 * Math.sin(twoD - l) - 662.5 * Math.sin(lprime) + 396.3 * Math.sin(l) - 218 * Math.sin(twoD - lprime);
    var twoPsi = 2 * psi;
    var threePsi = 3 * psi;
    inclinationSecPart += 46.997 * Math.cos(psi) * t - 0.614 * Math.cos(twoD - twoF + psi) * t + 0.614 * Math.cos(twoD - twoF - psi) * t - 0.0297 * Math.cos(twoPsi) * t2 - 0.0335 * Math.cos(psi) * t2 + 0.0012 * Math.cos(twoD - twoF + twoPsi) * t2 - 0.00016 * Math.cos(psi) * t3 + 0.00004 * Math.cos(threePsi) * t3 + 0.00004 * Math.cos(twoPsi) * t3;
    var perigeeAndMean = 2.116 * Math.sin(psi) * t - 0.111 * Math.sin(twoD - twoF - psi) * t - 0.0015 * Math.sin(psi) * t2;
    longitudeOfPerigeeSecPart += perigeeAndMean;
    meanLongitudeSecPart += perigeeAndMean;
    longitudeOfNodeSecPart += -520.77 * Math.sin(psi) * t + 13.66 * Math.sin(twoD - twoF + psi) * t + 1.12 * Math.sin(twoD - psi) * t - 1.06 * Math.sin(twoF - psi) * t + 0.66 * Math.sin(twoPsi) * t2 + 0.371 * Math.sin(psi) * t2 - 0.035 * Math.sin(twoD - twoF + twoPsi) * t2 - 0.015 * Math.sin(twoD - twoF + psi) * t2 + 0.0014 * Math.sin(psi) * t3 - 0.0011 * Math.sin(threePsi) * t3 - 0.0009 * Math.sin(twoPsi) * t3;
    semimajorAxis *= MetersPerKilometer;
    var inclination = inclinationConstant + inclinationSecPart * RadiansPerArcSecond;
    var longitudeOfPerigee = longitudeOfPerigeeConstant + longitudeOfPerigeeSecPart * RadiansPerArcSecond;
    var meanLongitude = meanLongitudeConstant + meanLongitudeSecPart * RadiansPerArcSecond;
    var longitudeOfNode = longitudeOfNodeConstant + longitudeOfNodeSecPart * RadiansPerArcSecond;
    return elementsToCartesian(semimajorAxis, eccentricity, inclination, longitudeOfPerigee, longitudeOfNode, meanLongitude, GravitationalParameterOfEarth, result);
}
var moonEarthMassRatio = 0.012300034;
var factor = moonEarthMassRatio / (moonEarthMassRatio + 1) * -1;
function computeSimonEarth(date, result) {
    result = computeSimonMoon(date, result);
    return Cartesian3.multiplyByScalar(result, factor, result);
}
var axesTransformation = new Matrix3(1.0000000000000002, 5.619723173785822e-16, 4.690511510146299e-19, -5.154129427414611e-16, 0.9174820620691819, -0.39777715593191376, -2.23970096136568e-16, 0.39777715593191376, 0.9174820620691819);
var translation = new Cartesian3();
Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame = function (date, result) {
    if (!defined(date)) {
        date = JulianDate.now();
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    translation = computeSimonEarthMoonBarycenter(date, translation);
    result = Cartesian3.negate(translation, result);
    computeSimonEarth(date, translation);
    Cartesian3.subtract(result, translation, result);
    Matrix3.multiplyByVector(axesTransformation, result, result);
    return result;
};
Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame = function (date, result) {
    if (!defined(date)) {
        date = JulianDate.now();
    }
    result = computeSimonMoon(date, result);
    Matrix3.multiplyByVector(axesTransformation, result, result);
    return result;
};
module.exports = Simon1994PlanetaryPositions;
},{"./Cartesian3":102,"./DeveloperError":123,"./JulianDate":168,"./Math":174,"./Matrix3":176,"./TimeConstants":221,"./TimeStandard":224,"./defined":245}],212:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), Color = require('./Color'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PolylinePipeline = require('./PolylinePipeline'), PrimitiveType = require('./PrimitiveType');
'use strict';
function interpolateColors(p0, p1, color0, color1, minDistance, array, offset) {
    var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);
    var i;
    var r0 = color0.red;
    var g0 = color0.green;
    var b0 = color0.blue;
    var a0 = color0.alpha;
    var r1 = color1.red;
    var g1 = color1.green;
    var b1 = color1.blue;
    var a1 = color1.alpha;
    if (Color.equals(color0, color1)) {
        for (i = 0; i < numPoints; i++) {
            array[offset++] = Color.floatToByte(r0);
            array[offset++] = Color.floatToByte(g0);
            array[offset++] = Color.floatToByte(b0);
            array[offset++] = Color.floatToByte(a0);
        }
        return offset;
    }
    var redPerVertex = (r1 - r0) / numPoints;
    var greenPerVertex = (g1 - g0) / numPoints;
    var bluePerVertex = (b1 - b0) / numPoints;
    var alphaPerVertex = (a1 - a0) / numPoints;
    var index = offset;
    for (i = 0; i < numPoints; i++) {
        array[index++] = Color.floatToByte(r0 + i * redPerVertex);
        array[index++] = Color.floatToByte(g0 + i * greenPerVertex);
        array[index++] = Color.floatToByte(b0 + i * bluePerVertex);
        array[index++] = Color.floatToByte(a0 + i * alphaPerVertex);
    }
    return index;
}
var SimplePolylineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var positions = options.positions;
    var colors = options.colors;
    var perVertex = defaultValue(options.colorsPerVertex, false);
    if (!defined(positions) || positions.length < 2) {
        throw new DeveloperError('At least two positions are required.');
    }
    if (defined(colors) && (perVertex && colors.length < positions.length || !perVertex && colors.length < positions.length - 1)) {
        throw new DeveloperError('colors has an invalid length.');
    }
    this._positions = positions;
    this._colors = colors;
    this._perVertex = perVertex;
    this._followSurface = defaultValue(options.followSurface, true);
    this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    this._workerName = 'createSimplePolylineGeometry';
    var numComponents = 1 + positions.length * Cartesian3.packedLength;
    numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;
    this.packedLength = numComponents + Ellipsoid.packedLength + 3;
};
SimplePolylineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var positions = value._positions;
    var length = positions.length;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        Cartesian3.pack(positions[i], array, startingIndex);
    }
    var colors = value._colors;
    length = defined(colors) ? colors.length : 0;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {
        Color.pack(colors[i], array, startingIndex);
    }
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    array[startingIndex++] = value._perVertex ? 1 : 0;
    array[startingIndex++] = value._followSurface ? 1 : 0;
    array[startingIndex] = value._granularity;
};
SimplePolylineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var length = array[startingIndex++];
    var positions = new Array(length);
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    length = array[startingIndex++];
    var colors = length > 0 ? new Array(length) : undefined;
    for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {
        colors[i] = Color.unpack(array, startingIndex);
    }
    var ellipsoid = Ellipsoid.unpack(array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    var perVertex = array[startingIndex++] === 1;
    var followSurface = array[startingIndex++] === 1;
    var granularity = array[startingIndex];
    if (!defined(result)) {
        return new SimplePolylineGeometry({
            positions: positions,
            colors: colors,
            ellipsoid: ellipsoid,
            perVertex: perVertex,
            followSurface: followSurface,
            granularity: granularity
        });
    }
    result._positions = positions;
    result._colors = colors;
    result._ellipsoid = ellipsoid;
    result._perVertex = perVertex;
    result._followSurface = followSurface;
    result._granularity = granularity;
    return result;
};
var scratchArray1 = new Array(2);
var scratchArray2 = new Array(2);
var generateArcOptionsScratch = {
        positions: scratchArray1,
        height: scratchArray2,
        ellipsoid: undefined,
        minDistance: undefined
    };
SimplePolylineGeometry.createGeometry = function (simplePolylineGeometry) {
    var positions = simplePolylineGeometry._positions;
    var colors = simplePolylineGeometry._colors;
    var perVertex = simplePolylineGeometry._perVertex;
    var followSurface = simplePolylineGeometry._followSurface;
    var granularity = simplePolylineGeometry._granularity;
    var ellipsoid = simplePolylineGeometry._ellipsoid;
    var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
    var perSegmentColors = defined(colors) && !perVertex;
    var i;
    var length = positions.length;
    var positionValues;
    var numberOfPositions;
    var colorValues;
    var color;
    var offset = 0;
    if (followSurface) {
        var heights = PolylinePipeline.extractHeights(positions, ellipsoid);
        var generateArcOptions = generateArcOptionsScratch;
        generateArcOptions.minDistance = minDistance;
        generateArcOptions.ellipsoid = ellipsoid;
        if (perSegmentColors) {
            var positionCount = 0;
            for (i = 0; i < length - 1; i++) {
                positionCount += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance) + 1;
            }
            positionValues = new Float64Array(positionCount * 3);
            colorValues = new Uint8Array(positionCount * 4);
            generateArcOptions.positions = scratchArray1;
            generateArcOptions.height = scratchArray2;
            var ci = 0;
            for (i = 0; i < length - 1; ++i) {
                scratchArray1[0] = positions[i];
                scratchArray1[1] = positions[i + 1];
                scratchArray2[0] = heights[i];
                scratchArray2[1] = heights[i + 1];
                var pos = PolylinePipeline.generateArc(generateArcOptions);
                if (defined(colors)) {
                    var segLen = pos.length / 3;
                    color = colors[i];
                    for (var k = 0; k < segLen; ++k) {
                        colorValues[ci++] = Color.floatToByte(color.red);
                        colorValues[ci++] = Color.floatToByte(color.green);
                        colorValues[ci++] = Color.floatToByte(color.blue);
                        colorValues[ci++] = Color.floatToByte(color.alpha);
                    }
                }
                positionValues.set(pos, offset);
                offset += pos.length;
            }
        } else {
            generateArcOptions.positions = positions;
            generateArcOptions.height = heights;
            positionValues = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));
            if (defined(colors)) {
                colorValues = new Uint8Array(positionValues.length / 3 * 4);
                for (i = 0; i < length - 1; ++i) {
                    var p0 = positions[i];
                    var p1 = positions[i + 1];
                    var c0 = colors[i];
                    var c1 = colors[i + 1];
                    offset = interpolateColors(p0, p1, c0, c1, minDistance, colorValues, offset);
                }
                var lastColor = colors[length - 1];
                colorValues[offset++] = Color.floatToByte(lastColor.red);
                colorValues[offset++] = Color.floatToByte(lastColor.green);
                colorValues[offset++] = Color.floatToByte(lastColor.blue);
                colorValues[offset++] = Color.floatToByte(lastColor.alpha);
            }
        }
    } else {
        numberOfPositions = perSegmentColors ? length * 2 - 2 : length;
        positionValues = new Float64Array(numberOfPositions * 3);
        colorValues = defined(colors) ? new Uint8Array(numberOfPositions * 4) : undefined;
        var positionIndex = 0;
        var colorIndex = 0;
        for (i = 0; i < length; ++i) {
            var p = positions[i];
            if (perSegmentColors && i > 0) {
                Cartesian3.pack(p, positionValues, positionIndex);
                positionIndex += 3;
                color = colors[i - 1];
                colorValues[colorIndex++] = Color.floatToByte(color.red);
                colorValues[colorIndex++] = Color.floatToByte(color.green);
                colorValues[colorIndex++] = Color.floatToByte(color.blue);
                colorValues[colorIndex++] = Color.floatToByte(color.alpha);
            }
            if (perSegmentColors && i === length - 1) {
                break;
            }
            Cartesian3.pack(p, positionValues, positionIndex);
            positionIndex += 3;
            if (defined(colors)) {
                color = colors[i];
                colorValues[colorIndex++] = Color.floatToByte(color.red);
                colorValues[colorIndex++] = Color.floatToByte(color.green);
                colorValues[colorIndex++] = Color.floatToByte(color.blue);
                colorValues[colorIndex++] = Color.floatToByte(color.alpha);
            }
        }
    }
    var attributes = new GeometryAttributes();
    attributes.position = new GeometryAttribute({
        componentDatatype: ComponentDatatype.DOUBLE,
        componentsPerAttribute: 3,
        values: positionValues
    });
    if (defined(colors)) {
        attributes.color = new GeometryAttribute({
            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,
            componentsPerAttribute: 4,
            values: colorValues,
            normalize: true
        });
    }
    numberOfPositions = positionValues.length / 3;
    var numberOfIndices = (numberOfPositions - 1) * 2;
    var indices = IndexDatatype.createTypedArray(numberOfPositions, numberOfIndices);
    var index = 0;
    for (i = 0; i < numberOfPositions - 1; ++i) {
        indices[index++] = i;
        indices[index++] = i + 1;
    }
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.LINES,
        boundingSphere: BoundingSphere.fromPoints(positions)
    });
};
module.exports = SimplePolylineGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./Color":111,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PolylinePipeline":189,"./PrimitiveType":193,"./defaultValue":243,"./defined":245}],213:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EllipsoidGeometry = require('./EllipsoidGeometry'), VertexFormat = require('./VertexFormat');
'use strict';
var SphereGeometry = function (options) {
    var radius = defaultValue(options.radius, 1);
    var radii = new Cartesian3(radius, radius, radius);
    var ellipsoidOptions = {
            radii: radii,
            stackPartitions: options.stackPartitions,
            slicePartitions: options.slicePartitions,
            vertexFormat: options.vertexFormat
        };
    this._ellipsoidGeometry = new EllipsoidGeometry(ellipsoidOptions);
    this._workerName = 'createSphereGeometry';
};
SphereGeometry.packedLength = EllipsoidGeometry.packedLength;
SphereGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    EllipsoidGeometry.pack(value._ellipsoidGeometry, array, startingIndex);
};
var scratchEllipsoidGeometry = new EllipsoidGeometry();
var scratchOptions = {
        radius: undefined,
        radii: new Cartesian3(),
        vertexFormat: new VertexFormat(),
        stackPartitions: undefined,
        slicePartitions: undefined
    };
SphereGeometry.unpack = function (array, startingIndex, result) {
    var ellipsoidGeometry = EllipsoidGeometry.unpack(array, startingIndex, scratchEllipsoidGeometry);
    scratchOptions.vertexFormat = VertexFormat.clone(ellipsoidGeometry._vertexFormat, scratchOptions.vertexFormat);
    scratchOptions.stackPartitions = ellipsoidGeometry._stackPartitions;
    scratchOptions.slicePartitions = ellipsoidGeometry._slicePartitions;
    if (!defined(result)) {
        scratchOptions.radius = ellipsoidGeometry._radii.x;
        return new SphereGeometry(scratchOptions);
    }
    Cartesian3.clone(ellipsoidGeometry._radii, scratchOptions.radii);
    result._ellipsoidGeometry = new EllipsoidGeometry(scratchOptions);
    return result;
};
SphereGeometry.createGeometry = function (sphereGeometry) {
    return EllipsoidGeometry.createGeometry(sphereGeometry._ellipsoidGeometry);
};
module.exports = SphereGeometry;
},{"./Cartesian3":102,"./DeveloperError":123,"./EllipsoidGeometry":132,"./VertexFormat":228,"./defaultValue":243,"./defined":245}],214:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EllipsoidOutlineGeometry = require('./EllipsoidOutlineGeometry');
'use strict';
var SphereOutlineGeometry = function (options) {
    var radius = defaultValue(options.radius, 1);
    var radii = new Cartesian3(radius, radius, radius);
    var ellipsoidOptions = {
            radii: radii,
            stackPartitions: options.stackPartitions,
            slicePartitions: options.slicePartitions,
            subdivisions: options.subdivisions
        };
    this._ellipsoidGeometry = new EllipsoidOutlineGeometry(ellipsoidOptions);
    this._workerName = 'createSphereOutlineGeometry';
};
SphereOutlineGeometry.packedLength = EllipsoidOutlineGeometry.packedLength;
SphereOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    EllipsoidOutlineGeometry.pack(value._ellipsoidGeometry, array, startingIndex);
};
var scratchEllipsoidGeometry = new EllipsoidOutlineGeometry();
var scratchOptions = {
        radius: undefined,
        radii: new Cartesian3(),
        stackPartitions: undefined,
        slicePartitions: undefined,
        subdivisions: undefined
    };
SphereOutlineGeometry.unpack = function (array, startingIndex, result) {
    var ellipsoidGeometry = EllipsoidOutlineGeometry.unpack(array, startingIndex, scratchEllipsoidGeometry);
    scratchOptions.stackPartitions = ellipsoidGeometry._stackPartitions;
    scratchOptions.slicePartitions = ellipsoidGeometry._slicePartitions;
    scratchOptions.subdivisions = ellipsoidGeometry._subdivisions;
    if (!defined(result)) {
        scratchOptions.radius = ellipsoidGeometry._radii.x;
        return new SphereOutlineGeometry(scratchOptions);
    }
    Cartesian3.clone(ellipsoidGeometry._radii, scratchOptions.radii);
    result._ellipsoidGeometry = new EllipsoidOutlineGeometry(scratchOptions);
    return result;
};
SphereOutlineGeometry.createGeometry = function (sphereGeometry) {
    return EllipsoidOutlineGeometry.createGeometry(sphereGeometry._ellipsoidGeometry);
};
module.exports = SphereOutlineGeometry;
},{"./Cartesian3":102,"./DeveloperError":123,"./EllipsoidOutlineGeometry":133,"./defaultValue":243,"./defined":245}],215:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var Spherical = function (clock, cone, magnitude) {
    this.clock = defaultValue(clock, 0);
    this.cone = defaultValue(cone, 0);
    this.magnitude = defaultValue(magnitude, 1);
};
Spherical.fromCartesian3 = function (cartesian3, result) {
    if (!defined(cartesian3)) {
        throw new DeveloperError('cartesian3 is required');
    }
    var x = cartesian3.x;
    var y = cartesian3.y;
    var z = cartesian3.z;
    var radialSquared = x * x + y * y;
    if (!defined(result)) {
        result = new Spherical();
    }
    result.clock = Math.atan2(y, x);
    result.cone = Math.atan2(Math.sqrt(radialSquared), z);
    result.magnitude = Math.sqrt(radialSquared + z * z);
    return result;
};
Spherical.clone = function (spherical, result) {
    if (!defined(spherical)) {
        return undefined;
    }
    if (!defined(result)) {
        return new Spherical(spherical.clock, spherical.cone, spherical.magnitude);
    }
    result.clock = spherical.clock;
    result.cone = spherical.cone;
    result.magnitude = spherical.magnitude;
    return result;
};
Spherical.normalize = function (spherical, result) {
    if (!defined(spherical)) {
        throw new DeveloperError('spherical is required');
    }
    if (!defined(result)) {
        return new Spherical(spherical.clock, spherical.cone, 1);
    }
    result.clock = spherical.clock;
    result.cone = spherical.cone;
    result.magnitude = 1;
    return result;
};
Spherical.equals = function (left, right) {
    return left === right || defined(left) && defined(right) && left.clock === right.clock && left.cone === right.cone && left.magnitude === right.magnitude;
};
Spherical.equalsEpsilon = function (left, right, epsilon) {
    epsilon = defaultValue(epsilon, 0);
    return left === right || defined(left) && defined(right) && Math.abs(left.clock - right.clock) <= epsilon && Math.abs(left.cone - right.cone) <= epsilon && Math.abs(left.magnitude - right.magnitude) <= epsilon;
};
Spherical.prototype.equals = function (other) {
    return Spherical.equals(this, other);
};
Spherical.prototype.clone = function (result) {
    return Spherical.clone(this, result);
};
Spherical.prototype.equalsEpsilon = function (other, epsilon) {
    return Spherical.equalsEpsilon(this, other, epsilon);
};
Spherical.prototype.toString = function () {
    return '(' + this.clock + ', ' + this.cone + ', ' + this.magnitude + ')';
};
module.exports = Spherical;
},{"./DeveloperError":123,"./defaultValue":243,"./defined":245}],216:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var Spline = function () {
    this.times = undefined;
    this.points = undefined;
    DeveloperError.throwInstantiationError();
};
Spline.prototype.evaluate = DeveloperError.throwInstantiationError;
Spline.prototype.findTimeInterval = function (time, startIndex) {
    var times = this.times;
    var length = times.length;
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (time < times[0] || time > times[length - 1]) {
        throw new DeveloperError('time is out of range.');
    }
    startIndex = defaultValue(startIndex, 0);
    if (time >= times[startIndex]) {
        if (startIndex + 1 < length && time < times[startIndex + 1]) {
            return startIndex;
        } else if (startIndex + 2 < length && time < times[startIndex + 2]) {
            return startIndex + 1;
        }
    } else if (startIndex - 1 >= 0 && time >= times[startIndex - 1]) {
        return startIndex - 1;
    }
    var i;
    if (time > times[startIndex]) {
        for (i = startIndex; i < length - 1; ++i) {
            if (time >= times[i] && time < times[i + 1]) {
                break;
            }
        }
    } else {
        for (i = startIndex - 1; i >= 0; --i) {
            if (time >= times[i] && time < times[i + 1]) {
                break;
            }
        }
    }
    if (i === length - 1) {
        i = length - 2;
    }
    return i;
};
module.exports = Spline;
},{"./DeveloperError":123,"./defaultValue":243,"./defined":245}],217:[function(require,module,exports){
var Uri = require('../ThirdParty/Uri'), when = require('../ThirdParty/when'), buildModuleUrl = require('./buildModuleUrl'), defaultValue = require('./defaultValue'), defined = require('./defined'), destroyObject = require('./destroyObject'), DeveloperError = require('./DeveloperError'), isCrossOriginUrl = require('./isCrossOriginUrl'), RuntimeError = require('./RuntimeError');
'use strict';
function canTransferArrayBuffer() {
    if (!defined(TaskProcessor._canTransferArrayBuffer)) {
        var worker = new Worker(getWorkerUrl('Workers/transferTypedArrayTest.js'));
        worker.postMessage = defaultValue(worker.webkitPostMessage, worker.postMessage);
        var value = 99;
        var array = new Int8Array([value]);
        try {
            worker.postMessage({ array: array }, [array.buffer]);
        } catch (e) {
            TaskProcessor._canTransferArrayBuffer = false;
            return TaskProcessor._canTransferArrayBuffer;
        }
        var deferred = when.defer();
        worker.onmessage = function (event) {
            var array = event.data.array;
            var result = defined(array) && array[0] === value;
            deferred.resolve(result);
            worker.terminate();
            TaskProcessor._canTransferArrayBuffer = result;
        };
        TaskProcessor._canTransferArrayBuffer = deferred.promise;
    }
    return TaskProcessor._canTransferArrayBuffer;
}
function completeTask(processor, data) {
    --processor._activeTasks;
    var id = data.id;
    if (!defined(id)) {
        return;
    }
    var deferreds = processor._deferreds;
    var deferred = deferreds[id];
    if (defined(data.error)) {
        var error = data.error;
        if (error.name === 'RuntimeError') {
            error = new RuntimeError(data.error.message);
            error.stack = data.error.stack;
        } else if (error.name === 'DeveloperError') {
            error = new DeveloperError(data.error.message);
            error.stack = data.error.stack;
        }
        deferred.reject(error);
    } else {
        deferred.resolve(data.result);
    }
    delete deferreds[id];
}
function getWorkerUrl(moduleID) {
    var url = buildModuleUrl(moduleID);
    if (isCrossOriginUrl(url)) {
        var script = 'importScripts("' + url + '");';
        var blob;
        try {
            blob = new Blob([script], { type: 'application/javascript' });
        } catch (e) {
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            blob = blobBuilder.getBlob('application/javascript');
        }
        var URL = window.URL || window.webkitURL;
        url = URL.createObjectURL(blob);
    }
    return url;
}
var bootstrapperUrlResult;
function getBootstrapperUrl() {
    if (!defined(bootstrapperUrlResult)) {
        bootstrapperUrlResult = getWorkerUrl('Workers/cesiumWorkerBootstrapper.js');
    }
    return bootstrapperUrlResult;
}
function createWorker(processor) {
    var worker = new Worker(getBootstrapperUrl());
    worker.postMessage = defaultValue(worker.webkitPostMessage, worker.postMessage);
    var bootstrapMessage = {
            loaderConfig: {},
            workerModule: TaskProcessor._workerModulePrefix + processor._workerName
        };
    if (defined(TaskProcessor._loaderConfig)) {
        bootstrapMessage.loaderConfig = TaskProcessor._loaderConfig;
    } else if (defined(require.toUrl)) {
        var baseUrl = new Uri('..').resolve(new Uri(buildModuleUrl('Workers/cesiumWorkerBootstrapper.js'))).toString();
        bootstrapMessage.loaderConfig.baseUrl = baseUrl;
    } else {
        bootstrapMessage.loaderConfig.paths = { 'Workers': buildModuleUrl('Workers') };
    }
    worker.postMessage(bootstrapMessage);
    worker.onmessage = function (event) {
        completeTask(processor, event.data);
    };
    return worker;
}
var TaskProcessor = function (workerName, maximumActiveTasks) {
    this._workerName = workerName;
    this._maximumActiveTasks = defaultValue(maximumActiveTasks, 5);
    this._activeTasks = 0;
    this._deferreds = {};
    this._nextID = 0;
};
var emptyTransferableObjectArray = [];
TaskProcessor.prototype.scheduleTask = function (parameters, transferableObjects) {
    if (!defined(this._worker)) {
        this._worker = createWorker(this);
    }
    if (this._activeTasks >= this._maximumActiveTasks) {
        return undefined;
    }
    ++this._activeTasks;
    var processor = this;
    return when(canTransferArrayBuffer(), function (canTransferArrayBuffer) {
        if (!defined(transferableObjects)) {
            transferableObjects = emptyTransferableObjectArray;
        } else if (!canTransferArrayBuffer) {
            transferableObjects.length = 0;
        }
        var id = processor._nextID++;
        var deferred = when.defer();
        processor._deferreds[id] = deferred;
        processor._worker.postMessage({
            id: id,
            parameters: parameters,
            canTransferArrayBuffer: canTransferArrayBuffer
        }, transferableObjects);
        return deferred.promise;
    });
};
TaskProcessor.prototype.isDestroyed = function () {
    return false;
};
TaskProcessor.prototype.destroy = function () {
    if (defined(this._worker)) {
        this._worker.terminate();
    }
    return destroyObject(this);
};
TaskProcessor._defaultWorkerModulePrefix = 'Workers/';
TaskProcessor._workerModulePrefix = TaskProcessor._defaultWorkerModulePrefix;
TaskProcessor._loaderConfig = undefined;
TaskProcessor._canTransferArrayBuffer = undefined;
module.exports = TaskProcessor;
},{"../ThirdParty/Uri":587,"../ThirdParty/when":596,"./DeveloperError":123,"./RuntimeError":207,"./buildModuleUrl":239,"./defaultValue":243,"./defined":245,"./destroyObject":247,"./isCrossOriginUrl":254}],218:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue');
'use strict';
var TerrainMesh = function TerrainMesh(center, vertices, indices, minimumHeight, maximumHeight, boundingSphere3D, occludeePointInScaledSpace, vertexStride) {
    this.center = center;
    this.vertices = vertices;
    this.stride = defaultValue(vertexStride, 6);
    this.indices = indices;
    this.minimumHeight = minimumHeight;
    this.maximumHeight = maximumHeight;
    this.boundingSphere3D = boundingSphere3D;
    this.occludeePointInScaledSpace = occludeePointInScaledSpace;
};
module.exports = TerrainMesh;
},{"../Core/defaultValue":243}],219:[function(require,module,exports){
var defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError');
'use strict';
var TerrainProvider = function () {
    DeveloperError.throwInstantiationError();
};
defineProperties(TerrainProvider.prototype, {
    errorEvent: { get: DeveloperError.throwInstantiationError },
    credit: { get: DeveloperError.throwInstantiationError },
    tilingScheme: { get: DeveloperError.throwInstantiationError },
    ready: { get: DeveloperError.throwInstantiationError },
    hasWaterMask: { get: DeveloperError.throwInstantiationError },
    hasVertexNormals: { get: DeveloperError.throwInstantiationError }
});
var regularGridIndexArrays = [];
TerrainProvider.getRegularGridIndices = function (width, height) {
    if (width * height > 64 * 1024) {
        throw new DeveloperError('The total number of vertices (width * height) must be less than or equal to 65536.');
    }
    var byWidth = regularGridIndexArrays[width];
    if (!defined(byWidth)) {
        regularGridIndexArrays[width] = byWidth = [];
    }
    var indices = byWidth[height];
    if (!defined(indices)) {
        indices = byWidth[height] = new Uint16Array((width - 1) * (height - 1) * 6);
        var index = 0;
        var indicesIndex = 0;
        for (var j = 0; j < height - 1; ++j) {
            for (var i = 0; i < width - 1; ++i) {
                var upperLeft = index;
                var lowerLeft = upperLeft + width;
                var lowerRight = lowerLeft + 1;
                var upperRight = upperLeft + 1;
                indices[indicesIndex++] = upperLeft;
                indices[indicesIndex++] = lowerLeft;
                indices[indicesIndex++] = upperRight;
                indices[indicesIndex++] = upperRight;
                indices[indicesIndex++] = lowerLeft;
                indices[indicesIndex++] = lowerRight;
                ++index;
            }
            ++index;
        }
    }
    return indices;
};
TerrainProvider.heightmapTerrainQuality = 0.25;
TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (ellipsoid, tileImageWidth, numberOfTilesAtLevelZero) {
    return ellipsoid.maximumRadius * 2 * Math.PI * TerrainProvider.heightmapTerrainQuality / (tileImageWidth * numberOfTilesAtLevelZero);
};
TerrainProvider.prototype.requestTileGeometry = DeveloperError.throwInstantiationError;
TerrainProvider.prototype.getLevelMaximumGeometricError = DeveloperError.throwInstantiationError;
TerrainProvider.prototype.getTileDataAvailable = DeveloperError.throwInstantiationError;
module.exports = TerrainProvider;
},{"./DeveloperError":123,"./defineProperties":244,"./defined":245}],220:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), formatError = require('./formatError');
'use strict';
var TileProviderError = function TileProviderError(provider, message, x, y, level, timesRetried) {
    this.provider = provider;
    this.message = message;
    this.x = x;
    this.y = y;
    this.level = level;
    this.timesRetried = defaultValue(timesRetried, 0);
    this.retry = false;
};
TileProviderError.handleError = function (previousError, provider, event, message, x, y, level, retryFunction) {
    var error = previousError;
    if (!defined(previousError)) {
        error = new TileProviderError(provider, message, x, y, level, 0);
    } else {
        error.provider = provider;
        error.message = message;
        error.x = x;
        error.y = y;
        error.level = level;
        error.retry = false;
        ++error.timesRetried;
    }
    if (event.numberOfListeners > 0) {
        event.raiseEvent(error);
    } else {
        console.log('An error occurred in "' + provider.constructor.name + '": ' + formatError(message));
    }
    if (error.retry && defined(retryFunction)) {
        retryFunction();
    }
    return error;
};
TileProviderError.handleSuccess = function (previousError) {
    if (defined(previousError)) {
        previousError.timesRetried = -1;
    }
};
module.exports = TileProviderError;
},{"./defaultValue":243,"./defined":245,"./formatError":248}],221:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var TimeConstants = {
        SECONDS_PER_MILLISECOND: 0.001,
        SECONDS_PER_MINUTE: 60,
        MINUTES_PER_HOUR: 60,
        HOURS_PER_DAY: 24,
        SECONDS_PER_HOUR: 3600,
        MINUTES_PER_DAY: 1440,
        SECONDS_PER_DAY: 86400,
        DAYS_PER_JULIAN_CENTURY: 36525,
        PICOSECOND: 1e-9,
        MODIFIED_JULIAN_DATE_DIFFERENCE: 2400000.5
    };
module.exports = freezeObject(TimeConstants);
},{"./freezeObject":249}],222:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject'), JulianDate = require('./JulianDate');
'use strict';
var TimeInterval = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.start = defined(options.start) ? JulianDate.clone(options.start) : new JulianDate();
    this.stop = defined(options.stop) ? JulianDate.clone(options.stop) : new JulianDate();
    this.data = options.data;
    this.isStartIncluded = defaultValue(options.isStartIncluded, true);
    this.isStopIncluded = defaultValue(options.isStopIncluded, true);
};
defineProperties(TimeInterval.prototype, {
    isEmpty: {
        get: function () {
            var stopComparedToStart = JulianDate.compare(this.stop, this.start);
            return stopComparedToStart < 0 || stopComparedToStart === 0 && (!this.isStartIncluded || !this.isStopIncluded);
        }
    }
});
var scratchInterval = {
        start: undefined,
        stop: undefined,
        isStartIncluded: undefined,
        isStopIncluded: undefined,
        data: undefined
    };
TimeInterval.fromIso8601 = function (options, result) {
    if (!defined(options)) {
        throw new DeveloperError('options is required.');
    }
    if (!defined(options.iso8601)) {
        throw new DeveloperError('options.iso8601 is required.');
    }
    var dates = options.iso8601.split('/');
    var start = JulianDate.fromIso8601(dates[0]);
    var stop = JulianDate.fromIso8601(dates[1]);
    var isStartIncluded = defaultValue(options.isStartIncluded, true);
    var isStopIncluded = defaultValue(options.isStopIncluded, true);
    var data = options.data;
    if (!defined(result)) {
        scratchInterval.start = start;
        scratchInterval.stop = stop;
        scratchInterval.isStartIncluded = isStartIncluded;
        scratchInterval.isStopIncluded = isStopIncluded;
        scratchInterval.data = data;
        return new TimeInterval(scratchInterval);
    }
    result.start = start;
    result.stop = stop;
    result.isStartIncluded = isStartIncluded;
    result.isStopIncluded = isStopIncluded;
    result.data = data;
    return result;
};
TimeInterval.toIso8601 = function (timeInterval, precision) {
    if (!defined(timeInterval)) {
        throw new DeveloperError('timeInterval is required.');
    }
    return JulianDate.toIso8601(timeInterval.start, precision) + '/' + JulianDate.toIso8601(timeInterval.stop, precision);
};
TimeInterval.clone = function (timeInterval, result) {
    if (!defined(timeInterval)) {
        return undefined;
    }
    if (!defined(result)) {
        return new TimeInterval(timeInterval);
    }
    result.start = timeInterval.start;
    result.stop = timeInterval.stop;
    result.isStartIncluded = timeInterval.isStartIncluded;
    result.isStopIncluded = timeInterval.isStopIncluded;
    result.data = timeInterval.data;
    return result;
};
TimeInterval.equals = function (left, right, dataComparer) {
    return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equals(left.start, right.start) && JulianDate.equals(left.stop, right.stop) && (left.data === right.data || defined(dataComparer) && dataComparer(left.data, right.data)));
};
TimeInterval.equalsEpsilon = function (left, right, epsilon, dataComparer) {
    if (typeof epsilon !== 'number') {
        throw new DeveloperError('epsilon is required and must be a number.');
    }
    return left === right || defined(left) && defined(right) && (left.isEmpty && right.isEmpty || left.isStartIncluded === right.isStartIncluded && left.isStopIncluded === right.isStopIncluded && JulianDate.equalsEpsilon(left.start, right.start, epsilon) && JulianDate.equalsEpsilon(left.stop, right.stop, epsilon) && (left.data === right.data || defined(dataComparer) && dataComparer(left.data, right.data)));
};
TimeInterval.intersect = function (left, right, result, mergeCallback) {
    if (!defined(left)) {
        throw new DeveloperError('left is required.');
    }
    if (!defined(result)) {
        throw new DeveloperError('result is required.');
    }
    if (!defined(right)) {
        return TimeInterval.clone(TimeInterval.EMPTY, result);
    }
    var leftStart = left.start;
    var leftStop = left.stop;
    var rightStart = right.start;
    var rightStop = right.stop;
    var intersectsStartRight = JulianDate.greaterThanOrEquals(rightStart, leftStart) && JulianDate.greaterThanOrEquals(leftStop, rightStart);
    var intersectsStartLeft = !intersectsStartRight && JulianDate.lessThanOrEquals(rightStart, leftStart) && JulianDate.lessThanOrEquals(leftStart, rightStop);
    if (!intersectsStartRight && !intersectsStartLeft) {
        return TimeInterval.clone(TimeInterval.EMPTY, result);
    }
    var leftIsStartIncluded = left.isStartIncluded;
    var leftIsStopIncluded = left.isStopIncluded;
    var rightIsStartIncluded = right.isStartIncluded;
    var rightIsStopIncluded = right.isStopIncluded;
    var leftLessThanRight = JulianDate.lessThan(leftStop, rightStop);
    result.start = intersectsStartRight ? rightStart : leftStart;
    result.isStartIncluded = leftIsStartIncluded && rightIsStartIncluded || !JulianDate.equals(rightStart, leftStart) && (intersectsStartRight && rightIsStartIncluded || intersectsStartLeft && leftIsStartIncluded);
    result.stop = leftLessThanRight ? leftStop : rightStop;
    result.isStopIncluded = leftLessThanRight ? leftIsStopIncluded : leftIsStopIncluded && rightIsStopIncluded || !JulianDate.equals(rightStop, leftStop) && rightIsStopIncluded;
    result.data = defined(mergeCallback) ? mergeCallback(left.data, right.data) : left.data;
    return result;
};
TimeInterval.contains = function (timeInterval, julianDate) {
    if (!defined(timeInterval)) {
        throw new DeveloperError('timeInterval is required.');
    }
    if (!defined(julianDate)) {
        throw new DeveloperError('julianDate is required.');
    }
    if (timeInterval.isEmpty) {
        return false;
    }
    var startComparedToDate = JulianDate.compare(timeInterval.start, julianDate);
    if (startComparedToDate === 0) {
        return timeInterval.isStartIncluded;
    }
    var dateComparedToStop = JulianDate.compare(julianDate, timeInterval.stop);
    if (dateComparedToStop === 0) {
        return timeInterval.isStopIncluded;
    }
    return startComparedToDate < 0 && dateComparedToStop < 0;
};
TimeInterval.prototype.clone = function (result) {
    return TimeInterval.clone(this, result);
};
TimeInterval.prototype.equals = function (right, dataComparer) {
    return TimeInterval.equals(this, right, dataComparer);
};
TimeInterval.prototype.equalsEpsilon = function (right, epsilon, dataComparer) {
    return TimeInterval.equalsEpsilon(this, right, epsilon, dataComparer);
};
TimeInterval.prototype.toString = function () {
    return TimeInterval.toIso8601(this);
};
TimeInterval.EMPTY = freezeObject(new TimeInterval({
    start: new JulianDate(),
    stop: new JulianDate(),
    isStartIncluded: false,
    isStopIncluded: false
}));
module.exports = TimeInterval;
},{"./DeveloperError":123,"./JulianDate":168,"./defaultValue":243,"./defineProperties":244,"./defined":245,"./freezeObject":249}],223:[function(require,module,exports){
var binarySearch = require('./binarySearch'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Event = require('./Event'), JulianDate = require('./JulianDate'), TimeInterval = require('./TimeInterval');
'use strict';
function compareIntervalStartTimes(left, right) {
    return JulianDate.compare(left.start, right.start);
}
var TimeIntervalCollection = function () {
    this._intervals = [];
    this._changedEvent = new Event();
};
defineProperties(TimeIntervalCollection.prototype, {
    changedEvent: {
        get: function () {
            return this._changedEvent;
        }
    },
    start: {
        get: function () {
            var intervals = this._intervals;
            return intervals.length === 0 ? undefined : intervals[0].start;
        }
    },
    isStartIncluded: {
        get: function () {
            var intervals = this._intervals;
            return intervals.length === 0 ? false : intervals[0].isStartIncluded;
        }
    },
    stop: {
        get: function () {
            var intervals = this._intervals;
            var length = intervals.length;
            return length === 0 ? undefined : intervals[length - 1].stop;
        }
    },
    isStopIncluded: {
        get: function () {
            var intervals = this._intervals;
            var length = intervals.length;
            return length === 0 ? false : intervals[length - 1].isStopIncluded;
        }
    },
    length: {
        get: function () {
            return this._intervals.length;
        }
    },
    isEmpty: {
        get: function () {
            return this._intervals.length === 0;
        }
    }
});
TimeIntervalCollection.prototype.equals = function (right, dataComparer) {
    if (this === right) {
        return true;
    }
    if (!(right instanceof TimeIntervalCollection)) {
        return false;
    }
    var intervals = this._intervals;
    var rightIntervals = right._intervals;
    var length = intervals.length;
    if (length !== rightIntervals.length) {
        return false;
    }
    for (var i = 0; i < length; i++) {
        if (!TimeInterval.equals(intervals[i], rightIntervals[i], dataComparer)) {
            return false;
        }
    }
    return true;
};
TimeIntervalCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    return this._intervals[index];
};
TimeIntervalCollection.prototype.removeAll = function () {
    if (this._intervals.length > 0) {
        this._intervals.length = 0;
        this._changedEvent.raiseEvent(this);
    }
};
TimeIntervalCollection.prototype.findIntervalContainingDate = function (date) {
    var index = this.indexOf(date);
    return index >= 0 ? this._intervals[index] : undefined;
};
TimeIntervalCollection.prototype.findDataForIntervalContainingDate = function (date) {
    var index = this.indexOf(date);
    return index >= 0 ? this._intervals[index].data : undefined;
};
TimeIntervalCollection.prototype.contains = function (date) {
    return this.indexOf(date) >= 0;
};
var indexOfScratch = new TimeInterval();
TimeIntervalCollection.prototype.indexOf = function (date) {
    if (!defined(date)) {
        throw new DeveloperError('date is required');
    }
    var intervals = this._intervals;
    indexOfScratch.start = date;
    indexOfScratch.stop = date;
    var index = binarySearch(intervals, indexOfScratch, compareIntervalStartTimes);
    if (index >= 0) {
        if (intervals[index].isStartIncluded) {
            return index;
        }
        if (index > 0 && intervals[index - 1].stop.equals(date) && intervals[index - 1].isStopIncluded) {
            return index - 1;
        }
        return ~index;
    }
    index = ~index;
    if (index > 0 && index - 1 < intervals.length && TimeInterval.contains(intervals[index - 1], date)) {
        return index - 1;
    }
    return ~index;
};
TimeIntervalCollection.prototype.findInterval = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var start = options.start;
    var stop = options.stop;
    var isStartIncluded = options.isStartIncluded;
    var isStopIncluded = options.isStopIncluded;
    var intervals = this._intervals;
    for (var i = 0, len = intervals.length; i < len; i++) {
        var interval = intervals[i];
        if ((!defined(start) || interval.start.equals(start)) && (!defined(stop) || interval.stop.equals(stop)) && (!defined(isStartIncluded) || interval.isStartIncluded === isStartIncluded) && (!defined(isStopIncluded) || interval.isStopIncluded === isStopIncluded)) {
            return intervals[i];
        }
    }
    return undefined;
};
TimeIntervalCollection.prototype.addInterval = function (interval, dataComparer) {
    if (!defined(interval)) {
        throw new DeveloperError('interval is required');
    }
    if (interval.isEmpty) {
        return;
    }
    var comparison;
    var index;
    var intervals = this._intervals;
    if (intervals.length === 0 || JulianDate.greaterThan(interval.start, intervals[intervals.length - 1].stop)) {
        intervals.push(interval);
        this._changedEvent.raiseEvent(this);
        return;
    }
    index = binarySearch(intervals, interval, compareIntervalStartTimes);
    if (index < 0) {
        index = ~index;
    } else {
        if (index > 0 && interval.isStartIncluded && intervals[index - 1].isStartIncluded && intervals[index - 1].start.equals(interval.start)) {
            --index;
        } else if (index < intervals.length && !interval.isStartIncluded && intervals[index].isStartIncluded && intervals[index].start.equals(interval.start)) {
            ++index;
        }
    }
    if (index > 0) {
        comparison = JulianDate.compare(intervals[index - 1].stop, interval.start);
        if (comparison > 0 || comparison === 0 && (intervals[index - 1].isStopIncluded || interval.isStartIncluded)) {
            if (defined(dataComparer) ? dataComparer(intervals[index - 1].data, interval.data) : intervals[index - 1].data === interval.data) {
                if (JulianDate.greaterThan(interval.stop, intervals[index - 1].stop)) {
                    interval = new TimeInterval({
                        start: intervals[index - 1].start,
                        stop: interval.stop,
                        isStartIncluded: intervals[index - 1].isStartIncluded,
                        isStopIncluded: interval.isStopIncluded,
                        data: interval.data
                    });
                } else {
                    interval = new TimeInterval({
                        start: intervals[index - 1].start,
                        stop: intervals[index - 1].stop,
                        isStartIncluded: intervals[index - 1].isStartIncluded,
                        isStopIncluded: intervals[index - 1].isStopIncluded || interval.stop.equals(intervals[index - 1].stop) && interval.isStopIncluded,
                        data: interval.data
                    });
                }
                intervals.splice(index - 1, 1);
                --index;
            } else {
                comparison = JulianDate.compare(intervals[index - 1].stop, interval.stop);
                if (comparison > 0 || comparison === 0 && intervals[index - 1].isStopIncluded && !interval.isStopIncluded) {
                    intervals.splice(index - 1, 1, new TimeInterval({
                        start: intervals[index - 1].start,
                        stop: interval.start,
                        isStartIncluded: intervals[index - 1].isStartIncluded,
                        isStopIncluded: !interval.isStartIncluded,
                        data: intervals[index - 1].data
                    }), new TimeInterval({
                        start: interval.stop,
                        stop: intervals[index - 1].stop,
                        isStartIncluded: !interval.isStopIncluded,
                        isStopIncluded: intervals[index - 1].isStopIncluded,
                        data: intervals[index - 1].data
                    }));
                } else {
                    intervals[index - 1] = new TimeInterval({
                        start: intervals[index - 1].start,
                        stop: interval.start,
                        isStartIncluded: intervals[index - 1].isStartIncluded,
                        isStopIncluded: !interval.isStartIncluded,
                        data: intervals[index - 1].data
                    });
                }
            }
        }
    }
    while (index < intervals.length) {
        comparison = JulianDate.compare(interval.stop, intervals[index].start);
        if (comparison > 0 || comparison === 0 && (interval.isStopIncluded || intervals[index].isStartIncluded)) {
            if (defined(dataComparer) ? dataComparer(intervals[index].data, interval.data) : intervals[index].data === interval.data) {
                interval = new TimeInterval({
                    start: interval.start,
                    stop: JulianDate.greaterThan(intervals[index].stop, interval.stop) ? intervals[index].stop : interval.stop,
                    isStartIncluded: interval.isStartIncluded,
                    isStopIncluded: JulianDate.greaterThan(intervals[index].stop, interval.stop) ? intervals[index].isStopIncluded : interval.isStopIncluded,
                    data: interval.data
                });
                intervals.splice(index, 1);
            } else {
                intervals[index] = new TimeInterval({
                    start: interval.stop,
                    stop: intervals[index].stop,
                    isStartIncluded: !interval.isStopIncluded,
                    isStopIncluded: intervals[index].isStopIncluded,
                    data: intervals[index].data
                });
                if (intervals[index].isEmpty) {
                    intervals.splice(index, 1);
                } else {
                    break;
                }
            }
        } else {
            break;
        }
    }
    intervals.splice(index, 0, interval);
    this._changedEvent.raiseEvent(this);
};
TimeIntervalCollection.prototype.removeInterval = function (interval) {
    if (!defined(interval)) {
        throw new DeveloperError('interval is required');
    }
    if (interval.isEmpty) {
        return false;
    }
    var result = false;
    var intervals = this._intervals;
    var index = binarySearch(intervals, interval, compareIntervalStartTimes);
    if (index < 0) {
        index = ~index;
    }
    var intervalStart = interval.start;
    var intervalStop = interval.stop;
    var intervalIsStartIncluded = interval.isStartIncluded;
    var intervalIsStopIncluded = interval.isStopIncluded;
    if (index > 0) {
        var indexMinus1 = intervals[index - 1];
        var indexMinus1Stop = indexMinus1.stop;
        if (JulianDate.greaterThan(indexMinus1Stop, intervalStart) || TimeInterval.equals(indexMinus1Stop, intervalStart) && indexMinus1.isStopIncluded && intervalIsStartIncluded) {
            result = true;
            if (JulianDate.greaterThan(indexMinus1Stop, intervalStop) || indexMinus1.isStopIncluded && !intervalIsStopIncluded && TimeInterval.equals(indexMinus1Stop, intervalStop)) {
                intervals.splice(index, 0, new TimeInterval({
                    start: intervalStop,
                    stop: indexMinus1Stop,
                    isStartIncluded: !intervalIsStopIncluded,
                    isStopIncluded: indexMinus1.isStopIncluded,
                    data: indexMinus1.data
                }));
            }
            intervals[index - 1] = new TimeInterval({
                start: indexMinus1.start,
                stop: intervalStart,
                isStartIncluded: indexMinus1.isStartIncluded,
                isStopIncluded: !intervalIsStartIncluded,
                data: indexMinus1.data
            });
        }
    }
    var indexInterval = intervals[index];
    if (index < intervals.length && !intervalIsStartIncluded && indexInterval.isStartIncluded && intervalStart.equals(indexInterval.start)) {
        result = true;
        intervals.splice(index, 0, new TimeInterval({
            start: indexInterval.start,
            stop: indexInterval.start,
            isStartIncluded: true,
            isStopIncluded: true,
            data: indexInterval.data
        }));
        ++index;
        indexInterval = intervals[index];
    }
    while (index < intervals.length && JulianDate.greaterThan(intervalStop, indexInterval.stop)) {
        result = true;
        intervals.splice(index, 1);
    }
    if (index < intervals.length && intervalStop.equals(indexInterval.stop)) {
        result = true;
        if (!intervalIsStopIncluded && indexInterval.isStopIncluded) {
            if (index + 1 < intervals.length && intervals[index + 1].start.equals(intervalStop) && indexInterval.data === intervals[index + 1].data) {
                intervals.splice(index, 1);
                indexInterval = new TimeInterval({
                    start: indexInterval.start,
                    stop: indexInterval.stop,
                    isStartIncluded: true,
                    isStopIncluded: indexInterval.isStopIncluded,
                    data: indexInterval.data
                });
            } else {
                indexInterval = new TimeInterval({
                    start: intervalStop,
                    stop: intervalStop,
                    isStartIncluded: true,
                    isStopIncluded: true,
                    data: indexInterval.data
                });
            }
            intervals[index] = indexInterval;
        } else {
            intervals.splice(index, 1);
        }
    }
    if (index < intervals.length && (JulianDate.greaterThan(intervalStop, indexInterval.start) || intervalStop.equals(indexInterval.start) && intervalIsStopIncluded && indexInterval.isStartIncluded)) {
        result = true;
        intervals[index] = new TimeInterval({
            start: intervalStop,
            stop: indexInterval.stop,
            isStartIncluded: !intervalIsStopIncluded,
            isStopIncluded: indexInterval.isStopIncluded,
            data: indexInterval.data
        });
    }
    if (result) {
        this._changedEvent.raiseEvent(this);
    }
    return result;
};
TimeIntervalCollection.prototype.intersect = function (other, dataComparer, mergeCallback) {
    if (!defined(other)) {
        throw new DeveloperError('other is required.');
    }
    var left = 0;
    var right = 0;
    var result = new TimeIntervalCollection();
    var intervals = this._intervals;
    var otherIntervals = other._intervals;
    while (left < intervals.length && right < otherIntervals.length) {
        var leftInterval = intervals[left];
        var rightInterval = otherIntervals[right];
        if (JulianDate.lessThan(leftInterval.stop, rightInterval.start)) {
            ++left;
        } else if (JulianDate.lessThan(rightInterval.stop, leftInterval.start)) {
            ++right;
        } else {
            if (defined(mergeCallback) || (defined(dataComparer) && dataComparer(leftInterval.data, rightInterval.data) || !defined(dataComparer) && rightInterval.data === leftInterval.data)) {
                var intersection = TimeInterval.intersect(leftInterval, rightInterval, new TimeInterval(), mergeCallback);
                if (!intersection.isEmpty) {
                    result.addInterval(intersection, dataComparer);
                }
            }
            if (JulianDate.lessThan(leftInterval.stop, rightInterval.stop) || leftInterval.stop.equals(rightInterval.stop) && !leftInterval.isStopIncluded && rightInterval.isStopIncluded) {
                ++left;
            } else {
                ++right;
            }
        }
    }
    return result;
};
module.exports = TimeIntervalCollection;
},{"./DeveloperError":123,"./Event":138,"./JulianDate":168,"./TimeInterval":222,"./binarySearch":238,"./defaultValue":243,"./defineProperties":244,"./defined":245}],224:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var TimeStandard = {
        UTC: 0,
        TAI: 1
    };
module.exports = freezeObject(TimeStandard);
},{"./freezeObject":249}],225:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var Tipsify = {};
Tipsify.calculateACMR = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var indices = options.indices;
    var maximumIndex = options.maximumIndex;
    var cacheSize = defaultValue(options.cacheSize, 24);
    if (!defined(indices)) {
        throw new DeveloperError('indices is required.');
    }
    var numIndices = indices.length;
    if (numIndices < 3 || numIndices % 3 !== 0) {
        throw new DeveloperError('indices length must be a multiple of three.');
    }
    if (maximumIndex <= 0) {
        throw new DeveloperError('maximumIndex must be greater than zero.');
    }
    if (cacheSize < 3) {
        throw new DeveloperError('cacheSize must be greater than two.');
    }
    if (!defined(maximumIndex)) {
        maximumIndex = 0;
        var currentIndex = 0;
        var intoIndices = indices[currentIndex];
        while (currentIndex < numIndices) {
            if (intoIndices > maximumIndex) {
                maximumIndex = intoIndices;
            }
            ++currentIndex;
            intoIndices = indices[currentIndex];
        }
    }
    var vertexTimeStamps = [];
    for (var i = 0; i < maximumIndex + 1; i++) {
        vertexTimeStamps[i] = 0;
    }
    var s = cacheSize + 1;
    for (var j = 0; j < numIndices; ++j) {
        if (s - vertexTimeStamps[indices[j]] > cacheSize) {
            vertexTimeStamps[indices[j]] = s;
            ++s;
        }
    }
    return (s - cacheSize + 1) / (numIndices / 3);
};
Tipsify.tipsify = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var indices = options.indices;
    var maximumIndex = options.maximumIndex;
    var cacheSize = defaultValue(options.cacheSize, 24);
    var cursor;
    function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {
        while (deadEnd.length >= 1) {
            var d = deadEnd[deadEnd.length - 1];
            deadEnd.splice(deadEnd.length - 1, 1);
            if (vertices[d].numLiveTriangles > 0) {
                return d;
            }
        }
        while (cursor < maximumIndexPlusOne) {
            if (vertices[cursor].numLiveTriangles > 0) {
                ++cursor;
                return cursor - 1;
            }
            ++cursor;
        }
        return -1;
    }
    function getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne) {
        var n = -1;
        var p;
        var m = -1;
        var itOneRing = 0;
        while (itOneRing < oneRing.length) {
            var index = oneRing[itOneRing];
            if (vertices[index].numLiveTriangles) {
                p = 0;
                if (s - vertices[index].timeStamp + 2 * vertices[index].numLiveTriangles <= cacheSize) {
                    p = s - vertices[index].timeStamp;
                }
                if (p > m || m === -1) {
                    m = p;
                    n = index;
                }
            }
            ++itOneRing;
        }
        if (n === -1) {
            return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);
        }
        return n;
    }
    if (!defined(indices)) {
        throw new DeveloperError('indices is required.');
    }
    var numIndices = indices.length;
    if (numIndices < 3 || numIndices % 3 !== 0) {
        throw new DeveloperError('indices length must be a multiple of three.');
    }
    if (maximumIndex <= 0) {
        throw new DeveloperError('maximumIndex must be greater than zero.');
    }
    if (cacheSize < 3) {
        throw new DeveloperError('cacheSize must be greater than two.');
    }
    var maximumIndexPlusOne = 0;
    var currentIndex = 0;
    var intoIndices = indices[currentIndex];
    var endIndex = numIndices;
    if (defined(maximumIndex)) {
        maximumIndexPlusOne = maximumIndex + 1;
    } else {
        while (currentIndex < endIndex) {
            if (intoIndices > maximumIndexPlusOne) {
                maximumIndexPlusOne = intoIndices;
            }
            ++currentIndex;
            intoIndices = indices[currentIndex];
        }
        if (maximumIndexPlusOne === -1) {
            return 0;
        }
        ++maximumIndexPlusOne;
    }
    var vertices = [];
    for (var i = 0; i < maximumIndexPlusOne; i++) {
        vertices[i] = {
            numLiveTriangles: 0,
            timeStamp: 0,
            vertexTriangles: []
        };
    }
    currentIndex = 0;
    var triangle = 0;
    while (currentIndex < endIndex) {
        vertices[indices[currentIndex]].vertexTriangles.push(triangle);
        ++vertices[indices[currentIndex]].numLiveTriangles;
        vertices[indices[currentIndex + 1]].vertexTriangles.push(triangle);
        ++vertices[indices[currentIndex + 1]].numLiveTriangles;
        vertices[indices[currentIndex + 2]].vertexTriangles.push(triangle);
        ++vertices[indices[currentIndex + 2]].numLiveTriangles;
        ++triangle;
        currentIndex += 3;
    }
    var f = 0;
    var s = cacheSize + 1;
    cursor = 1;
    var oneRing = [];
    var deadEnd = [];
    var vertex;
    var intoVertices;
    var currentOutputIndex = 0;
    var outputIndices = [];
    var numTriangles = numIndices / 3;
    var triangleEmitted = [];
    for (i = 0; i < numTriangles; i++) {
        triangleEmitted[i] = false;
    }
    var index;
    var limit;
    while (f !== -1) {
        oneRing = [];
        intoVertices = vertices[f];
        limit = intoVertices.vertexTriangles.length;
        for (var k = 0; k < limit; ++k) {
            triangle = intoVertices.vertexTriangles[k];
            if (!triangleEmitted[triangle]) {
                triangleEmitted[triangle] = true;
                currentIndex = triangle + triangle + triangle;
                for (var j = 0; j < 3; ++j) {
                    index = indices[currentIndex];
                    oneRing.push(index);
                    deadEnd.push(index);
                    outputIndices[currentOutputIndex] = index;
                    ++currentOutputIndex;
                    vertex = vertices[index];
                    --vertex.numLiveTriangles;
                    if (s - vertex.timeStamp > cacheSize) {
                        vertex.timeStamp = s;
                        ++s;
                    }
                    ++currentIndex;
                }
            }
        }
        f = getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne);
    }
    return outputIndices;
};
module.exports = Tipsify;
},{"./DeveloperError":123,"./defaultValue":243,"./defined":245}],226:[function(require,module,exports){
var when = require('../ThirdParty/when'), Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), Cartesian4 = require('./Cartesian4'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EarthOrientationParameters = require('./EarthOrientationParameters'), EarthOrientationParametersSample = require('./EarthOrientationParametersSample'), Ellipsoid = require('./Ellipsoid'), Iau2006XysData = require('./Iau2006XysData'), Iau2006XysSample = require('./Iau2006XysSample'), JulianDate = require('./JulianDate'), CesiumMath = require('./Math'), Matrix3 = require('./Matrix3'), Matrix4 = require('./Matrix4'), Quaternion = require('./Quaternion'), TimeConstants = require('./TimeConstants');
'use strict';
var Transforms = {};
var eastNorthUpToFixedFrameNormal = new Cartesian3();
var eastNorthUpToFixedFrameTangent = new Cartesian3();
var eastNorthUpToFixedFrameBitangent = new Cartesian3();
Transforms.eastNorthUpToFixedFrame = function (origin, ellipsoid, result) {
    if (!defined(origin)) {
        throw new DeveloperError('origin is required.');
    }
    if (CesiumMath.equalsEpsilon(origin.x, 0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0, CesiumMath.EPSILON14)) {
        var sign = CesiumMath.sign(origin.z);
        if (!defined(result)) {
            return new Matrix4(0, -sign, 0, origin.x, 1, 0, 0, origin.y, 0, 0, sign, origin.z, 0, 0, 0, 1);
        }
        result[0] = 0;
        result[1] = 1;
        result[2] = 0;
        result[3] = 0;
        result[4] = -sign;
        result[5] = 0;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = sign;
        result[11] = 0;
        result[12] = origin.x;
        result[13] = origin.y;
        result[14] = origin.z;
        result[15] = 1;
        return result;
    }
    var normal = eastNorthUpToFixedFrameNormal;
    var tangent = eastNorthUpToFixedFrameTangent;
    var bitangent = eastNorthUpToFixedFrameBitangent;
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    ellipsoid.geodeticSurfaceNormal(origin, normal);
    tangent.x = -origin.y;
    tangent.y = origin.x;
    tangent.z = 0;
    Cartesian3.normalize(tangent, tangent);
    Cartesian3.cross(normal, tangent, bitangent);
    if (!defined(result)) {
        return new Matrix4(tangent.x, bitangent.x, normal.x, origin.x, tangent.y, bitangent.y, normal.y, origin.y, tangent.z, bitangent.z, normal.z, origin.z, 0, 0, 0, 1);
    }
    result[0] = tangent.x;
    result[1] = tangent.y;
    result[2] = tangent.z;
    result[3] = 0;
    result[4] = bitangent.x;
    result[5] = bitangent.y;
    result[6] = bitangent.z;
    result[7] = 0;
    result[8] = normal.x;
    result[9] = normal.y;
    result[10] = normal.z;
    result[11] = 0;
    result[12] = origin.x;
    result[13] = origin.y;
    result[14] = origin.z;
    result[15] = 1;
    return result;
};
var northEastDownToFixedFrameNormal = new Cartesian3();
var northEastDownToFixedFrameTangent = new Cartesian3();
var northEastDownToFixedFrameBitangent = new Cartesian3();
Transforms.northEastDownToFixedFrame = function (origin, ellipsoid, result) {
    if (!defined(origin)) {
        throw new DeveloperError('origin is required.');
    }
    if (CesiumMath.equalsEpsilon(origin.x, 0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0, CesiumMath.EPSILON14)) {
        var sign = CesiumMath.sign(origin.z);
        if (!defined(result)) {
            return new Matrix4(-sign, 0, 0, origin.x, 0, 1, 0, origin.y, 0, 0, -sign, origin.z, 0, 0, 0, 1);
        }
        result[0] = -sign;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 1;
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = -sign;
        result[11] = 0;
        result[12] = origin.x;
        result[13] = origin.y;
        result[14] = origin.z;
        result[15] = 1;
        return result;
    }
    var normal = northEastDownToFixedFrameNormal;
    var tangent = northEastDownToFixedFrameTangent;
    var bitangent = northEastDownToFixedFrameBitangent;
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    ellipsoid.geodeticSurfaceNormal(origin, normal);
    tangent.x = -origin.y;
    tangent.y = origin.x;
    tangent.z = 0;
    Cartesian3.normalize(tangent, tangent);
    Cartesian3.cross(normal, tangent, bitangent);
    if (!defined(result)) {
        return new Matrix4(bitangent.x, tangent.x, -normal.x, origin.x, bitangent.y, tangent.y, -normal.y, origin.y, bitangent.z, tangent.z, -normal.z, origin.z, 0, 0, 0, 1);
    }
    result[0] = bitangent.x;
    result[1] = bitangent.y;
    result[2] = bitangent.z;
    result[3] = 0;
    result[4] = tangent.x;
    result[5] = tangent.y;
    result[6] = tangent.z;
    result[7] = 0;
    result[8] = -normal.x;
    result[9] = -normal.y;
    result[10] = -normal.z;
    result[11] = 0;
    result[12] = origin.x;
    result[13] = origin.y;
    result[14] = origin.z;
    result[15] = 1;
    return result;
};
Transforms.northUpEastToFixedFrame = function (origin, ellipsoid, result) {
    if (!defined(origin)) {
        throw new DeveloperError('origin is required.');
    }
    if (CesiumMath.equalsEpsilon(origin.x, 0, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(origin.y, 0, CesiumMath.EPSILON14)) {
        var sign = CesiumMath.sign(origin.z);
        if (!defined(result)) {
            return new Matrix4(-sign, 0, 0, origin.x, 0, 0, 1, origin.y, 0, sign, 0, origin.z, 0, 0, 0, 1);
        }
        result[0] = -sign;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = 0;
        result[6] = sign;
        result[7] = 0;
        result[8] = 0;
        result[9] = 1;
        result[10] = 0;
        result[11] = 0;
        result[12] = origin.x;
        result[13] = origin.y;
        result[14] = origin.z;
        result[15] = 1;
        return result;
    }
    var normal = eastNorthUpToFixedFrameNormal;
    var tangent = eastNorthUpToFixedFrameTangent;
    var bitangent = eastNorthUpToFixedFrameBitangent;
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    ellipsoid.geodeticSurfaceNormal(origin, normal);
    tangent.x = -origin.y;
    tangent.y = origin.x;
    tangent.z = 0;
    Cartesian3.normalize(tangent, tangent);
    Cartesian3.cross(normal, tangent, bitangent);
    if (!defined(result)) {
        return new Matrix4(bitangent.x, normal.x, tangent.x, origin.x, bitangent.y, normal.y, tangent.y, origin.y, bitangent.z, normal.z, tangent.z, origin.z, 0, 0, 0, 1);
    }
    result[0] = bitangent.x;
    result[1] = bitangent.y;
    result[2] = bitangent.z;
    result[3] = 0;
    result[4] = normal.x;
    result[5] = normal.y;
    result[6] = normal.z;
    result[7] = 0;
    result[8] = tangent.x;
    result[9] = tangent.y;
    result[10] = tangent.z;
    result[11] = 0;
    result[12] = origin.x;
    result[13] = origin.y;
    result[14] = origin.z;
    result[15] = 1;
    return result;
};
var scratchHPRQuaternion = new Quaternion();
var scratchScale = new Cartesian3(1, 1, 1);
var scratchHPRMatrix4 = new Matrix4();
Transforms.headingPitchRollToFixedFrame = function (origin, heading, pitch, roll, ellipsoid, result) {
    var hprQuaternion = Quaternion.fromHeadingPitchRoll(heading, pitch, roll, scratchHPRQuaternion);
    var hprMatrix = Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.ZERO, hprQuaternion, scratchScale, scratchHPRMatrix4);
    result = Transforms.eastNorthUpToFixedFrame(origin, ellipsoid, result);
    return Matrix4.multiply(result, hprMatrix, result);
};
var scratchENUMatrix4 = new Matrix4();
var scratchHPRMatrix3 = new Matrix3();
Transforms.headingPitchRollQuaternion = function (origin, heading, pitch, roll, ellipsoid, result) {
    var transform = Transforms.headingPitchRollToFixedFrame(origin, heading, pitch, roll, ellipsoid, scratchENUMatrix4);
    var rotation = Matrix4.getRotation(transform, scratchHPRMatrix3);
    return Quaternion.fromRotationMatrix(rotation, result);
};
var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
var gmstConstant1 = 8640184.812866;
var gmstConstant2 = 0.093104;
var gmstConstant3 = -0.0000062;
var rateCoef = 1.1772758384668e-19;
var wgs84WRPrecessing = 0.000072921158553;
var twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400;
var dateInUtc = new JulianDate();
Transforms.computeTemeToPseudoFixedMatrix = function (date, result) {
    if (!defined(date)) {
        throw new DeveloperError('date is required.');
    }
    dateInUtc = JulianDate.addSeconds(date, -JulianDate.computeTaiMinusUtc(date), dateInUtc);
    var utcDayNumber = dateInUtc.dayNumber;
    var utcSecondsIntoDay = dateInUtc.secondsOfDay;
    var t;
    var diffDays = utcDayNumber - 2451545;
    if (utcSecondsIntoDay >= 43200) {
        t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
    } else {
        t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
    }
    var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
    var angle = gmst0 * twoPiOverSecondsInDay % CesiumMath.TWO_PI;
    var ratio = wgs84WRPrecessing + rateCoef * (utcDayNumber - 2451545.5);
    var secondsSinceMidnight = (utcSecondsIntoDay + TimeConstants.SECONDS_PER_DAY * 0.5) % TimeConstants.SECONDS_PER_DAY;
    var gha = angle + ratio * secondsSinceMidnight;
    var cosGha = Math.cos(gha);
    var sinGha = Math.sin(gha);
    if (!defined(result)) {
        return new Matrix3(cosGha, sinGha, 0, -sinGha, cosGha, 0, 0, 0, 1);
    }
    result[0] = cosGha;
    result[1] = -sinGha;
    result[2] = 0;
    result[3] = sinGha;
    result[4] = cosGha;
    result[5] = 0;
    result[6] = 0;
    result[7] = 0;
    result[8] = 1;
    return result;
};
Transforms.iau2006XysData = new Iau2006XysData();
Transforms.earthOrientationParameters = EarthOrientationParameters.NONE;
var ttMinusTai = 32.184;
var j2000ttDays = 2451545;
Transforms.preloadIcrfFixed = function (timeInterval) {
    var startDayTT = timeInterval.start.dayNumber;
    var startSecondTT = timeInterval.start.secondsOfDay + ttMinusTai;
    var stopDayTT = timeInterval.stop.dayNumber;
    var stopSecondTT = timeInterval.stop.secondsOfDay + ttMinusTai;
    var xysPromise = Transforms.iau2006XysData.preload(startDayTT, startSecondTT, stopDayTT, stopSecondTT);
    var eopPromise = Transforms.earthOrientationParameters.getPromiseToLoad();
    return when.all([
        xysPromise,
        eopPromise
    ]);
};
Transforms.computeIcrfToFixedMatrix = function (date, result) {
    if (!defined(date)) {
        throw new DeveloperError('date is required.');
    }
    if (!defined(result)) {
        result = new Matrix3();
    }
    var fixedToIcrfMtx = Transforms.computeFixedToIcrfMatrix(date, result);
    if (!defined(fixedToIcrfMtx)) {
        return undefined;
    }
    return Matrix3.transpose(fixedToIcrfMtx, result);
};
var xysScratch = new Iau2006XysSample(0, 0, 0);
var eopScratch = new EarthOrientationParametersSample(0, 0, 0, 0, 0, 0);
var rotation1Scratch = new Matrix3();
var rotation2Scratch = new Matrix3();
Transforms.computeFixedToIcrfMatrix = function (date, result) {
    if (!defined(date)) {
        throw new DeveloperError('date is required.');
    }
    if (!defined(result)) {
        result = new Matrix3();
    }
    var eop = Transforms.earthOrientationParameters.compute(date, eopScratch);
    if (!defined(eop)) {
        return undefined;
    }
    var dayTT = date.dayNumber;
    var secondTT = date.secondsOfDay + ttMinusTai;
    var xys = Transforms.iau2006XysData.computeXysRadians(dayTT, secondTT, xysScratch);
    if (!defined(xys)) {
        return undefined;
    }
    var x = xys.x + eop.xPoleOffset;
    var y = xys.y + eop.yPoleOffset;
    var a = 1 / (1 + Math.sqrt(1 - x * x - y * y));
    var rotation1 = rotation1Scratch;
    rotation1[0] = 1 - a * x * x;
    rotation1[3] = -a * x * y;
    rotation1[6] = x;
    rotation1[1] = -a * x * y;
    rotation1[4] = 1 - a * y * y;
    rotation1[7] = y;
    rotation1[2] = -x;
    rotation1[5] = -y;
    rotation1[8] = 1 - a * (x * x + y * y);
    var rotation2 = Matrix3.fromRotationZ(-xys.s, rotation2Scratch);
    var matrixQ = Matrix3.multiply(rotation1, rotation2, rotation1Scratch);
    var dateUt1day = date.dayNumber;
    var dateUt1sec = date.secondsOfDay - JulianDate.computeTaiMinusUtc(date) + eop.ut1MinusUtc;
    var daysSinceJ2000 = dateUt1day - 2451545;
    var fractionOfDay = dateUt1sec / TimeConstants.SECONDS_PER_DAY;
    var era = 0.779057273264 + fractionOfDay + 0.00273781191135448 * (daysSinceJ2000 + fractionOfDay);
    era = era % 1 * CesiumMath.TWO_PI;
    var earthRotation = Matrix3.fromRotationZ(era, rotation2Scratch);
    var pfToIcrf = Matrix3.multiply(matrixQ, earthRotation, rotation1Scratch);
    var cosxp = Math.cos(eop.xPoleWander);
    var cosyp = Math.cos(eop.yPoleWander);
    var sinxp = Math.sin(eop.xPoleWander);
    var sinyp = Math.sin(eop.yPoleWander);
    var ttt = dayTT - j2000ttDays + secondTT / TimeConstants.SECONDS_PER_DAY;
    ttt /= 36525;
    var sp = -0.000047 * ttt * CesiumMath.RADIANS_PER_DEGREE / 3600;
    var cossp = Math.cos(sp);
    var sinsp = Math.sin(sp);
    var fToPfMtx = rotation2Scratch;
    fToPfMtx[0] = cosxp * cossp;
    fToPfMtx[1] = cosxp * sinsp;
    fToPfMtx[2] = sinxp;
    fToPfMtx[3] = -cosyp * sinsp + sinyp * sinxp * cossp;
    fToPfMtx[4] = cosyp * cossp + sinyp * sinxp * sinsp;
    fToPfMtx[5] = -sinyp * cosxp;
    fToPfMtx[6] = -sinyp * sinsp - cosyp * sinxp * cossp;
    fToPfMtx[7] = sinyp * cossp - cosyp * sinxp * sinsp;
    fToPfMtx[8] = cosyp * cosxp;
    return Matrix3.multiply(pfToIcrf, fToPfMtx, result);
};
var pointToWindowCoordinatesTemp = new Cartesian4();
Transforms.pointToWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {
    result = Transforms.pointToGLWindowCoordinates(modelViewProjectionMatrix, viewportTransformation, point, result);
    result.y = 2 * viewportTransformation[5] - result.y;
    return result;
};
Transforms.pointToGLWindowCoordinates = function (modelViewProjectionMatrix, viewportTransformation, point, result) {
    if (!defined(modelViewProjectionMatrix)) {
        throw new DeveloperError('modelViewProjectionMatrix is required.');
    }
    if (!defined(viewportTransformation)) {
        throw new DeveloperError('viewportTransformation is required.');
    }
    if (!defined(point)) {
        throw new DeveloperError('point is required.');
    }
    if (!defined(result)) {
        result = new Cartesian2();
    }
    var tmp = pointToWindowCoordinatesTemp;
    Matrix4.multiplyByVector(modelViewProjectionMatrix, Cartesian4.fromElements(point.x, point.y, point.z, 1, tmp), tmp);
    Cartesian4.multiplyByScalar(tmp, 1 / tmp.w, tmp);
    Matrix4.multiplyByVector(viewportTransformation, tmp, tmp);
    return Cartesian2.fromCartesian4(tmp, result);
};
module.exports = Transforms;
},{"../ThirdParty/when":596,"./Cartesian2":101,"./Cartesian3":102,"./Cartesian4":103,"./DeveloperError":123,"./EarthOrientationParameters":124,"./EarthOrientationParametersSample":125,"./Ellipsoid":130,"./Iau2006XysData":158,"./Iau2006XysSample":159,"./JulianDate":168,"./Math":174,"./Matrix3":176,"./Matrix4":177,"./Quaternion":197,"./TimeConstants":221,"./defaultValue":243,"./defined":245}],227:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var TridiagonalSystemSolver = {};
TridiagonalSystemSolver.solve = function (lower, diagonal, upper, right) {
    if (!defined(lower) || !(lower instanceof Array)) {
        throw new DeveloperError('The array lower is required.');
    }
    if (!defined(diagonal) || !(diagonal instanceof Array)) {
        throw new DeveloperError('The array diagonal is required.');
    }
    if (!defined(upper) || !(upper instanceof Array)) {
        throw new DeveloperError('The array upper is required.');
    }
    if (!defined(right) || !(right instanceof Array)) {
        throw new DeveloperError('The array right is required.');
    }
    if (diagonal.length !== right.length) {
        throw new DeveloperError('diagonal and right must have the same lengths.');
    }
    if (lower.length !== upper.length) {
        throw new DeveloperError('lower and upper must have the same lengths.');
    } else if (lower.length !== diagonal.length - 1) {
        throw new DeveloperError('lower and upper must be one less than the length of diagonal.');
    }
    var c = new Array(upper.length);
    var d = new Array(right.length);
    var x = new Array(right.length);
    var i;
    for (i = 0; i < d.length; i++) {
        d[i] = new Cartesian3();
        x[i] = new Cartesian3();
    }
    c[0] = upper[0] / diagonal[0];
    d[0] = Cartesian3.multiplyByScalar(right[0], 1 / diagonal[0], d[0]);
    var scalar;
    for (i = 1; i < c.length; ++i) {
        scalar = 1 / (diagonal[i] - c[i - 1] * lower[i - 1]);
        c[i] = upper[i] * scalar;
        d[i] = Cartesian3.subtract(right[i], Cartesian3.multiplyByScalar(d[i - 1], lower[i - 1], d[i]), d[i]);
        d[i] = Cartesian3.multiplyByScalar(d[i], scalar, d[i]);
    }
    scalar = 1 / (diagonal[i] - c[i - 1] * lower[i - 1]);
    d[i] = Cartesian3.subtract(right[i], Cartesian3.multiplyByScalar(d[i - 1], lower[i - 1], d[i]), d[i]);
    d[i] = Cartesian3.multiplyByScalar(d[i], scalar, d[i]);
    x[x.length - 1] = d[d.length - 1];
    for (i = x.length - 2; i >= 0; --i) {
        x[i] = Cartesian3.subtract(d[i], Cartesian3.multiplyByScalar(x[i + 1], c[i], x[i]), x[i]);
    }
    return x;
};
module.exports = TridiagonalSystemSolver;
},{"./Cartesian3":102,"./DeveloperError":123,"./defined":245}],228:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), freezeObject = require('./freezeObject');
'use strict';
var VertexFormat = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.position = defaultValue(options.position, false);
    this.normal = defaultValue(options.normal, false);
    this.st = defaultValue(options.st, false);
    this.binormal = defaultValue(options.binormal, false);
    this.tangent = defaultValue(options.tangent, false);
    this.color = defaultValue(options.color, false);
};
VertexFormat.POSITION_ONLY = freezeObject(new VertexFormat({ position: true }));
VertexFormat.POSITION_AND_NORMAL = freezeObject(new VertexFormat({
    position: true,
    normal: true
}));
VertexFormat.POSITION_NORMAL_AND_ST = freezeObject(new VertexFormat({
    position: true,
    normal: true,
    st: true
}));
VertexFormat.POSITION_AND_ST = freezeObject(new VertexFormat({
    position: true,
    st: true
}));
VertexFormat.POSITION_AND_COLOR = freezeObject(new VertexFormat({
    position: true,
    color: true
}));
VertexFormat.ALL = freezeObject(new VertexFormat({
    position: true,
    normal: true,
    st: true,
    binormal: true,
    tangent: true
}));
VertexFormat.DEFAULT = VertexFormat.POSITION_NORMAL_AND_ST;
VertexFormat.packedLength = 6;
VertexFormat.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    array[startingIndex++] = value.position ? 1 : 0;
    array[startingIndex++] = value.normal ? 1 : 0;
    array[startingIndex++] = value.st ? 1 : 0;
    array[startingIndex++] = value.binormal ? 1 : 0;
    array[startingIndex++] = value.tangent ? 1 : 0;
    array[startingIndex++] = value.color ? 1 : 0;
};
VertexFormat.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    if (!defined(result)) {
        result = new VertexFormat();
    }
    result.position = array[startingIndex++] === 1;
    result.normal = array[startingIndex++] === 1;
    result.st = array[startingIndex++] === 1;
    result.binormal = array[startingIndex++] === 1;
    result.tangent = array[startingIndex++] === 1;
    result.color = array[startingIndex++] === 1;
    return result;
};
VertexFormat.clone = function (vertexFormat, result) {
    if (!defined(vertexFormat)) {
        return undefined;
    }
    if (!defined(result)) {
        result = new VertexFormat();
    }
    result.position = vertexFormat.position;
    result.normal = vertexFormat.normal;
    result.st = vertexFormat.st;
    result.binormal = vertexFormat.binormal;
    result.tangent = vertexFormat.tangent;
    result.color = vertexFormat.color;
    return result;
};
module.exports = VertexFormat;
},{"./DeveloperError":123,"./defaultValue":243,"./defined":245,"./freezeObject":249}],229:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var Visibility = {
        NONE: -1,
        PARTIAL: 0,
        FULL: 1
    };
module.exports = freezeObject(Visibility);
},{"./freezeObject":249}],230:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PrimitiveType = require('./PrimitiveType'), VertexFormat = require('./VertexFormat'), WallGeometryLibrary = require('./WallGeometryLibrary');
'use strict';
var scratchCartesian3Position1 = new Cartesian3();
var scratchCartesian3Position2 = new Cartesian3();
var scratchCartesian3Position3 = new Cartesian3();
var scratchCartesian3Position4 = new Cartesian3();
var scratchCartesian3Position5 = new Cartesian3();
var scratchBinormal = new Cartesian3();
var scratchTangent = new Cartesian3();
var scratchNormal = new Cartesian3();
var WallGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var wallPositions = options.positions;
    var maximumHeights = options.maximumHeights;
    var minimumHeights = options.minimumHeights;
    if (!defined(wallPositions)) {
        throw new DeveloperError('options.positions is required.');
    }
    if (wallPositions.length < 2) {
        throw new DeveloperError('options.positions length must be greater than or equal to 2.');
    }
    if (defined(maximumHeights) && maximumHeights.length !== wallPositions.length) {
        throw new DeveloperError('options.positions and options.maximumHeights must have the same length.');
    }
    if (defined(minimumHeights) && minimumHeights.length !== wallPositions.length) {
        throw new DeveloperError('options.positions and options.minimumHeights must have the same length.');
    }
    var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    this._positions = wallPositions;
    this._minimumHeights = minimumHeights;
    this._maximumHeights = maximumHeights;
    this._vertexFormat = VertexFormat.clone(vertexFormat);
    this._granularity = granularity;
    this._ellipsoid = Ellipsoid.clone(ellipsoid);
    this._workerName = 'createWallGeometry';
    var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;
    if (defined(minimumHeights)) {
        numComponents += minimumHeights.length;
    }
    if (defined(maximumHeights)) {
        numComponents += maximumHeights.length;
    }
    this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;
};
WallGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var positions = value._positions;
    var length = positions.length;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        Cartesian3.pack(positions[i], array, startingIndex);
    }
    var minimumHeights = value._minimumHeights;
    length = defined(minimumHeights) ? minimumHeights.length : 0;
    array[startingIndex++] = length;
    if (defined(minimumHeights)) {
        for (i = 0; i < length; ++i) {
            array[startingIndex++] = minimumHeights[i];
        }
    }
    var maximumHeights = value._maximumHeights;
    length = defined(maximumHeights) ? maximumHeights.length : 0;
    array[startingIndex++] = length;
    if (defined(maximumHeights)) {
        for (i = 0; i < length; ++i) {
            array[startingIndex++] = maximumHeights[i];
        }
    }
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    VertexFormat.pack(value._vertexFormat, array, startingIndex);
    startingIndex += VertexFormat.packedLength;
    array[startingIndex] = value._granularity;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchVertexFormat = new VertexFormat();
var scratchOptions = {
        positions: undefined,
        minimumHeights: undefined,
        maximumHeights: undefined,
        ellipsoid: scratchEllipsoid,
        vertexFormat: scratchVertexFormat,
        granularity: undefined
    };
WallGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var length = array[startingIndex++];
    var positions = new Array(length);
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    length = array[startingIndex++];
    var minimumHeights;
    if (length > 0) {
        minimumHeights = new Array(length);
        for (i = 0; i < length; ++i) {
            minimumHeights[i] = array[startingIndex++];
        }
    }
    length = array[startingIndex++];
    var maximumHeights;
    if (length > 0) {
        maximumHeights = new Array(length);
        for (i = 0; i < length; ++i) {
            maximumHeights[i] = array[startingIndex++];
        }
    }
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
    startingIndex += VertexFormat.packedLength;
    var granularity = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.positions = positions;
        scratchOptions.minimumHeights = minimumHeights;
        scratchOptions.maximumHeights = maximumHeights;
        scratchOptions.granularity = granularity;
        return new WallGeometry(scratchOptions);
    }
    result._positions = positions;
    result._minimumHeights = minimumHeights;
    result._maximumHeights = maximumHeights;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
    result._granularity = granularity;
    return result;
};
WallGeometry.fromConstantHeights = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var positions = options.positions;
    if (!defined(positions)) {
        throw new DeveloperError('options.positions is required.');
    }
    var minHeights;
    var maxHeights;
    var min = options.minimumHeight;
    var max = options.maximumHeight;
    var doMin = defined(min);
    var doMax = defined(max);
    if (doMin || doMax) {
        var length = positions.length;
        minHeights = doMin ? new Array(length) : undefined;
        maxHeights = doMax ? new Array(length) : undefined;
        for (var i = 0; i < length; ++i) {
            if (doMin) {
                minHeights[i] = min;
            }
            if (doMax) {
                maxHeights[i] = max;
            }
        }
    }
    var newOptions = {
            positions: positions,
            maximumHeights: maxHeights,
            minimumHeights: minHeights,
            ellipsoid: options.ellipsoid,
            vertexFormat: options.vertexFormat
        };
    return new WallGeometry(newOptions);
};
WallGeometry.createGeometry = function (wallGeometry) {
    var wallPositions = wallGeometry._positions;
    var minimumHeights = wallGeometry._minimumHeights;
    var maximumHeights = wallGeometry._maximumHeights;
    var vertexFormat = wallGeometry._vertexFormat;
    var granularity = wallGeometry._granularity;
    var ellipsoid = wallGeometry._ellipsoid;
    var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, true);
    if (!defined(pos)) {
        return undefined;
    }
    var bottomPositions = pos.bottomPositions;
    var topPositions = pos.topPositions;
    var length = topPositions.length;
    var size = length * 2;
    var positions = vertexFormat.position ? new Float64Array(size) : undefined;
    var normals = vertexFormat.normal ? new Float32Array(size) : undefined;
    var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;
    var binormals = vertexFormat.binormal ? new Float32Array(size) : undefined;
    var textureCoordinates = vertexFormat.st ? new Float32Array(size / 3 * 2) : undefined;
    var positionIndex = 0;
    var normalIndex = 0;
    var binormalIndex = 0;
    var tangentIndex = 0;
    var stIndex = 0;
    var normal = scratchNormal;
    var tangent = scratchTangent;
    var binormal = scratchBinormal;
    var recomputeNormal = true;
    length /= 3;
    var i;
    for (i = 0; i < length; ++i) {
        var i3 = i * 3;
        var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);
        var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);
        if (vertexFormat.position) {
            positions[positionIndex++] = bottomPosition.x;
            positions[positionIndex++] = bottomPosition.y;
            positions[positionIndex++] = bottomPosition.z;
            positions[positionIndex++] = topPosition.x;
            positions[positionIndex++] = topPosition.y;
            positions[positionIndex++] = topPosition.z;
        }
        if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.binormal) {
            var nextPosition;
            var nextTop = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Position5);
            var groundPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position2), scratchCartesian3Position2);
            if (i + 1 < length) {
                nextPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position3), scratchCartesian3Position3);
                nextTop = Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position5);
            }
            if (recomputeNormal) {
                var scalednextPosition = Cartesian3.subtract(nextTop, topPosition, scratchCartesian3Position4);
                var scaledGroundPosition = Cartesian3.subtract(groundPosition, topPosition, scratchCartesian3Position1);
                normal = Cartesian3.normalize(Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal), normal);
                recomputeNormal = false;
            }
            if (Cartesian3.equalsEpsilon(nextPosition, groundPosition, CesiumMath.EPSILON6)) {
                recomputeNormal = true;
            } else {
                if (vertexFormat.tangent) {
                    tangent = Cartesian3.normalize(Cartesian3.subtract(nextPosition, groundPosition, tangent), tangent);
                }
                if (vertexFormat.binormal) {
                    binormal = Cartesian3.normalize(Cartesian3.cross(normal, tangent, binormal), binormal);
                }
            }
            if (vertexFormat.normal) {
                normals[normalIndex++] = normal.x;
                normals[normalIndex++] = normal.y;
                normals[normalIndex++] = normal.z;
                normals[normalIndex++] = normal.x;
                normals[normalIndex++] = normal.y;
                normals[normalIndex++] = normal.z;
            }
            if (vertexFormat.tangent) {
                tangents[tangentIndex++] = tangent.x;
                tangents[tangentIndex++] = tangent.y;
                tangents[tangentIndex++] = tangent.z;
                tangents[tangentIndex++] = tangent.x;
                tangents[tangentIndex++] = tangent.y;
                tangents[tangentIndex++] = tangent.z;
            }
            if (vertexFormat.binormal) {
                binormals[binormalIndex++] = binormal.x;
                binormals[binormalIndex++] = binormal.y;
                binormals[binormalIndex++] = binormal.z;
                binormals[binormalIndex++] = binormal.x;
                binormals[binormalIndex++] = binormal.y;
                binormals[binormalIndex++] = binormal.z;
            }
        }
        if (vertexFormat.st) {
            var s = i / (length - 1);
            textureCoordinates[stIndex++] = s;
            textureCoordinates[stIndex++] = 0;
            textureCoordinates[stIndex++] = s;
            textureCoordinates[stIndex++] = 1;
        }
    }
    var attributes = new GeometryAttributes();
    if (vertexFormat.position) {
        attributes.position = new GeometryAttribute({
            componentDatatype: ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
        });
    }
    if (vertexFormat.normal) {
        attributes.normal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: normals
        });
    }
    if (vertexFormat.tangent) {
        attributes.tangent = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: tangents
        });
    }
    if (vertexFormat.binormal) {
        attributes.binormal = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: binormals
        });
    }
    if (vertexFormat.st) {
        attributes.st = new GeometryAttribute({
            componentDatatype: ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: textureCoordinates
        });
    }
    var numVertices = size / 3;
    size -= 6;
    var indices = IndexDatatype.createTypedArray(numVertices, size);
    var edgeIndex = 0;
    for (i = 0; i < numVertices - 2; i += 2) {
        var LL = i;
        var LR = i + 2;
        var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);
        var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);
        if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON6)) {
            continue;
        }
        var UL = i + 1;
        var UR = i + 3;
        indices[edgeIndex++] = UL;
        indices[edgeIndex++] = LL;
        indices[edgeIndex++] = UR;
        indices[edgeIndex++] = UR;
        indices[edgeIndex++] = LL;
        indices[edgeIndex++] = LR;
    }
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.TRIANGLES,
        boundingSphere: new BoundingSphere.fromVertices(positions)
    });
};
module.exports = WallGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PrimitiveType":193,"./VertexFormat":228,"./WallGeometryLibrary":231,"./defaultValue":243,"./defined":245}],231:[function(require,module,exports){
var Cartographic = require('./Cartographic'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), EllipsoidTangentPlane = require('./EllipsoidTangentPlane'), CesiumMath = require('./Math'), PolygonPipeline = require('./PolygonPipeline'), PolylinePipeline = require('./PolylinePipeline'), WindingOrder = require('./WindingOrder');
'use strict';
var WallGeometryLibrary = {};
function latLonEquals(c0, c1) {
    return CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON14) && CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON14);
}
var scratchCartographic1 = new Cartographic();
var scratchCartographic2 = new Cartographic();
function removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {
    var length = positions.length;
    if (length < 2) {
        return { positions: positions };
    }
    var hasBottomHeights = defined(bottomHeights);
    var hasTopHeights = defined(topHeights);
    var cleanedPositions = new Array(length);
    var cleanedTopHeights = new Array(length);
    var cleanedBottomHeights = new Array(length);
    var v0 = positions[0];
    cleanedPositions[0] = v0;
    var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);
    if (hasTopHeights) {
        c0.height = topHeights[0];
    }
    cleanedTopHeights[0] = c0.height;
    if (hasBottomHeights) {
        cleanedBottomHeights[0] = bottomHeights[0];
    } else {
        cleanedBottomHeights[0] = 0;
    }
    var index = 1;
    for (var i = 1; i < length; ++i) {
        var v1 = positions[i];
        var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);
        if (hasTopHeights) {
            c1.height = topHeights[i];
        }
        if (!latLonEquals(c0, c1)) {
            cleanedPositions[index] = v1;
            cleanedTopHeights[index] = c1.height;
            if (hasBottomHeights) {
                cleanedBottomHeights[index] = bottomHeights[i];
            } else {
                cleanedBottomHeights[index] = 0;
            }
            ++index;
        } else if (c0.height < c1.height) {
            cleanedTopHeights[index - 1] = c1.height;
        }
        Cartographic.clone(c1, c0);
    }
    cleanedPositions.length = index;
    cleanedTopHeights.length = index;
    cleanedBottomHeights.length = index;
    return {
        positions: cleanedPositions,
        topHeights: cleanedTopHeights,
        bottomHeights: cleanedBottomHeights
    };
}
var positionsArrayScratch = new Array(2);
var heightsArrayScratch = new Array(2);
var generateArcOptionsScratch = {
        positions: undefined,
        height: undefined,
        granularity: undefined,
        ellipsoid: undefined
    };
WallGeometryLibrary.computePositions = function (ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, duplicateCorners) {
    var o = removeDuplicates(ellipsoid, wallPositions, maximumHeights, minimumHeights);
    wallPositions = o.positions;
    maximumHeights = o.topHeights;
    minimumHeights = o.bottomHeights;
    if (wallPositions.length < 2) {
        return undefined;
    }
    if (wallPositions.length >= 3) {
        var tangentPlane = EllipsoidTangentPlane.fromPoints(wallPositions, ellipsoid);
        var positions2D = tangentPlane.projectPointsOntoPlane(wallPositions);
        if (PolygonPipeline.computeWindingOrder2D(positions2D) === WindingOrder.CLOCKWISE) {
            wallPositions.reverse();
            maximumHeights.reverse();
            minimumHeights.reverse();
        }
    }
    var length = wallPositions.length;
    var topPositions;
    var bottomPositions;
    var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
    var generateArcOptions = generateArcOptionsScratch;
    generateArcOptions.minDistance = minDistance;
    generateArcOptions.ellipsoid = ellipsoid;
    if (duplicateCorners) {
        var count = 0;
        var i;
        for (i = 0; i < length - 1; i++) {
            count += PolylinePipeline.numberOfPoints(wallPositions[i], wallPositions[i + 1], minDistance) + 1;
        }
        topPositions = new Float64Array(count * 3);
        bottomPositions = new Float64Array(count * 3);
        var generateArcPositions = positionsArrayScratch;
        var generateArcHeights = heightsArrayScratch;
        generateArcOptions.positions = generateArcPositions;
        generateArcOptions.height = generateArcHeights;
        var offset = 0;
        for (i = 0; i < length - 1; i++) {
            generateArcPositions[0] = wallPositions[i];
            generateArcPositions[1] = wallPositions[i + 1];
            generateArcHeights[0] = maximumHeights[i];
            generateArcHeights[1] = maximumHeights[i + 1];
            var pos = PolylinePipeline.generateArc(generateArcOptions);
            topPositions.set(pos, offset);
            generateArcHeights[0] = minimumHeights[i];
            generateArcHeights[1] = minimumHeights[i + 1];
            bottomPositions.set(PolylinePipeline.generateArc(generateArcOptions), offset);
            offset += pos.length;
        }
    } else {
        generateArcOptions.positions = wallPositions;
        generateArcOptions.height = maximumHeights;
        topPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));
        generateArcOptions.height = minimumHeights;
        bottomPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));
    }
    return {
        bottomPositions: bottomPositions,
        topPositions: topPositions
    };
};
module.exports = WallGeometryLibrary;
},{"./Cartographic":104,"./DeveloperError":123,"./EllipsoidTangentPlane":134,"./Math":174,"./PolygonPipeline":187,"./PolylinePipeline":189,"./WindingOrder":235,"./defined":245}],232:[function(require,module,exports){
var BoundingSphere = require('./BoundingSphere'), Cartesian3 = require('./Cartesian3'), ComponentDatatype = require('./ComponentDatatype'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), Geometry = require('./Geometry'), GeometryAttribute = require('./GeometryAttribute'), GeometryAttributes = require('./GeometryAttributes'), IndexDatatype = require('./IndexDatatype'), CesiumMath = require('./Math'), PrimitiveType = require('./PrimitiveType'), WallGeometryLibrary = require('./WallGeometryLibrary');
'use strict';
var scratchCartesian3Position1 = new Cartesian3();
var scratchCartesian3Position2 = new Cartesian3();
var WallOutlineGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var wallPositions = options.positions;
    var maximumHeights = options.maximumHeights;
    var minimumHeights = options.minimumHeights;
    if (!defined(wallPositions)) {
        throw new DeveloperError('options.positions is required.');
    }
    if (wallPositions.length < 2) {
        throw new DeveloperError('options.positions length must be greater than or equal to 2.');
    }
    if (defined(maximumHeights) && maximumHeights.length !== wallPositions.length) {
        throw new DeveloperError('options.positions and options.maximumHeights must have the same length.');
    }
    if (defined(minimumHeights) && minimumHeights.length !== wallPositions.length) {
        throw new DeveloperError('options.positions and options.minimumHeights must have the same length.');
    }
    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    this._positions = wallPositions;
    this._minimumHeights = minimumHeights;
    this._maximumHeights = maximumHeights;
    this._granularity = granularity;
    this._ellipsoid = Ellipsoid.clone(ellipsoid);
    this._workerName = 'createWallOutlineGeometry';
    var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;
    if (defined(minimumHeights)) {
        numComponents += minimumHeights.length;
    }
    if (defined(maximumHeights)) {
        numComponents += maximumHeights.length;
    }
    this.packedLength = numComponents + Ellipsoid.packedLength + 1;
};
WallOutlineGeometry.pack = function (value, array, startingIndex) {
    if (!defined(value)) {
        throw new DeveloperError('value is required');
    }
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var positions = value._positions;
    var length = positions.length;
    array[startingIndex++] = length;
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        Cartesian3.pack(positions[i], array, startingIndex);
    }
    var minimumHeights = value._minimumHeights;
    length = defined(minimumHeights) ? minimumHeights.length : 0;
    array[startingIndex++] = length;
    if (defined(minimumHeights)) {
        for (i = 0; i < length; ++i) {
            array[startingIndex++] = minimumHeights[i];
        }
    }
    var maximumHeights = value._maximumHeights;
    length = defined(maximumHeights) ? maximumHeights.length : 0;
    array[startingIndex++] = length;
    if (defined(maximumHeights)) {
        for (i = 0; i < length; ++i) {
            array[startingIndex++] = maximumHeights[i];
        }
    }
    Ellipsoid.pack(value._ellipsoid, array, startingIndex);
    startingIndex += Ellipsoid.packedLength;
    array[startingIndex] = value._granularity;
};
var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
var scratchOptions = {
        positions: undefined,
        minimumHeights: undefined,
        maximumHeights: undefined,
        ellipsoid: scratchEllipsoid,
        granularity: undefined
    };
WallOutlineGeometry.unpack = function (array, startingIndex, result) {
    if (!defined(array)) {
        throw new DeveloperError('array is required');
    }
    startingIndex = defaultValue(startingIndex, 0);
    var i;
    var length = array[startingIndex++];
    var positions = new Array(length);
    for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
        positions[i] = Cartesian3.unpack(array, startingIndex);
    }
    length = array[startingIndex++];
    var minimumHeights;
    if (length > 0) {
        minimumHeights = new Array(length);
        for (i = 0; i < length; ++i) {
            minimumHeights[i] = array[startingIndex++];
        }
    }
    length = array[startingIndex++];
    var maximumHeights;
    if (length > 0) {
        maximumHeights = new Array(length);
        for (i = 0; i < length; ++i) {
            maximumHeights[i] = array[startingIndex++];
        }
    }
    var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
    startingIndex += Ellipsoid.packedLength;
    var granularity = array[startingIndex];
    if (!defined(result)) {
        scratchOptions.positions = positions;
        scratchOptions.minimumHeights = minimumHeights;
        scratchOptions.maximumHeights = maximumHeights;
        scratchOptions.granularity = granularity;
        return new WallOutlineGeometry(scratchOptions);
    }
    result._positions = positions;
    result._minimumHeights = minimumHeights;
    result._maximumHeights = maximumHeights;
    result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
    result._granularity = granularity;
    return result;
};
WallOutlineGeometry.fromConstantHeights = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var positions = options.positions;
    if (!defined(positions)) {
        throw new DeveloperError('options.positions is required.');
    }
    var minHeights;
    var maxHeights;
    var min = options.minimumHeight;
    var max = options.maximumHeight;
    var doMin = defined(min);
    var doMax = defined(max);
    if (doMin || doMax) {
        var length = positions.length;
        minHeights = doMin ? new Array(length) : undefined;
        maxHeights = doMax ? new Array(length) : undefined;
        for (var i = 0; i < length; ++i) {
            if (doMin) {
                minHeights[i] = min;
            }
            if (doMax) {
                maxHeights[i] = max;
            }
        }
    }
    var newOptions = {
            positions: positions,
            maximumHeights: maxHeights,
            minimumHeights: minHeights,
            ellipsoid: options.ellipsoid
        };
    return new WallOutlineGeometry(newOptions);
};
WallOutlineGeometry.createGeometry = function (wallGeometry) {
    var wallPositions = wallGeometry._positions;
    var minimumHeights = wallGeometry._minimumHeights;
    var maximumHeights = wallGeometry._maximumHeights;
    var granularity = wallGeometry._granularity;
    var ellipsoid = wallGeometry._ellipsoid;
    var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, false);
    if (!defined(pos)) {
        return undefined;
    }
    var bottomPositions = pos.bottomPositions;
    var topPositions = pos.topPositions;
    var length = topPositions.length;
    var size = length * 2;
    var positions = new Float64Array(size);
    var positionIndex = 0;
    length /= 3;
    var i;
    for (i = 0; i < length; ++i) {
        var i3 = i * 3;
        var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);
        var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);
        positions[positionIndex++] = bottomPosition.x;
        positions[positionIndex++] = bottomPosition.y;
        positions[positionIndex++] = bottomPosition.z;
        positions[positionIndex++] = topPosition.x;
        positions[positionIndex++] = topPosition.y;
        positions[positionIndex++] = topPosition.z;
    }
    var attributes = new GeometryAttributes({
            position: new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: positions
            })
        });
    var numVertices = size / 3;
    size = 2 * numVertices - 4 + numVertices;
    var indices = IndexDatatype.createTypedArray(numVertices, size);
    var edgeIndex = 0;
    for (i = 0; i < numVertices - 2; i += 2) {
        var LL = i;
        var LR = i + 2;
        var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);
        var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);
        if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON6)) {
            continue;
        }
        var UL = i + 1;
        var UR = i + 3;
        indices[edgeIndex++] = UL;
        indices[edgeIndex++] = LL;
        indices[edgeIndex++] = UL;
        indices[edgeIndex++] = UR;
        indices[edgeIndex++] = LL;
        indices[edgeIndex++] = LR;
    }
    indices[edgeIndex++] = numVertices - 2;
    indices[edgeIndex++] = numVertices - 1;
    return new Geometry({
        attributes: attributes,
        indices: indices,
        primitiveType: PrimitiveType.LINES,
        boundingSphere: new BoundingSphere.fromVertices(positions)
    });
};
module.exports = WallOutlineGeometry;
},{"./BoundingSphere":98,"./Cartesian3":102,"./ComponentDatatype":113,"./DeveloperError":123,"./Ellipsoid":130,"./Geometry":145,"./GeometryAttribute":146,"./GeometryAttributes":147,"./IndexDatatype":162,"./Math":174,"./PrimitiveType":193,"./WallGeometryLibrary":231,"./defaultValue":243,"./defined":245}],233:[function(require,module,exports){
var Cartesian3 = require('./Cartesian3'), Cartographic = require('./Cartographic'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), DeveloperError = require('./DeveloperError'), Ellipsoid = require('./Ellipsoid'), CesiumMath = require('./Math');
'use strict';
var WebMercatorProjection = function (ellipsoid) {
    this._ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    this._semimajorAxis = this._ellipsoid.maximumRadius;
    this._oneOverSemimajorAxis = 1 / this._semimajorAxis;
};
defineProperties(WebMercatorProjection.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    }
});
WebMercatorProjection.mercatorAngleToGeodeticLatitude = function (mercatorAngle) {
    return CesiumMath.PI_OVER_TWO - 2 * Math.atan(Math.exp(-mercatorAngle));
};
WebMercatorProjection.geodeticLatitudeToMercatorAngle = function (latitude) {
    if (latitude > WebMercatorProjection.MaximumLatitude) {
        latitude = WebMercatorProjection.MaximumLatitude;
    } else if (latitude < -WebMercatorProjection.MaximumLatitude) {
        latitude = -WebMercatorProjection.MaximumLatitude;
    }
    var sinLatitude = Math.sin(latitude);
    return 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));
};
WebMercatorProjection.MaximumLatitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI);
WebMercatorProjection.prototype.project = function (cartographic, result) {
    var semimajorAxis = this._semimajorAxis;
    var x = cartographic.longitude * semimajorAxis;
    var y = WebMercatorProjection.geodeticLatitudeToMercatorAngle(cartographic.latitude) * semimajorAxis;
    var z = cartographic.height;
    if (!defined(result)) {
        return new Cartesian3(x, y, z);
    }
    result.x = x;
    result.y = y;
    result.z = z;
    return result;
};
WebMercatorProjection.prototype.unproject = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required');
    }
    var oneOverEarthSemimajorAxis = this._oneOverSemimajorAxis;
    var longitude = cartesian.x * oneOverEarthSemimajorAxis;
    var latitude = WebMercatorProjection.mercatorAngleToGeodeticLatitude(cartesian.y * oneOverEarthSemimajorAxis);
    var height = cartesian.z;
    if (!defined(result)) {
        return new Cartographic(longitude, latitude, height);
    }
    result.longitude = longitude;
    result.latitude = latitude;
    result.height = height;
    return result;
};
module.exports = WebMercatorProjection;
},{"./Cartesian3":102,"./Cartographic":104,"./DeveloperError":123,"./Ellipsoid":130,"./Math":174,"./defaultValue":243,"./defineProperties":244,"./defined":245}],234:[function(require,module,exports){
var Cartesian2 = require('./Cartesian2'), defaultValue = require('./defaultValue'), defined = require('./defined'), defineProperties = require('./defineProperties'), Ellipsoid = require('./Ellipsoid'), Rectangle = require('./Rectangle'), WebMercatorProjection = require('./WebMercatorProjection');
'use strict';
var WebMercatorTilingScheme = function WebMercatorTilingScheme(options) {
    options = defaultValue(options, {});
    this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 1);
    this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);
    this._projection = new WebMercatorProjection(this._ellipsoid);
    if (defined(options.rectangleSouthwestInMeters) && defined(options.rectangleNortheastInMeters)) {
        this._rectangleSouthwestInMeters = options.rectangleSouthwestInMeters;
        this._rectangleNortheastInMeters = options.rectangleNortheastInMeters;
    } else {
        var semimajorAxisTimesPi = this._ellipsoid.maximumRadius * Math.PI;
        this._rectangleSouthwestInMeters = new Cartesian2(-semimajorAxisTimesPi, -semimajorAxisTimesPi);
        this._rectangleNortheastInMeters = new Cartesian2(semimajorAxisTimesPi, semimajorAxisTimesPi);
    }
    var southwest = this._projection.unproject(this._rectangleSouthwestInMeters);
    var northeast = this._projection.unproject(this._rectangleNortheastInMeters);
    this._rectangle = new Rectangle(southwest.longitude, southwest.latitude, northeast.longitude, northeast.latitude);
};
defineProperties(WebMercatorTilingScheme.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    },
    rectangle: {
        get: function () {
            return this._rectangle;
        }
    },
    projection: {
        get: function () {
            return this._projection;
        }
    }
});
WebMercatorTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {
    return this._numberOfLevelZeroTilesX << level;
};
WebMercatorTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {
    return this._numberOfLevelZeroTilesY << level;
};
WebMercatorTilingScheme.prototype.rectangleToNativeRectangle = function (rectangle, result) {
    var projection = this._projection;
    var southwest = projection.project(Rectangle.southwest(rectangle));
    var northeast = projection.project(Rectangle.northeast(rectangle));
    if (!defined(result)) {
        return new Rectangle(southwest.x, southwest.y, northeast.x, northeast.y);
    }
    result.west = southwest.x;
    result.south = southwest.y;
    result.east = northeast.x;
    result.north = northeast.y;
    return result;
};
WebMercatorTilingScheme.prototype.tileXYToNativeRectangle = function (x, y, level, result) {
    var xTiles = this.getNumberOfXTilesAtLevel(level);
    var yTiles = this.getNumberOfYTilesAtLevel(level);
    var xTileWidth = (this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x) / xTiles;
    var west = this._rectangleSouthwestInMeters.x + x * xTileWidth;
    var east = this._rectangleSouthwestInMeters.x + (x + 1) * xTileWidth;
    var yTileHeight = (this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y) / yTiles;
    var north = this._rectangleNortheastInMeters.y - y * yTileHeight;
    var south = this._rectangleNortheastInMeters.y - (y + 1) * yTileHeight;
    if (!defined(result)) {
        return new Rectangle(west, south, east, north);
    }
    result.west = west;
    result.south = south;
    result.east = east;
    result.north = north;
    return result;
};
WebMercatorTilingScheme.prototype.tileXYToRectangle = function (x, y, level, result) {
    var nativeRectangle = this.tileXYToNativeRectangle(x, y, level, result);
    var projection = this._projection;
    var southwest = projection.unproject(new Cartesian2(nativeRectangle.west, nativeRectangle.south));
    var northeast = projection.unproject(new Cartesian2(nativeRectangle.east, nativeRectangle.north));
    nativeRectangle.west = southwest.longitude;
    nativeRectangle.south = southwest.latitude;
    nativeRectangle.east = northeast.longitude;
    nativeRectangle.north = northeast.latitude;
    return nativeRectangle;
};
WebMercatorTilingScheme.prototype.positionToTileXY = function (position, level, result) {
    var rectangle = this._rectangle;
    if (!Rectangle.contains(rectangle, position)) {
        return undefined;
    }
    var xTiles = this.getNumberOfXTilesAtLevel(level);
    var yTiles = this.getNumberOfYTilesAtLevel(level);
    var overallWidth = this._rectangleNortheastInMeters.x - this._rectangleSouthwestInMeters.x;
    var xTileWidth = overallWidth / xTiles;
    var overallHeight = this._rectangleNortheastInMeters.y - this._rectangleSouthwestInMeters.y;
    var yTileHeight = overallHeight / yTiles;
    var projection = this._projection;
    var webMercatorPosition = projection.project(position);
    var distanceFromWest = webMercatorPosition.x - this._rectangleSouthwestInMeters.x;
    var distanceFromNorth = this._rectangleNortheastInMeters.y - webMercatorPosition.y;
    var xTileCoordinate = distanceFromWest / xTileWidth | 0;
    if (xTileCoordinate >= xTiles) {
        xTileCoordinate = xTiles - 1;
    }
    var yTileCoordinate = distanceFromNorth / yTileHeight | 0;
    if (yTileCoordinate >= yTiles) {
        yTileCoordinate = yTiles - 1;
    }
    if (!defined(result)) {
        return new Cartesian2(xTileCoordinate, yTileCoordinate);
    }
    result.x = xTileCoordinate;
    result.y = yTileCoordinate;
    return result;
};
module.exports = WebMercatorTilingScheme;
},{"./Cartesian2":101,"./Ellipsoid":130,"./Rectangle":201,"./WebMercatorProjection":233,"./defaultValue":243,"./defineProperties":244,"./defined":245}],235:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var WindingOrder = {
        CLOCKWISE: 2304,
        COUNTER_CLOCKWISE: 2305,
        validate: function (windingOrder) {
            return windingOrder === WindingOrder.CLOCKWISE || windingOrder === WindingOrder.COUNTER_CLOCKWISE;
        }
    };
module.exports = freezeObject(WindingOrder);
},{"./freezeObject":249}],236:[function(require,module,exports){
'use strict';
var appendForwardSlash = function (url) {
    if (url.length === 0 || url[url.length - 1] !== '/') {
        url = url + '/';
    }
    return url;
};
module.exports = appendForwardSlash;
},{}],237:[function(require,module,exports){
var Cartesian2 = require('./Cartesian2'), Cartesian3 = require('./Cartesian3'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var scratchCartesian1 = new Cartesian3();
var scratchCartesian2 = new Cartesian3();
var scratchCartesian3 = new Cartesian3();
var barycentricCoordinates = function (point, p0, p1, p2, result) {
    if (!defined(point) || !defined(p0) || !defined(p1) || !defined(p2)) {
        throw new DeveloperError('point, p0, p1, and p2 are required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    var v0, v1, v2;
    var dot00, dot01, dot02, dot11, dot12;
    if (!defined(p0.z)) {
        v0 = Cartesian2.subtract(p1, p0, scratchCartesian1);
        v1 = Cartesian2.subtract(p2, p0, scratchCartesian2);
        v2 = Cartesian2.subtract(point, p0, scratchCartesian3);
        dot00 = Cartesian2.dot(v0, v0);
        dot01 = Cartesian2.dot(v0, v1);
        dot02 = Cartesian2.dot(v0, v2);
        dot11 = Cartesian2.dot(v1, v1);
        dot12 = Cartesian2.dot(v1, v2);
    } else {
        v0 = Cartesian3.subtract(p1, p0, scratchCartesian1);
        v1 = Cartesian3.subtract(p2, p0, scratchCartesian2);
        v2 = Cartesian3.subtract(point, p0, scratchCartesian3);
        dot00 = Cartesian3.dot(v0, v0);
        dot01 = Cartesian3.dot(v0, v1);
        dot02 = Cartesian3.dot(v0, v2);
        dot11 = Cartesian3.dot(v1, v1);
        dot12 = Cartesian3.dot(v1, v2);
    }
    var q = 1 / (dot00 * dot11 - dot01 * dot01);
    result.y = (dot11 * dot02 - dot01 * dot12) * q;
    result.z = (dot00 * dot12 - dot01 * dot02) * q;
    result.x = 1 - result.y - result.z;
    return result;
};
module.exports = barycentricCoordinates;
},{"./Cartesian2":101,"./Cartesian3":102,"./DeveloperError":123,"./defined":245}],238:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var binarySearch = function (array, itemToFind, comparator) {
    if (!defined(array)) {
        throw new DeveloperError('array is required.');
    }
    if (!defined(itemToFind)) {
        throw new DeveloperError('itemToFind is required.');
    }
    if (!defined(comparator)) {
        throw new DeveloperError('comparator is required.');
    }
    var low = 0;
    var high = array.length - 1;
    var i;
    var comparison;
    while (low <= high) {
        i = ~~((low + high) / 2);
        comparison = comparator(array[i], itemToFind);
        if (comparison < 0) {
            low = i + 1;
            continue;
        }
        if (comparison > 0) {
            high = i - 1;
            continue;
        }
        return i;
    }
    return ~(high + 1);
};
module.exports = binarySearch;
},{"./DeveloperError":123,"./defined":245}],239:[function(require,module,exports){
var Uri = require('../ThirdParty/Uri'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var cesiumScriptRegex = /((?:.*\/)|^)cesium[\w-]*\.js(?:\W|$)/i;
function getBaseUrlFromCesiumScript() {
    var scripts = document.getElementsByTagName('script');
    for (var i = 0, len = scripts.length; i < len; ++i) {
        var src = scripts[i].getAttribute('src');
        var result = cesiumScriptRegex.exec(src);
        if (result !== null) {
            return result[1];
        }
    }
    return undefined;
}
var baseUrl;
function getCesiumBaseUrl() {
    if (defined(baseUrl)) {
        return baseUrl;
    }
    var baseUrlString;
    if (typeof CESIUM_BASE_URL !== 'undefined') {
        baseUrlString = CESIUM_BASE_URL;
    } else {
        baseUrlString = getBaseUrlFromCesiumScript();
    }
    if (!defined(baseUrlString)) {
        throw new DeveloperError('Unable to determine Cesium base URL automatically, try defining a global variable called CESIUM_BASE_URL.');
    }
    baseUrl = new Uri(baseUrlString).resolve(new Uri(document.location.href));
    return baseUrl;
}
function buildModuleUrlFromRequireToUrl(moduleID) {
    return require.toUrl('../' + moduleID);
}
function buildModuleUrlFromBaseUrl(moduleID) {
    return new Uri(moduleID).resolve(getCesiumBaseUrl()).toString();
}
var implementation;
var a;
var buildModuleUrl = function (moduleID) {
    if (!defined(implementation)) {
        if (defined(require.toUrl)) {
            implementation = buildModuleUrlFromRequireToUrl;
        } else {
            implementation = buildModuleUrlFromBaseUrl;
        }
    }
    if (!defined(a)) {
        a = document.createElement('a');
    }
    var url = implementation(moduleID);
    a.href = url;
    a.href = a.href;
    return a.href;
};
buildModuleUrl._cesiumScriptRegex = cesiumScriptRegex;
module.exports = buildModuleUrl;
},{"../ThirdParty/Uri":587,"./DeveloperError":123,"./defined":245}],240:[function(require,module,exports){
var defaultValue = require('./defaultValue');
'use strict';
var clone = function (object, deep) {
    if (object === null || typeof object !== 'object') {
        return object;
    }
    deep = defaultValue(deep, false);
    var result = new object.constructor();
    for (var propertyName in object) {
        if (object.hasOwnProperty(propertyName)) {
            var value = object[propertyName];
            if (deep) {
                value = clone(value, deep);
            }
            result[propertyName] = value;
        }
    }
    return result;
};
module.exports = clone;
},{"./defaultValue":243}],241:[function(require,module,exports){
var defaultValue = require('./defaultValue'), defined = require('./defined');
'use strict';
var combine = function (object1, object2, deep) {
    deep = defaultValue(deep, false);
    var result = {};
    var object1Defined = defined(object1);
    var object2Defined = defined(object2);
    var property;
    var object1Value;
    var object2Value;
    if (object1Defined) {
        for (property in object1) {
            if (object1.hasOwnProperty(property)) {
                object1Value = object1[property];
                if (object2Defined && deep && typeof object1Value === 'object' && object2.hasOwnProperty(property)) {
                    object2Value = object2[property];
                    if (typeof object2Value === 'object') {
                        result[property] = combine(object1Value, object2Value, deep);
                    } else {
                        result[property] = object1Value;
                    }
                } else {
                    result[property] = object1Value;
                }
            }
        }
    }
    if (object2Defined) {
        for (property in object2) {
            if (object2.hasOwnProperty(property) && !result.hasOwnProperty(property)) {
                object2Value = object2[property];
                result[property] = object2Value;
            }
        }
    }
    return result;
};
module.exports = combine;
},{"./defaultValue":243,"./defined":245}],242:[function(require,module,exports){
'use strict';
var createGuid = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : r & 3 | 8;
        return v.toString(16);
    });
};
module.exports = createGuid;
},{}],243:[function(require,module,exports){
var freezeObject = require('./freezeObject');
'use strict';
var defaultValue = function (a, b) {
    if (a !== undefined) {
        return a;
    }
    return b;
};
defaultValue.EMPTY_OBJECT = freezeObject({});
module.exports = defaultValue;
},{"./freezeObject":249}],244:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var definePropertyWorks = function () {
        try {
            return 'x' in Object.defineProperty({}, 'x', {});
        } catch (e) {
            return false;
        }
    }();
var defineProperties = Object.defineProperties;
if (!definePropertyWorks || !defined(defineProperties)) {
    defineProperties = function (o) {
        return o;
    };
}
module.exports = defineProperties;
},{"./defined":245}],245:[function(require,module,exports){
'use strict';
var defined = function (value) {
    return value !== undefined;
};
module.exports = defined;
},{}],246:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var warnings = {};
var deprecationWarning = function (identifier, message) {
    if (!defined(identifier) || !defined(message)) {
        throw new DeveloperError('identifier and message are required.');
    }
    if (!defined(warnings[identifier])) {
        warnings[identifier] = true;
        console.log(message);
    }
};
module.exports = deprecationWarning;
},{"./DeveloperError":123,"./defined":245}],247:[function(require,module,exports){
var defaultValue = require('./defaultValue'), DeveloperError = require('./DeveloperError');
'use strict';
function returnTrue() {
    return true;
}
var destroyObject = function (object, message) {
    message = defaultValue(message, 'This object was destroyed, i.e., destroy() was called.');
    function throwOnDestroyed() {
        throw new DeveloperError(message);
    }
    for (var key in object) {
        if (typeof object[key] === 'function') {
            object[key] = throwOnDestroyed;
        }
    }
    object.isDestroyed = returnTrue;
    return undefined;
};
module.exports = destroyObject;
},{"./DeveloperError":123,"./defaultValue":243}],248:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var formatError = function (object) {
    var result;
    var name = object.name;
    var message = object.message;
    if (defined(name) && defined(message)) {
        result = name + ': ' + message;
    } else {
        result = object.toString();
    }
    var stack = object.stack;
    if (defined(stack)) {
        result += '\n' + stack;
    }
    return result;
};
module.exports = formatError;
},{"./defined":245}],249:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var freezeObject = Object.freeze;
if (!defined(freezeObject)) {
    freezeObject = function (o) {
        return o;
    };
}
module.exports = freezeObject;
},{"./defined":245}],250:[function(require,module,exports){
var Uri = require('../ThirdParty/Uri'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var getFilenameFromUri = function (uri) {
    if (!defined(uri)) {
        throw new DeveloperError('uri is required.');
    }
    var uriObject = new Uri(uri);
    uriObject.normalize();
    var path = uriObject.path;
    var index = path.lastIndexOf('/');
    if (index !== -1) {
        path = path.substr(index + 1);
    }
    return path;
};
module.exports = getFilenameFromUri;
},{"../ThirdParty/Uri":587,"./DeveloperError":123,"./defined":245}],251:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var context2DsByWidthAndHeight = {};
var getImagePixels = function (image, width, height) {
    if (!defined(width)) {
        width = image.width;
    }
    if (!defined(height)) {
        height = image.height;
    }
    var context2DsByHeight = context2DsByWidthAndHeight[width];
    if (!defined(context2DsByHeight)) {
        context2DsByHeight = {};
        context2DsByWidthAndHeight[width] = context2DsByHeight;
    }
    var context2d = context2DsByHeight[height];
    if (!defined(context2d)) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        context2d = canvas.getContext('2d');
        context2d.globalCompositeOperation = 'copy';
        context2DsByHeight[height] = context2d;
    }
    context2d.drawImage(image, 0, 0, width, height);
    return context2d.getImageData(0, 0, width, height).data;
};
module.exports = getImagePixels;
},{"./defined":245}],252:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var getTimestamp;
if (typeof performance !== 'undefined' && defined(performance.now)) {
    getTimestamp = function () {
        return performance.now();
    };
} else {
    getTimestamp = function () {
        return Date.now();
    };
}
module.exports = getTimestamp;
},{"./defined":245}],253:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var isArray = Array.isArray;
if (!defined(isArray)) {
    isArray = function (value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    };
}
module.exports = isArray;
},{"./defined":245}],254:[function(require,module,exports){
var defined = require('./defined');
'use strict';
var a;
var isCrossOriginUrl = function (url) {
    if (!defined(a)) {
        a = document.createElement('a');
    }
    a.href = window.location.href;
    var host = a.host;
    var protocol = a.protocol;
    a.href = url;
    a.href = a.href;
    return protocol !== a.protocol || host !== a.host;
};
module.exports = isCrossOriginUrl;
},{"./defined":245}],255:[function(require,module,exports){
var DeveloperError = require('./DeveloperError');
'use strict';
function isLeapYear(year) {
    if (year === null || isNaN(year)) {
        throw new DeveloperError('year is required and must be a number.');
    }
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
module.exports = isLeapYear;
},{"./DeveloperError":123}],256:[function(require,module,exports){
var Uri = require('../ThirdParty/Uri'), when = require('../ThirdParty/when'), combine = require('./combine'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), objectToQuery = require('./objectToQuery'), queryToObject = require('./queryToObject');
'use strict';
var jsonp = function (url, options) {
    if (!defined(url)) {
        throw new DeveloperError('url is required.');
    }
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var functionName;
    do {
        functionName = 'jsonp' + Math.random().toString().substring(2, 8);
    } while (defined(window[functionName]));
    var deferred = when.defer();
    window[functionName] = function (data) {
        deferred.resolve(data);
        try {
            delete window[functionName];
        } catch (e) {
            window[functionName] = undefined;
        }
    };
    var uri = new Uri(url);
    var queryOptions = queryToObject(defaultValue(uri.query, ''));
    if (defined(options.parameters)) {
        queryOptions = combine(options.parameters, queryOptions);
    }
    var callbackParameterName = defaultValue(options.callbackParameterName, 'callback');
    queryOptions[callbackParameterName] = functionName;
    uri.query = objectToQuery(queryOptions);
    url = uri.toString();
    var proxy = options.proxy;
    if (defined(proxy)) {
        url = proxy.getURL(url);
    }
    jsonp.loadAndExecuteScript(url, functionName, deferred);
    return deferred.promise;
};
jsonp.loadAndExecuteScript = function (url, functionName, deferred) {
    var script = document.createElement('script');
    script.async = true;
    script.src = url;
    var head = document.getElementsByTagName('head')[0];
    script.onload = function () {
        script.onload = undefined;
        head.removeChild(script);
    };
    script.onerror = function (e) {
        deferred.reject(e);
    };
    head.appendChild(script);
};
jsonp.defaultLoadAndExecuteScript = jsonp.loadAndExecuteScript;
module.exports = jsonp;
},{"../ThirdParty/Uri":587,"../ThirdParty/when":596,"./DeveloperError":123,"./combine":241,"./defaultValue":243,"./defined":245,"./objectToQuery":266,"./queryToObject":269}],257:[function(require,module,exports){
var loadWithXhr = require('./loadWithXhr');
'use strict';
var loadArrayBuffer = function (url, headers) {
    return loadWithXhr({
        url: url,
        responseType: 'arraybuffer',
        headers: headers
    });
};
module.exports = loadArrayBuffer;
},{"./loadWithXhr":263}],258:[function(require,module,exports){
var loadWithXhr = require('./loadWithXhr');
'use strict';
var loadBlob = function (url, headers) {
    return loadWithXhr({
        url: url,
        responseType: 'blob',
        headers: headers
    });
};
module.exports = loadBlob;
},{"./loadWithXhr":263}],259:[function(require,module,exports){
var when = require('../ThirdParty/when'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), isCrossOriginUrl = require('./isCrossOriginUrl');
'use strict';
var dataUriRegex = /^data:/;
var loadImage = function (url, allowCrossOrigin) {
    if (!defined(url)) {
        throw new DeveloperError('url is required.');
    }
    allowCrossOrigin = defaultValue(allowCrossOrigin, true);
    return when(url, function (url) {
        var crossOrigin;
        if (dataUriRegex.test(url) || !allowCrossOrigin) {
            crossOrigin = false;
        } else {
            crossOrigin = isCrossOriginUrl(url);
        }
        var deferred = when.defer();
        loadImage.createImage(url, crossOrigin, deferred);
        return deferred.promise;
    });
};
loadImage.createImage = function (url, crossOrigin, deferred) {
    var image = new Image();
    image.onload = function (e) {
        deferred.resolve(image);
    };
    image.onerror = function (e) {
        deferred.reject(e);
    };
    if (crossOrigin) {
        image.crossOrigin = '';
    }
    image.src = url;
};
loadImage.defaultCreateImage = loadImage.createImage;
module.exports = loadImage;
},{"../ThirdParty/when":596,"./DeveloperError":123,"./defaultValue":243,"./defined":245,"./isCrossOriginUrl":254}],260:[function(require,module,exports){
var when = require('../ThirdParty/when'), loadBlob = require('./loadBlob'), loadImage = require('./loadImage');
'use strict';
var dataUriRegex = /^data:/;
var loadImageViaBlob = function (url) {
    if (dataUriRegex.test(url)) {
        return loadImage(url);
    }
    return loadBlob(url).then(function (blob) {
        var blobUrl = window.URL.createObjectURL(blob);
        return loadImage(blobUrl, false).then(function (image) {
            image.blob = blob;
            window.URL.revokeObjectURL(blobUrl);
            return image;
        }, function (error) {
            window.URL.revokeObjectURL(blobUrl);
            return when.reject(error);
        });
    });
};
var xhrBlobSupported = function () {
        try {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', '#', true);
            xhr.responseType = 'blob';
            return xhr.responseType === 'blob';
        } catch (e) {
            return false;
        }
    }();
module.exports = xhrBlobSupported ? loadImageViaBlob : loadImage;
},{"../ThirdParty/when":596,"./loadBlob":258,"./loadImage":259}],261:[function(require,module,exports){
var clone = require('./clone'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), loadText = require('./loadText');
'use strict';
var defaultHeaders = { Accept: 'application/json,*/*;q=0.01' };
var loadJson = function loadJson(url, headers) {
    if (!defined(url)) {
        throw new DeveloperError('url is required.');
    }
    if (!defined(headers)) {
        headers = defaultHeaders;
    } else if (!defined(headers.Accept)) {
        headers = clone(headers);
        headers.Accept = defaultHeaders.Accept;
    }
    return loadText(url, headers).then(function (value) {
        return JSON.parse(value);
    });
};
module.exports = loadJson;
},{"./DeveloperError":123,"./clone":240,"./defined":245,"./loadText":262}],262:[function(require,module,exports){
var loadWithXhr = require('./loadWithXhr');
'use strict';
var loadText = function (url, headers) {
    return loadWithXhr({
        url: url,
        headers: headers,
        preferText: true
    });
};
module.exports = loadText;
},{"./loadWithXhr":263}],263:[function(require,module,exports){
var when = require('../ThirdParty/when'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError'), RequestErrorEvent = require('./RequestErrorEvent'), RuntimeError = require('./RuntimeError');
'use strict';
var loadWithXhr = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.url)) {
        throw new DeveloperError('options.url is required.');
    }
    var responseType = options.responseType;
    var method = defaultValue(options.method, 'GET');
    var data = options.data;
    var headers = options.headers;
    var overrideMimeType = options.overrideMimeType;
    var preferText = options.preferText;
    return when(options.url, function (url) {
        var deferred = when.defer();
        loadWithXhr.load(url, responseType, method, data, headers, deferred, overrideMimeType, preferText);
        return deferred.promise;
    });
};
var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
function decodeDataUriText(isBase64, data) {
    var result = decodeURIComponent(data);
    if (isBase64) {
        return atob(result);
    }
    return result;
}
function decodeDataUriArrayBuffer(isBase64, data) {
    var byteString = decodeDataUriText(isBase64, data);
    var buffer = new ArrayBuffer(byteString.length);
    var view = new Uint8Array(buffer);
    for (var i = 0; i < byteString.length; i++) {
        view[i] = byteString.charCodeAt(i);
    }
    return buffer;
}
function decodeDataUri(dataUriRegexResult, responseType) {
    responseType = defaultValue(responseType, '');
    var mimeType = dataUriRegexResult[1];
    var isBase64 = !!dataUriRegexResult[2];
    var data = dataUriRegexResult[3];
    switch (responseType) {
    case '':
    case 'text':
        return decodeDataUriText(isBase64, data);
    case 'arraybuffer':
        return decodeDataUriArrayBuffer(isBase64, data);
    case 'blob':
        var buffer = decodeDataUriArrayBuffer(isBase64, data);
        return new Blob([buffer], { type: mimeType });
    case 'document':
        var parser = new DOMParser();
        return parser.parseFromString(decodeDataUriText(isBase64, data), mimeType);
    case 'json':
        return JSON.parse(decodeDataUriText(isBase64, data));
    default:
        throw new DeveloperError('Unhandled responseType: ' + responseType);
    }
}
loadWithXhr.load = function (url, responseType, method, data, headers, deferred, overrideMimeType, preferText) {
    var dataUriRegexResult = dataUriRegex.exec(url);
    if (dataUriRegexResult !== null) {
        deferred.resolve(decodeDataUri(dataUriRegexResult, responseType));
        return;
    }
    var xhr = new XMLHttpRequest();
    var weWantXml = false;
    if (defined(overrideMimeType)) {
        if (defined(xhr.overrideMimeType)) {
            xhr.overrideMimeType(overrideMimeType);
        } else if (overrideMimeType === 'text/xml' && responseType === 'document') {
            weWantXml = true;
            responseType = 'text';
        }
    }
    xhr.open(method, url, true);
    if (defined(headers)) {
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    }
    if (defined(responseType)) {
        xhr.responseType = responseType;
    }
    xhr.onload = function (e) {
        if (xhr.status === 200) {
            if (defined(xhr.response)) {
                if (weWantXml) {
                    var parser = new DOMParser();
                    deferred.resolve(parser.parseFromString(xhr.response, 'text/xml'));
                } else {
                    deferred.resolve(xhr.response);
                }
            } else {
                if (!defaultValue(preferText, false) && defined(xhr.responseXML) && xhr.responseXML.hasChildNodes()) {
                    deferred.resolve(xhr.responseXML);
                } else if (defined(xhr.responseText)) {
                    deferred.resolve(xhr.responseText);
                } else {
                    deferred.reject(new RuntimeError('unknown XMLHttpRequest response type.'));
                }
            }
        } else {
            deferred.reject(new RequestErrorEvent(xhr.status, xhr.response, xhr.getAllResponseHeaders()));
        }
    };
    xhr.onerror = function (e) {
        deferred.reject(new RequestErrorEvent());
    };
    xhr.send(data);
};
loadWithXhr.defaultLoad = loadWithXhr.load;
module.exports = loadWithXhr;
},{"../ThirdParty/when":596,"./DeveloperError":123,"./RequestErrorEvent":206,"./RuntimeError":207,"./defaultValue":243,"./defined":245}],264:[function(require,module,exports){
var loadWithXhr = require('./loadWithXhr');
'use strict';
var loadXML = function (url, headers) {
    return loadWithXhr({
        url: url,
        responseType: 'document',
        headers: headers,
        overrideMimeType: 'text/xml'
    });
};
module.exports = loadXML;
},{"./loadWithXhr":263}],265:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var leftScratchArray = [];
var rightScratchArray = [];
function merge(array, compare, userDefinedObject, start, middle, end) {
    var leftLength = middle - start + 1;
    var rightLength = end - middle;
    var left = leftScratchArray;
    var right = rightScratchArray;
    var i;
    var j;
    for (i = 0; i < leftLength; ++i) {
        left[i] = array[start + i];
    }
    for (j = 0; j < rightLength; ++j) {
        right[j] = array[middle + j + 1];
    }
    i = 0;
    j = 0;
    for (var k = start; k <= end; ++k) {
        var leftElement = left[i];
        var rightElement = right[j];
        if (i < leftLength && (j >= rightLength || compare(leftElement, rightElement, userDefinedObject) <= 0)) {
            array[k] = leftElement;
            ++i;
        } else if (j < rightLength) {
            array[k] = rightElement;
            ++j;
        }
    }
}
function sort(array, compare, userDefinedObject, start, end) {
    if (start >= end) {
        return;
    }
    var middle = Math.floor((start + end) * 0.5);
    sort(array, compare, userDefinedObject, start, middle);
    sort(array, compare, userDefinedObject, middle + 1, end);
    merge(array, compare, userDefinedObject, start, middle, end);
}
var mergeSort = function (array, comparator, userDefinedObject) {
    if (!defined(array)) {
        throw new DeveloperError('array is required.');
    }
    if (!defined(comparator)) {
        throw new DeveloperError('comparator is required.');
    }
    var length = array.length;
    var scratchLength = Math.ceil(length * 0.5);
    leftScratchArray.length = scratchLength;
    rightScratchArray.length = scratchLength;
    sort(array, comparator, userDefinedObject, 0, length - 1);
    leftScratchArray.length = 0;
    rightScratchArray.length = 0;
};
module.exports = mergeSort;
},{"./DeveloperError":123,"./defined":245}],266:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError'), isArray = require('./isArray');
'use strict';
var objectToQuery = function (obj) {
    if (!defined(obj)) {
        throw new DeveloperError('obj is required.');
    }
    var result = '';
    for (var propName in obj) {
        if (obj.hasOwnProperty(propName)) {
            var value = obj[propName];
            var part = encodeURIComponent(propName) + '=';
            if (isArray(value)) {
                for (var i = 0, len = value.length; i < len; ++i) {
                    result += part + encodeURIComponent(value[i]) + '&';
                }
            } else {
                result += part + encodeURIComponent(value) + '&';
            }
        }
    }
    result = result.slice(0, -1);
    return result;
};
module.exports = objectToQuery;
},{"./DeveloperError":123,"./defined":245,"./isArray":253}],267:[function(require,module,exports){
'use strict';
var parseResponseHeaders = function (headerString) {
    var headers = {};
    if (!headerString) {
        return headers;
    }
    var headerPairs = headerString.split('\r\n');
    for (var i = 0; i < headerPairs.length; ++i) {
        var headerPair = headerPairs[i];
        var index = headerPair.indexOf(': ');
        if (index > 0) {
            var key = headerPair.substring(0, index);
            var val = headerPair.substring(index + 2);
            headers[key] = val;
        }
    }
    return headers;
};
module.exports = parseResponseHeaders;
},{}],268:[function(require,module,exports){
var barycentricCoordinates = require('./barycentricCoordinates'), Cartesian3 = require('./Cartesian3');
'use strict';
var coords = new Cartesian3();
var pointInsideTriangle = function (point, p0, p1, p2) {
    barycentricCoordinates(point, p0, p1, p2, coords);
    return coords.x > 0 && coords.y > 0 && coords.z > 0;
};
module.exports = pointInsideTriangle;
},{"./Cartesian3":102,"./barycentricCoordinates":237}],269:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError'), isArray = require('./isArray');
'use strict';
var queryToObject = function (queryString) {
    if (!defined(queryString)) {
        throw new DeveloperError('queryString is required.');
    }
    var result = {};
    if (queryString === '') {
        return result;
    }
    var parts = queryString.replace(/\+/g, '%20').split('&');
    for (var i = 0, len = parts.length; i < len; ++i) {
        var subparts = parts[i].split('=');
        var name = decodeURIComponent(subparts[0]);
        var value = subparts[1];
        if (defined(value)) {
            value = decodeURIComponent(value);
        } else {
            value = '';
        }
        var resultValue = result[name];
        if (typeof resultValue === 'string') {
            result[name] = [
                resultValue,
                value
            ];
        } else if (isArray(resultValue)) {
            resultValue.push(value);
        } else {
            result[name] = value;
        }
    }
    return result;
};
module.exports = queryToObject;
},{"./DeveloperError":123,"./defined":245,"./isArray":253}],270:[function(require,module,exports){
var defined = require('./defined'), getTimestamp = require('./getTimestamp');
'use strict';
var implementation = window.requestAnimationFrame;
(function () {
    if (!defined(implementation)) {
        var vendors = [
                'webkit',
                'moz',
                'ms',
                'o'
            ];
        var i = 0;
        var len = vendors.length;
        while (i < len && !defined(implementation)) {
            implementation = window[vendors[i] + 'RequestAnimationFrame'];
            ++i;
        }
    }
    if (!defined(implementation)) {
        var msPerFrame = 1000 / 60;
        var lastFrameTime = 0;
        implementation = function (callback) {
            var currentTime = getTimestamp();
            var delay = Math.max(msPerFrame - (currentTime - lastFrameTime), 0);
            lastFrameTime = currentTime + delay;
            return setTimeout(function () {
                callback(lastFrameTime);
            }, delay);
        };
    }
}());
var requestAnimationFrame = function (callback) {
    return implementation(callback);
};
module.exports = requestAnimationFrame;
},{"./defined":245,"./getTimestamp":252}],271:[function(require,module,exports){
var defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var subdivideArray = function (array, numberOfArrays) {
    if (!defined(array)) {
        throw new DeveloperError('array is required.');
    }
    if (!defined(numberOfArrays) || numberOfArrays < 1) {
        throw new DeveloperError('numberOfArrays must be greater than 0.');
    }
    var result = [];
    var len = array.length;
    var i = 0;
    while (i < len) {
        var size = Math.ceil((len - i) / numberOfArrays--);
        result.push(array.slice(i, i + size));
        i += size;
    }
    return result;
};
module.exports = subdivideArray;
},{"./DeveloperError":123,"./defined":245}],272:[function(require,module,exports){
var Uri = require('../ThirdParty/Uri'), when = require('../ThirdParty/when'), defaultValue = require('./defaultValue');
'use strict';
var activeRequests = {};
var pageUri = new Uri(document.location.href);
function getServer(url) {
    var uri = new Uri(url).resolve(pageUri);
    uri.normalize();
    var server = uri.authority;
    if (!/:/.test(server)) {
        server = server + ':' + (uri.scheme === 'https' ? '443' : '80');
    }
    return server;
}
var throttleRequestByServer = function (url, requestFunction) {
    var server = getServer(url);
    var activeRequestsForServer = defaultValue(activeRequests[server], 0);
    if (activeRequestsForServer >= throttleRequestByServer.maximumRequestsPerServer) {
        return undefined;
    }
    activeRequests[server] = activeRequestsForServer + 1;
    return when(requestFunction(url), function (result) {
        activeRequests[server]--;
        return result;
    }).otherwise(function (error) {
        activeRequests[server]--;
        return when.reject(error);
    });
};
throttleRequestByServer.maximumRequestsPerServer = 6;
module.exports = throttleRequestByServer;
},{"../ThirdParty/Uri":587,"../ThirdParty/when":596,"./defaultValue":243}],273:[function(require,module,exports){
var measureText = require('../ThirdParty/measureText'), Color = require('./Color'), defaultValue = require('./defaultValue'), defined = require('./defined'), DeveloperError = require('./DeveloperError');
'use strict';
var imageSmoothingEnabledName;
var writeTextToCanvas = function (text, options) {
    if (!defined(text)) {
        throw new DeveloperError('text is required.');
    }
    if (text === '') {
        return undefined;
    }
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var font = defaultValue(options.font, '10px sans-serif');
    var stroke = defaultValue(options.stroke, false);
    var fill = defaultValue(options.fill, true);
    var strokeWidth = defaultValue(options.strokeWidth, 1);
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    canvas.style.font = font;
    var context2D = canvas.getContext('2d');
    if (!defined(imageSmoothingEnabledName)) {
        if (defined(context2D.imageSmoothingEnabled)) {
            imageSmoothingEnabledName = 'imageSmoothingEnabled';
        } else if (defined(context2D.mozImageSmoothingEnabled)) {
            imageSmoothingEnabledName = 'mozImageSmoothingEnabled';
        } else if (defined(context2D.webkitImageSmoothingEnabled)) {
            imageSmoothingEnabledName = 'webkitImageSmoothingEnabled';
        } else if (defined(context2D.msImageSmoothingEnabled)) {
            imageSmoothingEnabledName = 'msImageSmoothingEnabled';
        }
    }
    context2D.font = font;
    context2D.lineJoin = 'round';
    context2D.lineWidth = strokeWidth;
    context2D[imageSmoothingEnabledName] = false;
    context2D.textBaseline = defaultValue(options.textBaseline, 'bottom');
    canvas.style.visibility = 'hidden';
    document.body.appendChild(canvas);
    var dimensions = measureText(context2D, text, stroke, fill);
    dimensions.computedWidth = Math.max(dimensions.width, dimensions.bounds.maxx - dimensions.bounds.minx);
    canvas.dimensions = dimensions;
    document.body.removeChild(canvas);
    canvas.style.visibility = '';
    var baseline = dimensions.height - dimensions.ascent;
    canvas.width = dimensions.computedWidth;
    canvas.height = dimensions.height;
    var y = canvas.height - baseline;
    context2D.font = font;
    context2D.lineJoin = 'round';
    context2D.lineWidth = strokeWidth;
    context2D[imageSmoothingEnabledName] = false;
    if (stroke) {
        var strokeColor = defaultValue(options.strokeColor, Color.BLACK);
        context2D.strokeStyle = strokeColor.toCssColorString();
        context2D.strokeText(text, 0, y);
    }
    if (fill) {
        var fillColor = defaultValue(options.fillColor, Color.WHITE);
        context2D.fillStyle = fillColor.toCssColorString();
        context2D.fillText(text, 0, y);
    }
    return canvas;
};
module.exports = writeTextToCanvas;
},{"../ThirdParty/measureText":592,"./Color":111,"./DeveloperError":123,"./defaultValue":243,"./defined":245}],274:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var BillboardGraphics = function () {
    this._image = undefined;
    this._imageSubscription = undefined;
    this._imageSubRegion = undefined;
    this._imageSubRegionSubscription = undefined;
    this._width = undefined;
    this._widthSubscription = undefined;
    this._height = undefined;
    this._heightSubscription = undefined;
    this._scale = undefined;
    this._scaleSubscription = undefined;
    this._rotation = undefined;
    this._rotationSubscription = undefined;
    this._alignedAxis = undefined;
    this._alignedAxisSubscription = undefined;
    this._horizontalOrigin = undefined;
    this._horizontalOriginSubscription = undefined;
    this._verticalOrigin = undefined;
    this._verticalOriginSubscription = undefined;
    this._color = undefined;
    this._colorSubscription = undefined;
    this._eyeOffset = undefined;
    this._eyeOffsetSubscription = undefined;
    this._pixelOffset = undefined;
    this._pixelOffsetSubscription = undefined;
    this._show = undefined;
    this._showSubscription = undefined;
    this._scaleByDistance = undefined;
    this._scaleByDistanceSubscription = undefined;
    this._translucencyByDistance = undefined;
    this._translucencyByDistanceSubscription = undefined;
    this._pixelOffsetScaleByDistance = undefined;
    this._pixelOffsetScaleByDistanceSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(BillboardGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    image: createPropertyDescriptor('image'),
    imageSubRegion: createPropertyDescriptor('imageSubRegion'),
    scale: createPropertyDescriptor('scale'),
    rotation: createPropertyDescriptor('rotation'),
    alignedAxis: createPropertyDescriptor('alignedAxis'),
    horizontalOrigin: createPropertyDescriptor('horizontalOrigin'),
    verticalOrigin: createPropertyDescriptor('verticalOrigin'),
    color: createPropertyDescriptor('color'),
    eyeOffset: createPropertyDescriptor('eyeOffset'),
    pixelOffset: createPropertyDescriptor('pixelOffset'),
    show: createPropertyDescriptor('show'),
    width: createPropertyDescriptor('width'),
    height: createPropertyDescriptor('height'),
    scaleByDistance: createPropertyDescriptor('scaleByDistance'),
    translucencyByDistance: createPropertyDescriptor('translucencyByDistance'),
    pixelOffsetScaleByDistance: createPropertyDescriptor('pixelOffsetScaleByDistance')
});
BillboardGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new BillboardGraphics();
    }
    result.color = this._color;
    result.eyeOffset = this._eyeOffset;
    result.horizontalOrigin = this._horizontalOrigin;
    result.image = this._image;
    result.imageSubRegion = this._imageSubRegion;
    result.pixelOffset = this._pixelOffset;
    result.scale = this._scale;
    result.rotation = this._rotation;
    result.alignedAxis = this._alignedAxis;
    result.show = this._show;
    result.verticalOrigin = this._verticalOrigin;
    result.width = this._width;
    result.height = this._height;
    result.scaleByDistance = this._scaleByDistance;
    result.translucencyByDistance = this._translucencyByDistance;
    result.pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
    return result;
};
BillboardGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.color = defaultValue(this._color, source.color);
    this.eyeOffset = defaultValue(this._eyeOffset, source.eyeOffset);
    this.horizontalOrigin = defaultValue(this._horizontalOrigin, source.horizontalOrigin);
    this.image = defaultValue(this._image, source.image);
    this.imageSubRegion = defaultValue(this._imageSubRegion, source.imageSubRegion);
    this.pixelOffset = defaultValue(this._pixelOffset, source.pixelOffset);
    this.scale = defaultValue(this._scale, source.scale);
    this.rotation = defaultValue(this._rotation, source.rotation);
    this.alignedAxis = defaultValue(this._alignedAxis, source.alignedAxis);
    this.show = defaultValue(this._show, source.show);
    this.verticalOrigin = defaultValue(this._verticalOrigin, source.verticalOrigin);
    this.width = defaultValue(this._width, source.width);
    this.height = defaultValue(this._height, source.height);
    this.scaleByDistance = defaultValue(this._scaleByDistance, source.scaleByDistance);
    this.translucencyByDistance = defaultValue(this._translucencyByDistance, source.translucencyByDistance);
    this.pixelOffsetScaleByDistance = defaultValue(this._pixelOffsetScaleByDistance, source.pixelOffsetScaleByDistance);
};
module.exports = BillboardGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],275:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), BoundingRectangle = require('../Core/BoundingRectangle'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), NearFarScalar = require('../Core/NearFarScalar'), BillboardCollection = require('../Scene/BillboardCollection'), HorizontalOrigin = require('../Scene/HorizontalOrigin'), VerticalOrigin = require('../Scene/VerticalOrigin'), Property = require('./Property');
'use strict';
var defaultColor = Color.WHITE;
var defaultEyeOffset = Cartesian3.ZERO;
var defaultPixelOffset = Cartesian2.ZERO;
var defaultScale = 1;
var defaultRotation = 0;
var defaultAlignedAxis = Cartesian3.ZERO;
var defaultHorizontalOrigin = HorizontalOrigin.CENTER;
var defaultVerticalOrigin = VerticalOrigin.CENTER;
var position = new Cartesian3();
var color = new Color();
var eyeOffset = new Cartesian3();
var pixelOffset = new Cartesian2();
var scaleByDistance = new NearFarScalar();
var translucencyByDistance = new NearFarScalar();
var pixelOffsetScaleByDistance = new NearFarScalar();
var boundingRectangle = new BoundingRectangle();
var EntityData = function (entity) {
    this.entity = entity;
    this.billboard = undefined;
    this.textureValue = undefined;
};
var BillboardVisualizer = function (scene, entityCollection) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(entityCollection)) {
        throw new DeveloperError('entityCollection is required.');
    }
    entityCollection.collectionChanged.addEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);
    this._scene = scene;
    this._unusedIndexes = [];
    this._billboardCollection = undefined;
    this._entityCollection = entityCollection;
    this._items = new AssociativeArray();
    this._onCollectionChanged(entityCollection, entityCollection.entities, [], []);
};
BillboardVisualizer.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var items = this._items.values;
    var unusedIndexes = this._unusedIndexes;
    for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
        var entity = item.entity;
        var billboardGraphics = entity._billboard;
        var textureValue;
        var billboard = item.billboard;
        var show = entity.isAvailable(time) && Property.getValueOrDefault(billboardGraphics._show, time, true);
        if (show) {
            position = Property.getValueOrUndefined(entity._position, time, position);
            textureValue = Property.getValueOrUndefined(billboardGraphics._image, time);
            show = defined(position) && defined(textureValue);
        }
        if (!show) {
            returnBillboard(item, unusedIndexes);
            continue;
        }
        if (!defined(billboard)) {
            var billboardCollection = this._billboardCollection;
            if (!defined(billboardCollection)) {
                billboardCollection = new BillboardCollection();
                this._billboardCollection = billboardCollection;
                this._scene.primitives.add(billboardCollection);
            }
            var length = unusedIndexes.length;
            if (length > 0) {
                billboard = billboardCollection.get(unusedIndexes.pop());
            } else {
                billboard = billboardCollection.add();
            }
            billboard.id = entity;
            billboard.image = undefined;
            item.billboard = billboard;
        }
        billboard.show = show;
        if (item.textureValue !== textureValue) {
            billboard.image = textureValue;
            item.textureValue = textureValue;
        }
        billboard.position = position;
        billboard.color = Property.getValueOrDefault(billboardGraphics._color, time, defaultColor, color);
        billboard.eyeOffset = Property.getValueOrDefault(billboardGraphics._eyeOffset, time, defaultEyeOffset, eyeOffset);
        billboard.pixelOffset = Property.getValueOrDefault(billboardGraphics._pixelOffset, time, defaultPixelOffset, pixelOffset);
        billboard.scale = Property.getValueOrDefault(billboardGraphics._scale, time, defaultScale);
        billboard.rotation = Property.getValueOrDefault(billboardGraphics._rotation, time, defaultRotation);
        billboard.alignedAxis = Property.getValueOrDefault(billboardGraphics._alignedAxis, time, defaultAlignedAxis);
        billboard.horizontalOrigin = Property.getValueOrDefault(billboardGraphics._horizontalOrigin, time, defaultHorizontalOrigin);
        billboard.verticalOrigin = Property.getValueOrDefault(billboardGraphics._verticalOrigin, time, defaultVerticalOrigin);
        billboard.width = Property.getValueOrUndefined(billboardGraphics._width, time);
        billboard.height = Property.getValueOrUndefined(billboardGraphics._height, time);
        billboard.scaleByDistance = Property.getValueOrUndefined(billboardGraphics._scaleByDistance, time, scaleByDistance);
        billboard.translucencyByDistance = Property.getValueOrUndefined(billboardGraphics._translucencyByDistance, time, translucencyByDistance);
        billboard.pixelOffsetScaleByDistance = Property.getValueOrUndefined(billboardGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistance);
        var subRegion = Property.getValueOrUndefined(billboardGraphics._imageSubRegion, time, boundingRectangle);
        if (defined(subRegion)) {
            billboard.setImageSubRegion(billboard._imageId, subRegion);
        }
    }
    return true;
};
BillboardVisualizer.prototype.isDestroyed = function () {
    return false;
};
BillboardVisualizer.prototype.destroy = function () {
    this._entityCollection.collectionChanged.removeEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);
    if (defined(this._billboardCollection)) {
        this._scene.primitives.remove(this._billboardCollection);
    }
    return destroyObject(this);
};
BillboardVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
    var i;
    var entity;
    var unusedIndexes = this._unusedIndexes;
    var items = this._items;
    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        if (defined(entity._billboard) && defined(entity._position)) {
            items.set(entity.id, new EntityData(entity));
        }
    }
    for (i = changed.length - 1; i > -1; i--) {
        entity = changed[i];
        if (defined(entity._billboard) && defined(entity._position)) {
            if (!items.contains(entity.id)) {
                items.set(entity.id, new EntityData(entity));
            }
        } else {
            returnBillboard(items.get(entity.id), unusedIndexes);
            items.remove(entity.id);
        }
    }
    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        returnBillboard(items.get(entity.id), unusedIndexes);
        items.remove(entity.id);
    }
};
function returnBillboard(item, unusedIndexes) {
    if (defined(item)) {
        var billboard = item.billboard;
        if (defined(billboard)) {
            item.textureValue = undefined;
            item.billboard = undefined;
            billboard.show = false;
            billboard.image = undefined;
            unusedIndexes.push(billboard._index);
        }
    }
}
module.exports = BillboardVisualizer;
},{"../Core/AssociativeArray":93,"../Core/BoundingRectangle":97,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/NearFarScalar":178,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/BillboardCollection":369,"../Scene/HorizontalOrigin":394,"../Scene/VerticalOrigin":454,"./Property":321}],276:[function(require,module,exports){
var BoxGeometry = require('../Core/BoxGeometry'), BoxOutlineGeometry = require('../Core/BoxOutlineGeometry'), Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var scratchColor = new Color();
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.dimensions = undefined;
};
var BoxGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(BoxGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'box', entity.box, undefined);
};
defineProperties(BoxGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(BoxGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: { value: true },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
BoxGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
BoxGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
BoxGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: BoxGeometry.fromDimensions(this._options),
        modelMatrix: entity._getModelMatrix(Iso8601.MINIMUM_VALUE),
        attributes: attributes
    });
};
BoxGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: BoxOutlineGeometry.fromDimensions(this._options),
        modelMatrix: entity._getModelMatrix(Iso8601.MINIMUM_VALUE),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
BoxGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
BoxGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
BoxGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'position' || propertyName === 'orientation' || propertyName === 'box')) {
        return;
    }
    var box = this._entity.box;
    if (!defined(box)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = box.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = box.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var dimensions = box.dimensions;
    var position = entity.position;
    var show = box.show;
    if (!defined(dimensions) || !defined(position) || defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(box.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(box.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(box.outlineColor, defaultOutlineColor) : undefined;
    var outlineWidth = box.outlineWidth;
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    if (!position.isConstant || !Property.isConstant(entity.orientation) || !dimensions.isConstant || !Property.isConstant(outlineWidth)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.dimensions = dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
BoxGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var primitives = this._primitives;
    primitives.remove(this._primitive);
    primitives.remove(this._outlinePrimitive);
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var box = entity.box;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(box.show, time, true)) {
        return;
    }
    var options = this._options;
    var modelMatrix = entity._getModelMatrix(time);
    var dimensions = Property.getValueOrUndefined(box.dimensions, time, options.dimensions);
    if (!defined(modelMatrix) || !defined(dimensions)) {
        return;
    }
    options.dimensions = dimensions;
    if (Property.getValueOrDefault(box.fill, time, true)) {
        var material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, this._material);
        this._material = material;
        var appearance = new MaterialAppearance({
                material: material,
                translucent: material.isTranslucent(),
                closed: true
            });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: BoxGeometry.fromDimensions(options),
                modelMatrix: modelMatrix
            }),
            appearance: appearance,
            asynchronous: false
        }));
    }
    if (Property.getValueOrDefault(box.outline, time, true)) {
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        var outlineColor = Property.getValueOrClonedDefault(box.outlineColor, time, Color.BLACK, scratchColor);
        var outlineWidth = Property.getValueOrDefault(box.outlineWidth, 1);
        var translucent = outlineColor.alpha !== 1;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: BoxOutlineGeometry.fromDimensions(options),
                modelMatrix: modelMatrix,
                attributes: { color: ColorGeometryInstanceAttribute.fromColor(outlineColor) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: translucent,
                renderState: { lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    var primitives = this._primitives;
    primitives.remove(this._primitive);
    primitives.remove(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = BoxGeometryUpdater;
},{"../Core/BoxGeometry":99,"../Core/BoxOutlineGeometry":100,"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],277:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event');
'use strict';
var CallbackProperty = function (callback, isConstant) {
    this._callback = undefined;
    this._isConstant = undefined;
    this._definitionChanged = new Event();
    this.setCallback(callback, isConstant);
};
defineProperties(CallbackProperty.prototype, {
    isConstant: {
        get: function () {
            return this._isConstant;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    }
});
CallbackProperty.prototype.getValue = function (time, result) {
    return this._callback(time, result);
};
CallbackProperty.prototype.setCallback = function (callback, isConstant) {
    if (!defined(callback)) {
        throw new DeveloperError('callback is required.');
    }
    if (!defined(isConstant)) {
        throw new DeveloperError('isConstant is required.');
    }
    var changed = this._callback !== callback || this._isConstant !== isConstant;
    this._callback = callback;
    this._isConstant = isConstant;
    if (changed) {
        this._definitionChanged.raiseEvent(this);
    }
};
CallbackProperty.prototype.equals = function (other) {
    return this === other || other instanceof CallbackProperty && this._callback === other._callback && this._isConstant === other._isConstant;
};
module.exports = CallbackProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defineProperties":244,"../Core/defined":245}],278:[function(require,module,exports){
var Color = require('../Core/Color'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), ConstantProperty = require('./ConstantProperty'), createPropertyDescriptor = require('./createPropertyDescriptor'), Property = require('./Property');
'use strict';
var ColorMaterialProperty = function (colorProperty) {
    this._definitionChanged = new Event();
    this._color = undefined;
    this._colorSubscription = undefined;
    this.color = colorProperty;
};
ColorMaterialProperty.fromColor = function (color) {
    if (!defined(color)) {
        throw new DeveloperError('color is required');
    }
    return new ColorMaterialProperty(new ConstantProperty(color));
};
defineProperties(ColorMaterialProperty.prototype, {
    isConstant: {
        get: function () {
            return Property.isConstant(this._color);
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    color: createPropertyDescriptor('color')
});
ColorMaterialProperty.prototype.getType = function (time) {
    return 'Color';
};
ColorMaterialProperty.prototype.getValue = function (time, result) {
    if (!defined(result)) {
        result = {};
    }
    result.color = Property.getValueOrClonedDefault(this._color, time, Color.WHITE, result.color);
    return result;
};
ColorMaterialProperty.prototype.equals = function (other) {
    return this === other || other instanceof ColorMaterialProperty && Property.equals(this._color, other._color);
};
module.exports = ColorMaterialProperty;
},{"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defineProperties":244,"../Core/defined":245,"./ConstantProperty":283,"./Property":321,"./createPropertyDescriptor":336}],279:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), CompositeProperty = require('./CompositeProperty'), Property = require('./Property');
'use strict';
var CompositeMaterialProperty = function () {
    this._definitionChanged = new Event();
    this._composite = new CompositeProperty();
    this._composite.definitionChanged.addEventListener(CompositeMaterialProperty.prototype._raiseDefinitionChanged, this);
};
defineProperties(CompositeMaterialProperty.prototype, {
    isConstant: {
        get: function () {
            return this._composite.isConstant;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    intervals: {
        get: function () {
            return this._composite._intervals;
        }
    }
});
CompositeMaterialProperty.prototype.getType = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required');
    }
    var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
    if (defined(innerProperty)) {
        return innerProperty.getType(time);
    }
    return undefined;
};
CompositeMaterialProperty.prototype.getValue = function (time, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required');
    }
    var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
    if (defined(innerProperty)) {
        return innerProperty.getValue(time, result);
    }
    return undefined;
};
CompositeMaterialProperty.prototype.equals = function (other) {
    return this === other || other instanceof CompositeMaterialProperty && this._composite.equals(other._composite, Property.equals);
};
CompositeMaterialProperty.prototype._raiseDefinitionChanged = function () {
    this._definitionChanged.raiseEvent(this);
};
module.exports = CompositeMaterialProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defineProperties":244,"../Core/defined":245,"./CompositeProperty":281,"./Property":321}],280:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), ReferenceFrame = require('../Core/ReferenceFrame'), CompositeProperty = require('./CompositeProperty'), Property = require('./Property');
'use strict';
var CompositePositionProperty = function (referenceFrame) {
    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
    this._definitionChanged = new Event();
    this._composite = new CompositeProperty();
    this._composite.definitionChanged.addEventListener(CompositePositionProperty.prototype._raiseDefinitionChanged, this);
};
defineProperties(CompositePositionProperty.prototype, {
    isConstant: {
        get: function () {
            return this._composite.isConstant;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    intervals: {
        get: function () {
            return this._composite.intervals;
        }
    },
    referenceFrame: {
        get: function () {
            return this._referenceFrame;
        },
        set: function (value) {
            this._referenceFrame = value;
        }
    }
});
CompositePositionProperty.prototype.getValue = function (time, result) {
    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
};
CompositePositionProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!defined(referenceFrame)) {
        throw new DeveloperError('referenceFrame is required.');
    }
    var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);
    if (defined(innerProperty)) {
        return innerProperty.getValueInReferenceFrame(time, referenceFrame, result);
    }
    return undefined;
};
CompositePositionProperty.prototype.equals = function (other) {
    return this === other || other instanceof CompositePositionProperty && this._referenceFrame === other._referenceFrame && this._composite.equals(other._composite, Property.equals);
};
CompositePositionProperty.prototype._raiseDefinitionChanged = function () {
    this._definitionChanged.raiseEvent(this);
};
module.exports = CompositePositionProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/ReferenceFrame":205,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./CompositeProperty":281,"./Property":321}],281:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), EventHelper = require('../Core/EventHelper'), TimeIntervalCollection = require('../Core/TimeIntervalCollection'), Property = require('./Property');
'use strict';
function subscribeAll(property, eventHelper, definitionChanged, intervals) {
    var callback = function () {
        definitionChanged.raiseEvent(property);
    };
    var items = [];
    eventHelper.removeAll();
    var length = intervals.length;
    for (var i = 0; i < length; i++) {
        var interval = intervals.get(i);
        if (defined(interval.data) && items.indexOf(interval.data) === -1) {
            eventHelper.add(interval.data.definitionChanged, callback);
        }
    }
}
var CompositeProperty = function () {
    this._eventHelper = new EventHelper();
    this._definitionChanged = new Event();
    this._intervals = new TimeIntervalCollection();
    this._intervals.changedEvent.addEventListener(CompositeProperty.prototype._intervalsChanged, this);
};
defineProperties(CompositeProperty.prototype, {
    isConstant: {
        get: function () {
            return this._intervals.isEmpty;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    intervals: {
        get: function () {
            return this._intervals;
        }
    }
});
CompositeProperty.prototype.getValue = function (time, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required');
    }
    var innerProperty = this._intervals.findDataForIntervalContainingDate(time);
    if (defined(innerProperty)) {
        return innerProperty.getValue(time, result);
    }
    return undefined;
};
CompositeProperty.prototype.equals = function (other) {
    return this === other || other instanceof CompositeProperty && this._intervals.equals(other._intervals, Property.equals);
};
CompositeProperty.prototype._intervalsChanged = function () {
    subscribeAll(this, this._eventHelper, this._definitionChanged, this._intervals);
    this._definitionChanged.raiseEvent(this);
};
module.exports = CompositeProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/EventHelper":139,"../Core/TimeIntervalCollection":223,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321}],282:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), ReferenceFrame = require('../Core/ReferenceFrame'), PositionProperty = require('./PositionProperty');
'use strict';
var ConstantPositionProperty = function (value, referenceFrame) {
    this._definitionChanged = new Event();
    this._value = Cartesian3.clone(value);
    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
};
defineProperties(ConstantPositionProperty.prototype, {
    isConstant: {
        get: function () {
            return !defined(this._value) || this._referenceFrame === ReferenceFrame.FIXED;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    referenceFrame: {
        get: function () {
            return this._referenceFrame;
        }
    }
});
ConstantPositionProperty.prototype.getValue = function (time, result) {
    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
};
ConstantPositionProperty.prototype.setValue = function (value, referenceFrame) {
    var definitionChanged = false;
    if (!Cartesian3.equals(this._value, value)) {
        definitionChanged = true;
        this._value = Cartesian3.clone(value);
    }
    if (defined(referenceFrame) && this._referenceFrame !== referenceFrame) {
        definitionChanged = true;
        this._referenceFrame = referenceFrame;
    }
    if (definitionChanged) {
        this._definitionChanged.raiseEvent(this);
    }
};
ConstantPositionProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!defined(referenceFrame)) {
        throw new DeveloperError('referenceFrame is required.');
    }
    return PositionProperty.convertToReferenceFrame(time, this._value, this._referenceFrame, referenceFrame, result);
};
ConstantPositionProperty.prototype.equals = function (other) {
    return this === other || other instanceof ConstantPositionProperty && Cartesian3.equals(this._value, other._value) && this._referenceFrame === other._referenceFrame;
};
module.exports = ConstantPositionProperty;
},{"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/ReferenceFrame":205,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./PositionProperty":319}],283:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event');
'use strict';
var ConstantProperty = function (value) {
    this._value = undefined;
    this._hasClone = false;
    this._hasEquals = false;
    this._definitionChanged = new Event();
    this.setValue(value);
};
defineProperties(ConstantProperty.prototype, {
    isConstant: { value: true },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    }
});
ConstantProperty.prototype.getValue = function (time, result) {
    return this._hasClone ? this._value.clone(result) : this._value;
};
ConstantProperty.prototype.setValue = function (value) {
    var oldValue = this._value;
    if (oldValue !== value) {
        var isDefined = defined(value);
        var hasClone = isDefined && typeof value.clone === 'function';
        var hasEquals = isDefined && typeof value.equals === 'function';
        this._hasClone = hasClone;
        this._hasEquals = hasEquals;
        var changed = !hasEquals || !value.equals(oldValue);
        if (changed) {
            this._value = !hasClone ? value : value.clone();
            this._definitionChanged.raiseEvent(this);
        }
    }
};
ConstantProperty.prototype.equals = function (other) {
    return this === other || other instanceof ConstantProperty && (!this._hasEquals && this._value === other._value || this._hasEquals && this._value.equals(other._value));
};
module.exports = ConstantProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245}],284:[function(require,module,exports){
var Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), CorridorGeometry = require('../Core/CorridorGeometry'), CorridorOutlineGeometry = require('../Core/CorridorOutlineGeometry'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var scratchColor = new Color();
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.positions = undefined;
    this.width = undefined;
    this.cornerType = undefined;
    this.height = undefined;
    this.extrudedHeight = undefined;
    this.granularity = undefined;
};
var CorridorGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(CorridorGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._isClosed = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'corridor', entity.corridor, undefined);
};
defineProperties(CorridorGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(CorridorGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: {
        get: function () {
            return this._isClosed;
        }
    },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
CorridorGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
CorridorGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
CorridorGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new CorridorGeometry(this._options),
        attributes: attributes
    });
};
CorridorGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: new CorridorOutlineGeometry(this._options),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
CorridorGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
CorridorGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
CorridorGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'corridor')) {
        return;
    }
    var corridor = this._entity.corridor;
    if (!defined(corridor)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = corridor.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = corridor.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var positions = corridor.positions;
    var show = corridor.show;
    if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || !defined(positions)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(corridor.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(corridor.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(corridor.outlineColor, defaultOutlineColor) : undefined;
    var height = corridor.height;
    var extrudedHeight = corridor.extrudedHeight;
    var granularity = corridor.granularity;
    var width = corridor.width;
    var outlineWidth = corridor.outlineWidth;
    var cornerType = corridor.cornerType;
    this._isClosed = defined(extrudedHeight);
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    if (!positions.isConstant || !Property.isConstant(height) || !Property.isConstant(extrudedHeight) || !Property.isConstant(granularity) || !Property.isConstant(width) || !Property.isConstant(outlineWidth) || !Property.isConstant(cornerType)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.positions = positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);
        options.height = defined(height) ? height.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.extrudedHeight = defined(extrudedHeight) ? extrudedHeight.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.cornerType = defined(cornerType) ? cornerType.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
CorridorGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var primitives = this._primitives;
    primitives.remove(this._primitive);
    primitives.remove(this._outlinePrimitive);
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var corridor = entity.corridor;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(corridor.show, time, true)) {
        return;
    }
    var options = this._options;
    var positions = Property.getValueOrUndefined(corridor.positions, time, options.positions);
    var width = Property.getValueOrUndefined(corridor.width, time);
    if (!defined(positions) || !defined(width)) {
        return;
    }
    options.positions = positions;
    options.width = width;
    options.height = Property.getValueOrUndefined(corridor.height, time);
    options.extrudedHeight = Property.getValueOrUndefined(corridor.extrudedHeight, time);
    options.granularity = Property.getValueOrUndefined(corridor.granularity, time);
    options.cornerType = Property.getValueOrUndefined(corridor.cornerType, time);
    if (!defined(corridor.fill) || corridor.fill.getValue(time)) {
        var material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, this._material);
        this._material = material;
        var appearance = new MaterialAppearance({
                material: material,
                translucent: material.isTranslucent(),
                closed: defined(options.extrudedHeight)
            });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new CorridorGeometry(options)
            }),
            appearance: appearance,
            asynchronous: false
        }));
    }
    if (defined(corridor.outline) && corridor.outline.getValue(time)) {
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        var outlineColor = Property.getValueOrClonedDefault(corridor.outlineColor, time, Color.BLACK, scratchColor);
        var outlineWidth = Property.getValueOrDefault(corridor.outlineWidth, 1);
        var translucent = outlineColor.alpha !== 1;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new CorridorOutlineGeometry(options),
                attributes: { color: ColorGeometryInstanceAttribute.fromColor(outlineColor) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: translucent,
                renderState: { lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    this._primitives.remove(this._primitive);
    this._primitives.remove(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = CorridorGeometryUpdater;
},{"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/CorridorGeometry":115,"../Core/CorridorOutlineGeometry":117,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],285:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), CylinderGeometry = require('../Core/CylinderGeometry'), CylinderOutlineGeometry = require('../Core/CylinderOutlineGeometry'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var scratchColor = new Color();
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.length = undefined;
    this.topRadius = undefined;
    this.bottomRadius = undefined;
    this.slices = undefined;
    this.numberOfVerticalLines = undefined;
};
var CylinderGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(CylinderGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'cylinder', entity.cylinder, undefined);
};
defineProperties(CylinderGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(CylinderGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: { value: true },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
CylinderGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
CylinderGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
CylinderGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new CylinderGeometry(this._options),
        modelMatrix: entity._getModelMatrix(Iso8601.MINIMUM_VALUE),
        attributes: attributes
    });
};
CylinderGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: new CylinderOutlineGeometry(this._options),
        modelMatrix: entity._getModelMatrix(Iso8601.MINIMUM_VALUE),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
CylinderGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
CylinderGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
CylinderGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'position' || propertyName === 'orientation' || propertyName === 'cylinder')) {
        return;
    }
    var cylinder = entity.cylinder;
    if (!defined(cylinder)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = cylinder.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = cylinder.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var position = entity.position;
    var length = cylinder.length;
    var topRadius = cylinder.topRadius;
    var bottomRadius = cylinder.bottomRadius;
    var show = cylinder.show;
    if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || (!defined(position) || !defined(length) || !defined(topRadius) || !defined(bottomRadius))) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(cylinder.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(cylinder.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(cylinder.outlineColor, defaultOutlineColor) : undefined;
    var slices = cylinder.slices;
    var outlineWidth = cylinder.outlineWidth;
    var numberOfVerticalLines = cylinder.numberOfVerticalLines;
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    if (!position.isConstant || !Property.isConstant(entity.orientation) || !length.isConstant || !topRadius.isConstant || !bottomRadius.isConstant || !Property.isConstant(slices) || !Property.isConstant(outlineWidth) || !Property.isConstant(numberOfVerticalLines)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.length = length.getValue(Iso8601.MINIMUM_VALUE);
        options.topRadius = topRadius.getValue(Iso8601.MINIMUM_VALUE);
        options.bottomRadius = bottomRadius.getValue(Iso8601.MINIMUM_VALUE);
        options.slices = defined(slices) ? slices.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.numberOfVerticalLines = defined(numberOfVerticalLines) ? numberOfVerticalLines.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
CylinderGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var primitives = this._primitives;
    primitives.removeAndDestroy(this._primitive);
    primitives.removeAndDestroy(this._outlinePrimitive);
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var cylinder = entity.cylinder;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(cylinder.show, time, true)) {
        return;
    }
    var options = this._options;
    var modelMatrix = entity._getModelMatrix(time);
    var length = Property.getValueOrUndefined(cylinder.length, time);
    var topRadius = Property.getValueOrUndefined(cylinder.topRadius, time);
    var bottomRadius = Property.getValueOrUndefined(cylinder.bottomRadius, time);
    if (!defined(modelMatrix) || !defined(length) || !defined(topRadius) || !defined(bottomRadius)) {
        return;
    }
    options.length = length;
    options.topRadius = topRadius;
    options.bottomRadius = bottomRadius;
    options.slices = Property.getValueOrUndefined(cylinder.slices, time);
    options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, time);
    if (Property.getValueOrDefault(cylinder.fill, time, true)) {
        var material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, this._material);
        this._material = material;
        var appearance = new MaterialAppearance({
                material: material,
                translucent: material.isTranslucent(),
                closed: true
            });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new CylinderGeometry(options),
                modelMatrix: modelMatrix
            }),
            appearance: appearance,
            asynchronous: false
        }));
    }
    if (Property.getValueOrDefault(cylinder.outline, time, false)) {
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        var outlineColor = Property.getValueOrClonedDefault(cylinder.outlineColor, time, Color.BLACK, scratchColor);
        var outlineWidth = Property.getValueOrDefault(cylinder.outlineWidth, 1);
        var translucent = outlineColor.alpha !== 1;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new CylinderOutlineGeometry(options),
                modelMatrix: modelMatrix,
                attributes: { color: ColorGeometryInstanceAttribute.fromColor(outlineColor) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: translucent,
                renderState: { lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    var primitives = this._primitives;
    primitives.removeAndDestroy(this._primitive);
    primitives.removeAndDestroy(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = CylinderGeometryUpdater;
},{"../Core/Cartesian3":102,"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/CylinderGeometry":120,"../Core/CylinderOutlineGeometry":122,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],286:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartographic = require('../Core/Cartographic'), ClockRange = require('../Core/ClockRange'), ClockStep = require('../Core/ClockStep'), Color = require('../Core/Color'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Ellipsoid = require('../Core/Ellipsoid'), Event = require('../Core/Event'), ExtrapolationType = require('../Core/ExtrapolationType'), getFilenameFromUri = require('../Core/getFilenameFromUri'), HermitePolynomialApproximation = require('../Core/HermitePolynomialApproximation'), isArray = require('../Core/isArray'), Iso8601 = require('../Core/Iso8601'), JulianDate = require('../Core/JulianDate'), LagrangePolynomialApproximation = require('../Core/LagrangePolynomialApproximation'), LinearApproximation = require('../Core/LinearApproximation'), loadJson = require('../Core/loadJson'), CesiumMath = require('../Core/Math'), Quaternion = require('../Core/Quaternion'), Rectangle = require('../Core/Rectangle'), ReferenceFrame = require('../Core/ReferenceFrame'), RuntimeError = require('../Core/RuntimeError'), Spherical = require('../Core/Spherical'), TimeInterval = require('../Core/TimeInterval'), TimeIntervalCollection = require('../Core/TimeIntervalCollection'), HorizontalOrigin = require('../Scene/HorizontalOrigin'), LabelStyle = require('../Scene/LabelStyle'), VerticalOrigin = require('../Scene/VerticalOrigin'), Uri = require('../ThirdParty/Uri'), when = require('../ThirdParty/when'), BillboardGraphics = require('./BillboardGraphics'), ColorMaterialProperty = require('./ColorMaterialProperty'), CompositeMaterialProperty = require('./CompositeMaterialProperty'), CompositePositionProperty = require('./CompositePositionProperty'), CompositeProperty = require('./CompositeProperty'), ConstantPositionProperty = require('./ConstantPositionProperty'), ConstantProperty = require('./ConstantProperty'), DataSource = require('./DataSource'), DataSourceClock = require('./DataSourceClock'), EllipseGraphics = require('./EllipseGraphics'), EllipsoidGraphics = require('./EllipsoidGraphics'), EntityCollection = require('./EntityCollection'), GridMaterialProperty = require('./GridMaterialProperty'), ImageMaterialProperty = require('./ImageMaterialProperty'), LabelGraphics = require('./LabelGraphics'), ModelGraphics = require('./ModelGraphics'), PathGraphics = require('./PathGraphics'), PointGraphics = require('./PointGraphics'), PolygonGraphics = require('./PolygonGraphics'), PolylineGlowMaterialProperty = require('./PolylineGlowMaterialProperty'), PolylineGraphics = require('./PolylineGraphics'), PolylineOutlineMaterialProperty = require('./PolylineOutlineMaterialProperty'), PositionPropertyArray = require('./PositionPropertyArray'), RectangleGraphics = require('./RectangleGraphics'), ReferenceProperty = require('./ReferenceProperty'), SampledPositionProperty = require('./SampledPositionProperty'), SampledProperty = require('./SampledProperty'), StripeMaterialProperty = require('./StripeMaterialProperty'), StripeOrientation = require('./StripeOrientation'), TimeIntervalCollectionPositionProperty = require('./TimeIntervalCollectionPositionProperty'), TimeIntervalCollectionProperty = require('./TimeIntervalCollectionProperty'), WallGraphics = require('./WallGraphics');
'use strict';
var currentId;
function makeReference(collection, referenceString) {
    if (referenceString[0] === '#') {
        referenceString = currentId + referenceString;
    }
    return ReferenceProperty.fromString(collection, referenceString);
}
var scratchCartesian = new Cartesian3();
var scratchSpherical = new Spherical();
var scratchCartographic = new Cartographic();
var scratchTimeInterval = new TimeInterval();
function unwrapColorInterval(czmlInterval) {
    var rgbaf = czmlInterval.rgbaf;
    if (defined(rgbaf)) {
        return rgbaf;
    }
    var rgba = czmlInterval.rgba;
    if (!defined(rgba)) {
        return undefined;
    }
    if (rgba.length === Color.length) {
        return [
            Color.byteToFloat(rgba[0]),
            Color.byteToFloat(rgba[1]),
            Color.byteToFloat(rgba[2]),
            Color.byteToFloat(rgba[3])
        ];
    }
    var len = rgba.length;
    rgbaf = new Array(len);
    for (var i = 0; i < len; i += 5) {
        rgbaf[i] = rgba[i];
        rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);
        rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);
        rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);
        rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);
    }
    return rgbaf;
}
function unwrapImageInterval(czmlInterval, sourceUri) {
    var result = defaultValue(czmlInterval.image, czmlInterval);
    if (defined(sourceUri)) {
        var baseUri = new Uri(document.location.href);
        sourceUri = new Uri(sourceUri);
        result = new Uri(result).resolve(sourceUri.resolve(baseUri)).toString();
    }
    return result;
}
function unwrapUriInterval(czmlInterval, sourceUri) {
    var result = defaultValue(czmlInterval.uri, czmlInterval);
    if (defined(sourceUri)) {
        var baseUri = new Uri(document.location.href);
        sourceUri = new Uri(sourceUri);
        result = new Uri(result).resolve(sourceUri.resolve(baseUri)).toString();
    }
    return result;
}
function unwrapRectangleInterval(czmlInterval) {
    var wsenDegrees = czmlInterval.wsenDegrees;
    if (defined(wsenDegrees)) {
        var length = wsenDegrees.length;
        for (var i = 0; i < length; i++) {
            wsenDegrees[i] = CesiumMath.toRadians(wsenDegrees[i]);
        }
        return wsenDegrees;
    }
    return czmlInterval.wsen;
}
function unwrapCartesianInterval(czmlInterval) {
    if (defined(czmlInterval.cartesian)) {
        return czmlInterval.cartesian;
    }
    if (defined(czmlInterval.cartesianVelocity)) {
        return czmlInterval.cartesianVelocity;
    }
    if (defined(czmlInterval.unitCartesian)) {
        return czmlInterval.unitCartesian;
    }
    var i;
    var len;
    var result;
    var unitSpherical = czmlInterval.unitSpherical;
    if (defined(unitSpherical)) {
        len = unitSpherical.length;
        if (len === 2) {
            scratchSpherical.clock = unitSpherical[0];
            scratchSpherical.cone = unitSpherical[1];
            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);
            result = [
                scratchCartesian.x,
                scratchCartesian.y,
                scratchCartesian.z
            ];
        } else {
            var sphericalIt = 0;
            result = new Array(len / 3 * 4);
            for (i = 0; i < len; i += 4) {
                result[i] = unitSpherical[sphericalIt++];
                scratchSpherical.clock = unitSpherical[sphericalIt++];
                scratchSpherical.cone = unitSpherical[sphericalIt++];
                Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);
                result[i + 1] = scratchCartesian.x;
                result[i + 2] = scratchCartesian.y;
                result[i + 3] = scratchCartesian.z;
            }
        }
        return result;
    }
    var cartographic = czmlInterval.cartographicRadians;
    if (defined(cartographic)) {
        if (cartographic.length === 3) {
            scratchCartographic.longitude = cartographic[0];
            scratchCartographic.latitude = cartographic[1];
            scratchCartographic.height = cartographic[2];
            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);
            result = [
                scratchCartesian.x,
                scratchCartesian.y,
                scratchCartesian.z
            ];
        } else {
            len = cartographic.length;
            result = new Array(len);
            for (i = 0; i < len; i += 4) {
                scratchCartographic.longitude = cartographic[i + 1];
                scratchCartographic.latitude = cartographic[i + 2];
                scratchCartographic.height = cartographic[i + 3];
                Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);
                result[i] = cartographic[i];
                result[i + 1] = scratchCartesian.x;
                result[i + 2] = scratchCartesian.y;
                result[i + 3] = scratchCartesian.z;
            }
        }
        return result;
    }
    var cartographicDegrees = czmlInterval.cartographicDegrees;
    if (!defined(cartographicDegrees)) {
        throw new RuntimeError(JSON.stringify(czmlInterval) + ' is not a valid CZML interval.');
    }
    if (cartographicDegrees.length === 3) {
        scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[0]);
        scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[1]);
        scratchCartographic.height = cartographicDegrees[2];
        Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);
        result = [
            scratchCartesian.x,
            scratchCartesian.y,
            scratchCartesian.z
        ];
    } else {
        len = cartographicDegrees.length;
        result = new Array(len);
        for (i = 0; i < len; i += 4) {
            scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[i + 1]);
            scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[i + 2]);
            scratchCartographic.height = cartographicDegrees[i + 3];
            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);
            result[i] = cartographicDegrees[i];
            result[i + 1] = scratchCartesian.x;
            result[i + 2] = scratchCartesian.y;
            result[i + 3] = scratchCartesian.z;
        }
    }
    return result;
}
function unwrapInterval(type, czmlInterval, sourceUri) {
    switch (type) {
    case Boolean:
        return defaultValue(czmlInterval['boolean'], czmlInterval);
    case Cartesian2:
        return czmlInterval.cartesian2;
    case Cartesian3:
        return unwrapCartesianInterval(czmlInterval);
    case Color:
        return unwrapColorInterval(czmlInterval);
    case StripeOrientation:
        return StripeOrientation[defaultValue(czmlInterval.stripeOrientation, czmlInterval)];
    case HorizontalOrigin:
        return HorizontalOrigin[defaultValue(czmlInterval.horizontalOrigin, czmlInterval)];
    case Image:
        return unwrapUriInterval(czmlInterval, sourceUri);
    case JulianDate:
        return JulianDate.fromIso8601(defaultValue(czmlInterval.date, czmlInterval));
    case LabelStyle:
        return LabelStyle[defaultValue(czmlInterval.labelStyle, czmlInterval)];
    case Number:
        return defaultValue(czmlInterval.number, czmlInterval);
    case String:
        return defaultValue(czmlInterval.string, czmlInterval);
    case Array:
        return czmlInterval.array;
    case Quaternion:
        return czmlInterval.unitQuaternion;
    case Rectangle:
        return unwrapRectangleInterval(czmlInterval);
    case Uri:
        return unwrapUriInterval(czmlInterval, sourceUri);
    case VerticalOrigin:
        return VerticalOrigin[defaultValue(czmlInterval.verticalOrigin, czmlInterval)];
    default:
        throw new DeveloperError(type);
    }
}
var interpolators = {
        HERMITE: HermitePolynomialApproximation,
        LAGRANGE: LagrangePolynomialApproximation,
        LINEAR: LinearApproximation
    };
function updateInterpolationSettings(packetData, property) {
    var interpolationAlgorithm = packetData.interpolationAlgorithm;
    if (defined(interpolationAlgorithm) || defined(packetData.interpolationDegree)) {
        property.setInterpolationOptions({
            interpolationAlgorithm: interpolators[interpolationAlgorithm],
            interpolationDegree: packetData.interpolationDegree
        });
    }
    var forwardExtrapolationType = packetData.forwardExtrapolationType;
    if (defined(forwardExtrapolationType)) {
        property.forwardExtrapolationType = ExtrapolationType[forwardExtrapolationType];
    }
    var forwardExtrapolationDuration = packetData.forwardExtrapolationDuration;
    if (defined(forwardExtrapolationDuration)) {
        property.forwardExtrapolationDuration = forwardExtrapolationDuration;
    }
    var backwardExtrapolationType = packetData.backwardExtrapolationType;
    if (defined(backwardExtrapolationType)) {
        property.backwardExtrapolationType = ExtrapolationType[backwardExtrapolationType];
    }
    var backwardExtrapolationDuration = packetData.backwardExtrapolationDuration;
    if (defined(backwardExtrapolationDuration)) {
        property.backwardExtrapolationDuration = backwardExtrapolationDuration;
    }
}
function processProperty(type, object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
    var combinedInterval;
    var packetInterval = packetData.interval;
    if (defined(packetInterval)) {
        iso8601Scratch.iso8601 = packetInterval;
        combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
        if (defined(constrainedInterval)) {
            combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
        }
    } else if (defined(constrainedInterval)) {
        combinedInterval = constrainedInterval;
    }
    var packedLength;
    var isSampled;
    var unwrappedInterval;
    var unwrappedIntervalLength;
    var isReference = defined(packetData.reference);
    var hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);
    if (!isReference) {
        unwrappedInterval = unwrapInterval(type, packetData, sourceUri);
        packedLength = defaultValue(type.packedLength, 1);
        unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);
        isSampled = !defined(packetData.array) && typeof unwrappedInterval !== 'string' && unwrappedIntervalLength > packedLength;
    }
    if (!isSampled && !hasInterval) {
        if (isReference) {
            object[propertyName] = makeReference(entityCollection, packetData.reference);
        } else if (defined(type.unpack)) {
            object[propertyName] = new ConstantProperty(type.unpack(unwrappedInterval, 0));
        } else {
            object[propertyName] = new ConstantProperty(unwrappedInterval);
        }
        return;
    }
    var property = object[propertyName];
    var epoch;
    var packetEpoch = packetData.epoch;
    if (defined(packetEpoch)) {
        epoch = JulianDate.fromIso8601(packetEpoch);
    }
    if (isSampled && !hasInterval) {
        if (!(property instanceof SampledProperty)) {
            property = new SampledProperty(type);
            object[propertyName] = property;
        }
        property.addSamplesPackedArray(unwrappedInterval, epoch);
        updateInterpolationSettings(packetData, property);
        return;
    }
    var interval;
    if (!isSampled && hasInterval) {
        combinedInterval = combinedInterval.clone();
        if (isReference) {
            combinedInterval.data = makeReference(entityCollection, packetData.reference);
        } else if (defined(type.unpack)) {
            combinedInterval.data = type.unpack(unwrappedInterval, 0);
        } else {
            combinedInterval.data = unwrappedInterval;
        }
        if (!defined(property)) {
            if (isReference) {
                property = new CompositeProperty();
            } else {
                property = new TimeIntervalCollectionProperty();
            }
            object[propertyName] = property;
        }
        if (!isReference && property instanceof TimeIntervalCollectionProperty) {
            property.intervals.addInterval(combinedInterval);
        } else if (property instanceof CompositeProperty) {
            combinedInterval.data = isReference ? combinedInterval.data : new ConstantProperty(combinedInterval.data);
            property.intervals.addInterval(combinedInterval);
        } else {
            interval = Iso8601.MAXIMUM_INTERVAL.clone();
            interval.data = property;
            property = new CompositeProperty();
            object[propertyName] = property;
            property.intervals.addInterval(interval);
            combinedInterval.data = isReference ? combinedInterval.data : new ConstantProperty(combinedInterval.data);
            property.intervals.addInterval(combinedInterval);
        }
        return;
    }
    if (!defined(property)) {
        property = new CompositeProperty();
        object[propertyName] = property;
    }
    if (!(property instanceof CompositeProperty)) {
        interval = Iso8601.MAXIMUM_INTERVAL.clone();
        interval.data = property;
        property = new CompositeProperty();
        object[propertyName] = property;
        property.intervals.addInterval(interval);
    }
    var intervals = property.intervals;
    interval = intervals.findInterval(combinedInterval);
    if (!defined(interval) || !(interval.data instanceof SampledProperty)) {
        interval = combinedInterval.clone();
        interval.data = new SampledProperty(type);
        intervals.addInterval(interval);
    }
    interval.data.addSamplesPackedArray(unwrappedInterval, epoch);
    updateInterpolationSettings(packetData, interval.data);
    return;
}
function processPacketData(type, object, propertyName, packetData, interval, sourceUri, entityCollection) {
    if (!defined(packetData)) {
        return;
    }
    if (isArray(packetData)) {
        for (var i = 0, len = packetData.length; i < len; i++) {
            processProperty(type, object, propertyName, packetData[i], interval, sourceUri, entityCollection);
        }
    } else {
        processProperty(type, object, propertyName, packetData, interval, sourceUri, entityCollection);
    }
}
function processPositionProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
    var combinedInterval;
    var packetInterval = packetData.interval;
    if (defined(packetInterval)) {
        iso8601Scratch.iso8601 = packetInterval;
        combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
        if (defined(constrainedInterval)) {
            combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
        }
    } else if (defined(constrainedInterval)) {
        combinedInterval = constrainedInterval;
    }
    var referenceFrame;
    var unwrappedInterval;
    var isSampled = false;
    var unwrappedIntervalLength;
    var numberOfDerivatives = defined(packetData.cartesianVelocity) ? 1 : 0;
    var packedLength = Cartesian3.packedLength * (numberOfDerivatives + 1);
    var isReference = defined(packetData.reference);
    var hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);
    if (!isReference) {
        referenceFrame = defaultValue(ReferenceFrame[packetData.referenceFrame], undefined);
        unwrappedInterval = unwrapCartesianInterval(packetData);
        unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);
        isSampled = unwrappedIntervalLength > packedLength;
    }
    if (!isSampled && !hasInterval) {
        if (isReference) {
            object[propertyName] = makeReference(entityCollection, packetData.reference);
        } else {
            object[propertyName] = new ConstantPositionProperty(Cartesian3.unpack(unwrappedInterval), referenceFrame);
        }
        return;
    }
    var property = object[propertyName];
    var epoch;
    var packetEpoch = packetData.epoch;
    if (defined(packetEpoch)) {
        epoch = JulianDate.fromIso8601(packetEpoch);
    }
    if (isSampled && !hasInterval) {
        if (!(property instanceof SampledPositionProperty) || defined(referenceFrame) && property.referenceFrame !== referenceFrame) {
            property = new SampledPositionProperty(referenceFrame, numberOfDerivatives);
            object[propertyName] = property;
        }
        property.addSamplesPackedArray(unwrappedInterval, epoch);
        updateInterpolationSettings(packetData, property);
        return;
    }
    var interval;
    if (!isSampled && hasInterval) {
        combinedInterval = combinedInterval.clone();
        if (isReference) {
            combinedInterval.data = makeReference(entityCollection, packetData.reference);
        } else {
            combinedInterval.data = Cartesian3.unpack(unwrappedInterval);
        }
        if (!defined(property)) {
            if (isReference) {
                property = new CompositePositionProperty(referenceFrame);
            } else {
                property = new TimeIntervalCollectionPositionProperty(referenceFrame);
            }
            object[propertyName] = property;
        }
        if (!isReference && property instanceof TimeIntervalCollectionPositionProperty && (defined(referenceFrame) && property.referenceFrame === referenceFrame)) {
            property.intervals.addInterval(combinedInterval);
        } else if (property instanceof CompositePositionProperty) {
            combinedInterval.data = isReference ? combinedInterval.data : new ConstantPositionProperty(combinedInterval.data, referenceFrame);
            property.intervals.addInterval(combinedInterval);
        } else {
            interval = Iso8601.MAXIMUM_INTERVAL.clone();
            interval.data = property;
            property = new CompositePositionProperty(property.referenceFrame);
            object[propertyName] = property;
            property.intervals.addInterval(interval);
            combinedInterval.data = isReference ? combinedInterval.data : new ConstantPositionProperty(combinedInterval.data, referenceFrame);
            property.intervals.addInterval(combinedInterval);
        }
        return;
    }
    if (!defined(property)) {
        property = new CompositePositionProperty(referenceFrame);
        object[propertyName] = property;
    } else if (!(property instanceof CompositePositionProperty)) {
        interval = Iso8601.MAXIMUM_INTERVAL.clone();
        interval.data = property;
        property = new CompositePositionProperty(property.referenceFrame);
        object[propertyName] = property;
        property.intervals.addInterval(interval);
    }
    var intervals = property.intervals;
    interval = intervals.findInterval(combinedInterval);
    if (!defined(interval) || !(interval.data instanceof SampledPositionProperty) || defined(referenceFrame) && interval.data.referenceFrame !== referenceFrame) {
        interval = combinedInterval.clone();
        interval.data = new SampledPositionProperty(referenceFrame, numberOfDerivatives);
        intervals.addInterval(interval);
    }
    interval.data.addSamplesPackedArray(unwrappedInterval, epoch);
    updateInterpolationSettings(packetData, interval.data);
}
function processPositionPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {
    if (!defined(packetData)) {
        return;
    }
    if (isArray(packetData)) {
        for (var i = 0, len = packetData.length; i < len; i++) {
            processPositionProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);
        }
    } else {
        processPositionProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);
    }
}
function processMaterialProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {
    var combinedInterval;
    var packetInterval = packetData.interval;
    if (defined(packetInterval)) {
        iso8601Scratch.iso8601 = packetInterval;
        combinedInterval = TimeInterval.fromIso8601(iso8601Scratch);
        if (defined(constrainedInterval)) {
            combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);
        }
    } else if (defined(constrainedInterval)) {
        combinedInterval = constrainedInterval;
    }
    var property = object[propertyName];
    var existingMaterial;
    var existingInterval;
    if (defined(combinedInterval)) {
        if (!(property instanceof CompositeMaterialProperty)) {
            property = new CompositeMaterialProperty();
            object[propertyName] = property;
        }
        var thisIntervals = property.intervals;
        existingInterval = thisIntervals.findInterval({
            start: combinedInterval.start,
            stop: combinedInterval.stop
        });
        if (defined(existingInterval)) {
            existingMaterial = existingInterval.data;
        } else {
            existingInterval = combinedInterval.clone();
            thisIntervals.addInterval(existingInterval);
        }
    } else {
        existingMaterial = property;
    }
    var materialData;
    if (defined(packetData.solidColor)) {
        if (!(existingMaterial instanceof ColorMaterialProperty)) {
            existingMaterial = new ColorMaterialProperty();
        }
        materialData = packetData.solidColor;
        processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, undefined, entityCollection);
    } else if (defined(packetData.grid)) {
        if (!(existingMaterial instanceof GridMaterialProperty)) {
            existingMaterial = new GridMaterialProperty();
        }
        materialData = packetData.grid;
        processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
        processPacketData(Number, existingMaterial, 'cellAlpha', materialData.cellAlpha, undefined, sourceUri, entityCollection);
        processPacketData(Cartesian2, existingMaterial, 'lineThickness', materialData.lineThickness, undefined, sourceUri, entityCollection);
        processPacketData(Cartesian2, existingMaterial, 'lineOffset', materialData.lineOffset, undefined, sourceUri, entityCollection);
        processPacketData(Cartesian2, existingMaterial, 'lineCount', materialData.lineCount, undefined, sourceUri, entityCollection);
    } else if (defined(packetData.image)) {
        if (!(existingMaterial instanceof ImageMaterialProperty)) {
            existingMaterial = new ImageMaterialProperty();
        }
        materialData = packetData.image;
        processPacketData(Image, existingMaterial, 'image', materialData.image, undefined, sourceUri, entityCollection);
        processPacketData(Cartesian2, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);
    } else if (defined(packetData.stripe)) {
        if (!(existingMaterial instanceof StripeMaterialProperty)) {
            existingMaterial = new StripeMaterialProperty();
        }
        materialData = packetData.stripe;
        processPacketData(StripeOrientation, existingMaterial, 'orientation', materialData.orientation, undefined, sourceUri, entityCollection);
        processPacketData(Color, existingMaterial, 'evenColor', materialData.evenColor, undefined, sourceUri, entityCollection);
        processPacketData(Color, existingMaterial, 'oddColor', materialData.oddColor, undefined, sourceUri, entityCollection);
        processPacketData(Number, existingMaterial, 'offset', materialData.offset, undefined, sourceUri, entityCollection);
        processPacketData(Number, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);
    } else if (defined(packetData.polylineOutline)) {
        if (!(existingMaterial instanceof PolylineOutlineMaterialProperty)) {
            existingMaterial = new PolylineOutlineMaterialProperty();
        }
        materialData = packetData.polylineOutline;
        processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
        processPacketData(Color, existingMaterial, 'outlineColor', materialData.outlineColor, undefined, sourceUri, entityCollection);
        processPacketData(Number, existingMaterial, 'outlineWidth', materialData.outlineWidth, undefined, sourceUri, entityCollection);
    } else if (defined(packetData.polylineGlow)) {
        if (!(existingMaterial instanceof PolylineGlowMaterialProperty)) {
            existingMaterial = new PolylineGlowMaterialProperty();
        }
        materialData = packetData.polylineGlow;
        processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);
        processPacketData(Number, existingMaterial, 'glowPower', materialData.glowPower, undefined, sourceUri, entityCollection);
    }
    if (defined(existingInterval)) {
        existingInterval.data = existingMaterial;
    } else {
        object[propertyName] = existingMaterial;
    }
}
function processMaterialPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {
    if (!defined(packetData)) {
        return;
    }
    if (isArray(packetData)) {
        for (var i = 0, len = packetData.length; i < len; i++) {
            processMaterialProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);
        }
    } else {
        processMaterialProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);
    }
}
function processName(entity, packet, entityCollection, sourceUri) {
    entity.name = defaultValue(packet.name, entity.name);
}
function processDescription(entity, packet, entityCollection, sourceUri) {
    var descriptionData = packet.description;
    if (defined(descriptionData)) {
        processPacketData(String, entity, 'description', descriptionData, undefined, sourceUri, entityCollection);
    }
}
function processPosition(entity, packet, entityCollection, sourceUri) {
    var positionData = packet.position;
    if (defined(positionData)) {
        processPositionPacketData(entity, 'position', positionData, undefined, sourceUri, entityCollection);
    }
}
function processViewFrom(entity, packet, entityCollection, sourceUri) {
    var viewFromData = packet.viewFrom;
    if (defined(viewFromData)) {
        processPacketData(Cartesian3, entity, 'viewFrom', viewFromData, undefined, sourceUri, entityCollection);
    }
}
function processOrientation(entity, packet, entityCollection, sourceUri) {
    var orientationData = packet.orientation;
    if (defined(orientationData)) {
        processPacketData(Quaternion, entity, 'orientation', orientationData, undefined, sourceUri, entityCollection);
    }
}
function processVertexData(object, propertyName, positionsData, entityCollection) {
    var i;
    var len;
    var references = positionsData.references;
    if (defined(references)) {
        var properties = [];
        for (i = 0, len = references.length; i < len; i++) {
            properties.push(makeReference(entityCollection, references[i]));
        }
        var iso8601Interval = positionsData.interval;
        if (defined(iso8601Interval)) {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
            if (!(object[propertyName] instanceof CompositePositionProperty)) {
                iso8601Interval.data = new PositionPropertyArray(properties);
                var property = new CompositePositionProperty();
                property.intervals.addInterval(iso8601Interval);
                object[propertyName] = property;
            }
        } else {
            object[propertyName] = new PositionPropertyArray(properties);
        }
    } else {
        var values = [];
        var tmp = positionsData.cartesian;
        if (defined(tmp)) {
            for (i = 0, len = tmp.length; i < len; i += 3) {
                values.push(new Cartesian3(tmp[i], tmp[i + 1], tmp[i + 2]));
            }
            positionsData.array = values;
        } else {
            tmp = positionsData.cartographicRadians;
            if (defined(tmp)) {
                for (i = 0, len = tmp.length; i < len; i += 3) {
                    scratchCartographic.longitude = tmp[i];
                    scratchCartographic.latitude = tmp[i + 1];
                    scratchCartographic.height = tmp[i + 2];
                    values.push(Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic));
                }
                positionsData.array = values;
            } else {
                tmp = positionsData.cartographicDegrees;
                if (defined(tmp)) {
                    for (i = 0, len = tmp.length; i < len; i += 3) {
                        values.push(Cartesian3.fromDegrees(tmp[i], tmp[i + 1], tmp[i + 2]));
                    }
                    positionsData.array = values;
                }
            }
        }
        if (defined(positionsData.array)) {
            processPacketData(Array, object, propertyName, positionsData, undefined, undefined, entityCollection);
        }
    }
}
function processPositions(object, propertyName, positionsData, entityCollection) {
    if (!defined(positionsData)) {
        return;
    }
    if (isArray(positionsData)) {
        var length = positionsData.length;
        for (var i = 0; i < length; i++) {
            processVertexData(object, propertyName, positionsData[i], entityCollection);
        }
    } else {
        processVertexData(object, propertyName, positionsData, entityCollection);
    }
}
function processAvailability(entity, packet, entityCollection, sourceUri) {
    var interval;
    var packetData = packet.availability;
    if (!defined(packetData)) {
        return;
    }
    var intervals;
    if (isArray(packetData)) {
        var length = packetData.length;
        for (var i = 0; i < length; i++) {
            if (!defined(intervals)) {
                intervals = new TimeIntervalCollection();
            }
            iso8601Scratch.iso8601 = packetData[i];
            interval = TimeInterval.fromIso8601(iso8601Scratch);
            intervals.addInterval(interval);
        }
    } else {
        iso8601Scratch.iso8601 = packetData;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
        intervals = new TimeIntervalCollection();
        intervals.addInterval(interval);
    }
    entity.availability = intervals;
}
var iso8601Scratch = { iso8601: undefined };
function processBillboard(entity, packet, entityCollection, sourceUri) {
    var billboardData = packet.billboard;
    if (!defined(billboardData)) {
        return;
    }
    var interval;
    var intervalString = billboardData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var billboard = entity.billboard;
    if (!defined(billboard)) {
        entity.billboard = billboard = new BillboardGraphics();
    }
    processPacketData(Color, billboard, 'color', billboardData.color, interval, sourceUri, entityCollection);
    processPacketData(Cartesian3, billboard, 'eyeOffset', billboardData.eyeOffset, interval, sourceUri, entityCollection);
    processPacketData(HorizontalOrigin, billboard, 'horizontalOrigin', billboardData.horizontalOrigin, interval, sourceUri, entityCollection);
    processPacketData(Image, billboard, 'image', billboardData.image, interval, sourceUri, entityCollection);
    processPacketData(Cartesian2, billboard, 'pixelOffset', billboardData.pixelOffset, interval, sourceUri, entityCollection);
    processPacketData(Number, billboard, 'scale', billboardData.scale, interval, sourceUri, entityCollection);
    processPacketData(Number, billboard, 'rotation', billboardData.rotation, interval, sourceUri, entityCollection);
    processPacketData(Cartesian3, billboard, 'alignedAxis', billboardData.alignedAxis, interval, sourceUri, entityCollection);
    processPacketData(Boolean, billboard, 'show', billboardData.show, interval, sourceUri, entityCollection);
    processPacketData(VerticalOrigin, billboard, 'verticalOrigin', billboardData.verticalOrigin, interval, sourceUri, entityCollection);
}
function processDocument(packet, dataSource) {
    var version = packet.version;
    if (defined(version)) {
        if (typeof version === 'string') {
            var tokens = version.split('.');
            if (tokens.length === 2) {
                if (tokens[0] !== '1') {
                    throw new RuntimeError('Cesium only supports CZML version 1.');
                }
                dataSource._version = version;
            }
        }
    }
    if (!defined(dataSource._version)) {
        throw new RuntimeError('CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format.');
    }
    var documentPacket = dataSource._documentPacket;
    if (defined(packet.name)) {
        documentPacket.name = packet.name;
    }
    var clockPacket = packet.clock;
    if (defined(clockPacket)) {
        var clock = documentPacket.clock;
        if (!defined(clock)) {
            documentPacket.clock = {
                interval: clockPacket.interval,
                currentTime: clockPacket.currentTime,
                range: clockPacket.range,
                step: clockPacket.step,
                multiplier: clockPacket.multiplier
            };
        } else {
            clock.interval = defaultValue(clockPacket.interval, clock.interval);
            clock.currentTime = defaultValue(clockPacket.currentTime, clock.currentTime);
            clock.range = defaultValue(clockPacket.range, clock.range);
            clock.step = defaultValue(clockPacket.step, clock.step);
            clock.multiplier = defaultValue(clockPacket.multiplier, clock.multiplier);
        }
    }
}
function processEllipse(entity, packet, entityCollection, sourceUri) {
    var ellipseData = packet.ellipse;
    if (!defined(ellipseData)) {
        return;
    }
    var interval;
    var intervalString = ellipseData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var ellipse = entity.ellipse;
    if (!defined(ellipse)) {
        entity.ellipse = ellipse = new EllipseGraphics();
    }
    processPacketData(Boolean, ellipse, 'show', ellipseData.show, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'rotation', ellipseData.rotation, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'semiMajorAxis', ellipseData.semiMajorAxis, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'semiMinorAxis', ellipseData.semiMinorAxis, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'height', ellipseData.height, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'extrudedHeight', ellipseData.extrudedHeight, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'granularity', ellipseData.granularity, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'stRotation', ellipseData.stRotation, interval, sourceUri, entityCollection);
    processMaterialPacketData(ellipse, 'material', ellipseData.material, interval, sourceUri, entityCollection);
    processPacketData(Boolean, ellipse, 'fill', ellipseData.fill, interval, sourceUri, entityCollection);
    processPacketData(Boolean, ellipse, 'outline', ellipseData.outline, interval, sourceUri, entityCollection);
    processPacketData(Color, ellipse, 'outlineColor', ellipseData.outlineColor, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'outlineWidth', ellipseData.outlineWidth, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipse, 'numberOfVerticalLines', ellipseData.numberOfVerticalLines, interval, sourceUri, entityCollection);
}
function processEllipsoid(entity, packet, entityCollection, sourceUri) {
    var ellipsoidData = packet.ellipsoid;
    if (!defined(ellipsoidData)) {
        return;
    }
    var interval;
    var intervalString = ellipsoidData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var ellipsoid = entity.ellipsoid;
    if (!defined(ellipsoid)) {
        entity.ellipsoid = ellipsoid = new EllipsoidGraphics();
    }
    processPacketData(Boolean, ellipsoid, 'show', ellipsoidData.show, interval, sourceUri, entityCollection);
    processPacketData(Cartesian3, ellipsoid, 'radii', ellipsoidData.radii, interval, sourceUri, entityCollection);
    processMaterialPacketData(ellipsoid, 'material', ellipsoidData.material, interval, sourceUri, entityCollection);
    processPacketData(Boolean, ellipsoid, 'fill', ellipsoidData.fill, interval, sourceUri, entityCollection);
    processPacketData(Boolean, ellipsoid, 'outline', ellipsoidData.outline, interval, sourceUri, entityCollection);
    processPacketData(Color, ellipsoid, 'outlineColor', ellipsoidData.outlineColor, interval, sourceUri, entityCollection);
    processPacketData(Number, ellipsoid, 'outlineWidth', ellipsoidData.outlineWidth, interval, sourceUri, entityCollection);
}
function processLabel(entity, packet, entityCollection, sourceUri) {
    var labelData = packet.label;
    if (!defined(labelData)) {
        return;
    }
    var interval;
    var intervalString = labelData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var label = entity.label;
    if (!defined(label)) {
        entity.label = label = new LabelGraphics();
    }
    processPacketData(Color, label, 'fillColor', labelData.fillColor, interval, sourceUri, entityCollection);
    processPacketData(Color, label, 'outlineColor', labelData.outlineColor, interval, sourceUri, entityCollection);
    processPacketData(Number, label, 'outlineWidth', labelData.outlineWidth, interval, sourceUri, entityCollection);
    processPacketData(Cartesian3, label, 'eyeOffset', labelData.eyeOffset, interval, sourceUri, entityCollection);
    processPacketData(HorizontalOrigin, label, 'horizontalOrigin', labelData.horizontalOrigin, interval, sourceUri, entityCollection);
    processPacketData(String, label, 'text', labelData.text, interval, sourceUri, entityCollection);
    processPacketData(Cartesian2, label, 'pixelOffset', labelData.pixelOffset, interval, sourceUri, entityCollection);
    processPacketData(Number, label, 'scale', labelData.scale, interval, sourceUri, entityCollection);
    processPacketData(Boolean, label, 'show', labelData.show, interval, sourceUri, entityCollection);
    processPacketData(VerticalOrigin, label, 'verticalOrigin', labelData.verticalOrigin, interval, sourceUri, entityCollection);
    processPacketData(String, label, 'font', labelData.font, interval, sourceUri, entityCollection);
    processPacketData(LabelStyle, label, 'style', labelData.style, interval, sourceUri, entityCollection);
}
function processModel(entity, packet, entityCollection, sourceUri) {
    var modelData = packet.model;
    if (!defined(modelData)) {
        return;
    }
    var interval;
    var intervalString = modelData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var model = entity.model;
    if (!defined(model)) {
        entity.model = model = new ModelGraphics();
    }
    processPacketData(Boolean, model, 'show', modelData.show, interval, sourceUri, entityCollection);
    processPacketData(Number, model, 'scale', modelData.scale, interval, sourceUri, entityCollection);
    processPacketData(Number, model, 'minimumPixelSize', modelData.minimumPixelSize, interval, sourceUri, entityCollection);
    processPacketData(Uri, model, 'uri', modelData.gltf, interval, sourceUri, entityCollection);
}
function processPath(entity, packet, entityCollection, sourceUri) {
    var pathData = packet.path;
    if (!defined(pathData)) {
        return;
    }
    var interval;
    var intervalString = pathData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var path = entity.path;
    if (!defined(path)) {
        entity.path = path = new PathGraphics();
    }
    processPacketData(Boolean, path, 'show', pathData.show, interval, sourceUri, entityCollection);
    processPacketData(Number, path, 'width', pathData.width, interval, sourceUri, entityCollection);
    processPacketData(Number, path, 'resolution', pathData.resolution, interval, sourceUri, entityCollection);
    processPacketData(Number, path, 'leadTime', pathData.leadTime, interval, sourceUri, entityCollection);
    processPacketData(Number, path, 'trailTime', pathData.trailTime, interval, sourceUri, entityCollection);
    processMaterialPacketData(path, 'material', pathData.material, interval, sourceUri, entityCollection);
}
function processPoint(entity, packet, entityCollection, sourceUri) {
    var pointData = packet.point;
    if (!defined(pointData)) {
        return;
    }
    var interval;
    var intervalString = pointData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var point = entity.point;
    if (!defined(point)) {
        entity.point = point = new PointGraphics();
    }
    processPacketData(Color, point, 'color', pointData.color, interval, sourceUri, entityCollection);
    processPacketData(Number, point, 'pixelSize', pointData.pixelSize, interval, sourceUri, entityCollection);
    processPacketData(Color, point, 'outlineColor', pointData.outlineColor, interval, sourceUri, entityCollection);
    processPacketData(Number, point, 'outlineWidth', pointData.outlineWidth, interval, sourceUri, entityCollection);
    processPacketData(Boolean, point, 'show', pointData.show, interval, sourceUri, entityCollection);
}
function processPolygon(entity, packet, entityCollection, sourceUri) {
    var polygonData = packet.polygon;
    if (!defined(polygonData)) {
        return;
    }
    var interval;
    var intervalString = polygonData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var polygon = entity.polygon;
    if (!defined(polygon)) {
        entity.polygon = polygon = new PolygonGraphics();
    }
    processPacketData(Boolean, polygon, 'show', polygonData.show, interval, sourceUri, entityCollection);
    processMaterialPacketData(polygon, 'material', polygonData.material, interval, sourceUri, entityCollection);
    processPacketData(Number, polygon, 'height', polygonData.height, interval, sourceUri, entityCollection);
    processPacketData(Number, polygon, 'extrudedHeight', polygonData.extrudedHeight, interval, sourceUri, entityCollection);
    processPacketData(Number, polygon, 'granularity', polygonData.granularity, interval, sourceUri, entityCollection);
    processPacketData(Number, polygon, 'stRotation', polygonData.stRotation, interval, sourceUri, entityCollection);
    processPacketData(Boolean, polygon, 'fill', polygonData.fill, interval, sourceUri, entityCollection);
    processPacketData(Boolean, polygon, 'outline', polygonData.outline, interval, sourceUri, entityCollection);
    processPacketData(Color, polygon, 'outlineColor', polygonData.outlineColor, interval, sourceUri, entityCollection);
    processPacketData(Number, polygon, 'outlineWidth', polygonData.outlineWidth, interval, sourceUri, entityCollection);
    processPacketData(Boolean, polygon, 'perPositionHeight', polygonData.perPositionHeight, interval, sourceUri, entityCollection);
    processPositions(polygon, 'hierarchy', polygonData.positions, entityCollection);
}
function processRectangle(entity, packet, entityCollection, sourceUri) {
    var rectangleData = packet.rectangle;
    if (!defined(rectangleData)) {
        return;
    }
    var interval;
    var intervalString = rectangleData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var rectangle = entity.rectangle;
    if (!defined(rectangle)) {
        entity.rectangle = rectangle = new RectangleGraphics();
    }
    processPacketData(Boolean, rectangle, 'show', rectangleData.show, interval, sourceUri, entityCollection);
    processPacketData(Rectangle, rectangle, 'coordinates', rectangleData.coordinates, interval, sourceUri, entityCollection);
    processMaterialPacketData(rectangle, 'material', rectangleData.material, interval, sourceUri, entityCollection);
    processPacketData(Number, rectangle, 'height', rectangleData.height, interval, sourceUri, entityCollection);
    processPacketData(Number, rectangle, 'extrudedHeight', rectangleData.extrudedHeight, interval, sourceUri, entityCollection);
    processPacketData(Number, rectangle, 'granularity', rectangleData.granularity, interval, sourceUri, entityCollection);
    processPacketData(Number, rectangle, 'rotation', rectangleData.rotation, interval, sourceUri, entityCollection);
    processPacketData(Number, rectangle, 'stRotation', rectangleData.stRotation, interval, sourceUri, entityCollection);
    processPacketData(Boolean, rectangle, 'fill', rectangleData.fill, interval, sourceUri, entityCollection);
    processPacketData(Boolean, rectangle, 'outline', rectangleData.outline, interval, sourceUri, entityCollection);
    processPacketData(Color, rectangle, 'outlineColor', rectangleData.outlineColor, interval, sourceUri, entityCollection);
    processPacketData(Number, rectangle, 'outlineWidth', rectangleData.outlineWidth, interval, sourceUri, entityCollection);
    processPacketData(Boolean, rectangle, 'closeBottom', rectangleData.closeBottom, interval, sourceUri, entityCollection);
    processPacketData(Boolean, rectangle, 'closeTop', rectangleData.closeTop, interval, sourceUri, entityCollection);
}
function processWall(entity, packet, entityCollection, sourceUri) {
    var wallData = packet.wall;
    if (!defined(wallData)) {
        return;
    }
    var interval;
    var intervalString = wallData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var wall = entity.wall;
    if (!defined(wall)) {
        entity.wall = wall = new WallGraphics();
    }
    processPacketData(Boolean, wall, 'show', wallData.show, interval, sourceUri, entityCollection);
    processMaterialPacketData(wall, 'material', wallData.material, interval, sourceUri, entityCollection);
    processPacketData(Array, wall, 'minimumHeights', wallData.minimumHeights, interval, sourceUri, entityCollection);
    processPacketData(Array, wall, 'maximumHeights', wallData.maximumHeights, interval, sourceUri, entityCollection);
    processPacketData(Number, wall, 'granularity', wallData.granularity, interval, sourceUri, entityCollection);
    processPacketData(Boolean, wall, 'fill', wallData.fill, interval, sourceUri, entityCollection);
    processPacketData(Boolean, wall, 'outline', wallData.outline, interval, sourceUri, entityCollection);
    processPacketData(Color, wall, 'outlineColor', wallData.outlineColor, interval, sourceUri, entityCollection);
    processPacketData(Number, wall, 'outlineWidth', wallData.outlineWidth, interval, sourceUri, entityCollection);
    processPositions(wall, 'positions', wallData.positions, entityCollection);
}
function processPolyline(entity, packet, entityCollection, sourceUri) {
    var polylineData = packet.polyline;
    if (!defined(polylineData)) {
        return;
    }
    var interval;
    var intervalString = polylineData.interval;
    if (defined(intervalString)) {
        iso8601Scratch.iso8601 = intervalString;
        interval = TimeInterval.fromIso8601(iso8601Scratch);
    }
    var polyline = entity.polyline;
    if (!defined(polyline)) {
        entity.polyline = polyline = new PolylineGraphics();
    }
    processPacketData(Boolean, polyline, 'show', polylineData.show, interval, sourceUri, entityCollection);
    processPacketData(Number, polyline, 'width', polylineData.width, interval, sourceUri, entityCollection);
    processMaterialPacketData(polyline, 'material', polylineData.material, interval, sourceUri, entityCollection);
    processPacketData(Boolean, polyline, 'followSurface', polylineData.followSurface, interval, sourceUri, entityCollection);
    processPacketData(Number, polyline, 'granularity', polylineData.granularity, interval, sourceUri, entityCollection);
    processPositions(polyline, 'positions', polylineData.positions, entityCollection);
}
function processCzmlPacket(packet, entityCollection, updaterFunctions, sourceUri, dataSource) {
    var objectId = packet.id;
    if (!defined(objectId)) {
        objectId = createGuid();
    }
    currentId = objectId;
    if (!defined(dataSource._version) && objectId !== 'document') {
        throw new RuntimeError('The first CZML packet is required to be the document object.');
    }
    if (packet['delete'] === true) {
        entityCollection.removeById(objectId);
    } else if (objectId === 'document') {
        processDocument(packet, dataSource);
    } else {
        var entity = entityCollection.getOrCreateEntity(objectId);
        var parentId = packet.parent;
        if (defined(parentId)) {
            entity.parent = entityCollection.getOrCreateEntity(parentId);
        }
        for (var i = updaterFunctions.length - 1; i > -1; i--) {
            updaterFunctions[i](entity, packet, entityCollection, sourceUri);
        }
    }
    currentId = undefined;
}
function updateClock(dataSource) {
    var clock;
    var clockPacket = dataSource._documentPacket.clock;
    if (!defined(clockPacket)) {
        if (!defined(dataSource._clock)) {
            var availability = dataSource._entityCollection.computeAvailability();
            if (!availability.start.equals(Iso8601.MINIMUM_VALUE)) {
                var startTime = availability.start;
                var stopTime = availability.stop;
                var totalSeconds = JulianDate.secondsDifference(stopTime, startTime);
                var multiplier = Math.round(totalSeconds / 120);
                clock = new DataSourceClock();
                clock.startTime = JulianDate.clone(startTime);
                clock.stopTime = JulianDate.clone(stopTime);
                clock.clockRange = ClockRange.LOOP_STOP;
                clock.multiplier = multiplier;
                clock.currentTime = JulianDate.clone(startTime);
                clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
                dataSource._clock = clock;
                return true;
            }
        }
        return false;
    }
    if (defined(dataSource._clock)) {
        clock = dataSource._clock.clone();
    } else {
        clock = new DataSourceClock();
        clock.startTime = Iso8601.MINIMUM_VALUE.clone();
        clock.stopTime = Iso8601.MAXIMUM_VALUE.clone();
        clock.currentTime = Iso8601.MINIMUM_VALUE.clone();
        clock.clockRange = ClockRange.LOOP_STOP;
        clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
        clock.multiplier = 1;
    }
    if (defined(clockPacket.interval)) {
        iso8601Scratch.iso8601 = clockPacket.interval;
        var interval = TimeInterval.fromIso8601(iso8601Scratch);
        clock.startTime = interval.start;
        clock.stopTime = interval.stop;
    }
    if (defined(clockPacket.currentTime)) {
        clock.currentTime = JulianDate.fromIso8601(clockPacket.currentTime);
    }
    if (defined(clockPacket.range)) {
        clock.clockRange = defaultValue(ClockRange[clockPacket.range], ClockRange.LOOP_STOP);
    }
    if (defined(clockPacket.step)) {
        clock.clockStep = defaultValue(ClockStep[clockPacket.step], ClockStep.SYSTEM_CLOCK_MULTIPLIER);
    }
    if (defined(clockPacket.multiplier)) {
        clock.multiplier = clockPacket.multiplier;
    }
    if (!clock.equals(dataSource._clock)) {
        dataSource._clock = clock.clone(dataSource._clock);
        return true;
    }
    return false;
}
function loadCzml(dataSource, czml, sourceUri, clear) {
    DataSource.setLoading(dataSource, true);
    var entityCollection = dataSource._entityCollection;
    if (clear) {
        dataSource._version = undefined;
        dataSource._documentPacket = new DocumentPacket();
        entityCollection.removeAll();
    }
    CzmlDataSource._processCzml(czml, entityCollection, sourceUri, undefined, dataSource);
    var raiseChangedEvent = updateClock(dataSource);
    var documentPacket = dataSource._documentPacket;
    if (defined(documentPacket.name) && dataSource._name !== documentPacket.name) {
        dataSource._name = documentPacket.name;
        raiseChangedEvent = true;
    } else if (!defined(dataSource._name) && defined(sourceUri)) {
        dataSource._name = getFilenameFromUri(sourceUri);
        raiseChangedEvent = true;
    }
    DataSource.setLoading(dataSource, false);
    if (raiseChangedEvent) {
        dataSource._changed.raiseEvent(dataSource);
    }
}
var DocumentPacket = function () {
    this.name = undefined;
    this.clock = undefined;
};
var CzmlDataSource = function (name) {
    this._name = name;
    this._changed = new Event();
    this._error = new Event();
    this._isLoading = false;
    this._loading = new Event();
    this._clock = undefined;
    this._documentPacket = new DocumentPacket();
    this._version = undefined;
    this._entityCollection = new EntityCollection();
};
defineProperties(CzmlDataSource.prototype, {
    name: {
        get: function () {
            return this._name;
        }
    },
    clock: {
        get: function () {
            return this._clock;
        }
    },
    entities: {
        get: function () {
            return this._entityCollection;
        }
    },
    isLoading: {
        get: function () {
            return this._isLoading;
        }
    },
    changedEvent: {
        get: function () {
            return this._changed;
        }
    },
    errorEvent: {
        get: function () {
            return this._error;
        }
    },
    loadingEvent: {
        get: function () {
            return this._loading;
        }
    }
});
CzmlDataSource.updaters = [
    processBillboard,
    processEllipse,
    processEllipsoid,
    processLabel,
    processModel,
    processName,
    processDescription,
    processPath,
    processPoint,
    processPolygon,
    processPolyline,
    processRectangle,
    processPosition,
    processViewFrom,
    processWall,
    processOrientation,
    processAvailability
];
CzmlDataSource.prototype.process = function (czml, sourceUri) {
    if (!defined(czml)) {
        throw new DeveloperError('czml is required.');
    }
    loadCzml(this, czml, sourceUri, false);
};
CzmlDataSource.prototype.load = function (czml, sourceUri) {
    if (!defined(czml)) {
        throw new DeveloperError('czml is required.');
    }
    loadCzml(this, czml, sourceUri, true);
};
CzmlDataSource.prototype.processUrl = function (url) {
    if (!defined(url)) {
        throw new DeveloperError('url is required.');
    }
    DataSource.setLoading(this, true);
    var dataSource = this;
    return when(loadJson(url), function (czml) {
        loadCzml(dataSource, czml, url, false);
    }).otherwise(function (error) {
        DataSource.setLoading(dataSource, false);
        dataSource._error.raiseEvent(dataSource, error);
        return when.reject(error);
    });
};
CzmlDataSource.prototype.loadUrl = function (url) {
    if (!defined(url)) {
        throw new DeveloperError('url is required.');
    }
    DataSource.setLoading(this, true);
    var dataSource = this;
    return when(loadJson(url), function (czml) {
        loadCzml(dataSource, czml, url, true);
    }).otherwise(function (error) {
        DataSource.setLoading(dataSource, false);
        dataSource._error.raiseEvent(dataSource, error);
        return when.reject(error);
    });
};
CzmlDataSource.processPacketData = processPacketData;
CzmlDataSource.processPositionPacketData = processPositionPacketData;
CzmlDataSource.processMaterialPacketData = processMaterialPacketData;
CzmlDataSource._processCzml = function (czml, entityCollection, sourceUri, updaterFunctions, dataSource) {
    updaterFunctions = defined(updaterFunctions) ? updaterFunctions : CzmlDataSource.updaters;
    if (isArray(czml)) {
        for (var i = 0, len = czml.length; i < len; i++) {
            processCzmlPacket(czml[i], entityCollection, updaterFunctions, sourceUri, dataSource);
        }
    } else {
        processCzmlPacket(czml, entityCollection, updaterFunctions, sourceUri, dataSource);
    }
};
module.exports = CzmlDataSource;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartographic":104,"../Core/ClockRange":109,"../Core/ClockStep":110,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Ellipsoid":130,"../Core/Event":138,"../Core/ExtrapolationType":140,"../Core/HermitePolynomialApproximation":155,"../Core/Iso8601":167,"../Core/JulianDate":168,"../Core/LagrangePolynomialApproximation":170,"../Core/LinearApproximation":172,"../Core/Math":174,"../Core/Quaternion":197,"../Core/Rectangle":201,"../Core/ReferenceFrame":205,"../Core/RuntimeError":207,"../Core/Spherical":215,"../Core/TimeInterval":222,"../Core/TimeIntervalCollection":223,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/getFilenameFromUri":250,"../Core/isArray":253,"../Core/loadJson":261,"../Scene/HorizontalOrigin":394,"../Scene/LabelStyle":403,"../Scene/VerticalOrigin":454,"../ThirdParty/Uri":587,"../ThirdParty/when":596,"./BillboardGraphics":274,"./ColorMaterialProperty":278,"./CompositeMaterialProperty":279,"./CompositePositionProperty":280,"./CompositeProperty":281,"./ConstantPositionProperty":282,"./ConstantProperty":283,"./DataSource":287,"./DataSourceClock":288,"./EllipseGraphics":292,"./EllipsoidGraphics":294,"./EntityCollection":296,"./GridMaterialProperty":300,"./ImageMaterialProperty":301,"./LabelGraphics":303,"./ModelGraphics":306,"./PathGraphics":308,"./PointGraphics":310,"./PolygonGraphics":313,"./PolylineGlowMaterialProperty":315,"./PolylineGraphics":316,"./PolylineOutlineMaterialProperty":317,"./PositionPropertyArray":320,"./RectangleGraphics":323,"./ReferenceProperty":324,"./SampledPositionProperty":325,"./SampledProperty":326,"./StripeMaterialProperty":330,"./StripeOrientation":331,"./TimeIntervalCollectionPositionProperty":332,"./TimeIntervalCollectionProperty":333,"./WallGraphics":335}],287:[function(require,module,exports){
var defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError');
'use strict';
var DataSource = function () {
    DeveloperError.throwInstantiationError();
};
defineProperties(DataSource.prototype, {
    name: { get: DeveloperError.throwInstantiationError },
    clock: { get: DeveloperError.throwInstantiationError },
    entities: { get: DeveloperError.throwInstantiationError },
    isLoading: { get: DeveloperError.throwInstantiationError },
    changedEvent: { get: DeveloperError.throwInstantiationError },
    errorEvent: { get: DeveloperError.throwInstantiationError },
    loadingEvent: { get: DeveloperError.throwInstantiationError }
});
DataSource.prototype.update = DeveloperError.throwInstantiationError;
DataSource.setLoading = function (dataSource, isLoading) {
    if (dataSource._isLoading !== isLoading) {
        if (isLoading) {
            dataSource._entityCollection.suspendEvents();
        } else {
            dataSource._entityCollection.resumeEvents();
        }
        dataSource._isLoading = isLoading;
        dataSource._loading.raiseEvent(dataSource, isLoading);
    }
};
module.exports = DataSource;
},{"../Core/DeveloperError":123,"../Core/defineProperties":244}],288:[function(require,module,exports){
var Clock = require('../Core/Clock'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), JulianDate = require('../Core/JulianDate'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var DataSourceClock = function () {
    this._startTime = undefined;
    this._stopTime = undefined;
    this._currentTime = undefined;
    this._clockRange = undefined;
    this._clockStep = undefined;
    this._multiplier = undefined;
    this._definitionChanged = new Event();
};
defineProperties(DataSourceClock.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    startTime: createPropertyDescriptor('startTime'),
    stopTime: createPropertyDescriptor('stopTime'),
    currentTime: createPropertyDescriptor('currentTime'),
    clockRange: createPropertyDescriptor('clockRange'),
    clockStep: createPropertyDescriptor('clockStep'),
    multiplier: createPropertyDescriptor('multiplier')
});
DataSourceClock.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new DataSourceClock();
    }
    result.startTime = this.startTime;
    result.stopTime = this.stopTime;
    result.currentTime = this.currentTime;
    result.clockRange = this.clockRange;
    result.clockStep = this.clockStep;
    result.multiplier = this.multiplier;
    return result;
};
DataSourceClock.prototype.equals = function (other) {
    return this === other || defined(other) && JulianDate.equals(this.startTime, other.startTime) && JulianDate.equals(this.stopTime, other.stopTime) && JulianDate.equals(this.currentTime, other.currentTime) && this.clockRange === other.clockRange && this.clockStep === other.clockStep && this.multiplier === other.multiplier;
};
DataSourceClock.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.startTime = defaultValue(this.startTime, source.startTime);
    this.stopTime = defaultValue(this.stopTime, source.stopTime);
    this.currentTime = defaultValue(this.currentTime, source.currentTime);
    this.clockRange = defaultValue(this.clockRange, source.clockRange);
    this.clockStep = defaultValue(this.clockStep, source.clockStep);
    this.multiplier = defaultValue(this.multiplier, source.multiplier);
};
DataSourceClock.prototype.getValue = function (result) {
    if (!defined(result)) {
        result = new Clock();
    }
    result.startTime = this.startTime;
    result.stopTime = this.stopTime;
    result.clockRange = this.clockRange;
    result.clockStep = this.clockStep;
    result.multiplier = this.multiplier;
    result.currentTime = this.currentTime;
    return result;
};
module.exports = DataSourceClock;
},{"../Core/Clock":108,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/JulianDate":168,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],289:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event');
'use strict';
var DataSourceCollection = function () {
    this._dataSources = [];
    this._dataSourceAdded = new Event();
    this._dataSourceRemoved = new Event();
};
defineProperties(DataSourceCollection.prototype, {
    length: {
        get: function () {
            return this._dataSources.length;
        }
    },
    dataSourceAdded: {
        get: function () {
            return this._dataSourceAdded;
        }
    },
    dataSourceRemoved: {
        get: function () {
            return this._dataSourceRemoved;
        }
    }
});
DataSourceCollection.prototype.add = function (dataSource) {
    if (!defined(dataSource)) {
        throw new DeveloperError('dataSource is required.');
    }
    this._dataSources.push(dataSource);
    this._dataSourceAdded.raiseEvent(this, dataSource);
};
DataSourceCollection.prototype.remove = function (dataSource, destroy) {
    destroy = defaultValue(destroy, false);
    var index = this._dataSources.indexOf(dataSource);
    if (index !== -1) {
        this._dataSources.splice(index, 1);
        this._dataSourceRemoved.raiseEvent(this, dataSource);
        if (destroy && typeof dataSource.destroy === 'function') {
            dataSource.destroy();
        }
        return true;
    }
    return false;
};
DataSourceCollection.prototype.removeAll = function (destroy) {
    destroy = defaultValue(destroy, false);
    var dataSources = this._dataSources;
    for (var i = 0, len = dataSources.length; i < len; ++i) {
        var dataSource = dataSources[i];
        this._dataSourceRemoved.raiseEvent(this, dataSource);
        if (destroy && typeof dataSource.destroy === 'function') {
            dataSource.destroy();
        }
    }
    dataSources.length = 0;
};
DataSourceCollection.prototype.contains = function (dataSource) {
    return this.indexOf(dataSource) !== -1;
};
DataSourceCollection.prototype.indexOf = function (dataSource) {
    return this._dataSources.indexOf(dataSource);
};
DataSourceCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    return this._dataSources[index];
};
DataSourceCollection.prototype.isDestroyed = function () {
    return false;
};
DataSourceCollection.prototype.destroy = function () {
    this.removeAll(true);
    return destroyObject(this);
};
module.exports = DataSourceCollection;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247}],290:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), EventHelper = require('../Core/EventHelper'), BillboardVisualizer = require('./BillboardVisualizer'), BoxGeometryUpdater = require('./BoxGeometryUpdater'), CorridorGeometryUpdater = require('./CorridorGeometryUpdater'), CylinderGeometryUpdater = require('./CylinderGeometryUpdater'), EllipseGeometryUpdater = require('./EllipseGeometryUpdater'), EllipsoidGeometryUpdater = require('./EllipsoidGeometryUpdater'), GeometryVisualizer = require('./GeometryVisualizer'), LabelVisualizer = require('./LabelVisualizer'), ModelVisualizer = require('./ModelVisualizer'), PathVisualizer = require('./PathVisualizer'), PointVisualizer = require('./PointVisualizer'), PolygonGeometryUpdater = require('./PolygonGeometryUpdater'), PolylineGeometryUpdater = require('./PolylineGeometryUpdater'), PolylineVolumeGeometryUpdater = require('./PolylineVolumeGeometryUpdater'), RectangleGeometryUpdater = require('./RectangleGeometryUpdater'), WallGeometryUpdater = require('./WallGeometryUpdater');
'use strict';
var DataSourceDisplay = function (options) {
    var scene = options.scene;
    var dataSourceCollection = options.dataSourceCollection;
    if (!defined(options)) {
        throw new DeveloperError('options is required.');
    }
    if (!defined(options.scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(options.dataSourceCollection)) {
        throw new DeveloperError('dataSourceCollection is required.');
    }
    this._eventHelper = new EventHelper();
    this._eventHelper.add(dataSourceCollection.dataSourceAdded, this._onDataSourceAdded, this);
    this._eventHelper.add(dataSourceCollection.dataSourceRemoved, this._onDataSourceRemoved, this);
    this._dataSourceCollection = dataSourceCollection;
    this._scene = scene;
    this._visualizersCallback = defaultValue(options.visualizersCallback, DataSourceDisplay.defaultVisualizersCallback);
    for (var i = 0, len = dataSourceCollection.length; i < len; i++) {
        this._onDataSourceAdded(dataSourceCollection, dataSourceCollection.get(i));
    }
};
DataSourceDisplay.defaultVisualizersCallback = function (scene, dataSource) {
    var entities = dataSource.entities;
    return [
        new BillboardVisualizer(scene, entities),
        new GeometryVisualizer(BoxGeometryUpdater, scene, entities),
        new GeometryVisualizer(CylinderGeometryUpdater, scene, entities),
        new GeometryVisualizer(CorridorGeometryUpdater, scene, entities),
        new GeometryVisualizer(EllipseGeometryUpdater, scene, entities),
        new GeometryVisualizer(EllipsoidGeometryUpdater, scene, entities),
        new GeometryVisualizer(PolygonGeometryUpdater, scene, entities),
        new GeometryVisualizer(PolylineGeometryUpdater, scene, entities),
        new GeometryVisualizer(PolylineVolumeGeometryUpdater, scene, entities),
        new GeometryVisualizer(RectangleGeometryUpdater, scene, entities),
        new GeometryVisualizer(WallGeometryUpdater, scene, entities),
        new LabelVisualizer(scene, entities),
        new ModelVisualizer(scene, entities),
        new PointVisualizer(scene, entities),
        new PathVisualizer(scene, entities)
    ];
};
DataSourceDisplay.prototype.getScene = function () {
    return this._scene;
};
DataSourceDisplay.prototype.getDataSources = function () {
    return this._dataSourceCollection;
};
DataSourceDisplay.prototype.isDestroyed = function () {
    return false;
};
DataSourceDisplay.prototype.destroy = function () {
    this._eventHelper.removeAll();
    var dataSourceCollection = this._dataSourceCollection;
    for (var i = 0, length = dataSourceCollection.length; i < length; ++i) {
        this._onDataSourceRemoved(this._dataSourceCollection, dataSourceCollection.get(i));
    }
    return destroyObject(this);
};
DataSourceDisplay.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var result = true;
    var i;
    var x;
    var visualizers;
    var vLength;
    var dataSources = this._dataSourceCollection;
    var length = dataSources.length;
    for (i = 0; i < length; i++) {
        var dataSource = dataSources.get(i);
        if (defined(dataSource.update)) {
            result = dataSource.update(time) && result;
        }
        visualizers = dataSource._visualizers;
        vLength = visualizers.length;
        for (x = 0; x < vLength; x++) {
            result = visualizers[x].update(time) && result;
        }
    }
    return result;
};
DataSourceDisplay.prototype._onDataSourceAdded = function (dataSourceCollection, dataSource) {
    var visualizers = this._visualizersCallback(this._scene, dataSource);
    dataSource._visualizers = visualizers;
};
DataSourceDisplay.prototype._onDataSourceRemoved = function (dataSourceCollection, dataSource) {
    var visualizers = dataSource._visualizers;
    var length = visualizers.length;
    for (var i = 0; i < length; i++) {
        visualizers[i].destroy();
        dataSource._visualizers = undefined;
    }
};
module.exports = DataSourceDisplay;
},{"../Core/DeveloperError":123,"../Core/EventHelper":139,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"./BillboardVisualizer":275,"./BoxGeometryUpdater":276,"./CorridorGeometryUpdater":284,"./CylinderGeometryUpdater":285,"./EllipseGeometryUpdater":291,"./EllipsoidGeometryUpdater":293,"./GeometryVisualizer":299,"./LabelVisualizer":304,"./ModelVisualizer":307,"./PathVisualizer":309,"./PointVisualizer":311,"./PolygonGeometryUpdater":312,"./PolylineGeometryUpdater":314,"./PolylineVolumeGeometryUpdater":318,"./RectangleGeometryUpdater":322,"./WallGeometryUpdater":334}],291:[function(require,module,exports){
var Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), EllipseGeometry = require('../Core/EllipseGeometry'), EllipseOutlineGeometry = require('../Core/EllipseOutlineGeometry'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var scratchColor = new Color();
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.center = undefined;
    this.semiMajorAxis = undefined;
    this.semiMinorAxis = undefined;
    this.rotation = undefined;
    this.height = undefined;
    this.extrudedHeight = undefined;
    this.granularity = undefined;
    this.stRotation = undefined;
    this.numberOfVerticalLines = undefined;
};
var EllipseGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(EllipseGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._isClosed = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'ellipse', entity.ellipse, undefined);
};
defineProperties(EllipseGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(EllipseGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: {
        get: function () {
            return this._isClosed;
        }
    },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
EllipseGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
EllipseGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
EllipseGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new EllipseGeometry(this._options),
        attributes: attributes
    });
};
EllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: new EllipseOutlineGeometry(this._options),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
EllipseGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
EllipseGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
EllipseGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'position' || propertyName === 'ellipse')) {
        return;
    }
    var ellipse = this._entity.ellipse;
    if (!defined(ellipse)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = ellipse.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = ellipse.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var position = this._entity.position;
    var semiMajorAxis = ellipse.semiMajorAxis;
    var semiMinorAxis = ellipse.semiMinorAxis;
    var show = ellipse.show;
    if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || (!defined(position) || !defined(semiMajorAxis) || !defined(semiMinorAxis))) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(ellipse.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(ellipse.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(ellipse.outlineColor, defaultOutlineColor) : undefined;
    var rotation = ellipse.rotation;
    var height = ellipse.height;
    var extrudedHeight = ellipse.extrudedHeight;
    var granularity = ellipse.granularity;
    var stRotation = ellipse.stRotation;
    var outlineWidth = ellipse.outlineWidth;
    var numberOfVerticalLines = ellipse.numberOfVerticalLines;
    this._isClosed = defined(extrudedHeight);
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    if (!position.isConstant || !semiMajorAxis.isConstant || !semiMinorAxis.isConstant || !Property.isConstant(rotation) || !Property.isConstant(height) || !Property.isConstant(extrudedHeight) || !Property.isConstant(granularity) || !Property.isConstant(stRotation) || !Property.isConstant(outlineWidth) || !Property.isConstant(numberOfVerticalLines)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.center = position.getValue(Iso8601.MINIMUM_VALUE, options.center);
        options.semiMajorAxis = semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMajorAxis);
        options.semiMinorAxis = semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMinorAxis);
        options.rotation = defined(rotation) ? rotation.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.height = defined(height) ? height.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.extrudedHeight = defined(extrudedHeight) ? extrudedHeight.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.stRotation = defined(stRotation) ? stRotation.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.numberOfVerticalLines = defined(numberOfVerticalLines) ? numberOfVerticalLines.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
EllipseGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var primitives = this._primitives;
    primitives.removeAndDestroy(this._primitive);
    primitives.removeAndDestroy(this._outlinePrimitive);
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var ellipse = entity.ellipse;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(ellipse.show, time, true)) {
        return;
    }
    var options = this._options;
    var center = Property.getValueOrUndefined(entity.position, time, options.center);
    var semiMajorAxis = Property.getValueOrUndefined(ellipse.semiMajorAxis, time);
    var semiMinorAxis = Property.getValueOrUndefined(ellipse.semiMinorAxis, time);
    if (!defined(center) || !defined(semiMajorAxis) || !defined(semiMinorAxis)) {
        return;
    }
    options.center = center;
    options.semiMajorAxis = semiMajorAxis;
    options.semiMinorAxis = semiMinorAxis;
    options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);
    options.height = Property.getValueOrUndefined(ellipse.height, time);
    options.extrudedHeight = Property.getValueOrUndefined(ellipse.extrudedHeight, time);
    options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);
    options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);
    options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, time);
    if (Property.getValueOrDefault(ellipse.fill, time, true)) {
        var material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, this._material);
        this._material = material;
        var appearance = new MaterialAppearance({
                material: material,
                translucent: material.isTranslucent(),
                closed: defined(options.extrudedHeight)
            });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new EllipseGeometry(options)
            }),
            appearance: appearance,
            asynchronous: false
        }));
    }
    if (Property.getValueOrDefault(ellipse.outline, time, false)) {
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        var outlineColor = Property.getValueOrClonedDefault(ellipse.outlineColor, time, Color.BLACK, scratchColor);
        var outlineWidth = Property.getValueOrDefault(ellipse.outlineWidth, 1);
        var translucent = outlineColor.alpha !== 1;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new EllipseOutlineGeometry(options),
                attributes: { color: ColorGeometryInstanceAttribute.fromColor(outlineColor) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: translucent,
                renderState: { lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    var primitives = this._primitives;
    primitives.removeAndDestroy(this._primitive);
    primitives.removeAndDestroy(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = EllipseGeometryUpdater;
},{"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/EllipseGeometry":127,"../Core/EllipseOutlineGeometry":129,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],292:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var EllipseGraphics = function () {
    this._semiMajorAxis = undefined;
    this._semiMajorAxisSubscription = undefined;
    this._semiMinorAxis = undefined;
    this._semiMinorAxisSubscription = undefined;
    this._rotation = undefined;
    this._rotationSubscription = undefined;
    this._show = undefined;
    this._showSubscription = undefined;
    this._material = undefined;
    this._materialSubscription = undefined;
    this._height = undefined;
    this._heightSubscription = undefined;
    this._extrudedHeight = undefined;
    this._extrudedHeightSubscription = undefined;
    this._granularity = undefined;
    this._granularitySubscription = undefined;
    this._stRotation = undefined;
    this._stRotationSubscription = undefined;
    this._fill = undefined;
    this._fillSubscription = undefined;
    this._outline = undefined;
    this._outlineSubscription = undefined;
    this._outlineColor = undefined;
    this._outlineColorSubscription = undefined;
    this._outlineWidth = undefined;
    this._outlineWidthSubscription = undefined;
    this._numberOfVerticalLines = undefined;
    this._numberOfVerticalLinesSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(EllipseGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    semiMajorAxis: createPropertyDescriptor('semiMajorAxis'),
    semiMinorAxis: createPropertyDescriptor('semiMinorAxis'),
    rotation: createPropertyDescriptor('rotation'),
    show: createPropertyDescriptor('show'),
    material: createPropertyDescriptor('material'),
    height: createPropertyDescriptor('height'),
    extrudedHeight: createPropertyDescriptor('extrudedHeight'),
    granularity: createPropertyDescriptor('granularity'),
    stRotation: createPropertyDescriptor('stRotation'),
    fill: createPropertyDescriptor('fill'),
    outline: createPropertyDescriptor('outline'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    numberOfVerticalLines: createPropertyDescriptor('numberOfVerticalLines')
});
EllipseGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new EllipseGraphics();
    }
    result.rotation = this.rotation;
    result.semiMajorAxis = this.semiMajorAxis;
    result.semiMinorAxis = this.semiMinorAxis;
    result.show = this.show;
    result.material = this.material;
    result.height = this.height;
    result.extrudedHeight = this.extrudedHeight;
    result.granularity = this.granularity;
    result.stRotation = this.stRotation;
    result.fill = this.fill;
    result.outline = this.outline;
    result.outlineColor = this.outlineColor;
    result.outlineWidth = this.outlineWidth;
    result.numberOfVerticalLines = this.numberOfVerticalLines;
    return result;
};
EllipseGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.rotation = defaultValue(this.rotation, source.rotation);
    this.semiMajorAxis = defaultValue(this.semiMajorAxis, source.semiMajorAxis);
    this.semiMinorAxis = defaultValue(this.semiMinorAxis, source.semiMinorAxis);
    this.show = defaultValue(this.show, source.show);
    this.material = defaultValue(this.material, source.material);
    this.height = defaultValue(this.height, source.height);
    this.extrudedHeight = defaultValue(this.extrudedHeight, source.extrudedHeight);
    this.granularity = defaultValue(this.granularity, source.granularity);
    this.stRotation = defaultValue(this.stRotation, source.stRotation);
    this.fill = defaultValue(this.fill, source.fill);
    this.outline = defaultValue(this.outline, source.outline);
    this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
    this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
    this.numberOfVerticalLines = defaultValue(this.numberOfVerticalLines, source.numberOfVerticalLines);
};
module.exports = EllipseGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],293:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), EllipsoidGeometry = require('../Core/EllipsoidGeometry'), EllipsoidOutlineGeometry = require('../Core/EllipsoidOutlineGeometry'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), Matrix4 = require('../Core/Matrix4'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), SceneMode = require('../Scene/SceneMode'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var radiiScratch = new Cartesian3();
var scratchColor = new Color();
var unitSphere = new Cartesian3(1, 1, 1);
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.radii = undefined;
    this.stackPartitions = undefined;
    this.slicePartitions = undefined;
    this.subdivisions = undefined;
};
var EllipsoidGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._scene = scene;
    this._entity = entity;
    this._entitySubscription = entity.definitionChanged.addEventListener(EllipsoidGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'ellipsoid', entity.ellipsoid, undefined);
};
defineProperties(EllipsoidGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(EllipsoidGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: { value: true },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
EllipsoidGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
EllipsoidGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
EllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new EllipsoidGeometry(this._options),
        modelMatrix: entity._getModelMatrix(Iso8601.MINIMUM_VALUE),
        attributes: attributes
    });
};
EllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: new EllipsoidOutlineGeometry(this._options),
        modelMatrix: entity._getModelMatrix(Iso8601.MINIMUM_VALUE),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
EllipsoidGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
EllipsoidGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
EllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'position' || propertyName === 'orientation' || propertyName === 'ellipsoid')) {
        return;
    }
    var ellipsoid = entity.ellipsoid;
    if (!defined(ellipsoid)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = ellipsoid.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = ellipsoid.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var position = entity.position;
    var radii = ellipsoid.radii;
    var show = ellipsoid.show;
    if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || (!defined(position) || !defined(radii))) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(ellipsoid.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(ellipsoid.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(ellipsoid.outlineColor, defaultOutlineColor) : undefined;
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    var stackPartitions = ellipsoid.stackPartitions;
    var slicePartitions = ellipsoid.slicePartitions;
    var outlineWidth = ellipsoid.outlineWidth;
    var subdivisions = ellipsoid.subdivisions;
    if (!position.isConstant || !Property.isConstant(entity.orientation) || !radii.isConstant || !Property.isConstant(stackPartitions) || !Property.isConstant(slicePartitions) || !Property.isConstant(outlineWidth) || !Property.isConstant(subdivisions)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.radii = radii.getValue(Iso8601.MINIMUM_VALUE, options.radii);
        options.stackPartitions = defined(stackPartitions) ? stackPartitions.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.slicePartitions = defined(slicePartitions) ? slicePartitions.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.subdivisions = defined(subdivisions) ? subdivisions.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
EllipsoidGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._entity = geometryUpdater._entity;
    this._scene = geometryUpdater._scene;
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
    this._modelMatrix = new Matrix4();
    this._material = undefined;
    this._attributes = undefined;
    this._outlineAttributes = undefined;
    this._lastSceneMode = undefined;
    this._lastShow = undefined;
    this._lastOutlineShow = undefined;
    this._lastOutlineWidth = undefined;
    this._lastOutlineColor = undefined;
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var entity = this._entity;
    var ellipsoid = entity.ellipsoid;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(ellipsoid.show, time, true)) {
        if (defined(this._primitive)) {
            this._primitive.show = false;
        }
        if (defined(this._outlinePrimitive)) {
            this._outlinePrimitive.show = false;
        }
        return;
    }
    var radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);
    var modelMatrix = entity._getModelMatrix(time, this._modelMatrix);
    if (!defined(modelMatrix) || !defined(radii)) {
        if (defined(this._primitive)) {
            this._primitive.show = false;
        }
        if (defined(this._outlinePrimitive)) {
            this._outlinePrimitive.show = false;
        }
        return;
    }
    var appearance;
    var showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);
    var showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);
    var outlineColor = Property.getValueOrClonedDefault(ellipsoid.outlineColor, time, Color.BLACK, scratchColor);
    var material = MaterialProperty.getValue(time, defaultValue(ellipsoid.material, defaultMaterial), this._material);
    this._material = material;
    var stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, time);
    var slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, time);
    var subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);
    var outlineWidth = Property.getValueOrDefault(ellipsoid.outlineWidth, time, 1);
    var sceneMode = this._scene.mode;
    var in3D = sceneMode === SceneMode.SCENE3D;
    var options = this._options;
    var rebuildPrimitives = !in3D || this._lastSceneMode !== sceneMode || !defined(this._primitive) || options.stackPartitions !== stackPartitions || options.slicePartitions !== slicePartitions || options.subdivisions !== subdivisions || this._lastOutlineWidth !== outlineWidth;
    if (rebuildPrimitives) {
        var primitives = this._primitives;
        primitives.removeAndDestroy(this._primitive);
        primitives.removeAndDestroy(this._outlinePrimitive);
        this._lastSceneMode = sceneMode;
        this._lastOutlineWidth = outlineWidth;
        options.stackPartitions = stackPartitions;
        options.slicePartitions = slicePartitions;
        options.subdivisions = subdivisions;
        options.radii = in3D ? unitSphere : radii;
        appearance = new MaterialAppearance({
            material: material,
            translucent: material.isTranslucent(),
            closed: true
        });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new EllipsoidGeometry(options),
                modelMatrix: !in3D ? modelMatrix : undefined,
                attributes: { show: new ShowGeometryInstanceAttribute(showFill) }
            }),
            appearance: appearance,
            asynchronous: false
        }));
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new EllipsoidOutlineGeometry(options),
                modelMatrix: !in3D ? modelMatrix : undefined,
                attributes: {
                    show: new ShowGeometryInstanceAttribute(showOutline),
                    color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
                }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: outlineColor.alpha !== 1,
                renderState: { lineWidth: this._geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
        this._lastShow = showFill;
        this._lastOutlineShow = showOutline;
        this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);
    } else if (this._primitive.ready) {
        var primitive = this._primitive;
        var outlinePrimitive = this._outlinePrimitive;
        primitive.show = true;
        outlinePrimitive.show = true;
        appearance = primitive.appearance;
        appearance.material = material;
        var attributes = this._attributes;
        if (!defined(attributes)) {
            attributes = primitive.getGeometryInstanceAttributes(entity);
            this._attributes = attributes;
        }
        if (showFill !== this._lastShow) {
            attributes.show = ShowGeometryInstanceAttribute.toValue(showFill, attributes.show);
            this._lastShow = showFill;
        }
        var outlineAttributes = this._outlineAttributes;
        if (!defined(outlineAttributes)) {
            outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(entity);
            this._outlineAttributes = outlineAttributes;
        }
        if (showOutline !== this._lastOutlineShow) {
            outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(showOutline, outlineAttributes.show);
            this._lastOutlineShow = showOutline;
        }
        if (!Color.equals(outlineColor, this._lastOutlineColor)) {
            outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, outlineAttributes.color);
            Color.clone(outlineColor, this._lastOutlineColor);
        }
    }
    if (in3D) {
        radii.x = Math.max(radii.x, 0.001);
        radii.y = Math.max(radii.y, 0.001);
        radii.z = Math.max(radii.z, 0.001);
        modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);
        this._primitive.modelMatrix = modelMatrix;
        this._outlinePrimitive.modelMatrix = modelMatrix;
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    var primitives = this._primitives;
    primitives.removeAndDestroy(this._primitive);
    primitives.removeAndDestroy(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = EllipsoidGeometryUpdater;
},{"../Core/Cartesian3":102,"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/EllipsoidGeometry":132,"../Core/EllipsoidOutlineGeometry":133,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/Matrix4":177,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"../Scene/SceneMode":438,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],294:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var EllipsoidGraphics = function () {
    this._show = undefined;
    this._showSubscription = undefined;
    this._radii = undefined;
    this._radiiSubscription = undefined;
    this._material = undefined;
    this._materialSubscription = undefined;
    this._stackPartitions = undefined;
    this._stackPartitionsSubscription = undefined;
    this._slicePartitions = undefined;
    this._slicePartitionsSubscription = undefined;
    this._subdivisions = undefined;
    this._subdivisionsSubscription = undefined;
    this._fill = undefined;
    this._fillSubscription = undefined;
    this._outline = undefined;
    this._outlineSubscription = undefined;
    this._outlineColor = undefined;
    this._outlineColorSubscription = undefined;
    this._outlineWidth = undefined;
    this._outlineWidthSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(EllipsoidGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    show: createPropertyDescriptor('show'),
    radii: createPropertyDescriptor('radii'),
    material: createPropertyDescriptor('material'),
    fill: createPropertyDescriptor('fill'),
    outline: createPropertyDescriptor('outline'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    stackPartitions: createPropertyDescriptor('stackPartitions'),
    slicePartitions: createPropertyDescriptor('slicePartitions'),
    subdivisions: createPropertyDescriptor('subdivisions')
});
EllipsoidGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new EllipsoidGraphics();
    }
    result.show = this.show;
    result.radii = this.radii;
    result.material = this.material;
    result.fill = this.fill;
    result.outline = this.outline;
    result.outlineColor = this.outlineColor;
    result.outlineWidth = this.outlineWidth;
    result.stackPartitions = this.stackPartitions;
    result.slicePartitions = this.slicePartitions;
    result.subdivisions = this.subdivisions;
    return result;
};
EllipsoidGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.show = defaultValue(this.show, source.show);
    this.radii = defaultValue(this.radii, source.radii);
    this.material = defaultValue(this.material, source.material);
    this.fill = defaultValue(this.fill, source.fill);
    this.outline = defaultValue(this.outline, source.outline);
    this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
    this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
    this.stackPartitions = defaultValue(this.stackPartitions, source.stackPartitions);
    this.slicePartitions = defaultValue(this.slicePartitions, source.slicePartitions);
    this.subdivisions = defaultValue(this.subdivisions, source.subdivisions);
};
module.exports = EllipsoidGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],295:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), Quaternion = require('../Core/Quaternion'), Transforms = require('../Core/Transforms'), createPropertyDescriptor = require('./createPropertyDescriptor'), Property = require('./Property');
'use strict';
var Entity = function (id) {
    if (!defined(id)) {
        id = createGuid();
    }
    this._availability = undefined;
    this._id = id;
    this._definitionChanged = new Event();
    this._name = undefined;
    this._parent = undefined;
    this._propertyNames = [
        'billboard',
        'box',
        'corridor',
        'cylinder',
        'description',
        'ellipse',
        'ellipsoid',
        'label',
        'model',
        'orientation',
        'path',
        'point',
        'polygon',
        'polyline',
        'polylineVolume',
        'position',
        'rectangle',
        'viewFrom',
        'wall'
    ];
    this._billboard = undefined;
    this._billboardSubscription = undefined;
    this._box = undefined;
    this._boxSubscription = undefined;
    this._corridor = undefined;
    this._corridorSubscription = undefined;
    this._cylinder = undefined;
    this._cylinderSubscription = undefined;
    this._description = undefined;
    this._descriptionSubscription = undefined;
    this._ellipse = undefined;
    this._ellipseSubscription = undefined;
    this._ellipsoid = undefined;
    this._ellipsoidSubscription = undefined;
    this._label = undefined;
    this._labelSubscription = undefined;
    this._model = undefined;
    this._modelSubscription = undefined;
    this._orientation = undefined;
    this._orientationSubscription = undefined;
    this._path = undefined;
    this._pathSubscription = undefined;
    this._point = undefined;
    this._pointSubscription = undefined;
    this._polygon = undefined;
    this._polygonSubscription = undefined;
    this._polyline = undefined;
    this._polylineSubscription = undefined;
    this._polylineVolume = undefined;
    this._polylineVolumeSubscription = undefined;
    this._position = undefined;
    this._positionSubscription = undefined;
    this._rectangle = undefined;
    this._rectangleSubscription = undefined;
    this._viewFrom = undefined;
    this._viewFromSubscription = undefined;
    this._wall = undefined;
    this._wallSubscription = undefined;
};
defineProperties(Entity.prototype, {
    availability: createPropertyDescriptor('availability'),
    id: {
        get: function () {
            return this._id;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    name: {
        configurable: false,
        get: function () {
            return this._name;
        },
        set: function (value) {
            var oldValue = this._name;
            if (oldValue !== value) {
                this._name = value;
                this._definitionChanged.raiseEvent(this, 'name', value, oldValue);
            }
        }
    },
    parent: createPropertyDescriptor('parent'),
    propertyNames: {
        get: function () {
            return this._propertyNames;
        }
    },
    billboard: createPropertyDescriptor('billboard'),
    box: createPropertyDescriptor('box'),
    corridor: createPropertyDescriptor('corridor'),
    cylinder: createPropertyDescriptor('cylinder'),
    description: createPropertyDescriptor('description'),
    ellipse: createPropertyDescriptor('ellipse'),
    ellipsoid: createPropertyDescriptor('ellipsoid'),
    label: createPropertyDescriptor('label'),
    model: createPropertyDescriptor('model'),
    orientation: createPropertyDescriptor('orientation'),
    path: createPropertyDescriptor('path'),
    point: createPropertyDescriptor('point'),
    polygon: createPropertyDescriptor('polygon'),
    polyline: createPropertyDescriptor('polyline'),
    polylineVolume: createPropertyDescriptor('polylineVolume'),
    position: createPropertyDescriptor('position'),
    rectangle: createPropertyDescriptor('rectangle'),
    viewFrom: createPropertyDescriptor('viewFrom'),
    wall: createPropertyDescriptor('wall')
});
Entity.prototype.isAvailable = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var availability = this._availability;
    return !defined(availability) || availability.contains(time);
};
Entity.prototype.addProperty = function (propertyName) {
    var propertyNames = this._propertyNames;
    if (!defined(propertyName)) {
        throw new DeveloperError('propertyName is required.');
    }
    if (propertyNames.indexOf(propertyName) !== -1) {
        throw new DeveloperError(propertyName + ' is already a registered property.');
    }
    if (propertyName in this) {
        throw new DeveloperError(propertyName + ' is a reserved property name.');
    }
    propertyNames.push(propertyName);
    Object.defineProperty(this, propertyName, createPropertyDescriptor(propertyName, true));
};
Entity.prototype.removeProperty = function (propertyName) {
    var propertyNames = this._propertyNames;
    if (!defined(propertyName)) {
        throw new DeveloperError('propertyName is required.');
    }
    if (propertyNames.indexOf(propertyName) === -1) {
        throw new DeveloperError(propertyName + ' is not a registered property.');
    }
    this._propertyNames.push(propertyName);
    delete this[propertyName];
};
Entity.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.name = defaultValue(this.name, source.name);
    this.availability = defaultValue(source.availability, this.availability);
    var propertyNames = this._propertyNames;
    var sourcePropertyNames = source._propertyNames;
    var propertyNamesLength = sourcePropertyNames.length;
    for (var i = 0; i < propertyNamesLength; i++) {
        var name = sourcePropertyNames[i];
        var targetProperty = this[name];
        var sourceProperty = source[name];
        if (!defined(targetProperty) && propertyNames.indexOf(name) === -1) {
            this.addProperty(name);
        }
        if (defined(sourceProperty)) {
            if (defined(targetProperty)) {
                if (defined(targetProperty.merge)) {
                    targetProperty.merge(sourceProperty);
                }
            } else if (defined(sourceProperty.merge) && defined(sourceProperty.clone)) {
                this[name] = sourceProperty.clone();
            } else {
                this[name] = sourceProperty;
            }
        }
    }
};
var matrix3Scratch = new Matrix3();
var positionScratch = new Cartesian3();
var orientationScratch = new Quaternion();
Entity.prototype._getModelMatrix = function (time, result) {
    var position = Property.getValueOrUndefined(this._position, time, positionScratch);
    if (!defined(position)) {
        return undefined;
    }
    var orientation = Property.getValueOrUndefined(this._orientation, time, orientationScratch);
    if (!defined(orientation)) {
        result = Transforms.eastNorthUpToFixedFrame(position, undefined, result);
    } else {
        result = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, result);
    }
    return result;
};
module.exports = Entity;
},{"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/Quaternion":197,"../Core/Transforms":226,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321,"./createPropertyDescriptor":336}],296:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), createGuid = require('../Core/createGuid'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), Iso8601 = require('../Core/Iso8601'), JulianDate = require('../Core/JulianDate'), RuntimeError = require('../Core/RuntimeError'), TimeInterval = require('../Core/TimeInterval'), Entity = require('./Entity');
'use strict';
function fireChangedEvent(collection) {
    if (collection._suspendCount === 0) {
        var added = collection._addedEntities;
        var removed = collection._removedEntities;
        var changed = collection._changedEntities;
        if (changed.length !== 0 || added.length !== 0 || removed.length !== 0) {
            collection._collectionChanged.raiseEvent(collection, added.values, removed.values, changed.values);
            added.removeAll();
            removed.removeAll();
            changed.removeAll();
        }
    }
}
var EntityCollection = function () {
    this._entities = new AssociativeArray();
    this._addedEntities = new AssociativeArray();
    this._removedEntities = new AssociativeArray();
    this._changedEntities = new AssociativeArray();
    this._suspendCount = 0;
    this._collectionChanged = new Event();
    this._id = createGuid();
};
EntityCollection.prototype.suspendEvents = function () {
    this._suspendCount++;
};
EntityCollection.prototype.resumeEvents = function () {
    if (this._suspendCount === 0) {
        throw new DeveloperError('resumeEvents can not be called before suspendEvents.');
    }
    this._suspendCount--;
    fireChangedEvent(this);
};
EntityCollection.collectionChangedEventCallback = undefined;
defineProperties(EntityCollection.prototype, {
    collectionChanged: {
        get: function () {
            return this._collectionChanged;
        }
    },
    id: {
        get: function () {
            return this._id;
        }
    },
    entities: {
        get: function () {
            return this._entities.values;
        }
    }
});
EntityCollection.prototype.computeAvailability = function () {
    var startTime = Iso8601.MAXIMUM_VALUE;
    var stopTime = Iso8601.MINIMUM_VALUE;
    var entities = this._entities.values;
    for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];
        var availability = entity.availability;
        if (defined(availability)) {
            var start = availability.start;
            var stop = availability.stop;
            if (JulianDate.lessThan(start, startTime) && !start.equals(Iso8601.MINIMUM_VALUE)) {
                startTime = start;
            }
            if (JulianDate.greaterThan(stop, stopTime) && !stop.equals(Iso8601.MAXIMUM_VALUE)) {
                stopTime = stop;
            }
        }
    }
    if (Iso8601.MAXIMUM_VALUE.equals(startTime)) {
        startTime = Iso8601.MINIMUM_VALUE;
    }
    if (Iso8601.MINIMUM_VALUE.equals(stopTime)) {
        stopTime = Iso8601.MAXIMUM_VALUE;
    }
    return new TimeInterval({
        start: startTime,
        stop: stopTime
    });
};
EntityCollection.prototype.add = function (entity) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required.');
    }
    var id = entity.id;
    var entities = this._entities;
    if (entities.contains(id)) {
        throw new RuntimeError('An entity with id ' + id + ' already exists in this collection.');
    }
    entities.set(id, entity);
    var removedEntities = this._removedEntities;
    if (!this._removedEntities.remove(id)) {
        this._addedEntities.set(id, entity);
    }
    entity.definitionChanged.addEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
    fireChangedEvent(this);
};
EntityCollection.prototype.remove = function (entity) {
    if (!defined(entity)) {
        return false;
    }
    return this.removeById(entity.id);
};
EntityCollection.prototype.removeById = function (id) {
    if (!defined(id)) {
        return false;
    }
    var entities = this._entities;
    var entity = entities.get(id);
    if (!this._entities.remove(id)) {
        return false;
    }
    if (!this._addedEntities.remove(id)) {
        this._removedEntities.set(id, entity);
        this._changedEntities.remove(id);
    }
    this._entities.remove(id);
    entity.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
    fireChangedEvent(this);
    return true;
};
EntityCollection.prototype.removeAll = function () {
    var entities = this._entities;
    var entitiesLength = entities.length;
    var array = entities.values;
    var addedEntities = this._addedEntities;
    var removed = this._removedEntities;
    for (var i = 0; i < entitiesLength; i++) {
        var existingItem = array[i];
        var existingItemId = existingItem.id;
        var addedItem = addedEntities.get(existingItemId);
        if (!defined(addedItem)) {
            existingItem.definitionChanged.removeEventListener(EntityCollection.prototype._onEntityDefinitionChanged, this);
            removed.set(existingItemId, existingItem);
        }
    }
    entities.removeAll();
    addedEntities.removeAll();
    this._changedEntities.removeAll();
    fireChangedEvent(this);
};
EntityCollection.prototype.getById = function (id) {
    if (!defined(id)) {
        throw new DeveloperError('id is required.');
    }
    return this._entities.get(id);
};
EntityCollection.prototype.getOrCreateEntity = function (id) {
    if (!defined(id)) {
        throw new DeveloperError('id is required.');
    }
    var entity = this._entities.get(id);
    if (!defined(entity)) {
        entity = new Entity(id);
        this.add(entity);
    }
    return entity;
};
EntityCollection.prototype._onEntityDefinitionChanged = function (entity) {
    var id = entity.id;
    if (!this._addedEntities.contains(id)) {
        this._changedEntities.set(id, entity);
    }
    fireChangedEvent(this);
};
module.exports = EntityCollection;
},{"../Core/AssociativeArray":93,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/Iso8601":167,"../Core/JulianDate":168,"../Core/RuntimeError":207,"../Core/TimeInterval":222,"../Core/createGuid":242,"../Core/defineProperties":244,"../Core/defined":245,"./Entity":295}],297:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Ellipsoid = require('../Core/Ellipsoid'), JulianDate = require('../Core/JulianDate'), CesiumMath = require('../Core/Math'), Matrix3 = require('../Core/Matrix3'), Transforms = require('../Core/Transforms'), SceneMode = require('../Scene/SceneMode');
'use strict';
var updateTransformMatrix3Scratch1 = new Matrix3();
var updateTransformMatrix3Scratch2 = new Matrix3();
var updateTransformMatrix3Scratch3 = new Matrix3();
var updateTransformCartesian3Scratch1 = new Cartesian3();
var updateTransformCartesian3Scratch2 = new Cartesian3();
var updateTransformCartesian3Scratch3 = new Cartesian3();
var updateTransformCartesian3Scratch4 = new Cartesian3();
var updateTransformCartesian3Scratch5 = new Cartesian3();
var updateTransformCartesian3Scratch6 = new Cartesian3();
var deltaTime = new JulianDate();
var northUpAxisFactor = 1.25;
function updateTransform(that, camera, updateLookAt, positionProperty, time, ellipsoid) {
    var cartesian = positionProperty.getValue(time, that._lastCartesian);
    if (defined(cartesian)) {
        var hasBasis = false;
        var xBasis;
        var yBasis;
        var zBasis;
        deltaTime = JulianDate.addSeconds(time, 0.001, deltaTime);
        var deltaCartesian = positionProperty.getValue(deltaTime, updateTransformCartesian3Scratch1);
        if (defined(deltaCartesian)) {
            var toInertial = Transforms.computeFixedToIcrfMatrix(time, updateTransformMatrix3Scratch1);
            var toInertialDelta = Transforms.computeFixedToIcrfMatrix(deltaTime, updateTransformMatrix3Scratch2);
            var toFixed;
            if (!defined(toInertial) || !defined(toInertialDelta)) {
                toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, updateTransformMatrix3Scratch3);
                toInertial = Matrix3.transpose(toFixed, updateTransformMatrix3Scratch1);
                toInertialDelta = Transforms.computeTemeToPseudoFixedMatrix(deltaTime, updateTransformMatrix3Scratch2);
                Matrix3.transpose(toInertialDelta, toInertialDelta);
            } else {
                toFixed = Matrix3.transpose(toInertial, updateTransformMatrix3Scratch3);
            }
            var inertialCartesian = Matrix3.multiplyByVector(toInertial, cartesian, updateTransformCartesian3Scratch5);
            var inertialDeltaCartesian = Matrix3.multiplyByVector(toInertialDelta, deltaCartesian, updateTransformCartesian3Scratch6);
            Cartesian3.subtract(inertialCartesian, inertialDeltaCartesian, updateTransformCartesian3Scratch4);
            var inertialVelocity = Cartesian3.magnitude(updateTransformCartesian3Scratch4) * 1000;
            var mu = 398600441800000;
            var semiMajorAxis = -mu / (inertialVelocity * inertialVelocity - 2 * mu / Cartesian3.magnitude(inertialCartesian));
            if (semiMajorAxis < 0 || semiMajorAxis > northUpAxisFactor * ellipsoid.maximumRadius) {
                xBasis = updateTransformCartesian3Scratch2;
                Cartesian3.normalize(cartesian, xBasis);
                Cartesian3.negate(xBasis, xBasis);
                zBasis = Cartesian3.clone(Cartesian3.UNIT_Z, updateTransformCartesian3Scratch3);
                yBasis = Cartesian3.cross(zBasis, xBasis, updateTransformCartesian3Scratch1);
                if (Cartesian3.magnitude(yBasis) > CesiumMath.EPSILON7) {
                    Cartesian3.normalize(xBasis, xBasis);
                    Cartesian3.normalize(yBasis, yBasis);
                    zBasis = Cartesian3.cross(xBasis, yBasis, updateTransformCartesian3Scratch3);
                    Cartesian3.normalize(zBasis, zBasis);
                    hasBasis = true;
                }
            } else if (!Cartesian3.equalsEpsilon(cartesian, deltaCartesian, CesiumMath.EPSILON7)) {
                zBasis = updateTransformCartesian3Scratch2;
                Cartesian3.normalize(inertialCartesian, zBasis);
                Cartesian3.normalize(inertialDeltaCartesian, inertialDeltaCartesian);
                yBasis = Cartesian3.cross(zBasis, inertialDeltaCartesian, updateTransformCartesian3Scratch3);
                if (!Cartesian3.equalsEpsilon(yBasis, Cartesian3.ZERO, CesiumMath.EPSILON7)) {
                    xBasis = Cartesian3.cross(yBasis, zBasis, updateTransformCartesian3Scratch1);
                    Matrix3.multiplyByVector(toFixed, xBasis, xBasis);
                    Matrix3.multiplyByVector(toFixed, yBasis, yBasis);
                    Matrix3.multiplyByVector(toFixed, zBasis, zBasis);
                    Cartesian3.normalize(xBasis, xBasis);
                    Cartesian3.normalize(yBasis, yBasis);
                    Cartesian3.normalize(zBasis, zBasis);
                    hasBasis = true;
                }
            }
        }
        if (hasBasis) {
            var transform = camera.transform;
            transform[0] = xBasis.x;
            transform[1] = xBasis.y;
            transform[2] = xBasis.z;
            transform[3] = 0;
            transform[4] = yBasis.x;
            transform[5] = yBasis.y;
            transform[6] = yBasis.z;
            transform[7] = 0;
            transform[8] = zBasis.x;
            transform[9] = zBasis.y;
            transform[10] = zBasis.z;
            transform[11] = 0;
            transform[12] = cartesian.x;
            transform[13] = cartesian.y;
            transform[14] = cartesian.z;
            transform[15] = 0;
        } else {
            Transforms.eastNorthUpToFixedFrame(cartesian, ellipsoid, camera.transform);
        }
    }
    if (updateLookAt) {
        if (that.scene.mode === SceneMode.SCENE2D) {
            camera.lookAt(that._offset2D, Cartesian3.ZERO, that._up2D);
        } else {
            camera.lookAt(that._offset3D, Cartesian3.ZERO, that._up3D);
        }
    }
}
var offset3DCrossScratch = new Cartesian3();
var EntityView = function (entity, scene, ellipsoid) {
    this.entity = entity;
    this.scene = scene;
    this.ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    this._lastEntity = undefined;
    this._mode = undefined;
    this._lastCartesian = new Cartesian3();
    this._offset3D = new Cartesian3();
    this._up3D = new Cartesian3();
    this._offset2D = new Cartesian3();
    this._up2D = new Cartesian3();
};
defineProperties(EntityView, {
    defaultOffset3D: {
        get: function () {
            return this._defaultOffset3D;
        },
        set: function (vector) {
            this._defaultOffset3D = Cartesian3.clone(vector, new Cartesian3());
            this._defaultUp3D = Cartesian3.cross(this._defaultOffset3D, Cartesian3.cross(Cartesian3.UNIT_Z, this._defaultOffset3D, offset3DCrossScratch), new Cartesian3());
            Cartesian3.normalize(this._defaultUp3D, this._defaultUp3D);
            this._defaultOffset2D = new Cartesian3(0, 0, Cartesian3.magnitude(this._defaultOffset3D));
            this._defaultUp2D = Cartesian3.clone(Cartesian3.UNIT_Y);
        }
    }
});
EntityView.defaultOffset3D = new Cartesian3(-14000, 3500, 3500);
EntityView.prototype.update = function (time) {
    var scene = this.scene;
    var entity = this.entity;
    var ellipsoid = this.ellipsoid;
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!defined(scene)) {
        throw new DeveloperError('EntityView.scene is required.');
    }
    if (!defined(entity)) {
        throw new DeveloperError('EntityView.entity is required.');
    }
    if (!defined(ellipsoid)) {
        throw new DeveloperError('EntityView.ellipsoid is required.');
    }
    if (!defined(entity.position)) {
        throw new DeveloperError('entity.position is required.');
    }
    var positionProperty = entity.position;
    var objectChanged = entity !== this._lastEntity;
    var sceneModeChanged = scene.mode !== this._mode && scene.mode !== SceneMode.MORPHING;
    var offset3D = this._offset3D;
    var up3D = this._up3D;
    var offset2D = this._offset2D;
    var up2D = this._up2D;
    var camera = scene.camera;
    if (objectChanged) {
        var viewFromProperty = entity.viewFrom;
        if (!defined(viewFromProperty) || !defined(viewFromProperty.getValue(time, offset3D))) {
            Cartesian3.clone(EntityView._defaultOffset2D, offset2D);
            Cartesian3.clone(EntityView._defaultUp2D, up2D);
            Cartesian3.clone(EntityView._defaultOffset3D, offset3D);
            Cartesian3.clone(EntityView._defaultUp3D, up3D);
        } else {
            Cartesian3.cross(Cartesian3.UNIT_Z, offset3D, up3D);
            Cartesian3.cross(offset3D, up3D, up3D);
            Cartesian3.normalize(up3D, up3D);
            var mag = Cartesian3.magnitude(offset3D);
            Cartesian3.fromElements(0, 0, mag, offset2D);
            Cartesian3.clone(this._defaultUp2D, up2D);
        }
    } else if (!sceneModeChanged && scene.mode !== SceneMode.MORPHING) {
        if (this._mode === SceneMode.SCENE2D) {
            var distance = Math.max(camera.frustum.right - camera.frustum.left, camera.frustum.top - camera.frustum.bottom);
            Cartesian3.fromElements(0, 0, distance, offset2D);
            Cartesian3.clone(camera.up, up2D);
        } else if (this._mode === SceneMode.SCENE3D || this._mode === SceneMode.COLUMBUS_VIEW) {
            Cartesian3.clone(camera.position, offset3D);
            Cartesian3.clone(camera.up, up3D);
        }
    }
    var updateLookAt = objectChanged || sceneModeChanged;
    this._lastEntity = entity;
    this._mode = scene.mode !== SceneMode.MORPHING ? scene.mode : this._mode;
    if (scene.mode !== SceneMode.MORPHING) {
        updateTransform(this, camera, updateLookAt, positionProperty, time, ellipsoid);
    }
};
module.exports = EntityView;
},{"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/Ellipsoid":130,"../Core/JulianDate":168,"../Core/Math":174,"../Core/Matrix3":176,"../Core/Transforms":226,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Scene/SceneMode":438}],298:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), getFilenameFromUri = require('../Core/getFilenameFromUri'), loadJson = require('../Core/loadJson'), PinBuilder = require('../Core/PinBuilder'), PolygonHierarchy = require('../Core/PolygonHierarchy'), RuntimeError = require('../Core/RuntimeError'), VerticalOrigin = require('../Scene/VerticalOrigin'), topojson = require('../ThirdParty/topojson'), when = require('../ThirdParty/when'), BillboardGraphics = require('./BillboardGraphics'), CallbackProperty = require('./CallbackProperty'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantPositionProperty = require('./ConstantPositionProperty'), ConstantProperty = require('./ConstantProperty'), DataSource = require('./DataSource'), EntityCollection = require('./EntityCollection'), PolygonGraphics = require('./PolygonGraphics'), PolylineGraphics = require('./PolylineGraphics');
'use strict';
function defaultCrsFunction(coordinates) {
    return Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);
}
var crsNames = {
        'urn:ogc:def:crs:OGC:1.3:CRS84': defaultCrsFunction,
        'EPSG:4326': defaultCrsFunction
    };
var crsLinkHrefs = {};
var crsLinkTypes = {};
var defaultMarkerSize = 48;
var defaultMarkerSymbol;
var defaultMarkerColor = Color.ROYALBLUE;
var defaultStroke = Color.YELLOW;
var defaultStrokeWidth = 2;
var defaultFill = Color.fromBytes(255, 255, 0, 100);
var defaultStrokeWidthProperty = new ConstantProperty(defaultStrokeWidth);
var defaultStrokeMaterialProperty = ColorMaterialProperty.fromColor(defaultStroke);
var defaultFillMaterialProperty = ColorMaterialProperty.fromColor(defaultFill);
var sizes = {
        small: 24,
        medium: 48,
        large: 64
    };
var simpleStyleIdentifiers = [
        'title',
        'description',
        'marker-size',
        'marker-symbol',
        'marker-color',
        'stroke',
        'stroke-opacity',
        'stroke-width',
        'fill',
        'fill-opacity'
    ];
var stringifyScratch = new Array(4);
function describe(properties, nameProperty) {
    var html = '<table class="cesium-infoBox-defaultTable"><tbody>';
    for (var key in properties) {
        if (properties.hasOwnProperty(key)) {
            if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {
                continue;
            }
            var value = properties[key];
            if (defined(value)) {
                if (typeof value === 'object') {
                    html += '<tr><th>' + key + '</th><td>' + describe(value) + '</td></tr>';
                } else {
                    html += '<tr><th>' + key + '</th><td>' + value + '</td></tr>';
                }
            }
        }
    }
    html += '</tbody></table>';
    return html;
}
function createDescriptionCallback(properties, nameProperty) {
    var description;
    return function (time, result) {
        if (!defined(description)) {
            description = describe(properties, nameProperty);
        }
        return description;
    };
}
function createObject(geoJson, entityCollection) {
    var id = geoJson.id;
    if (!defined(id) || geoJson.type !== 'Feature') {
        id = createGuid();
    } else {
        var i = 2;
        var finalId = id;
        while (defined(entityCollection.getById(finalId))) {
            finalId = id + '_' + i;
            i++;
        }
        id = finalId;
    }
    var entity = entityCollection.getOrCreateEntity(id);
    var properties = geoJson.properties;
    if (defined(properties)) {
        entity.addProperty('properties');
        entity.properties = properties;
        var nameProperty;
        var name = properties.title;
        if (defined(name)) {
            entity.name = name;
            nameProperty = 'title';
        } else {
            var namePropertyPrecedence = Number.MAX_VALUE;
            for (var key in properties) {
                if (properties.hasOwnProperty(key) && properties[key]) {
                    var lowerKey = key.toLowerCase();
                    if (namePropertyPrecedence > 1 && lowerKey === 'title') {
                        namePropertyPrecedence = 1;
                        nameProperty = key;
                        break;
                    } else if (namePropertyPrecedence > 2 && lowerKey === 'name') {
                        namePropertyPrecedence = 2;
                        nameProperty = key;
                    } else if (namePropertyPrecedence > 3 && /title/i.test(key)) {
                        namePropertyPrecedence = 3;
                        nameProperty = key;
                    } else if (namePropertyPrecedence > 4 && /name/i.test(key)) {
                        namePropertyPrecedence = 4;
                        nameProperty = key;
                    }
                }
            }
            if (defined(nameProperty)) {
                entity.name = properties[nameProperty];
            }
        }
        var description = properties.description;
        if (!defined(description)) {
            entity.description = new CallbackProperty(createDescriptionCallback(properties, nameProperty), true);
        } else {
            entity.description = new ConstantProperty(description);
        }
    }
    return entity;
}
function coordinatesArrayToCartesianArray(coordinates, crsFunction) {
    var positions = new Array(coordinates.length);
    for (var i = 0; i < coordinates.length; i++) {
        positions[i] = crsFunction(coordinates[i]);
    }
    return positions;
}
function processFeature(dataSource, feature, notUsed, crsFunction, options) {
    if (!defined(feature.geometry)) {
        throw new RuntimeError('feature.geometry is required.');
    }
    if (feature.geometry === null) {
        createObject(feature, dataSource._entityCollection);
    } else {
        var geometryType = feature.geometry.type;
        var geometryHandler = geometryTypes[geometryType];
        if (!defined(geometryHandler)) {
            throw new RuntimeError('Unknown geometry type: ' + geometryType);
        }
        geometryHandler(dataSource, feature, feature.geometry, crsFunction, options);
    }
}
function processFeatureCollection(dataSource, featureCollection, notUsed, crsFunction, options) {
    var features = featureCollection.features;
    for (var i = 0, len = features.length; i < len; i++) {
        processFeature(dataSource, features[i], undefined, crsFunction, options);
    }
}
function processGeometryCollection(dataSource, geoJson, geometryCollection, crsFunction, options) {
    var geometries = geometryCollection.geometries;
    for (var i = 0, len = geometries.length; i < len; i++) {
        var geometry = geometries[i];
        var geometryType = geometry.type;
        var geometryHandler = geometryTypes[geometryType];
        if (!defined(geometryHandler)) {
            throw new RuntimeError('Unknown geometry type: ' + geometryType);
        }
        geometryHandler(dataSource, geoJson, geometry, crsFunction, options);
    }
}
function createPoint(dataSource, geoJson, crsFunction, coordinates, options) {
    var symbol = options.markerSymbol;
    var color = options.markerColor;
    var size = options.markerSize;
    var properties = geoJson.properties;
    if (defined(properties)) {
        var cssColor = properties['marker-color'];
        if (defined(cssColor)) {
            color = Color.fromCssColorString(cssColor);
        }
        size = defaultValue(sizes[properties['marker-size']], size);
        symbol = defaultValue(properties['marker-symbol'], symbol);
    }
    stringifyScratch[0] = symbol;
    stringifyScratch[1] = color;
    stringifyScratch[2] = size;
    var id = JSON.stringify(stringifyScratch);
    var canvasOrPromise;
    if (defined(symbol)) {
        if (symbol.length === 1) {
            canvasOrPromise = dataSource._pinBuilder.fromText(symbol.toUpperCase(), color, size);
        } else {
            canvasOrPromise = dataSource._pinBuilder.fromMakiIconId(symbol, color, size);
        }
    } else {
        canvasOrPromise = dataSource._pinBuilder.fromColor(color, size);
    }
    dataSource._promises.push(when(canvasOrPromise, function (dataUrl) {
        var billboard = new BillboardGraphics();
        billboard.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);
        billboard.image = new ConstantProperty(dataUrl);
        var entity = createObject(geoJson, dataSource._entityCollection);
        entity.billboard = billboard;
        entity.position = new ConstantPositionProperty(crsFunction(coordinates));
    }));
}
function processPoint(dataSource, geoJson, geometry, crsFunction, options) {
    createPoint(dataSource, geoJson, crsFunction, geometry.coordinates, options);
}
function processMultiPoint(dataSource, geoJson, geometry, crsFunction, options) {
    var coordinates = geometry.coordinates;
    for (var i = 0; i < coordinates.length; i++) {
        createPoint(dataSource, geoJson, crsFunction, coordinates[i], options);
    }
}
function createLineString(dataSource, geoJson, crsFunction, coordinates, options) {
    var material = options.strokeMaterialProperty;
    var widthProperty = options.strokeWidthProperty;
    var properties = geoJson.properties;
    if (defined(properties)) {
        var width = properties['stroke-width'];
        if (defined(width)) {
            widthProperty = new ConstantProperty(width);
        }
        var color;
        var stroke = properties.stroke;
        if (defined(stroke)) {
            color = Color.fromCssColorString(stroke);
        }
        var opacity = properties['stroke-opacity'];
        if (defined(opacity) && opacity !== 1) {
            if (!defined(color)) {
                color = material.color.clone();
            }
            color.alpha = opacity;
        }
        if (defined(color)) {
            material = ColorMaterialProperty.fromColor(color);
        }
    }
    var polyline = new PolylineGraphics();
    polyline.material = material;
    polyline.width = widthProperty;
    polyline.positions = new ConstantProperty(coordinatesArrayToCartesianArray(coordinates, crsFunction));
    var entity = createObject(geoJson, dataSource._entityCollection);
    entity.polyline = polyline;
}
function processLineString(dataSource, geoJson, geometry, crsFunction, options) {
    createLineString(dataSource, geoJson, crsFunction, geometry.coordinates, options);
}
function processMultiLineString(dataSource, geoJson, geometry, crsFunction, options) {
    var lineStrings = geometry.coordinates;
    for (var i = 0; i < lineStrings.length; i++) {
        createLineString(dataSource, geoJson, crsFunction, lineStrings[i], options);
    }
}
function createPolygon(dataSource, geoJson, crsFunction, coordinates, options) {
    if (coordinates.length === 0 || coordinates[0].length === 0) {
        return;
    }
    var outlineColorProperty = options.strokeMaterialProperty.color;
    var material = options.fillMaterialProperty;
    var widthProperty = options.strokeWidthProperty;
    var properties = geoJson.properties;
    if (defined(properties)) {
        var width = properties['stroke-width'];
        if (defined(width)) {
            widthProperty = new ConstantProperty(width);
        }
        var color;
        var stroke = properties.stroke;
        if (defined(stroke)) {
            color = Color.fromCssColorString(stroke);
        }
        var opacity = properties['stroke-opacity'];
        if (defined(opacity) && opacity !== 1) {
            if (!defined(color)) {
                color = options.strokeMaterialProperty.color.clone();
            }
            color.alpha = opacity;
        }
        if (defined(color)) {
            outlineColorProperty = new ConstantProperty(color);
        }
        var fillColor;
        var fill = properties.fill;
        if (defined(fill)) {
            fillColor = Color.fromCssColorString(fill);
            fillColor.alpha = material.color.alpha;
        }
        opacity = properties['fill-opacity'];
        if (defined(opacity) && opacity !== material.color.alpha) {
            if (!defined(fillColor)) {
                fillColor = material.color.clone();
            }
            fillColor.alpha = opacity;
        }
        if (defined(fillColor)) {
            material = ColorMaterialProperty.fromColor(fillColor);
        }
    }
    var polygon = new PolygonGraphics();
    polygon.outline = new ConstantProperty(true);
    polygon.outlineColor = outlineColorProperty;
    polygon.outlineWidth = widthProperty;
    polygon.material = material;
    var holes = [];
    for (var i = 1, len = coordinates.length; i < len; i++) {
        holes.push(new PolygonHierarchy(coordinatesArrayToCartesianArray(coordinates[i], crsFunction)));
    }
    var positions = coordinates[0];
    polygon.hierarchy = new ConstantProperty(new PolygonHierarchy(coordinatesArrayToCartesianArray(positions, crsFunction), holes));
    if (positions[0].length > 2) {
        polygon.perPositionHeight = new ConstantProperty(true);
    }
    var entity = createObject(geoJson, dataSource._entityCollection);
    entity.polygon = polygon;
}
function processPolygon(dataSource, geoJson, geometry, crsFunction, options) {
    createPolygon(dataSource, geoJson, crsFunction, geometry.coordinates, options);
}
function processMultiPolygon(dataSource, geoJson, geometry, crsFunction, options) {
    var polygons = geometry.coordinates;
    for (var i = 0; i < polygons.length; i++) {
        createPolygon(dataSource, geoJson, crsFunction, polygons[i], options);
    }
}
function processTopology(dataSource, geoJson, geometry, crsFunction, options) {
    for (var property in geometry.objects) {
        if (geometry.objects.hasOwnProperty(property)) {
            var feature = topojson.feature(geometry, geometry.objects[property]);
            var typeHandler = geoJsonObjectTypes[feature.type];
            typeHandler(dataSource, feature, feature, crsFunction, options);
        }
    }
}
var geoJsonObjectTypes = {
        Feature: processFeature,
        FeatureCollection: processFeatureCollection,
        GeometryCollection: processGeometryCollection,
        LineString: processLineString,
        MultiLineString: processMultiLineString,
        MultiPoint: processMultiPoint,
        MultiPolygon: processMultiPolygon,
        Point: processPoint,
        Polygon: processPolygon,
        Topology: processTopology
    };
var geometryTypes = {
        GeometryCollection: processGeometryCollection,
        LineString: processLineString,
        MultiLineString: processMultiLineString,
        MultiPoint: processMultiPoint,
        MultiPolygon: processMultiPolygon,
        Point: processPoint,
        Polygon: processPolygon,
        Topology: processTopology
    };
var GeoJsonDataSource = function (name) {
    this._name = name;
    this._changed = new Event();
    this._error = new Event();
    this._isLoading = false;
    this._loading = new Event();
    this._entityCollection = new EntityCollection();
    this._promises = [];
    this._pinBuilder = new PinBuilder();
};
GeoJsonDataSource.fromUrl = function (url, options) {
    var result = new GeoJsonDataSource();
    result.loadUrl(url, options);
    return result;
};
defineProperties(GeoJsonDataSource, {
    markerSize: {
        get: function () {
            return defaultMarkerSize;
        },
        set: function (value) {
            defaultMarkerSize = value;
        }
    },
    markerSymbol: {
        get: function () {
            return defaultMarkerSymbol;
        },
        set: function (value) {
            defaultMarkerSymbol = value;
        }
    },
    markerColor: {
        get: function () {
            return defaultMarkerColor;
        },
        set: function (value) {
            defaultMarkerColor = value;
        }
    },
    stroke: {
        get: function () {
            return defaultStroke;
        },
        set: function (value) {
            defaultStroke = value;
            defaultStrokeMaterialProperty.color.setValue(value);
        }
    },
    strokeWidth: {
        get: function () {
            return defaultStrokeWidth;
        },
        set: function (value) {
            defaultStrokeWidth = value;
            defaultStrokeWidthProperty.setValue(value);
        }
    },
    fill: {
        get: function () {
            return defaultFill;
        },
        set: function (value) {
            defaultFill = value;
            defaultFillMaterialProperty = ColorMaterialProperty.fromColor(defaultFill);
        }
    },
    crsNames: {
        get: function () {
            return crsNames;
        }
    },
    crsLinkHrefs: {
        get: function () {
            return crsLinkHrefs;
        }
    },
    crsLinkTypes: {
        get: function () {
            return crsLinkTypes;
        }
    }
});
defineProperties(GeoJsonDataSource.prototype, {
    name: {
        get: function () {
            return this._name;
        }
    },
    clock: {
        value: undefined,
        writable: false
    },
    entities: {
        get: function () {
            return this._entityCollection;
        }
    },
    isLoading: {
        get: function () {
            return this._isLoading;
        }
    },
    changedEvent: {
        get: function () {
            return this._changed;
        }
    },
    errorEvent: {
        get: function () {
            return this._error;
        }
    },
    loadingEvent: {
        get: function () {
            return this._loading;
        }
    }
});
GeoJsonDataSource.prototype.refreshDescription = function (dynamicObject) {
    var geoJson = dynamicObject.geoJson;
    var properties = geoJson.properties;
    if (defined(properties)) {
        var key;
        var nameProperty;
        for (key in properties) {
            if (properties.hasOwnProperty(key) && properties[key]) {
                var upperKey = key.toUpperCase();
                if (upperKey === 'NAME' || upperKey === 'TITLE') {
                    nameProperty = key;
                    dynamicObject.name = properties[key];
                    break;
                }
            }
        }
        if (!defined(nameProperty)) {
            for (key in properties) {
                if (properties.hasOwnProperty(key) && properties[key]) {
                    if (/name/i.test(key) || /title/i.test(key)) {
                        nameProperty = key;
                        dynamicObject.name = properties[key];
                        break;
                    }
                }
            }
        }
        var description = describe(properties, nameProperty);
        dynamicObject.description = {
            getValue: function () {
                return description;
            }
        };
    }
};
GeoJsonDataSource.prototype.loadUrl = function (url, options) {
    if (!defined(url)) {
        throw new DeveloperError('url is required.');
    }
    DataSource.setLoading(this, true);
    var that = this;
    return when(loadJson(url), function (geoJson) {
        return load(that, geoJson, url, options);
    }).otherwise(function (error) {
        DataSource.setLoading(that, false);
        that._error.raiseEvent(that, error);
        return when.reject(error);
    });
};
GeoJsonDataSource.prototype.load = function (geoJson, options) {
    if (!defined(geoJson)) {
        throw new DeveloperError('geoJson is required.');
    }
    return load(this, geoJson, undefined, options);
};
function load(that, geoJson, sourceUri, options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    sourceUri = defaultValue(sourceUri, options.sourceUri);
    options = {
        markerSize: defaultValue(options.markerSize, defaultMarkerSize),
        markerSymbol: defaultValue(options.markerSymbol, defaultMarkerSymbol),
        markerColor: defaultValue(options.markerColor, defaultMarkerColor),
        strokeWidthProperty: new ConstantProperty(defaultValue(options.strokeWidth, defaultStrokeWidth)),
        strokeMaterialProperty: ColorMaterialProperty.fromColor(defaultValue(options.stroke, defaultStroke)),
        fillMaterialProperty: ColorMaterialProperty.fromColor(defaultValue(options.fill, defaultFill))
    };
    var name;
    if (defined(sourceUri)) {
        name = getFilenameFromUri(sourceUri);
    }
    if (defined(name) && that._name !== name) {
        that._name = name;
        that._changed.raiseEvent(that);
    }
    var typeHandler = geoJsonObjectTypes[geoJson.type];
    if (!defined(typeHandler)) {
        throw new DeveloperError('Unsupported GeoJSON object type: ' + geoJson.type);
    }
    var crsFunction = defaultCrsFunction;
    var crs = geoJson.crs;
    if (defined(crs)) {
        if (crs === null) {
            throw new RuntimeError('crs is null.');
        }
        if (!defined(crs.properties)) {
            throw new RuntimeError('crs.properties is undefined.');
        }
        var properties = crs.properties;
        if (crs.type === 'name') {
            crsFunction = crsNames[properties.name];
            if (!defined(crsFunction)) {
                throw new RuntimeError('Unknown crs name: ' + properties.name);
            }
        } else if (crs.type === 'link') {
            var handler = crsLinkHrefs[properties.href];
            if (!defined(handler)) {
                handler = crsLinkTypes[properties.type];
            }
            if (!defined(handler)) {
                throw new RuntimeError('Unable to resolve crs link: ' + JSON.stringify(properties));
            }
            crsFunction = handler(properties);
        } else if (crs.type === 'EPSG') {
            crsFunction = crsNames['EPSG:' + properties.code];
            if (!defined(crsFunction)) {
                throw new RuntimeError('Unknown crs EPSG code: ' + properties.code);
            }
        } else {
            throw new RuntimeError('Unknown crs type: ' + crs.type);
        }
    }
    DataSource.setLoading(that, true);
    return when(crsFunction, function (crsFunction) {
        that._entityCollection.removeAll();
        typeHandler(that, geoJson, geoJson, crsFunction, options);
        return when.all(that._promises, function () {
            that._promises.length = 0;
            DataSource.setLoading(that, false);
        });
    }).otherwise(function (error) {
        DataSource.setLoading(that, false);
        that._error.raiseEvent(that, error);
        return when.reject(error);
    });
}
module.exports = GeoJsonDataSource;
},{"../Core/Cartesian3":102,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/PinBuilder":180,"../Core/PolygonHierarchy":185,"../Core/RuntimeError":207,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/getFilenameFromUri":250,"../Core/loadJson":261,"../Scene/VerticalOrigin":454,"../ThirdParty/topojson":595,"../ThirdParty/when":596,"./BillboardGraphics":274,"./CallbackProperty":277,"./ColorMaterialProperty":278,"./ConstantPositionProperty":282,"./ConstantProperty":283,"./DataSource":287,"./EntityCollection":296,"./PolygonGraphics":313,"./PolylineGraphics":316}],299:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), ColorMaterialProperty = require('./ColorMaterialProperty'), StaticGeometryColorBatch = require('./StaticGeometryColorBatch'), StaticGeometryPerMaterialBatch = require('./StaticGeometryPerMaterialBatch'), StaticOutlineGeometryBatch = require('./StaticOutlineGeometryBatch');
'use strict';
var emptyArray = [];
var DynamicGeometryBatch = function (primitives) {
    this._primitives = primitives;
    this._dynamicUpdaters = new AssociativeArray();
};
DynamicGeometryBatch.prototype.add = function (time, updater) {
    this._dynamicUpdaters.set(updater.entity.id, updater.createDynamicUpdater(this._primitives));
};
DynamicGeometryBatch.prototype.remove = function (updater) {
    var id = updater.entity.id;
    var dynamicUpdater = this._dynamicUpdaters.get(id);
    if (defined(dynamicUpdater)) {
        this._dynamicUpdaters.remove(id);
        dynamicUpdater.destroy();
    }
};
DynamicGeometryBatch.prototype.update = function (time) {
    var geometries = this._dynamicUpdaters.values;
    for (var i = 0, len = geometries.length; i < len; i++) {
        geometries[i].update(time);
    }
    return true;
};
DynamicGeometryBatch.prototype.removeAllPrimitives = function () {
    var geometries = this._dynamicUpdaters.values;
    for (var i = 0, len = geometries.length; i < len; i++) {
        geometries[i].destroy();
    }
    this._dynamicUpdaters.removeAll();
};
function removeUpdater(that, updater) {
    that._outlineBatch.remove(updater);
    that._closedColorBatch.remove(updater);
    that._closedMaterialBatch.remove(updater);
    that._openColorBatch.remove(updater);
    that._openMaterialBatch.remove(updater);
    that._dynamicBatch.remove(updater);
}
function insertUpdaterIntoBatch(that, time, updater) {
    if (updater.isDynamic) {
        that._dynamicBatch.add(time, updater);
        return;
    }
    if (updater.outlineEnabled) {
        that._outlineBatch.add(time, updater);
    }
    if (updater.fillEnabled) {
        if (updater.isClosed) {
            if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {
                that._closedColorBatch.add(time, updater);
            } else {
                that._closedMaterialBatch.add(time, updater);
            }
        } else {
            if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {
                that._openColorBatch.add(time, updater);
            } else {
                that._openMaterialBatch.add(time, updater);
            }
        }
    }
}
var GeometryVisualizer = function (type, scene, entityCollection) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(entityCollection)) {
        throw new DeveloperError('entityCollection is required.');
    }
    this._type = type;
    var primitives = scene.primitives;
    this._scene = scene;
    this._primitives = primitives;
    this._entityCollection = undefined;
    this._addedObjects = new AssociativeArray();
    this._removedObjects = new AssociativeArray();
    this._changedObjects = new AssociativeArray();
    this._outlineBatch = new StaticOutlineGeometryBatch(primitives, scene);
    this._closedColorBatch = new StaticGeometryColorBatch(primitives, type.perInstanceColorAppearanceType, true);
    this._closedMaterialBatch = new StaticGeometryPerMaterialBatch(primitives, type.materialAppearanceType, true);
    this._openColorBatch = new StaticGeometryColorBatch(primitives, type.perInstanceColorAppearanceType, false);
    this._openMaterialBatch = new StaticGeometryPerMaterialBatch(primitives, type.materialAppearanceType, false);
    this._dynamicBatch = new DynamicGeometryBatch(primitives);
    this._subscriptions = new AssociativeArray();
    this._updaters = new AssociativeArray();
    this._entityCollection = entityCollection;
    entityCollection.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);
    this._onCollectionChanged(entityCollection, entityCollection.entities, emptyArray);
};
GeometryVisualizer.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var addedObjects = this._addedObjects;
    var added = addedObjects.values;
    var removedObjects = this._removedObjects;
    var removed = removedObjects.values;
    var changedObjects = this._changedObjects;
    var changed = changedObjects.values;
    var i;
    var entity;
    var id;
    var updater;
    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        id = entity.id;
        updater = this._updaters.get(id);
        removeUpdater(this, updater);
        updater.destroy();
        this._updaters.remove(id);
        this._subscriptions.get(id)();
        this._subscriptions.remove(id);
    }
    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        id = entity.id;
        updater = new this._type(entity, this._scene);
        this._updaters.set(id, updater);
        insertUpdaterIntoBatch(this, time, updater);
        this._subscriptions.set(id, updater.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged, this));
    }
    for (i = changed.length - 1; i > -1; i--) {
        entity = changed[i];
        id = entity.id;
        updater = this._updaters.get(id);
        removeUpdater(this, updater);
        insertUpdaterIntoBatch(this, time, updater);
    }
    addedObjects.removeAll();
    removedObjects.removeAll();
    changedObjects.removeAll();
    var isUpdated = this._closedColorBatch.update(time);
    isUpdated = this._closedMaterialBatch.update(time) && isUpdated;
    isUpdated = this._openColorBatch.update(time) && isUpdated;
    isUpdated = this._openMaterialBatch.update(time) && isUpdated;
    isUpdated = this._dynamicBatch.update(time) && isUpdated;
    isUpdated = this._outlineBatch.update(time) && isUpdated;
    return isUpdated;
};
GeometryVisualizer.prototype.isDestroyed = function () {
    return false;
};
GeometryVisualizer.prototype.destroy = function () {
    this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);
    this._addedObjects.removeAll();
    this._removedObjects.removeAll();
    this._outlineBatch.removeAllPrimitives();
    this._closedColorBatch.removeAllPrimitives();
    this._closedMaterialBatch.removeAllPrimitives();
    this._openColorBatch.removeAllPrimitives();
    this._openMaterialBatch.removeAllPrimitives();
    this._dynamicBatch.removeAllPrimitives();
    var subscriptions = this._subscriptions.values;
    var len = subscriptions.length;
    for (var i = 0; i < len; i++) {
        subscriptions[i]();
    }
    this._subscriptions.removeAll();
    return destroyObject(this);
};
GeometryVisualizer._onGeometryChanged = function (updater) {
    var removedObjects = this._removedObjects;
    var changedObjects = this._changedObjects;
    var entity = updater.entity;
    var id = entity.id;
    if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {
        changedObjects.set(id, entity);
    }
};
GeometryVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed) {
    var addedObjects = this._addedObjects;
    var removedObjects = this._removedObjects;
    var changedObjects = this._changedObjects;
    var i;
    var id;
    var entity;
    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        id = entity.id;
        if (!addedObjects.remove(id)) {
            removedObjects.set(id, entity);
            changedObjects.remove(id);
        }
    }
    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        id = entity.id;
        if (removedObjects.remove(id)) {
            changedObjects.set(id, entity);
        } else {
            addedObjects.set(id, entity);
        }
    }
};
module.exports = GeometryVisualizer;
},{"../Core/AssociativeArray":93,"../Core/DeveloperError":123,"../Core/defined":245,"../Core/destroyObject":247,"./ColorMaterialProperty":278,"./StaticGeometryColorBatch":327,"./StaticGeometryPerMaterialBatch":328,"./StaticOutlineGeometryBatch":329}],300:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Color = require('../Core/Color'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor'), Property = require('./Property');
'use strict';
var defaultColor = Color.WHITE;
var defaultCellAlpha = 0.1;
var defaultLineCount = new Cartesian2(8, 8);
var defaultLineOffset = new Cartesian2(0, 0);
var defaultLineThickness = new Cartesian2(1, 1);
var GridMaterialProperty = function () {
    this._definitionChanged = new Event();
    this._color = undefined;
    this._colorSubscription = undefined;
    this._cellAlpha = undefined;
    this._cellAlphaSubscription = undefined;
    this._lineCount = undefined;
    this._lineCountSubscription = undefined;
    this._lineThickness = undefined;
    this._lineThicknessSubscription = undefined;
    this._lineOffset = undefined;
    this._lineOffsetSubscription = undefined;
    this.color = undefined;
    this.cellAlpha = undefined;
    this.lineCount = undefined;
    this.lineThickness = undefined;
    this.lineOffset = undefined;
};
defineProperties(GridMaterialProperty.prototype, {
    isConstant: {
        get: function () {
            return Property.isConstant(this._color) && Property.isConstant(this._cellAlpha) && Property.isConstant(this._lineCount) && Property.isConstant(this._lineThickness) && Property.isConstant(this._lineOffset);
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    color: createPropertyDescriptor('color'),
    cellAlpha: createPropertyDescriptor('cellAlpha'),
    lineCount: createPropertyDescriptor('lineCount'),
    lineThickness: createPropertyDescriptor('lineThickness'),
    lineOffset: createPropertyDescriptor('lineOffset')
});
GridMaterialProperty.prototype.getType = function (time) {
    return 'Grid';
};
GridMaterialProperty.prototype.getValue = function (time, result) {
    if (!defined(result)) {
        result = {};
    }
    result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
    result.cellAlpha = Property.getValueOrDefault(this._cellAlpha, time, defaultCellAlpha);
    result.lineCount = Property.getValueOrClonedDefault(this._lineCount, time, defaultLineCount, result.lineCount);
    result.lineThickness = Property.getValueOrClonedDefault(this._lineThickness, time, defaultLineThickness, result.lineThickness);
    result.lineOffset = Property.getValueOrClonedDefault(this._lineOffset, time, defaultLineOffset, result.lineOffset);
    return result;
};
GridMaterialProperty.prototype.equals = function (other) {
    return this === other || other instanceof GridMaterialProperty && Property.equals(this._color, other._color) && Property.equals(this._cellAlpha, other._cellAlpha) && Property.equals(this._lineCount, other._lineCount) && Property.equals(this._lineThickness, other._lineThickness) && Property.equals(this._lineOffset, other._lineOffset);
};
module.exports = GridMaterialProperty;
},{"../Core/Cartesian2":101,"../Core/Color":111,"../Core/Event":138,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321,"./createPropertyDescriptor":336}],301:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor'), Property = require('./Property');
'use strict';
var defaultRepeat = new Cartesian2(1, 1);
var ImageMaterialProperty = function () {
    this._definitionChanged = new Event();
    this._image = undefined;
    this._imageSubscription = undefined;
    this._repeat = undefined;
    this._repeatSubscription = undefined;
};
defineProperties(ImageMaterialProperty.prototype, {
    isConstant: {
        get: function () {
            return Property.isConstant(this._image) && Property.isConstant(this._repeat);
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    image: createPropertyDescriptor('image'),
    repeat: createPropertyDescriptor('repeat')
});
ImageMaterialProperty.prototype.getType = function (time) {
    return 'Image';
};
ImageMaterialProperty.prototype.getValue = function (time, result) {
    if (!defined(result)) {
        result = {};
    }
    result.image = Property.getValueOrUndefined(this._image, time);
    result.repeat = Property.getValueOrClonedDefault(this._repeat, time, defaultRepeat, result.repeat);
    return result;
};
ImageMaterialProperty.prototype.equals = function (other) {
    return this === other || other instanceof ImageMaterialProperty && Property.equals(this._image, other._image) && Property.equals(this._repeat, other._repeat);
};
module.exports = ImageMaterialProperty;
},{"../Core/Cartesian2":101,"../Core/Event":138,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321,"./createPropertyDescriptor":336}],302:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartographic = require('../Core/Cartographic'), ClockRange = require('../Core/ClockRange'), ClockStep = require('../Core/ClockStep'), Color = require('../Core/Color'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Ellipsoid = require('../Core/Ellipsoid'), Event = require('../Core/Event'), getFilenameFromUri = require('../Core/getFilenameFromUri'), Iso8601 = require('../Core/Iso8601'), JulianDate = require('../Core/JulianDate'), loadBlob = require('../Core/loadBlob'), loadXML = require('../Core/loadXML'), CesiumMath = require('../Core/Math'), NearFarScalar = require('../Core/NearFarScalar'), PinBuilder = require('../Core/PinBuilder'), PolygonHierarchy = require('../Core/PolygonHierarchy'), Rectangle = require('../Core/Rectangle'), RuntimeError = require('../Core/RuntimeError'), TimeInterval = require('../Core/TimeInterval'), TimeIntervalCollection = require('../Core/TimeIntervalCollection'), LabelStyle = require('../Scene/LabelStyle'), VerticalOrigin = require('../Scene/VerticalOrigin'), Uri = require('../ThirdParty/Uri'), when = require('../ThirdParty/when'), zip = require('../ThirdParty/zip'), BillboardGraphics = require('./BillboardGraphics'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantPositionProperty = require('./ConstantPositionProperty'), ConstantProperty = require('./ConstantProperty'), DataSource = require('./DataSource'), DataSourceClock = require('./DataSourceClock'), Entity = require('./Entity'), EntityCollection = require('./EntityCollection'), ImageMaterialProperty = require('./ImageMaterialProperty'), LabelGraphics = require('./LabelGraphics'), PolygonGraphics = require('./PolygonGraphics'), PolylineGraphics = require('./PolylineGraphics'), PolylineOutlineMaterialProperty = require('./PolylineOutlineMaterialProperty'), RectangleGraphics = require('./RectangleGraphics'), SampledPositionProperty = require('./SampledPositionProperty');
'use strict';
var parser = new DOMParser();
var scratchCartographic = new Cartographic();
var scratchCartesian = new Cartesian3();
function isZipFile(blob) {
    if (blob.size < 4) {
        return false;
    }
    var magicBlob = blob.slice(0, 4);
    var deferred = when.defer();
    var reader = new FileReader();
    reader.addEventListener('load', function () {
        deferred.resolve(new DataView(reader.result).getUint32(0, false) === 1347093252);
    });
    reader.addEventListener('error', function () {
        deferred.reject(new RuntimeError('Error reading blob.'));
    });
    reader.readAsArrayBuffer(magicBlob);
    return deferred;
}
var readBlob = {
        asText: function (blob) {
            var deferred = when.defer();
            var reader = new FileReader();
            reader.addEventListener('load', function () {
                deferred.resolve(reader.result);
            });
            reader.addEventListener('error', function () {
                deferred.reject(new RuntimeError('Error reading blob as text.'));
            });
            reader.readAsText(blob);
            return deferred;
        }
    };
function loadXmlFromZip(reader, entry, uriResolver, deferred) {
    entry.getData(new zip.TextWriter(), function (text) {
        uriResolver.kml = parser.parseFromString(text, 'application/xml');
        deferred.resolve();
    }, function (current, total) {
    });
}
function loadDataUriFromZip(reader, entry, uriResolver, deferred) {
    entry.getData(new zip.Data64URIWriter(), function (dataUri) {
        uriResolver[entry.filename] = dataUri;
        deferred.resolve();
    }, function (current, total) {
    });
}
function proxyUrl(url, proxy) {
    if (defined(proxy)) {
        if (new Uri(url).scheme) {
            url = proxy.getURL(url);
        }
    }
    return url;
}
function createId(node) {
    return defined(node) && defined(node.id) && node.id.length !== 0 ? node.id : createGuid();
}
function readCoordinate(element, altitudeMode) {
    var baseHeight = 0;
    switch (altitudeMode) {
    case 'absolute':
        break;
    case 'relativeToGround':
        break;
    case 'clampToGround ':
        break;
    default:
        break;
    }
    var digits = element.textContent.trim().split(/[\s,\n]+/g);
    scratchCartographic = Cartographic.fromDegrees(digits[0], digits[1], defined(digits[2]) ? parseFloat(digits[2]) : 0, scratchCartographic);
    return Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic);
}
function readCoordinates(element) {
    var tuples = element.textContent.trim().split(/[\s\n]+/g);
    var numberOfCoordinates = tuples.length;
    var result = new Array(numberOfCoordinates);
    var resultIndex = 0;
    for (var i = 0; i < tuples.length; i++) {
        var coordinates = tuples[i].split(/[\s,\n]+/g);
        scratchCartographic = Cartographic.fromDegrees(parseFloat(coordinates[0]), parseFloat(coordinates[1]), defined(coordinates[2]) ? parseFloat(coordinates[2]) : 0, scratchCartographic);
        result[resultIndex++] = Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic);
    }
    return result;
}
var namespaces = {
        kml: [
            null,
            undefined,
            'http://www.opengis.net/kml/2.2',
            'http://earth.google.com/kml/2.2',
            'http://earth.google.com/kml/2.1',
            'http://earth.google.com/kml/2.0'
        ],
        gx: ['http://www.google.com/kml/ext/2.2'],
        atom: ['http://www.w3.org/2005/Atom']
    };
function queryFirstNode(node, tagName, namespace) {
    var childNodes = node.childNodes;
    var length = childNodes.length;
    for (var q = 0; q < length; q++) {
        var child = childNodes[q];
        if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {
            return child;
        }
    }
    return undefined;
}
function queryNodes(node, tagName, namespace) {
    var result = [];
    var childNodes = node.getElementsByTagName(tagName);
    var length = childNodes.length;
    for (var q = 0; q < length; q++) {
        var child = childNodes[q];
        if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {
            result.push(child);
        }
    }
    return result;
}
function queryChildNodes(node, tagName, namespace) {
    var result = [];
    var childNodes = node.childNodes;
    var length = childNodes.length;
    for (var q = 0; q < length; q++) {
        var child = childNodes[q];
        if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {
            result.push(child);
        }
    }
    return result;
}
function queryNumericValue(node, tagName, namespace) {
    var resultNode = queryFirstNode(node, tagName, namespace);
    if (defined(resultNode)) {
        var result = parseFloat(resultNode.textContent);
        return !isNaN(result) ? result : undefined;
    }
    return undefined;
}
function queryStringValue(node, tagName, namespace) {
    var result = queryFirstNode(node, tagName, namespace);
    if (defined(result)) {
        return result.textContent;
    }
    return undefined;
}
function queryBooleanValue(node, tagName, namespace) {
    var result = queryFirstNode(node, tagName, namespace);
    if (defined(result)) {
        return result.textContent === '1';
    }
    return undefined;
}
function resolveHref(href, dataSource, sourceUri, uriResolver) {
    var hrefResolved = false;
    if (defined(uriResolver)) {
        var blob = uriResolver[href];
        if (defined(blob)) {
            hrefResolved = true;
            href = blob;
        }
    }
    if (!hrefResolved && defined(sourceUri)) {
        var baseUri = new Uri(document.location.href);
        sourceUri = new Uri(sourceUri);
        href = new Uri(href).resolve(sourceUri.resolve(baseUri)).toString();
        href = proxyUrl(href, dataSource._proxy);
    }
    return href;
}
var colorOptions = {};
function queryColorValue(node, tagName, namespace) {
    var colorString = queryStringValue(node, tagName, namespace);
    if (!defined(colorString)) {
        return;
    }
    var alpha = parseInt(colorString.substring(0, 2), 16) / 255;
    var blue = parseInt(colorString.substring(2, 4), 16) / 255;
    var green = parseInt(colorString.substring(4, 6), 16) / 255;
    var red = parseInt(colorString.substring(6, 8), 16) / 255;
    if (queryStringValue(node, 'colorMode', namespace) !== 'random') {
        return new Color(red, green, blue, alpha);
    }
    if (red > 0) {
        colorOptions.maximumRed = red;
    } else {
        colorOptions.red = 0;
    }
    if (green > 0) {
        colorOptions.maximumGreen = green;
    } else {
        colorOptions.green = 0;
    }
    if (blue > 0) {
        colorOptions.maximumBlue = blue;
    } else {
        colorOptions.blue = 0;
    }
    colorOptions.alpha = alpha;
    return Color.fromRandom(colorOptions);
}
function processTimeSpan(node) {
    var result;
    var beginNode = queryFirstNode(node, 'begin', namespaces.kml);
    var beginDate = defined(beginNode) ? JulianDate.fromIso8601(beginNode.textContent) : undefined;
    var endNode = queryFirstNode(node, 'end', namespaces.kml);
    var endDate = defined(endNode) ? JulianDate.fromIso8601(endNode.textContent) : undefined;
    if (defined(beginDate) && defined(endDate)) {
        if (JulianDate.lessThan(endDate, beginDate)) {
            var tmp = beginDate;
            beginDate = endDate;
            endDate = tmp;
        }
        result = new TimeIntervalCollection();
        result.addInterval(new TimeInterval({
            start: beginDate,
            stop: endDate
        }));
    } else if (defined(beginDate)) {
        result = new TimeIntervalCollection();
        result.addInterval(new TimeInterval({
            start: beginDate,
            stop: Iso8601.MAXIMUM_VALUE
        }));
    } else if (defined(endDate)) {
        result = new TimeIntervalCollection();
        result.addInterval(new TimeInterval({
            start: Iso8601.MINIMUM_VALUE,
            stop: endDate
        }));
    }
    return result;
}
function createDefaultBillboard(dataSource) {
    var billboard = new BillboardGraphics();
    billboard.width = new ConstantProperty(32);
    billboard.height = new ConstantProperty(32);
    billboard.scaleByDistance = new ConstantProperty(new NearFarScalar(2414016, 1, 16093000, 0.1));
    return billboard;
}
function createDefaultLabel() {
    var label = new LabelGraphics();
    label.translucencyByDistance = new ConstantProperty(new NearFarScalar(1500000, 1, 3400000, 0));
    label.scale = new ConstantProperty(1);
    label.fillColor = new ConstantProperty(Color.WHITE);
    label.pixelOffset = new ConstantProperty(new Cartesian2(0, -16));
    label.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);
    label.font = new ConstantProperty('16pt sans-serif');
    label.style = new ConstantProperty(LabelStyle.FILL_AND_OUTLINE);
    return label;
}
function applyStyle(dataSource, styleNode, targetEntity, sourceUri, uriResolver) {
    for (var i = 0, len = styleNode.childNodes.length; i < len; i++) {
        var node = styleNode.childNodes.item(i);
        var material;
        if (node.nodeName === 'IconStyle') {
            var scale = queryNumericValue(node, 'scale', namespaces.kml);
            var color = queryColorValue(node, 'color', namespaces.kml);
            var iconNode = queryFirstNode(node, 'Icon', namespaces.kml);
            var href = defined(iconNode) ? queryStringValue(iconNode, 'href', namespaces.kml) : undefined;
            var icon = defined(href) ? resolveHref(href, dataSource, sourceUri, uriResolver) : undefined;
            var billboard = targetEntity.billboard;
            if (!defined(billboard)) {
                billboard = createDefaultBillboard(dataSource);
                targetEntity.billboard = billboard;
            }
            if (defined(icon)) {
                billboard.image = new ConstantProperty(icon);
            }
            if (defined(scale)) {
                billboard.scale = new ConstantProperty(scale);
            }
            if (defined(color)) {
                billboard.color = new ConstantProperty(color);
            }
        } else if (node.nodeName === 'LabelStyle') {
            var label = defined(targetEntity.label) ? targetEntity.label : new LabelGraphics();
            var labelScale = queryNumericValue(node, 'scale', namespaces.kml);
            var labelColor = queryColorValue(node, 'color', namespaces.kml);
            label.translucencyByDistance = new ConstantProperty(new NearFarScalar(1500000, 1, 3400000, 0));
            label.scale = defined(labelScale) ? new ConstantProperty(labelScale) : new ConstantProperty(1);
            label.fillColor = defined(labelColor) ? new ConstantProperty(labelColor) : new ConstantProperty(Color.WHITE);
            label.text = defined(targetEntity.name) ? new ConstantProperty(targetEntity.name) : undefined;
            label.pixelOffset = new ConstantProperty(new Cartesian2(0, -16));
            label.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);
            label.font = new ConstantProperty('16pt sans-serif');
            label.style = new ConstantProperty(LabelStyle.FILL_AND_OUTLINE);
            targetEntity.label = label;
        } else if (node.nodeName === 'LineStyle') {
            var polyline = defined(targetEntity.polyline) ? targetEntity.polyline : new PolylineGraphics();
            var lineColor = queryColorValue(node, 'color', namespaces.kml);
            var lineWidth = queryNumericValue(node, 'width', namespaces.kml);
            polyline.width = defined(lineWidth) ? new ConstantProperty(Math.max(lineWidth, 1)) : new ConstantProperty(1);
            material = new PolylineOutlineMaterialProperty();
            material.color = defined(lineColor) ? new ConstantProperty(lineColor) : new ConstantProperty(Color.WHITE);
            material.outlineWidth = new ConstantProperty(0);
            polyline.material = material;
            targetEntity.polyline = polyline;
        } else if (node.nodeName === 'PolyStyle') {
            targetEntity.polygon = defined(targetEntity.polygon) ? targetEntity.polygon : new PolygonGraphics();
            var polygonColor = queryColorValue(node, 'color', namespaces.kml);
            polygonColor = defined(polygonColor) ? polygonColor : Color.WHITE;
            material = new ColorMaterialProperty();
            material.color = new ConstantProperty(polygonColor);
            targetEntity.polygon.material = material;
            var fill = queryBooleanValue(node, 'fill', namespaces.kml);
            if (defined(fill)) {
                targetEntity.polygon.fill = new ConstantProperty(fill);
            }
            var outline = queryBooleanValue(node, 'outline', namespaces.kml);
            if (defined(outline)) {
                targetEntity.polygon.outline = new ConstantProperty(outline);
            }
        }
    }
}
function computeFinalStyle(entity, dataSource, placeMark, styleCollection, sourceUri, uriResolver) {
    var result = new Entity();
    var inlineStyles = queryChildNodes(placeMark, 'Style', namespaces.kml);
    var inlineStylesLength = inlineStyles.length;
    if (inlineStylesLength > 0) {
        applyStyle(dataSource, inlineStyles[inlineStylesLength - 1], result, sourceUri, uriResolver);
    }
    var externalStyle = queryFirstNode(placeMark, 'styleUrl', namespaces.kml);
    if (defined(externalStyle)) {
        var styleEntity = styleCollection.getById(externalStyle.textContent);
        if (typeof styleEntity !== 'undefined') {
            result.merge(styleEntity);
        }
    }
    if (!defined(result.billboard)) {
        result.billboard = createDefaultBillboard();
    }
    if (!defined(result.billboard.image)) {
        result.billboard.image = new ConstantProperty(dataSource._pinBuilder.fromColor(Color.YELLOW, 64).toDataURL());
    }
    if (defined(entity.name)) {
        entity.label = result.label ? result.label.clone() : createDefaultLabel();
        entity.label.text = new ConstantProperty(entity.name);
    }
    return result;
}
function processExternalStyles(dataSource, uri, styleCollection) {
    return when(loadXML(proxyUrl(uri, dataSource._proxy)), function (styleKml) {
        return processStyles(dataSource, styleKml, styleCollection, uri, true);
    });
}
function processStyles(dataSource, kml, styleCollection, sourceUri, isExternal, uriResolver) {
    var i;
    var id;
    var styleEntity;
    var styleNodes = queryNodes(kml, 'Style', namespaces.kml);
    var styleNodesLength = styleNodes.length;
    for (i = 0; i < styleNodesLength; i++) {
        var node = styleNodes[i];
        var attributes = node.attributes;
        id = defined(attributes.id) ? attributes.id.value : undefined;
        if (defined(id)) {
            id = '#' + id;
            if (isExternal && defined(sourceUri)) {
                id = sourceUri + id;
            }
            if (!defined(styleCollection.getById(id))) {
                styleEntity = new Entity(id);
                styleCollection.add(styleEntity);
                applyStyle(dataSource, node, styleEntity, sourceUri, uriResolver);
            }
        }
    }
    var styleMaps = queryNodes(kml, 'StyleMap', namespaces.kml);
    var styleMapsLength = styleMaps.length;
    for (i = 0; i < styleMapsLength; i++) {
        var styleMap = styleMaps[i];
        id = defined(styleMap.attributes.id) ? styleMap.attributes.id.value : undefined;
        if (defined(id)) {
            var pairs = styleMap.childNodes;
            for (var p = 0; p < pairs.length; p++) {
                var pair = pairs[p];
                if (pair.nodeName !== 'Pair') {
                    continue;
                }
                if (queryStringValue(pair, 'key', namespaces.kml) === 'normal') {
                    var styleUrl = queryStringValue(pair, 'styleUrl', namespaces.kml);
                    id = '#' + id;
                    if (isExternal && defined(sourceUri)) {
                        id = sourceUri + id;
                    }
                    if (!defined(styleCollection.getById(id))) {
                        styleEntity = styleCollection.getOrCreateEntity(id);
                        var base = styleCollection.getOrCreateEntity(styleUrl);
                        if (defined(base)) {
                            styleEntity.merge(base);
                        }
                    }
                    break;
                }
            }
        }
    }
    var externalStyleHash = {};
    var promises = [];
    var styleUrlNodes = kml.getElementsByTagName('styleUrl');
    var styleUrlNodesLength = styleUrlNodes.length;
    for (i = 0; i < styleUrlNodesLength; i++) {
        var styleReference = styleUrlNodes[i].textContent;
        if (styleReference[0] !== '#') {
            var tokens = styleReference.split('#');
            if (tokens.length !== 2) {
                throw new RuntimeError('Unable to parse style: ' + styleReference);
            }
            var uri = tokens[0];
            if (!defined(externalStyleHash[uri])) {
                if (defined(sourceUri)) {
                    var baseUri = new Uri(document.location.href);
                    sourceUri = new Uri(sourceUri);
                    uri = new Uri(uri).resolve(sourceUri.resolve(baseUri)).toString();
                }
                promises.push(processExternalStyles(dataSource, uri, styleCollection, sourceUri));
            }
        }
    }
    return promises;
}
function processPoint(dataSource, geometryNode, entity, styleEntity) {
    var coordinatesNode = queryFirstNode(geometryNode, 'coordinates', namespaces.kml);
    if (defined(coordinatesNode)) {
        var position = readCoordinate(coordinatesNode, queryStringValue(geometryNode, 'altitudeMode', namespaces.kml));
        if (defined(position)) {
            entity.position = new ConstantPositionProperty(position);
        }
    }
    entity.billboard = styleEntity.billboard;
}
function processLineStringOrLinearRing(dataSource, geometryNode, entity, styleEntity) {
    var polyline = defined(styleEntity.polyline) ? styleEntity.polyline.clone() : new PolylineGraphics();
    entity.polyline = polyline;
    var coordinatesNode = queryFirstNode(geometryNode, 'coordinates', namespaces.kml);
    if (defined(coordinatesNode)) {
        var coordinates = readCoordinates(coordinatesNode);
        if (defined(coordinates)) {
            polyline.positions = new ConstantProperty(coordinates);
        }
    }
}
function processPolygon(dataSource, geometryNode, entity, styleEntity) {
    var polygon = defined(styleEntity.polygon) ? styleEntity.polygon.clone() : new PolygonGraphics();
    polygon.outline = new ConstantProperty(true);
    polygon.outlineColor = defined(styleEntity.polyline) ? styleEntity.polyline.material.color : new ConstantProperty(Color.WHITE);
    polygon.outlineWidth = defined(styleEntity.polyline) ? styleEntity.polyline.width : undefined;
    entity.polygon = polygon;
    var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);
    if (defined(altitudeMode) && altitudeMode !== 'clampToGround' && altitudeMode !== 'clampToSeaFloor') {
        polygon.perPositionHeight = new ConstantProperty(true);
    }
    if (defaultValue(queryBooleanValue(geometryNode, 'extrude', namespaces.kml), false)) {
        polygon.extrudedHeight = new ConstantProperty(0);
    }
    var outerBoundaryIsNode = queryFirstNode(geometryNode, 'outerBoundaryIs', namespaces.kml);
    var linearRingNode = queryFirstNode(outerBoundaryIsNode, 'LinearRing', namespaces.kml);
    var coordinatesNode = queryFirstNode(linearRingNode, 'coordinates', namespaces.kml);
    if (defined(coordinatesNode)) {
        var coordinates = readCoordinates(coordinatesNode);
        if (defined(coordinates)) {
            var hierarchy = new PolygonHierarchy(coordinates);
            var innerBoundaryIsNodes = queryChildNodes(geometryNode, 'innerBoundaryIs', namespaces.kml);
            for (var j = 0; j < innerBoundaryIsNodes.length; j++) {
                linearRingNode = queryChildNodes(innerBoundaryIsNodes[j], 'LinearRing', namespaces.kml);
                for (var k = 0; k < linearRingNode.length; k++) {
                    coordinatesNode = queryFirstNode(linearRingNode[k], 'coordinates', namespaces.kml);
                    if (defined(coordinatesNode)) {
                        coordinates = readCoordinates(coordinatesNode);
                        if (defined(coordinates)) {
                            hierarchy.holes.push(new PolygonHierarchy(coordinates));
                        }
                    }
                }
            }
            polygon.hierarchy = new ConstantProperty(hierarchy);
        }
    }
}
function processTrack(dataSource, geometryNode, entity, styleEntity) {
    var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);
    var coordNodes = queryChildNodes(geometryNode, 'coord', namespaces.gx);
    var timeNodes = queryChildNodes(geometryNode, 'when', namespaces.kml);
    var coordinates = new Array(coordNodes.length);
    var times = new Array(timeNodes.length);
    for (var i = 0; i < times.length; i++) {
        coordinates[i] = readCoordinate(coordNodes[i], altitudeMode);
        times[i] = JulianDate.fromIso8601(timeNodes[i].textContent);
    }
    var property = new SampledPositionProperty();
    property.addSamples(times, coordinates);
    entity.position = property;
    entity.billboard = styleEntity.billboard;
}
function processMultiTrack(dataSource, geometryNode, entity, styleEntity) {
    var trackNodes = queryChildNodes(geometryNode, 'Track', namespaces.gx);
    for (var i = 0, len = trackNodes.length; i < len; i++) {
        var trackNode = trackNodes[i];
        var trackEntity = dataSource._entityCollection.getOrCreateEntity(createId(trackNode));
        trackEntity.parent = entity;
        var altitudeMode = queryStringValue(trackNode, 'altitudeMode', namespaces.kml);
        var coordNodes = queryChildNodes(trackNode, 'coord', namespaces.gx);
        var timeNodes = queryChildNodes(trackNode, 'when', namespaces.kml);
        var coordinates = new Array(coordNodes.length);
        var times = new Array(timeNodes.length);
        for (var x = 0; x < times.length; x++) {
            coordinates[x] = readCoordinate(coordNodes[x], altitudeMode);
            times[x] = JulianDate.fromIso8601(timeNodes[x].textContent);
        }
        var property = new SampledPositionProperty();
        property.addSamples(times, coordinates);
        trackEntity.position = property;
        trackEntity.billboard = styleEntity.billboard;
    }
}
function processMultiGeometry(dataSource, geometryNode, entity, styleEntity) {
    var childNodes = geometryNode.childNodes;
    for (var i = 0, len = childNodes.length; i < len; i++) {
        var childNode = childNodes.item(i);
        var geometryProcessor = geometryTypes[childNode.localName];
        if (defined(geometryProcessor)) {
            var childNodeId = createId(childNode);
            var childEntity = dataSource._entityCollection.getOrCreateEntity(childNodeId);
            childEntity.parent = entity;
            childEntity.name = entity.name;
            childEntity.availability = entity.availability;
            childEntity.label = entity.label;
            childEntity.description = entity.description;
            geometryProcessor(dataSource, childNode, childEntity, styleEntity);
        }
    }
}
var geometryTypes = {
        Point: processPoint,
        LineString: processLineStringOrLinearRing,
        LinearRing: processLineStringOrLinearRing,
        Polygon: processPolygon,
        Track: processTrack,
        MultiTrack: processMultiTrack,
        MultiGeometry: processMultiGeometry
    };
function processDocument(dataSource, parent, node, entityCollection, styleCollection, sourceUri, uriResolver) {
    var featureTypeNames = Object.keys(featureTypes);
    var featureTypeNamesLength = featureTypeNames.length;
    for (var i = 0; i < featureTypeNamesLength; i++) {
        var featureName = featureTypeNames[i];
        var processFeatureNode = featureTypes[featureName];
        var childNodes = node.childNodes;
        var length = childNodes.length;
        for (var q = 0; q < length; q++) {
            var child = childNodes[q];
            if (child.localName === featureName && namespaces.kml.indexOf(child.namespaceURI) !== -1) {
                processFeatureNode(dataSource, parent, child, entityCollection, styleCollection, sourceUri, uriResolver);
            }
        }
    }
}
function processFolder(dataSource, parent, node, entityCollection, styleCollection, sourceUri, uriResolver) {
    parent = new Entity(createId(node));
    parent.name = queryStringValue(node, 'name', namespaces.kml);
    entityCollection.add(parent);
    processDocument(dataSource, parent, node, entityCollection, styleCollection, sourceUri, uriResolver);
}
function processPlacemark(dataSource, parent, placemark, entityCollection, styleCollection, sourceUri, uriResolver) {
    var id = createId(placemark.id);
    var name = queryStringValue(placemark, 'name', namespaces.kml);
    var description = queryStringValue(placemark, 'description', namespaces.kml);
    var timeSpanNode = queryFirstNode(placemark, 'TimeSpan', namespaces.kml);
    var entity = entityCollection.getOrCreateEntity(id);
    entity.name = name;
    entity.parent = parent;
    entity.availability = defined(timeSpanNode) ? processTimeSpan(timeSpanNode) : undefined;
    entity.description = defined(description) ? new ConstantProperty(description) : undefined;
    var styleEntity = computeFinalStyle(entity, dataSource, placemark, styleCollection, sourceUri, uriResolver);
    var hasGeometry = false;
    var childNodes = placemark.childNodes;
    for (var i = 0, len = childNodes.length; i < len && !hasGeometry; i++) {
        var childNode = childNodes.item(i);
        var geometryProcessor = geometryTypes[childNode.localName];
        if (defined(geometryProcessor)) {
            geometryProcessor(dataSource, childNode, entity, styleEntity);
            hasGeometry = true;
        }
    }
    if (!hasGeometry) {
        entity.merge(styleEntity);
    }
}
function processGroundOverlay(dataSource, parent, groundOverlay, entityCollection, styleCollection, sourceUri, uriResolver) {
    var id = createId(groundOverlay.id);
    var entity = entityCollection.getOrCreateEntity(id);
    if (defined(parent)) {
        entity.parent = parent;
    }
    var styleEntity = computeFinalStyle(entity, dataSource, groundOverlay, styleCollection, sourceUri, uriResolver);
    entity.name = queryStringValue(groundOverlay, 'name', namespaces.kml);
    var nodes = groundOverlay.childNodes;
    var timeSpan = queryFirstNode(groundOverlay, 'TimeSpan', namespaces.kml);
    if (defined(timeSpan)) {
        entity.availability = processTimeSpan(timeSpan);
    }
    var description = queryStringValue(groundOverlay, 'description', namespaces.kml);
    entity.description = defined(description) ? new ConstantProperty(description) : undefined;
    var latLonBox = queryFirstNode(groundOverlay, 'LatLonBox', namespaces.kml);
    if (defined(latLonBox)) {
        var west = Math.max(-180, Math.min(180, queryNumericValue(latLonBox, 'west', namespaces.kml)));
        var south = Math.max(-90, Math.min(90, queryNumericValue(latLonBox, 'south', namespaces.kml)));
        var east = Math.max(-180, Math.min(180, queryNumericValue(latLonBox, 'east', namespaces.kml)));
        var north = Math.max(-90, Math.min(90, queryNumericValue(latLonBox, 'north', namespaces.kml)));
        var cb = Ellipsoid.WGS84;
        var rectangle = entity.rectangle;
        if (!defined(rectangle)) {
            rectangle = new RectangleGraphics();
            entity.rectangle = rectangle;
        }
        var extent = Rectangle.fromDegrees(west, south, east, north);
        rectangle.coordinates = new ConstantProperty(extent);
        entity.position = new ConstantPositionProperty(Ellipsoid.WGS84.cartographicToCartesian(Rectangle.center(extent, scratchCartesian), scratchCartographic));
        var material;
        var iconNode = queryFirstNode(groundOverlay, 'Icon', namespaces.kml);
        var href = defined(iconNode) ? queryStringValue(iconNode, 'href', namespaces.kml) : undefined;
        if (defined(href)) {
            var icon = resolveHref(href, dataSource, sourceUri, uriResolver);
            material = new ImageMaterialProperty();
            material.image = new ConstantProperty(icon);
        } else {
            var color = queryColorValue(groundOverlay, 'color', namespaces.kml);
            if (defined(color)) {
                material = ColorMaterialProperty.fromColor(color);
            }
        }
        rectangle.material = material;
        var rotation = queryNumericValue(latLonBox, 'rotation', namespaces.kml);
        if (defined(rotation)) {
            rectangle.rotation = new ConstantProperty(CesiumMath.toRadians(rotation));
        }
        var altitudeMode = queryStringValue(groundOverlay, 'altitudeMode', namespaces.kml);
        if (defined(altitudeMode)) {
            if (altitudeMode === 'absolute') {
                var altitude = queryNumericValue(groundOverlay, 'altitude', namespaces.kml);
                rectangle.height = new ConstantProperty(defined(altitude) ? altitude : 0);
            } else if (altitudeMode === 'clampToGround') {
            } else {
                throw new RuntimeError('Unknown enumeration: ' + altitudeMode);
            }
        }
    }
}
function processUnsupported(dataSource, parent, node, entityCollection, styleCollection, sourceUri, uriResolver) {
    window.console.log('Unsupported feature: ' + node.nodeName);
}
function processNetworkLink(dataSource, parent, node, entityCollection, styleCollection, sourceUri, uriResolver) {
    var link = queryFirstNode(node, 'Link', namespaces.kml);
    if (defined(link)) {
        var linkUrl = queryStringValue(link, 'href', namespaces.kml);
        if (defined(linkUrl)) {
            var networkLinkSource = new KmlDataSource(dataSource._proxy);
            var promise = when(networkLinkSource.loadUrl(linkUrl), function () {
                    var entities = networkLinkSource.entities.entities;
                    for (var i = 0; i < entities.length; i++) {
                        dataSource._entityCollection.suspendEvents();
                        dataSource._entityCollection.add(entities[i]);
                        dataSource._entityCollection.resumeEvents();
                    }
                });
            dataSource._promises.push(promise);
        }
    }
}
var featureTypes = {
        Document: processDocument,
        Folder: processFolder,
        Placemark: processPlacemark,
        NetworkLink: processNetworkLink,
        GroundOverlay: processGroundOverlay,
        PhotoOverlay: processUnsupported,
        ScreenOverlay: processUnsupported
    };
function processFeatureNode(dataSource, node, parent, entityCollection, styleCollection, sourceUri, uriResolver) {
    var featureProocessor = featureTypes[node.nodeName];
    if (!defined(featureProocessor)) {
        featureProocessor = featureTypes[node.nodeName];
    }
    if (defined(featureProocessor)) {
        featureProocessor(dataSource, parent, node, entityCollection, styleCollection, sourceUri, uriResolver);
    } else {
        window.console.log('Unsupported feature node: ' + node.nodeName);
    }
}
function loadKml(dataSource, kml, sourceUri, uriResolver) {
    dataSource._promises = [];
    var docElement = queryFirstNode(kml.documentElement, 'Document', namespaces.kml);
    var name = docElement ? queryStringValue(docElement, 'name', namespaces.kml) : undefined;
    if (!defined(name) && defined(sourceUri)) {
        name = getFilenameFromUri(sourceUri);
    }
    if (dataSource._name !== name) {
        dataSource._name = name;
        dataSource._changed.raiseEvent(dataSource);
    }
    var styleCollection = new EntityCollection();
    return when.all(processStyles(dataSource, kml, styleCollection, sourceUri, false, uriResolver), function () {
        var entityCollection = dataSource._entityCollection;
        processFeatureNode(dataSource, kml.documentElement.firstElementChild, undefined, entityCollection, styleCollection, sourceUri, uriResolver);
        var availability = entityCollection.computeAvailability();
        if (availability.equals(Iso8601.MAXIMUM_INTERVAL)) {
            if (defined(dataSource._clock)) {
                dataSource._clock = undefined;
                dataSource._changed.raiseEvent(dataSource);
            }
        } else {
            var clock = new DataSourceClock();
            clock.startTime = availability.start;
            clock.stopTime = availability.stop;
            clock.currentTime = availability.start;
            clock.clockRange = ClockRange.LOOP_STOP;
            clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
            clock.multiplier = Math.min(Math.max(JulianDate.secondsDifference(availability.stop, availability.start) / 60, 60), 50000000);
            if (!defined(dataSource._clock) || !dataSource._clock.equals(clock)) {
                dataSource._clock = clock;
                dataSource._changed.raiseEvent(dataSource);
            }
        }
        when.all(dataSource._promises, function () {
            DataSource.setLoading(dataSource, false);
        });
        return dataSource;
    });
}
function loadKmz(dataSource, blob, sourceUri) {
    var deferred = when.defer();
    zip.createReader(new zip.BlobReader(blob), function (reader) {
        reader.getEntries(function (entries) {
            var promises = [];
            var foundKML = false;
            var uriResolver = {};
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                if (!entry.directory) {
                    var innerDefer = when.defer();
                    promises.push(innerDefer.promise);
                    if (!foundKML && /\.kml$/i.test(entry.filename)) {
                        foundKML = true;
                        loadXmlFromZip(reader, entry, uriResolver, innerDefer);
                    } else {
                        loadDataUriFromZip(reader, entry, uriResolver, innerDefer);
                    }
                }
            }
            when.all(promises).then(function () {
                reader.close();
                if (!defined(uriResolver.kml)) {
                    deferred.reject(new RuntimeError('KMZ file does not contain a KML document.'));
                    return;
                }
                return loadKml(dataSource, uriResolver.kml, sourceUri, uriResolver).then(deferred.resolve);
            }).otherwise(deferred.reject);
        });
    }, function (e) {
        deferred.reject(e);
    });
    return deferred;
}
var KmlDataSource = function (proxy) {
    this._changed = new Event();
    this._error = new Event();
    this._loading = new Event();
    this._clock = undefined;
    this._entityCollection = new EntityCollection();
    this._name = undefined;
    this._isLoading = false;
    this._proxy = proxy;
    this._pinBuilder = new PinBuilder();
    this._promises = [];
};
KmlDataSource.fromUrl = function (url, proxy) {
    var result = new KmlDataSource(proxy);
    result.loadUrl(url);
    return result;
};
defineProperties(KmlDataSource.prototype, {
    name: {
        get: function () {
            return this._name;
        }
    },
    clock: {
        get: function () {
            return this._clock;
        }
    },
    entities: {
        get: function () {
            return this._entityCollection;
        }
    },
    isLoading: {
        get: function () {
            return this._isLoading;
        }
    },
    changedEvent: {
        get: function () {
            return this._changed;
        }
    },
    errorEvent: {
        get: function () {
            return this._error;
        }
    },
    loadingEvent: {
        get: function () {
            return this._loading;
        }
    }
});
KmlDataSource.prototype.load = function (kml, sourceUri) {
    if (!defined(kml)) {
        throw new DeveloperError('kml is required.');
    }
    DataSource.setLoading(this, true);
    var that = this;
    return when(loadKml(this, kml, sourceUri, undefined)).otherwise(function (error) {
        DataSource.setLoading(that, false);
        that._error.raiseEvent(that, error);
        return when.reject(error);
    });
};
KmlDataSource.prototype.loadKmz = function (kmz, sourceUri) {
    if (!defined(kmz)) {
        throw new DeveloperError('kmz is required.');
    }
    DataSource.setLoading(this, true);
    var that = this;
    return when(loadKmz(this, kmz, sourceUri)).otherwise(function (error) {
        DataSource.setLoading(that, false);
        that._error.raiseEvent(that, error);
        return when.reject(error);
    });
};
KmlDataSource.prototype.loadUrl = function (url) {
    if (!defined(url)) {
        throw new DeveloperError('url is required.');
    }
    DataSource.setLoading(this, true);
    var that = this;
    return when(loadBlob(proxyUrl(url, this._proxy))).then(function (blob) {
        return isZipFile(blob).then(function (isZip) {
            if (isZip) {
                return loadKmz(that, blob, url);
            }
            return when(readBlob.asText(blob)).then(function (text) {
                var kml = parser.parseFromString(text, 'application/xml');
                if (defined(kml.body) && kml.body !== null || kml.documentElement.tagName === 'parsererror') {
                    throw new RuntimeError(kml.body.innerText);
                }
                return loadKml(that, kml, url, undefined);
            });
        });
    }).otherwise(function (error) {
        DataSource.setLoading(that, false);
        that._error.raiseEvent(that, error);
        return when.reject(error);
    });
};
module.exports = KmlDataSource;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartographic":104,"../Core/ClockRange":109,"../Core/ClockStep":110,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Ellipsoid":130,"../Core/Event":138,"../Core/Iso8601":167,"../Core/JulianDate":168,"../Core/Math":174,"../Core/NearFarScalar":178,"../Core/PinBuilder":180,"../Core/PolygonHierarchy":185,"../Core/Rectangle":201,"../Core/RuntimeError":207,"../Core/TimeInterval":222,"../Core/TimeIntervalCollection":223,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/getFilenameFromUri":250,"../Core/loadBlob":258,"../Core/loadXML":264,"../Scene/LabelStyle":403,"../Scene/VerticalOrigin":454,"../ThirdParty/Uri":587,"../ThirdParty/when":596,"../ThirdParty/zip":597,"./BillboardGraphics":274,"./ColorMaterialProperty":278,"./ConstantPositionProperty":282,"./ConstantProperty":283,"./DataSource":287,"./DataSourceClock":288,"./Entity":295,"./EntityCollection":296,"./ImageMaterialProperty":301,"./LabelGraphics":303,"./PolygonGraphics":313,"./PolylineGraphics":316,"./PolylineOutlineMaterialProperty":317,"./RectangleGraphics":323,"./SampledPositionProperty":325}],303:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var LabelGraphics = function () {
    this._text = undefined;
    this._textSubscription = undefined;
    this._font = undefined;
    this._fontSubscription = undefined;
    this._style = undefined;
    this._styleSubscription = undefined;
    this._fillColor = undefined;
    this._fillColorSubscription = undefined;
    this._outlineColor = undefined;
    this._outlineColorSubscription = undefined;
    this._outlineWidth = undefined;
    this._outlineWidthSubscription = undefined;
    this._horizontalOrigin = undefined;
    this._horizontalOriginSubscription = undefined;
    this._verticalOrigin = undefined;
    this._verticalOriginSubscription = undefined;
    this._eyeOffset = undefined;
    this._eyeOffsetSubscription = undefined;
    this._pixelOffset = undefined;
    this._pixelOffsetSubscription = undefined;
    this._scale = undefined;
    this._scaleSubscription = undefined;
    this._show = undefined;
    this._showSubscription = undefined;
    this._translucencyByDistance = undefined;
    this._translucencyByDistanceSubscription = undefined;
    this._pixelOffsetScaleByDistance = undefined;
    this._pixelOffsetScaleByDistanceSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(LabelGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    text: createPropertyDescriptor('text'),
    font: createPropertyDescriptor('font'),
    style: createPropertyDescriptor('style'),
    fillColor: createPropertyDescriptor('fillColor'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    horizontalOrigin: createPropertyDescriptor('horizontalOrigin'),
    verticalOrigin: createPropertyDescriptor('verticalOrigin'),
    eyeOffset: createPropertyDescriptor('eyeOffset'),
    pixelOffset: createPropertyDescriptor('pixelOffset'),
    scale: createPropertyDescriptor('scale'),
    show: createPropertyDescriptor('show'),
    translucencyByDistance: createPropertyDescriptor('translucencyByDistance'),
    pixelOffsetScaleByDistance: createPropertyDescriptor('pixelOffsetScaleByDistance')
});
LabelGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new LabelGraphics();
    }
    result.text = this.text;
    result.font = this.font;
    result.show = this.show;
    result.style = this.style;
    result.fillColor = this.fillColor;
    result.outlineColor = this.outlineColor;
    result.outlineWidth = this.outlineWidth;
    result.scale = this.scale;
    result.horizontalOrigin = this.horizontalOrigin;
    result.verticalOrigin = this.verticalOrigin;
    result.eyeOffset = this.eyeOffset;
    result.pixelOffset = this.pixelOffset;
    result.translucencyByDistance = this._translucencyByDistance;
    result.pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
    return result;
};
LabelGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.text = defaultValue(this.text, source.text);
    this.font = defaultValue(this.font, source.font);
    this.show = defaultValue(this.show, source.show);
    this.style = defaultValue(this.style, source.style);
    this.fillColor = defaultValue(this.fillColor, source.fillColor);
    this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
    this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
    this.scale = defaultValue(this.scale, source.scale);
    this.horizontalOrigin = defaultValue(this.horizontalOrigin, source.horizontalOrigin);
    this.verticalOrigin = defaultValue(this.verticalOrigin, source.verticalOrigin);
    this.eyeOffset = defaultValue(this.eyeOffset, source.eyeOffset);
    this.pixelOffset = defaultValue(this.pixelOffset, source.pixelOffset);
    this.translucencyByDistance = defaultValue(this._translucencyByDistance, source._translucencyByDistance);
    this.pixelOffsetScaleByDistance = defaultValue(this._pixelOffsetScaleByDistance, source._pixelOffsetScaleByDistance);
};
module.exports = LabelGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],304:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), NearFarScalar = require('../Core/NearFarScalar'), HorizontalOrigin = require('../Scene/HorizontalOrigin'), LabelCollection = require('../Scene/LabelCollection'), LabelStyle = require('../Scene/LabelStyle'), VerticalOrigin = require('../Scene/VerticalOrigin'), Property = require('./Property');
'use strict';
var defaultScale = 1;
var defaultFont = '30px sans-serif';
var defaultStyle = LabelStyle.FILL;
var defaultFillColor = Color.WHITE;
var defaultOutlineColor = Color.BLACK;
var defaultOutlineWidth = 1;
var defaultPixelOffset = Cartesian2.ZERO;
var defaultEyeOffset = Cartesian3.ZERO;
var defaultHorizontalOrigin = HorizontalOrigin.CENTER;
var defaultVerticalOrigin = VerticalOrigin.CENTER;
var position = new Cartesian3();
var fillColor = new Color();
var outlineColor = new Color();
var eyeOffset = new Cartesian3();
var pixelOffset = new Cartesian2();
var translucencyByDistance = new NearFarScalar();
var pixelOffsetScaleByDistance = new NearFarScalar();
var EntityData = function (entity) {
    this.entity = entity;
    this.label = undefined;
    this.index = undefined;
};
var LabelVisualizer = function (scene, entityCollection) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(entityCollection)) {
        throw new DeveloperError('entityCollection is required.');
    }
    entityCollection.collectionChanged.addEventListener(LabelVisualizer.prototype._onCollectionChanged, this);
    this._scene = scene;
    this._unusedIndexes = [];
    this._labelCollection = undefined;
    this._entityCollection = entityCollection;
    this._items = new AssociativeArray();
    this._onCollectionChanged(entityCollection, entityCollection.entities, [], []);
};
LabelVisualizer.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var items = this._items.values;
    var unusedIndexes = this._unusedIndexes;
    for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
        var entity = item.entity;
        var labelGraphics = entity._label;
        var text;
        var label = item.label;
        var show = entity.isAvailable(time) && Property.getValueOrDefault(labelGraphics._show, time, true);
        if (show) {
            position = Property.getValueOrUndefined(entity._position, time, position);
            text = Property.getValueOrUndefined(labelGraphics._text, time);
            show = defined(position) && defined(text);
        }
        if (!show) {
            returnLabel(item, unusedIndexes);
            continue;
        }
        if (!defined(label)) {
            var labelCollection = this._labelCollection;
            if (!defined(labelCollection)) {
                labelCollection = new LabelCollection();
                this._labelCollection = labelCollection;
                this._scene.primitives.add(labelCollection);
            }
            var length = unusedIndexes.length;
            if (length > 0) {
                var index = unusedIndexes.pop();
                item.index = index;
                label = labelCollection.get(index);
            } else {
                label = labelCollection.add();
                item.index = labelCollection.length - 1;
            }
            label.id = entity;
            item.label = label;
        }
        label.show = true;
        label.position = position;
        label.text = text;
        label.scale = Property.getValueOrDefault(labelGraphics._scale, time, defaultScale);
        label.font = Property.getValueOrDefault(labelGraphics._font, time, defaultFont);
        label.style = Property.getValueOrDefault(labelGraphics._style, time, defaultStyle);
        label.fillColor = Property.getValueOrDefault(labelGraphics._fillColor, time, defaultFillColor, fillColor);
        label.outlineColor = Property.getValueOrDefault(labelGraphics._outlineColor, time, defaultOutlineColor, outlineColor);
        label.outlineWidth = Property.getValueOrDefault(labelGraphics._outlineWidth, time, defaultOutlineWidth);
        label.pixelOffset = Property.getValueOrDefault(labelGraphics._pixelOffset, time, defaultPixelOffset, pixelOffset);
        label.eyeOffset = Property.getValueOrDefault(labelGraphics._eyeOffset, time, defaultEyeOffset, eyeOffset);
        label.horizontalOrigin = Property.getValueOrDefault(labelGraphics._horizontalOrigin, time, defaultHorizontalOrigin);
        label.verticalOrigin = Property.getValueOrDefault(labelGraphics._verticalOrigin, time, defaultVerticalOrigin);
        label.translucencyByDistance = Property.getValueOrUndefined(labelGraphics._translucencyByDistance, time, translucencyByDistance);
        label.pixelOffsetScaleByDistance = Property.getValueOrUndefined(labelGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistance);
    }
    return true;
};
LabelVisualizer.prototype.isDestroyed = function () {
    return false;
};
LabelVisualizer.prototype.destroy = function () {
    this._entityCollection.collectionChanged.removeEventListener(LabelVisualizer.prototype._onCollectionChanged, this);
    if (defined(this._labelCollection)) {
        this._scene.primitives.remove(this._labelCollection);
    }
    return destroyObject(this);
};
LabelVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
    var i;
    var entity;
    var unusedIndexes = this._unusedIndexes;
    var items = this._items;
    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        if (defined(entity._label) && defined(entity._position)) {
            items.set(entity.id, new EntityData(entity));
        }
    }
    for (i = changed.length - 1; i > -1; i--) {
        entity = changed[i];
        if (defined(entity._label) && defined(entity._position)) {
            if (!items.contains(entity.id)) {
                items.set(entity.id, new EntityData(entity));
            }
        } else {
            returnLabel(items.get(entity.id), unusedIndexes);
            items.remove(entity.id);
        }
    }
    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        returnLabel(items.get(entity.id), unusedIndexes);
        items.remove(entity.id);
    }
};
function returnLabel(item, unusedIndexes) {
    if (defined(item)) {
        var label = item.label;
        if (defined(label)) {
            unusedIndexes.push(item.index);
            label.show = false;
            item.label = undefined;
            item.index = -1;
        }
    }
}
module.exports = LabelVisualizer;
},{"../Core/AssociativeArray":93,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/NearFarScalar":178,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/HorizontalOrigin":394,"../Scene/LabelCollection":402,"../Scene/LabelStyle":403,"../Scene/VerticalOrigin":454,"./Property":321}],305:[function(require,module,exports){
var Color = require('../Core/Color'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Material = require('../Scene/Material');
'use strict';
var MaterialProperty = function () {
    DeveloperError.throwInstantiationError();
};
defineProperties(MaterialProperty.prototype, {
    isConstant: { get: DeveloperError.throwInstantiationError },
    definitionChanged: { get: DeveloperError.throwInstantiationError }
});
MaterialProperty.prototype.getType = DeveloperError.throwInstantiationError;
MaterialProperty.prototype.getValue = DeveloperError.throwInstantiationError;
MaterialProperty.prototype.equals = DeveloperError.throwInstantiationError;
MaterialProperty.getValue = function (time, materialProperty, material) {
    var type;
    if (defined(materialProperty)) {
        type = materialProperty.getType(time);
        if (defined(type)) {
            if (!defined(material) || material.type !== type) {
                material = Material.fromType(type);
            }
            materialProperty.getValue(time, material.uniforms);
            return material;
        }
    }
    if (!defined(material) || material.type !== Material.ColorType) {
        material = Material.fromType(Material.ColorType);
    }
    Color.clone(Color.WHITE, material.uniforms.color);
    return material;
};
module.exports = MaterialProperty;
},{"../Core/Color":111,"../Core/DeveloperError":123,"../Core/defineProperties":244,"../Core/defined":245,"../Scene/Material":404}],306:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var ModelGraphics = function () {
    this._show = undefined;
    this._showSubscription = undefined;
    this._scale = undefined;
    this._scaleSubscription = undefined;
    this._minimumPixelSize = undefined;
    this._minimumPixelSizeSubscription = undefined;
    this._uri = undefined;
    this._uriSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(ModelGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    show: createPropertyDescriptor('show'),
    scale: createPropertyDescriptor('scale'),
    minimumPixelSize: createPropertyDescriptor('minimumPixelSize'),
    uri: createPropertyDescriptor('uri')
});
ModelGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new ModelGraphics();
    }
    result.show = this.show;
    result.scale = this.scale;
    result.minimumPixelSize = this.minimumPixelSize;
    result.uri = this.uri;
    return result;
};
ModelGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.show = defaultValue(this.show, source.show);
    this.scale = defaultValue(this.scale, source.scale);
    this.minimumPixelSize = defaultValue(this.minimumPixelSize, source.minimumPixelSize);
    this.uri = defaultValue(this.uri, source.uri);
};
module.exports = ModelGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],307:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), Cartesian3 = require('../Core/Cartesian3'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Matrix4 = require('../Core/Matrix4'), Model = require('../Scene/Model'), ModelAnimationLoop = require('../Scene/ModelAnimationLoop'), Property = require('./Property');
'use strict';
var defaultScale = 1;
var defaultMinimumPixelSize = 0;
var ModelVisualizer = function (scene, entityCollection) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(entityCollection)) {
        throw new DeveloperError('entityCollection is required.');
    }
    entityCollection.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged, this);
    this._scene = scene;
    this._primitives = scene.primitives;
    this._entityCollection = entityCollection;
    this._modelHash = {};
    this._entitiesToVisualize = new AssociativeArray();
    this._modelMatrixScratch = new Matrix4();
    this._onCollectionChanged(entityCollection, entityCollection.entities, [], []);
};
ModelVisualizer.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var context = this._scene.context;
    var entities = this._entitiesToVisualize.values;
    var modelHash = this._modelHash;
    var primitives = this._primitives;
    var scene = this._scene;
    for (var i = 0, len = entities.length; i < len; i++) {
        var entity = entities[i];
        var modelGraphics = entity._model;
        var uri;
        var modelData = modelHash[entity.id];
        var show = entity.isAvailable(time) && Property.getValueOrDefault(modelGraphics._show, time, true);
        var modelMatrix;
        if (show) {
            modelMatrix = entity._getModelMatrix(time, this._modelMatrixScratch);
            uri = Property.getValueOrUndefined(modelGraphics._uri, time);
            show = defined(modelMatrix) && defined(uri);
        }
        if (!show) {
            if (defined(modelData)) {
                modelData.modelPrimitive.show = false;
            }
            continue;
        }
        var model = defined(modelData) ? modelData.modelPrimitive : undefined;
        if (!defined(model) || uri !== modelData.uri) {
            if (defined(model)) {
                primitives.removeAndDestroy(model);
                delete modelHash[entity.id];
            }
            model = Model.fromGltf({ url: uri });
            model.readyPromise.then(onModelReady).otherwise(onModelError);
            model.id = entity;
            primitives.add(model);
            modelData = {
                modelPrimitive: model,
                uri: uri
            };
            modelHash[entity.id] = modelData;
        }
        model.show = true;
        model.scale = Property.getValueOrDefault(modelGraphics._scale, time, defaultScale);
        model.minimumPixelSize = Property.getValueOrDefault(modelGraphics._minimumPixelSize, time, defaultMinimumPixelSize);
        model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);
    }
    return true;
};
ModelVisualizer.prototype.isDestroyed = function () {
    return false;
};
ModelVisualizer.prototype.destroy = function () {
    this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged, this);
    var entities = this._entitiesToVisualize.values;
    var modelHash = this._modelHash;
    var primitives = this._primitives;
    for (var i = entities.length - 1; i > -1; i--) {
        removeModel(this, entities[i], modelHash, primitives);
    }
    return destroyObject(this);
};
ModelVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
    var i;
    var entity;
    var entities = this._entitiesToVisualize;
    var modelHash = this._modelHash;
    var primitives = this._primitives;
    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        if (defined(entity._model) && defined(entity._position)) {
            entities.set(entity.id, entity);
        }
    }
    for (i = changed.length - 1; i > -1; i--) {
        entity = changed[i];
        if (defined(entity._model) && defined(entity._position)) {
            entities.set(entity.id, entity);
        } else {
            removeModel(this, entity, modelHash, primitives);
            entities.remove(entity.id);
        }
    }
    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        removeModel(this, entity, modelHash, primitives);
        entities.remove(entity.id);
    }
};
function removeModel(visualizer, entity, modelHash, primitives) {
    var modelData = modelHash[entity.id];
    if (defined(modelData)) {
        primitives.removeAndDestroy(modelData.modelPrimitive);
        delete modelHash[entity.id];
    }
}
function onModelReady(model) {
    model.activeAnimations.addAll({ loop: ModelAnimationLoop.REPEAT });
}
function onModelError(error) {
    console.error(error);
}
module.exports = ModelVisualizer;
},{"../Core/AssociativeArray":93,"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/Matrix4":177,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/Model":406,"../Scene/ModelAnimationLoop":410,"./Property":321}],308:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var PathGraphics = function () {
    this._material = undefined;
    this._materialSubscription = undefined;
    this._show = undefined;
    this._showSubscription = undefined;
    this._width = undefined;
    this._widthSubscription = undefined;
    this._resolution = undefined;
    this._resolutionSubscription = undefined;
    this._leadTime = undefined;
    this._leadTimeSubscription = undefined;
    this._trailTime = undefined;
    this._trailTimeSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(PathGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    material: createPropertyDescriptor('material'),
    show: createPropertyDescriptor('show'),
    width: createPropertyDescriptor('width'),
    resolution: createPropertyDescriptor('resolution'),
    leadTime: createPropertyDescriptor('leadTime'),
    trailTime: createPropertyDescriptor('trailTime')
});
PathGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new PathGraphics();
    }
    result.material = this.material;
    result.width = this.width;
    result.resolution = this.resolution;
    result.show = this.show;
    result.leadTime = this.leadTime;
    result.trailTime = this.trailTime;
    return result;
};
PathGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.material = defaultValue(this.material, source.material);
    this.width = defaultValue(this.width, source.width);
    this.resolution = defaultValue(this.resolution, source.resolution);
    this.show = defaultValue(this.show, source.show);
    this.leadTime = defaultValue(this.leadTime, source.leadTime);
    this.trailTime = defaultValue(this.trailTime, source.trailTime);
};
module.exports = PathGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],309:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), Cartesian3 = require('../Core/Cartesian3'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), JulianDate = require('../Core/JulianDate'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), ReferenceFrame = require('../Core/ReferenceFrame'), TimeInterval = require('../Core/TimeInterval'), Transforms = require('../Core/Transforms'), PolylineCollection = require('../Scene/PolylineCollection'), SceneMode = require('../Scene/SceneMode'), CompositePositionProperty = require('./CompositePositionProperty'), ConstantPositionProperty = require('./ConstantPositionProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property'), ReferenceProperty = require('./ReferenceProperty'), SampledPositionProperty = require('./SampledPositionProperty'), TimeIntervalCollectionPositionProperty = require('./TimeIntervalCollectionPositionProperty');
'use strict';
var defaultResolution = 60;
var defaultWidth = 1;
var scratchTimeInterval = new TimeInterval();
var subSampleCompositePropertyScratch = new TimeInterval();
var subSampleIntervalPropertyScratch = new TimeInterval();
var EntityData = function (entity) {
    this.entity = entity;
    this.polyline = undefined;
    this.index = undefined;
    this.updater = undefined;
};
function subSampleSampledProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
    var times = property._property._times;
    var r = startingIndex;
    var tmp;
    tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);
    if (defined(tmp)) {
        result[r++] = tmp;
    }
    var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);
    var t = 0;
    var len = times.length;
    var current = times[t];
    var loopStop = stop;
    var sampling = false;
    var sampleStepsToTake;
    var sampleStepsTaken;
    var sampleStepSize;
    while (t < len) {
        if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {
            tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[r]);
            if (defined(tmp)) {
                result[r++] = tmp;
            }
            steppedOnNow = true;
        }
        if (JulianDate.greaterThan(current, start) && JulianDate.lessThan(current, loopStop) && !current.equals(updateTime)) {
            tmp = property.getValueInReferenceFrame(current, referenceFrame, result[r]);
            if (defined(tmp)) {
                result[r++] = tmp;
            }
        }
        if (t < len - 1) {
            if (maximumStep > 0 && !sampling) {
                var next = times[t + 1];
                var secondsUntilNext = JulianDate.secondsDifference(next, current);
                sampling = secondsUntilNext > maximumStep;
                if (sampling) {
                    sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);
                    sampleStepsTaken = 0;
                    sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);
                    sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);
                }
            }
            if (sampling && sampleStepsTaken < sampleStepsToTake) {
                current = JulianDate.addSeconds(current, sampleStepSize, new JulianDate());
                sampleStepsTaken++;
                continue;
            }
        }
        sampling = false;
        t++;
        current = times[t];
    }
    tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);
    if (defined(tmp)) {
        result[r++] = tmp;
    }
    return r;
}
function subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
    var tmp;
    var i = 0;
    var index = startingIndex;
    var time = start;
    var stepSize = Math.max(maximumStep, 60);
    var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);
    while (JulianDate.lessThan(time, stop)) {
        if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {
            steppedOnNow = true;
            tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);
            if (defined(tmp)) {
                result[index] = tmp;
                index++;
            }
        }
        tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);
        if (defined(tmp)) {
            result[index] = tmp;
            index++;
        }
        i++;
        time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());
    }
    tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);
    if (defined(tmp)) {
        result[index] = tmp;
        index++;
    }
    return index;
}
function subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
    subSampleIntervalPropertyScratch.start = start;
    subSampleIntervalPropertyScratch.stop = stop;
    var index = startingIndex;
    var intervals = property.intervals;
    for (var i = 0; i < intervals.length; i++) {
        var interval = intervals.get(i);
        if (!TimeInterval.intersect(interval, subSampleIntervalPropertyScratch, scratchTimeInterval).isEmpty) {
            var time = interval.start;
            if (!interval.isStartIncluded) {
                if (interval.isStopIncluded) {
                    time = interval.stop;
                } else {
                    time = JulianDate.addSeconds(interval.start, JulianDate.secondsDifference(interval.stop, interval.start) / 2, new JulianDate());
                }
            }
            var tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);
            if (defined(tmp)) {
                result[index] = tmp;
                index++;
            }
        }
    }
    return index;
}
function subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
    var tmp = property.getValueInReferenceFrame(start, referenceFrame, result[startingIndex]);
    if (defined(tmp)) {
        result[startingIndex++] = tmp;
    }
    return startingIndex;
}
function subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
    subSampleCompositePropertyScratch.start = start;
    subSampleCompositePropertyScratch.stop = stop;
    var index = startingIndex;
    var intervals = property.intervals;
    for (var i = 0; i < intervals.length; i++) {
        var interval = intervals.get(i);
        if (!TimeInterval.intersect(interval, subSampleCompositePropertyScratch, scratchTimeInterval).isEmpty) {
            var intervalStart = interval.start;
            var intervalStop = interval.stop;
            var sampleStart = start;
            if (JulianDate.greaterThan(intervalStart, sampleStart)) {
                sampleStart = intervalStart;
            }
            var sampleStop = stop;
            if (JulianDate.lessThan(intervalStop, sampleStop)) {
                sampleStop = intervalStop;
            }
            var intervalProperty = interval.data;
            if (intervalProperty instanceof ReferenceProperty) {
                intervalProperty = intervalProperty.resolvedProperty;
            }
            if (intervalProperty instanceof SampledPositionProperty) {
                index = subSampleSampledProperty(intervalProperty, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);
            } else if (intervalProperty instanceof CompositePositionProperty) {
                index = subSampleCompositeProperty(intervalProperty, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);
            } else if (intervalProperty instanceof TimeIntervalCollectionPositionProperty) {
                index = subSampleIntervalProperty(intervalProperty, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);
            } else if (intervalProperty instanceof ConstantPositionProperty) {
                index = subSampleConstantProperty(intervalProperty, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);
            } else {
                index = subSampleGenericProperty(intervalProperty, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);
            }
        }
    }
    return index;
}
function subSample(property, start, stop, updateTime, referenceFrame, maximumStep, result) {
    if (!defined(result)) {
        result = [];
    }
    if (property instanceof ReferenceProperty) {
        property = property.resolvedProperty;
    }
    var length = 0;
    if (property instanceof SampledPositionProperty) {
        length = subSampleSampledProperty(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);
    } else if (property instanceof CompositePositionProperty) {
        length = subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);
    } else if (property instanceof TimeIntervalCollectionPositionProperty) {
        length = subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);
    } else if (property instanceof ConstantPositionProperty) {
        length = subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);
    } else {
        length = subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);
    }
    result.length = length;
    return result;
}
var toFixedScratch = new Matrix3();
var PolylineUpdater = function (scene, referenceFrame) {
    this._unusedIndexes = [];
    this._polylineCollection = new PolylineCollection();
    this._scene = scene;
    this._referenceFrame = referenceFrame;
    scene.primitives.add(this._polylineCollection);
};
PolylineUpdater.prototype.update = function (time) {
    if (this._referenceFrame === ReferenceFrame.INERTIAL) {
        var toFixed = Transforms.computeIcrfToFixedMatrix(time, toFixedScratch);
        if (!defined(toFixed)) {
            toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, toFixedScratch);
        }
        Matrix4.fromRotationTranslation(toFixed, Cartesian3.ZERO, this._polylineCollection.modelMatrix);
    }
};
PolylineUpdater.prototype.updateObject = function (time, item) {
    var entity = item.entity;
    var pathGraphics = entity._path;
    var positionProperty = entity._position;
    var sampleStart;
    var sampleStop;
    var showProperty = pathGraphics._show;
    var polyline = item.polyline;
    var show = !defined(showProperty) || showProperty.getValue(time);
    if (show) {
        var leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);
        var trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);
        var availability = entity._availability;
        var hasAvailability = defined(availability);
        var hasLeadTime = defined(leadTime);
        var hasTrailTime = defined(trailTime);
        show = hasAvailability || hasLeadTime && hasTrailTime;
        if (show) {
            if (hasTrailTime) {
                sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());
            }
            if (hasLeadTime) {
                sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());
            }
            if (hasAvailability) {
                var start = availability.start;
                var stop = availability.stop;
                if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {
                    sampleStart = start;
                }
                if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {
                    sampleStop = stop;
                }
            }
            show = JulianDate.lessThan(sampleStart, sampleStop);
        }
    }
    if (!show) {
        if (defined(polyline)) {
            this._unusedIndexes.push(item.index);
            item.polyline = undefined;
            polyline.show = false;
            item.index = undefined;
        }
        return;
    }
    if (!defined(polyline)) {
        var unusedIndexes = this._unusedIndexes;
        var length = unusedIndexes.length;
        if (length > 0) {
            var index = unusedIndexes.pop();
            polyline = this._polylineCollection.get(index);
            item.index = index;
        } else {
            item.index = this._polylineCollection.length;
            polyline = this._polylineCollection.add();
        }
        polyline.id = entity;
        item.polyline = polyline;
    }
    var resolution = Property.getValueOrDefault(pathGraphics._resolution, time, defaultResolution);
    polyline.show = true;
    polyline.positions = subSample(positionProperty, sampleStart, sampleStop, time, this._referenceFrame, resolution, polyline.positions);
    polyline.material = MaterialProperty.getValue(time, pathGraphics._material, polyline.material);
    polyline.width = Property.getValueOrDefault(pathGraphics._width, time, defaultWidth);
};
PolylineUpdater.prototype.removeObject = function (item) {
    var polyline = item.polyline;
    if (defined(polyline)) {
        this._unusedIndexes.push(item.index);
        item.polyline = undefined;
        polyline.show = false;
        item.index = undefined;
    }
};
PolylineUpdater.prototype.destroy = function () {
    this._scene.primitives.remove(this._polylineCollection);
    return destroyObject(this);
};
var PathVisualizer = function (scene, entityCollection) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(entityCollection)) {
        throw new DeveloperError('entityCollection is required.');
    }
    entityCollection.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged, this);
    this._scene = scene;
    this._updaters = {};
    this._entityCollection = entityCollection;
    this._items = new AssociativeArray();
    this._onCollectionChanged(entityCollection, entityCollection.entities, [], []);
};
PathVisualizer.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var updaters = this._updaters;
    for (var key in updaters) {
        if (updaters.hasOwnProperty(key)) {
            updaters[key].update(time);
        }
    }
    var items = this._items.values;
    for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
        var entity = item.entity;
        var positionProperty = entity._position;
        var lastUpdater = entity._pathUpdater;
        var frameToVisualize = ReferenceFrame.FIXED;
        if (this._scene.mode === SceneMode.SCENE3D) {
            frameToVisualize = positionProperty.referenceFrame;
        }
        var currentUpdater = this._updaters[frameToVisualize];
        if (lastUpdater === currentUpdater && defined(currentUpdater)) {
            currentUpdater.updateObject(time, item);
            continue;
        }
        if (defined(lastUpdater)) {
            lastUpdater.removeObject(item);
        }
        if (!defined(currentUpdater)) {
            currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);
            currentUpdater.update(time);
            this._updaters[frameToVisualize] = currentUpdater;
        }
        item.updater = currentUpdater;
        if (defined(currentUpdater)) {
            currentUpdater.updateObject(time, item);
        }
    }
    return true;
};
PathVisualizer.prototype.isDestroyed = function () {
    return false;
};
PathVisualizer.prototype.destroy = function () {
    this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged, this);
    var updaters = this._updaters;
    for (var key in updaters) {
        if (updaters.hasOwnProperty(key)) {
            updaters[key].destroy();
        }
    }
    return destroyObject(this);
};
PathVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
    var i;
    var entity;
    var item;
    var items = this._items;
    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        if (defined(entity._path) && defined(entity._position)) {
            items.set(entity.id, new EntityData(entity));
        }
    }
    for (i = changed.length - 1; i > -1; i--) {
        entity = changed[i];
        if (defined(entity._path) && defined(entity._position)) {
            if (!items.contains(entity.id)) {
                items.set(entity.id, new EntityData(entity));
            }
        } else {
            item = items.get(entity.id);
            if (defined(item)) {
                item.updater.removeObject(item);
                items.remove(entity.id);
            }
        }
    }
    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        item = items.get(entity.id);
        if (defined(item)) {
            item.updater.removeObject(item);
            items.remove(entity.id);
        }
    }
};
PathVisualizer._subSample = subSample;
module.exports = PathVisualizer;
},{"../Core/AssociativeArray":93,"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/JulianDate":168,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/ReferenceFrame":205,"../Core/TimeInterval":222,"../Core/Transforms":226,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/PolylineCollection":425,"../Scene/SceneMode":438,"./CompositePositionProperty":280,"./ConstantPositionProperty":282,"./MaterialProperty":305,"./Property":321,"./ReferenceProperty":324,"./SampledPositionProperty":325,"./TimeIntervalCollectionPositionProperty":332}],310:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var PointGraphics = function () {
    this._color = undefined;
    this._colorSubscription = undefined;
    this._pixelSize = undefined;
    this._pixelSizeSubscription = undefined;
    this._outlineColor = undefined;
    this._outlineColorSubscription = undefined;
    this._outlineWidth = undefined;
    this._outlineWidthSubscription = undefined;
    this._show = undefined;
    this._showSubscription = undefined;
    this._scaleByDistance = undefined;
    this._scaleByDistanceSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(PointGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    color: createPropertyDescriptor('color'),
    pixelSize: createPropertyDescriptor('pixelSize'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    show: createPropertyDescriptor('show'),
    scaleByDistance: createPropertyDescriptor('scaleByDistance')
});
PointGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new PointGraphics();
    }
    result.color = this.color;
    result.pixelSize = this.pixelSize;
    result.outlineColor = this.outlineColor;
    result.outlineWidth = this.outlineWidth;
    result.show = this.show;
    result.scaleByDistance = this.scaleByDistance;
    return result;
};
PointGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.color = defaultValue(this.color, source.color);
    this.pixelSize = defaultValue(this.pixelSize, source.pixelSize);
    this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
    this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
    this.show = defaultValue(this.show, source.show);
    this.scaleByDistance = defaultValue(this.scaleByDistance, source.scaleByDistance);
};
module.exports = PointGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],311:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), NearFarScalar = require('../Core/NearFarScalar'), BillboardCollection = require('../Scene/BillboardCollection'), Property = require('./Property');
'use strict';
var defaultColor = Color.WHITE;
var defaultOutlineColor = Color.BLACK;
var defaultOutlineWidth = 0;
var defaultPixelSize = 1;
var color = new Color();
var position = new Cartesian3();
var outlineColor = new Color();
var scaleByDistance = new NearFarScalar();
var EntityData = function (entity) {
    this.entity = entity;
    this.billboard = undefined;
    this.color = undefined;
    this.outlineColor = undefined;
    this.pixelSize = undefined;
    this.outlineWidth = undefined;
};
var PointVisualizer = function (scene, entityCollection) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(entityCollection)) {
        throw new DeveloperError('entityCollection is required.');
    }
    entityCollection.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged, this);
    this._scene = scene;
    this._unusedIndexes = [];
    this._entityCollection = entityCollection;
    this._billboardCollection = undefined;
    this._items = new AssociativeArray();
    this._onCollectionChanged(entityCollection, entityCollection.entities, [], []);
};
PointVisualizer.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var items = this._items.values;
    var unusedIndexes = this._unusedIndexes;
    for (var i = 0, len = items.length; i < len; i++) {
        var item = items[i];
        var entity = item.entity;
        var pointGraphics = entity._point;
        var billboard = item.billboard;
        var show = entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);
        if (show) {
            position = Property.getValueOrUndefined(entity._position, time, position);
            show = defined(position);
        }
        if (!show) {
            returnBillboard(item, unusedIndexes);
            continue;
        }
        var init = false;
        var needRedraw = false;
        if (!defined(billboard)) {
            init = true;
            var billboardCollection = this._billboardCollection;
            if (!defined(billboardCollection)) {
                billboardCollection = new BillboardCollection();
                this._billboardCollection = billboardCollection;
                this._scene.primitives.add(billboardCollection);
            }
            var length = unusedIndexes.length;
            if (length > 0) {
                billboard = billboardCollection.get(unusedIndexes.pop());
            } else {
                billboard = billboardCollection.add();
            }
            billboard.id = entity;
            billboard.image = undefined;
            item.billboard = billboard;
            needRedraw = true;
        }
        billboard.show = true;
        billboard.position = position;
        billboard.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistance);
        var colorProperty = pointGraphics._color;
        var outlineColorProperty = pointGraphics._outlineColor;
        var newColor = init || !Property.isConstant(colorProperty) ? Property.getValueOrDefault(colorProperty, time, defaultColor, color) : item.color;
        var newOutlineColor = init || !Property.isConstant(outlineColorProperty) ? Property.getValueOrDefault(outlineColorProperty, time, defaultOutlineColor, outlineColor) : item.outlineColor;
        var newOutlineWidth = Math.round(Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth));
        var newPixelSize = Math.max(1, Math.round(Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize)));
        if (newOutlineWidth > 0) {
            billboard.scale = 1;
            needRedraw = needRedraw || newOutlineWidth !== item.outlineWidth || newPixelSize !== item.pixelSize || !Color.equals(newColor, item.color) || !Color.equals(newOutlineColor, item.outlineColor);
        } else {
            billboard.scale = newPixelSize / 50;
            newPixelSize = 50;
            needRedraw = needRedraw || newOutlineWidth !== item.outlineWidth || !Color.equals(newColor, item.color) || !Color.equals(newOutlineColor, item.outlineColor);
        }
        if (needRedraw) {
            item.color = Color.clone(newColor, item.color);
            item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);
            item.pixelSize = newPixelSize;
            item.outlineWidth = newOutlineWidth;
            var centerAlpha = newColor.alpha;
            var cssColor = newColor.toCssColorString();
            var cssOutlineColor = newOutlineColor.toCssColorString();
            var textureId = JSON.stringify([
                    cssColor,
                    newPixelSize,
                    cssOutlineColor,
                    newOutlineWidth
                ]);
            billboard.setImage(textureId, createCallback(centerAlpha, cssColor, cssOutlineColor, newOutlineWidth, newPixelSize));
        }
    }
    return true;
};
PointVisualizer.prototype.isDestroyed = function () {
    return false;
};
PointVisualizer.prototype.destroy = function () {
    this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged, this);
    if (defined(this._billboardCollection)) {
        this._scene.primitives.remove(this._billboardCollection);
    }
    return destroyObject(this);
};
PointVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
    var i;
    var entity;
    var unusedIndexes = this._unusedIndexes;
    var items = this._items;
    for (i = added.length - 1; i > -1; i--) {
        entity = added[i];
        if (defined(entity._point) && defined(entity._position)) {
            items.set(entity.id, new EntityData(entity));
        }
    }
    for (i = changed.length - 1; i > -1; i--) {
        entity = changed[i];
        if (defined(entity._point) && defined(entity._position)) {
            if (!items.contains(entity.id)) {
                items.set(entity.id, new EntityData(entity));
            }
        } else {
            returnBillboard(items.get(entity.id), unusedIndexes);
            items.remove(entity.id);
        }
    }
    for (i = removed.length - 1; i > -1; i--) {
        entity = removed[i];
        returnBillboard(items.get(entity.id), unusedIndexes);
        items.remove(entity.id);
    }
};
function returnBillboard(item, unusedIndexes) {
    if (defined(item)) {
        var billboard = item.billboard;
        if (defined(billboard)) {
            item.billboard = undefined;
            billboard.show = false;
            billboard.image = undefined;
            unusedIndexes.push(billboard._index);
        }
    }
}
function createCallback(centerAlpha, cssColor, cssOutlineColor, cssOutlineWidth, newPixelSize) {
    return function (id) {
        var canvas = document.createElement('canvas');
        var length = newPixelSize + 2 * cssOutlineWidth;
        canvas.height = canvas.width = length;
        var context2D = canvas.getContext('2d');
        context2D.clearRect(0, 0, length, length);
        if (cssOutlineWidth !== 0) {
            context2D.beginPath();
            context2D.arc(length / 2, length / 2, length / 2, 0, 2 * Math.PI, true);
            context2D.closePath();
            context2D.fillStyle = cssOutlineColor;
            context2D.fill();
            if (centerAlpha < 1) {
                context2D.save();
                context2D.globalCompositeOperation = 'destination-out';
                context2D.beginPath();
                context2D.arc(length / 2, length / 2, newPixelSize / 2, 0, 2 * Math.PI, true);
                context2D.closePath();
                context2D.fillStyle = 'black';
                context2D.fill();
                context2D.restore();
            }
        }
        context2D.beginPath();
        context2D.arc(length / 2, length / 2, newPixelSize / 2, 0, 2 * Math.PI, true);
        context2D.closePath();
        context2D.fillStyle = cssColor;
        context2D.fill();
        return canvas;
    };
}
module.exports = PointVisualizer;
},{"../Core/AssociativeArray":93,"../Core/Cartesian3":102,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/NearFarScalar":178,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/BillboardCollection":369,"./Property":321}],312:[function(require,module,exports){
var Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), isArray = require('../Core/isArray'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), PolygonGeometry = require('../Core/PolygonGeometry'), PolygonHierarchy = require('../Core/PolygonHierarchy'), PolygonOutlineGeometry = require('../Core/PolygonOutlineGeometry'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var scratchColor = new Color();
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.polygonHierarchy = undefined;
    this.perPositionHeight = undefined;
    this.height = undefined;
    this.extrudedHeight = undefined;
    this.granularity = undefined;
    this.stRotation = undefined;
};
var PolygonGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(PolygonGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._isClosed = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'polygon', entity.polygon, undefined);
};
defineProperties(PolygonGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(PolygonGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: {
        get: function () {
            return this._isClosed;
        }
    },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
PolygonGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
PolygonGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
PolygonGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new PolygonGeometry(this._options),
        attributes: attributes
    });
};
PolygonGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: new PolygonOutlineGeometry(this._options),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
PolygonGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
PolygonGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
PolygonGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'polygon')) {
        return;
    }
    var polygon = this._entity.polygon;
    if (!defined(polygon)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = polygon.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = polygon.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var hierarchy = polygon.hierarchy;
    var show = polygon.show;
    if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || !defined(hierarchy)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(polygon.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(polygon.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(polygon.outlineColor, defaultOutlineColor) : undefined;
    var height = polygon.height;
    var extrudedHeight = polygon.extrudedHeight;
    var granularity = polygon.granularity;
    var stRotation = polygon.stRotation;
    var outlineWidth = polygon.outlineWidth;
    var perPositionHeight = polygon.perPositionHeight;
    this._isClosed = defined(extrudedHeight);
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    if (!hierarchy.isConstant || !Property.isConstant(height) || !Property.isConstant(extrudedHeight) || !Property.isConstant(granularity) || !Property.isConstant(stRotation) || !Property.isConstant(outlineWidth) || !Property.isConstant(perPositionHeight)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        var hierarchyValue = hierarchy.getValue(Iso8601.MINIMUM_VALUE);
        if (isArray(hierarchyValue)) {
            options.polygonHierarchy = new PolygonHierarchy(hierarchyValue);
        } else {
            options.polygonHierarchy = hierarchyValue;
        }
        options.height = defined(height) ? height.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.extrudedHeight = defined(extrudedHeight) ? extrudedHeight.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.stRotation = defined(stRotation) ? stRotation.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.perPositionHeight = defined(perPositionHeight) ? perPositionHeight.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
PolygonGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var primitives = this._primitives;
    primitives.remove(this._primitive);
    primitives.remove(this._outlinePrimitive);
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var polygon = entity.polygon;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(polygon.show, time, true)) {
        return;
    }
    var options = this._options;
    var hierarchy = Property.getValueOrUndefined(polygon.hierarchy, time);
    if (!defined(hierarchy)) {
        return;
    }
    if (isArray(hierarchy)) {
        options.polygonHierarchy = new PolygonHierarchy(hierarchy);
    } else {
        options.polygonHierarchy = hierarchy;
    }
    options.height = Property.getValueOrUndefined(polygon.height, time);
    options.extrudedHeight = Property.getValueOrUndefined(polygon.extrudedHeight, time);
    options.granularity = Property.getValueOrUndefined(polygon.granularity, time);
    options.stRotation = Property.getValueOrUndefined(polygon.stRotation, time);
    options.perPositionHeight = Property.getValueOrUndefined(polygon.perPositionHeight, time);
    if (Property.getValueOrDefault(polygon.fill, time, true)) {
        var material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, this._material);
        this._material = material;
        var appearance = new MaterialAppearance({
                material: material,
                translucent: material.isTranslucent(),
                closed: defined(options.extrudedHeight)
            });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new PolygonGeometry(options)
            }),
            appearance: appearance,
            asynchronous: false
        }));
    }
    if (Property.getValueOrDefault(polygon.outline, time, false)) {
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        var outlineColor = Property.getValueOrClonedDefault(polygon.outlineColor, time, Color.BLACK, scratchColor);
        var outlineWidth = Property.getValueOrDefault(polygon.outlineWidth, 1);
        var translucent = outlineColor.alpha !== 1;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new PolygonOutlineGeometry(options),
                attributes: { color: ColorGeometryInstanceAttribute.fromColor(outlineColor) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: translucent,
                renderState: { lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    this._primitives.remove(this._primitive);
    this._primitives.remove(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = PolygonGeometryUpdater;
},{"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/PolygonGeometry":183,"../Core/PolygonHierarchy":185,"../Core/PolygonOutlineGeometry":186,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Core/isArray":253,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],313:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), deprecationWarning = require('../Core/deprecationWarning'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var PolygonGraphics = function () {
    this._show = undefined;
    this._showSubscription = undefined;
    this._material = undefined;
    this._materialSubscription = undefined;
    this._hierarchy = undefined;
    this._hierarchySubscription = undefined;
    this._height = undefined;
    this._heightSubscription = undefined;
    this._extrudedHeight = undefined;
    this._extrudedHeightSubscription = undefined;
    this._granularity = undefined;
    this._granularitySubscription = undefined;
    this._stRotation = undefined;
    this._stRotationSubscription = undefined;
    this._perPositionHeight = undefined;
    this._perPositionHeightSubscription = undefined;
    this._outline = undefined;
    this._outlineSubscription = undefined;
    this._outlineColor = undefined;
    this._outlineColorSubscription = undefined;
    this._outlineWidth = undefined;
    this._outlineWidthSubscription = undefined;
    this._definitionChanged = new Event();
    this._fill = undefined;
    this._fillSubscription = undefined;
};
defineProperties(PolygonGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    show: createPropertyDescriptor('show'),
    material: createPropertyDescriptor('material'),
    positions: {
        get: function () {
            deprecationWarning('PolygonGraphics.positions', 'PolygonGraphics.positions was deprecated in Cesium 1.6, use PolygonGraphics.hierarchy instead. This property will be removed in Cesium 1.9.');
            return this.hierarchy;
        },
        set: function (value) {
            deprecationWarning('PolygonGraphics.positions', 'PolygonGraphics.positions was deprecated in Cesium 1.6, use PolygonGraphics.hierarchy instead. This property will be removed in Cesium 1.9.');
            this.hierarchy = value;
        }
    },
    hierarchy: createPropertyDescriptor('hierarchy'),
    height: createPropertyDescriptor('height'),
    extrudedHeight: createPropertyDescriptor('extrudedHeight'),
    granularity: createPropertyDescriptor('granularity'),
    stRotation: createPropertyDescriptor('stRotation'),
    fill: createPropertyDescriptor('fill'),
    outline: createPropertyDescriptor('outline'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    perPositionHeight: createPropertyDescriptor('perPositionHeight')
});
PolygonGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new PolygonGraphics();
    }
    result.show = this.show;
    result.material = this.material;
    result.hierarchy = this.hierarchy;
    result.height = this.height;
    result.extrudedHeight = this.extrudedHeight;
    result.granularity = this.granularity;
    result.stRotation = this.stRotation;
    result.fill = this.fill;
    result.outline = this.outline;
    result.outlineColor = this.outlineColor;
    result.outlineWidth = this.outlineWidth;
    result.perPositionHeight = this.perPositionHeight;
    return result;
};
PolygonGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.show = defaultValue(this.show, source.show);
    this.material = defaultValue(this.material, source.material);
    this.hierarchy = defaultValue(this.hierarchy, source.hierarchy);
    this.height = defaultValue(this.height, source.height);
    this.extrudedHeight = defaultValue(this.extrudedHeight, source.extrudedHeight);
    this.granularity = defaultValue(this.granularity, source.granularity);
    this.stRotation = defaultValue(this.stRotation, source.stRotation);
    this.fill = defaultValue(this.fill, source.fill);
    this.outline = defaultValue(this.outline, source.outline);
    this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
    this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
    this.perPositionHeight = defaultValue(this.perPositionHeight, source.perPositionHeight);
};
module.exports = PolygonGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/deprecationWarning":246,"./createPropertyDescriptor":336}],314:[function(require,module,exports){
var Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Ellipsoid = require('../Core/Ellipsoid'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), PolylineGeometry = require('../Core/PolylineGeometry'), PolylinePipeline = require('../Core/PolylinePipeline'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), PolylineCollection = require('../Scene/PolylineCollection'), PolylineColorAppearance = require('../Scene/PolylineColorAppearance'), PolylineMaterialAppearance = require('../Scene/PolylineMaterialAppearance'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var polylineCollections = {};
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.positions = undefined;
    this.width = undefined;
    this.followSurface = undefined;
    this.granularity = undefined;
};
var PolylineGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._dynamic = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'polyline', entity.polyline, undefined);
};
defineProperties(PolylineGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PolylineColorAppearance },
    materialAppearanceType: { value: PolylineMaterialAppearance }
});
defineProperties(PolylineGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: { value: false },
    hasConstantOutline: { value: true },
    outlineColorProperty: { value: undefined },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: { value: false },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
PolylineGeometryUpdater.prototype.isOutlineVisible = function (time) {
    return false;
};
PolylineGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time);
};
PolylineGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var color;
    var attributes;
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new PolylineGeometry(this._options),
        attributes: attributes
    });
};
PolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    throw new DeveloperError('This instance does not represent an outlined geometry.');
};
PolylineGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
PolylineGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
PolylineGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'polyline')) {
        return;
    }
    var polyline = this._entity.polyline;
    if (!defined(polyline)) {
        if (this._fillEnabled) {
            this._fillEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var positionsProperty = polyline.positions;
    var show = polyline.show;
    if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || !defined(positionsProperty)) {
        if (this._fillEnabled) {
            this._fillEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(polyline.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._showProperty = defaultValue(show, defaultShow);
    this._fillEnabled = true;
    var width = polyline.width;
    var followSurface = polyline.followSurface;
    var granularity = polyline.granularity;
    if (!positionsProperty.isConstant || !Property.isConstant(width) || !Property.isConstant(followSurface) || !Property.isConstant(granularity)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        var positions = positionsProperty.getValue(Iso8601.MINIMUM_VALUE, options.positions);
        if (!defined(positions) || positions.length < 2) {
            if (this._fillEnabled) {
                this._fillEnabled = false;
                this._geometryChanged.raiseEvent(this);
            }
            return;
        }
        options.vertexFormat = isColorMaterial ? PolylineColorAppearance.VERTEX_FORMAT : PolylineMaterialAppearance.VERTEX_FORMAT;
        options.positions = positions;
        options.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.followSurface = defined(followSurface) ? followSurface.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
PolylineGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    var sceneId = geometryUpdater._scene.id;
    var polylineCollection = polylineCollections[sceneId];
    if (!defined(polylineCollection)) {
        polylineCollection = new PolylineCollection();
        polylineCollections[sceneId] = polylineCollection;
        primitives.add(polylineCollection);
    }
    var line = polylineCollection.add();
    line.id = geometryUpdater._entity;
    this._line = line;
    this._primitives = primitives;
    this._geometryUpdater = geometryUpdater;
    this._positions = [];
};
var generateCartesianArcOptions = {
        positions: undefined,
        granularity: undefined,
        height: undefined
    };
DynamicGeometryUpdater.prototype.update = function (time) {
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var polyline = entity.polyline;
    var line = this._line;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {
        line.show = false;
        return;
    }
    var positionsProperty = polyline.positions;
    var positions = Property.getValueOrUndefined(positionsProperty, time, this._positions);
    if (!defined(positions)) {
        line.show = false;
        return;
    }
    var followSurface = Property.getValueOrDefault(polyline._followSurface, time, true);
    if (followSurface) {
        generateCartesianArcOptions.positions = positions;
        generateCartesianArcOptions.granularity = Property.getValueOrUndefined(polyline._granularity, time);
        generateCartesianArcOptions.height = PolylinePipeline.extractHeights(positions, Ellipsoid.WGS84);
        positions = PolylinePipeline.generateCartesianArc(generateCartesianArcOptions);
    }
    line.show = true;
    line.positions = positions;
    line.material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, line.material);
    line.width = Property.getValueOrDefault(polyline._width, time, 1);
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    var geometryUpdater = this._geometryUpdater;
    var sceneId = geometryUpdater._scene.id;
    var polylineCollection = polylineCollections[sceneId];
    polylineCollection.remove(this._line);
    if (polylineCollection.length === 0) {
        this._primitives.removeAndDestroy(polylineCollection);
        delete polylineCollections[sceneId];
    }
    destroyObject(this);
};
module.exports = PolylineGeometryUpdater;
},{"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/Ellipsoid":130,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/PolylineGeometry":188,"../Core/PolylinePipeline":189,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/PolylineCollection":425,"../Scene/PolylineColorAppearance":426,"../Scene/PolylineMaterialAppearance":427,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],315:[function(require,module,exports){
var Color = require('../Core/Color'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor'), Property = require('./Property');
'use strict';
var defaultColor = Color.WHITE;
var defaultGlowPower = 0.25;
var PolylineGlowProperty = function () {
    this._definitionChanged = new Event();
    this._color = undefined;
    this._colorSubscription = undefined;
    this._glowPower = undefined;
    this._glowPowerSubscription = undefined;
};
defineProperties(PolylineGlowProperty.prototype, {
    isConstant: {
        get: function () {
            return Property.isConstant(this._color) && Property.isConstant(this._glow);
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    color: createPropertyDescriptor('color'),
    glowPower: createPropertyDescriptor('glowPower')
});
PolylineGlowProperty.prototype.getType = function (time) {
    return 'PolylineGlow';
};
PolylineGlowProperty.prototype.getValue = function (time, result) {
    if (!defined(result)) {
        result = {};
    }
    result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
    result.glowPower = Property.getValueOrDefault(this._glowPower, time, defaultGlowPower, result.glowPower);
    return result;
};
PolylineGlowProperty.prototype.equals = function (other) {
    return this === other || other instanceof PolylineGlowProperty && Property.equals(this._color, other._color) && Property.equals(this._glowPower, other._glowPower);
};
module.exports = PolylineGlowProperty;
},{"../Core/Color":111,"../Core/Event":138,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321,"./createPropertyDescriptor":336}],316:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var PolylineGraphics = function () {
    this._show = undefined;
    this._showSubscription = undefined;
    this._material = undefined;
    this._materialSubscription = undefined;
    this._positions = undefined;
    this._positionsSubscription = undefined;
    this._followSurface = undefined;
    this._followSurfaceSubscription = undefined;
    this._granularity = undefined;
    this._granularitySubscription = undefined;
    this._widthSubscription = undefined;
    this._width = undefined;
    this._widthSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(PolylineGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    show: createPropertyDescriptor('show'),
    material: createPropertyDescriptor('material'),
    positions: createPropertyDescriptor('positions'),
    width: createPropertyDescriptor('width'),
    followSurface: createPropertyDescriptor('followSurface'),
    granularity: createPropertyDescriptor('granularity')
});
PolylineGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new PolylineGraphics();
    }
    result.show = this.show;
    result.material = this.material;
    result.positions = this.positions;
    result.width = this.width;
    result.followSurface = this.followSurface;
    result.granularity = this.granularity;
    return result;
};
PolylineGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.show = defaultValue(this.show, source.show);
    this.material = defaultValue(this.material, source.material);
    this.positions = defaultValue(this.positions, source.positions);
    this.width = defaultValue(this.width, source.width);
    this.followSurface = defaultValue(this.followSurface, source.followSurface);
    this.granularity = defaultValue(this.granularity, source.granularity);
};
module.exports = PolylineGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],317:[function(require,module,exports){
var Color = require('../Core/Color'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor'), Property = require('./Property');
'use strict';
var defaultColor = Color.WHITE;
var defaultOutlineColor = Color.BLACK;
var defaultOutlineWidth = 0;
var PolylineOutlineMaterialProperty = function () {
    this._definitionChanged = new Event();
    this._color = undefined;
    this._colorSubscription = undefined;
    this._outlineColor = undefined;
    this._outlineColorSubscription = undefined;
    this._outlineWidth = undefined;
    this._outlineWidthSubscription = undefined;
};
defineProperties(PolylineOutlineMaterialProperty.prototype, {
    isConstant: {
        get: function () {
            return Property.isConstant(this._color) && Property.isConstant(this._outlineColor) && Property.isConstant(this._outlineWidth);
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    color: createPropertyDescriptor('color'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth')
});
PolylineOutlineMaterialProperty.prototype.getType = function (time) {
    return 'PolylineOutline';
};
PolylineOutlineMaterialProperty.prototype.getValue = function (time, result) {
    if (!defined(result)) {
        result = {};
    }
    result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
    result.outlineColor = Property.getValueOrClonedDefault(this._outlineColor, time, defaultOutlineColor, result.outlineColor);
    result.outlineWidth = Property.getValueOrDefault(this._outlineWidth, time, defaultOutlineWidth);
    return result;
};
PolylineOutlineMaterialProperty.prototype.equals = function (other) {
    return this === other || other instanceof PolylineOutlineMaterialProperty && Property.equals(this._color, other._color) && Property.equals(this._outlineColor, other._outlineColor) && Property.equals(this._outlineWidth, other._outlineWidth);
};
module.exports = PolylineOutlineMaterialProperty;
},{"../Core/Color":111,"../Core/Event":138,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321,"./createPropertyDescriptor":336}],318:[function(require,module,exports){
var Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), PolylineVolumeGeometry = require('../Core/PolylineVolumeGeometry'), PolylineVolumeOutlineGeometry = require('../Core/PolylineVolumeOutlineGeometry'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var scratchColor = new Color();
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.polylinePositions = undefined;
    this.shapePositions = undefined;
    this.cornerType = undefined;
    this.granularity = undefined;
};
var PolylineVolumeGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(PolylineVolumeGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'polylineVolume', entity.polylineVolume, undefined);
};
defineProperties(PolylineVolumeGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(PolylineVolumeGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: { value: true },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
PolylineVolumeGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
PolylineVolumeGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
PolylineVolumeGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new PolylineVolumeGeometry(this._options),
        attributes: attributes
    });
};
PolylineVolumeGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: new PolylineVolumeOutlineGeometry(this._options),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
PolylineVolumeGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
PolylineVolumeGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
PolylineVolumeGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'polylineVolume')) {
        return;
    }
    var polylineVolume = this._entity.polylineVolume;
    if (!defined(polylineVolume)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = polylineVolume.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = polylineVolume.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var positions = polylineVolume.positions;
    var shape = polylineVolume.shape;
    var show = polylineVolume.show;
    if (!defined(positions) || !defined(shape) || defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(polylineVolume.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(polylineVolume.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(polylineVolume.outlineColor, defaultOutlineColor) : undefined;
    var granularity = polylineVolume.granularity;
    var outlineWidth = polylineVolume.outlineWidth;
    var cornerType = polylineVolume.cornerType;
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    if (!positions.isConstant || !shape.isConstant || !Property.isConstant(granularity) || !Property.isConstant(outlineWidth) || !Property.isConstant(cornerType)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.polylinePositions = positions.getValue(Iso8601.MINIMUM_VALUE, options.polylinePositions);
        options.shapePositions = shape.getValue(Iso8601.MINIMUM_VALUE, options.shape);
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.cornerType = defined(cornerType) ? cornerType.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
PolylineVolumeGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var primitives = this._primitives;
    primitives.remove(this._primitive);
    primitives.remove(this._outlinePrimitive);
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var polylineVolume = entity.polylineVolume;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(polylineVolume.show, time, true)) {
        return;
    }
    var options = this._options;
    var positions = Property.getValueOrUndefined(polylineVolume.positions, time, options.polylinePositions);
    var shape = Property.getValueOrUndefined(polylineVolume.shape, time);
    if (!defined(positions) || !defined(shape)) {
        return;
    }
    options.polylinePositions = positions;
    options.shapePositions = shape;
    options.granularity = Property.getValueOrUndefined(polylineVolume.granularity, time);
    options.cornerType = Property.getValueOrUndefined(polylineVolume.cornerType, time);
    if (!defined(polylineVolume.fill) || polylineVolume.fill.getValue(time)) {
        var material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, this._material);
        this._material = material;
        var appearance = new MaterialAppearance({
                material: material,
                translucent: material.isTranslucent(),
                closed: true
            });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new PolylineVolumeGeometry(options)
            }),
            appearance: appearance,
            asynchronous: false
        }));
    }
    if (defined(polylineVolume.outline) && polylineVolume.outline.getValue(time)) {
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        var outlineColor = Property.getValueOrClonedDefault(polylineVolume.outlineColor, time, Color.BLACK, scratchColor);
        var outlineWidth = Property.getValueOrDefault(polylineVolume.outlineWidth, 1);
        var translucent = outlineColor.alpha !== 1;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new PolylineVolumeOutlineGeometry(options),
                attributes: { color: ColorGeometryInstanceAttribute.fromColor(outlineColor) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: translucent,
                renderState: { lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    this._primitives.remove(this._primitive);
    this._primitives.remove(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = PolylineVolumeGeometryUpdater;
},{"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/PolylineVolumeGeometry":190,"../Core/PolylineVolumeOutlineGeometry":192,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],319:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Matrix3 = require('../Core/Matrix3'), ReferenceFrame = require('../Core/ReferenceFrame'), Transforms = require('../Core/Transforms');
'use strict';
var PositionProperty = function () {
    DeveloperError.throwInstantiationError();
};
defineProperties(PositionProperty.prototype, {
    isConstant: { get: DeveloperError.throwInstantiationError },
    definitionChanged: { get: DeveloperError.throwInstantiationError },
    referenceFrame: { get: DeveloperError.throwInstantiationError }
});
PositionProperty.prototype.getValue = DeveloperError.throwInstantiationError;
PositionProperty.prototype.getValueInReferenceFrame = DeveloperError.throwInstantiationError;
PositionProperty.prototype.equals = DeveloperError.throwInstantiationError;
var scratchMatrix3 = new Matrix3();
PositionProperty.convertToReferenceFrame = function (time, value, inputFrame, outputFrame, result) {
    if (!defined(value)) {
        return value;
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    if (inputFrame === outputFrame) {
        return Cartesian3.clone(value, result);
    }
    var icrfToFixed = Transforms.computeIcrfToFixedMatrix(time, scratchMatrix3);
    if (!defined(icrfToFixed)) {
        icrfToFixed = Transforms.computeTemeToPseudoFixedMatrix(time, scratchMatrix3);
    }
    if (inputFrame === ReferenceFrame.INERTIAL) {
        return Matrix3.multiplyByVector(icrfToFixed, value, result);
    }
    if (inputFrame === ReferenceFrame.FIXED) {
        return Matrix3.multiplyByVector(Matrix3.transpose(icrfToFixed, scratchMatrix3), value, result);
    }
};
module.exports = PositionProperty;
},{"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/Matrix3":176,"../Core/ReferenceFrame":205,"../Core/Transforms":226,"../Core/defineProperties":244,"../Core/defined":245}],320:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), EventHelper = require('../Core/EventHelper'), ReferenceFrame = require('../Core/ReferenceFrame'), Property = require('./Property');
'use strict';
var PositionPropertyArray = function (value, referenceFrame) {
    this._value = undefined;
    this._definitionChanged = new Event();
    this._eventHelper = new EventHelper();
    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
    this.setValue(value);
};
defineProperties(PositionPropertyArray.prototype, {
    isConstant: {
        get: function () {
            var value = this._value;
            if (!defined(value)) {
                return true;
            }
            var length = value.length;
            for (var i = 0; i < length; i++) {
                if (!Property.isConstant(value[i])) {
                    return false;
                }
            }
            return true;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    referenceFrame: {
        get: function () {
            return this._referenceFrame;
        }
    }
});
PositionPropertyArray.prototype.getValue = function (time, result) {
    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
};
PositionPropertyArray.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!defined(referenceFrame)) {
        throw new DeveloperError('referenceFrame is required.');
    }
    var value = this._value;
    if (!defined(value)) {
        return undefined;
    }
    var length = value.length;
    if (!defined(result)) {
        result = new Array(length);
    }
    var i = 0;
    var x = 0;
    while (i < length) {
        var property = value[i];
        var itemValue = property.getValueInReferenceFrame(time, referenceFrame, result[i]);
        if (defined(itemValue)) {
            result[x] = itemValue;
            x++;
        }
        i++;
    }
    result.length = x;
    return result;
};
PositionPropertyArray.prototype.setValue = function (value) {
    var eventHelper = this._eventHelper;
    eventHelper.removeAll();
    if (defined(value)) {
        this._value = value.slice();
        var length = value.length;
        for (var i = 0; i < length; i++) {
            var property = value[i];
            if (defined(property)) {
                eventHelper.add(property.definitionChanged, PositionPropertyArray.prototype._raiseDefinitionChanged, this);
            }
        }
    } else {
        this._value = undefined;
    }
    this._definitionChanged.raiseEvent(this);
};
PositionPropertyArray.prototype.equals = function (other) {
    return this === other || other instanceof PositionPropertyArray && this._referenceFrame === other._referenceFrame && Property.arrayEquals(this._value, other._value);
};
PositionPropertyArray.prototype._raiseDefinitionChanged = function () {
    this._definitionChanged.raiseEvent(this);
};
module.exports = PositionPropertyArray;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/EventHelper":139,"../Core/ReferenceFrame":205,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321}],321:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Iso8601 = require('../Core/Iso8601');
'use strict';
var Property = function () {
    DeveloperError.throwInstantiationError();
};
defineProperties(Property.prototype, {
    isConstant: { get: DeveloperError.throwInstantiationError },
    definitionChanged: { get: DeveloperError.throwInstantiationError }
});
Property.prototype.getValue = DeveloperError.throwInstantiationError;
Property.prototype.equals = DeveloperError.throwInstantiationError;
Property.equals = function (left, right) {
    return left === right || defined(left) && left.equals(right);
};
Property.arrayEquals = function (left, right) {
    if (left === right) {
        return true;
    }
    if (!defined(left) || !defined(right) || left.length !== right.length) {
        return false;
    }
    var length = left.length;
    for (var i = 0; i < length; i++) {
        if (!Property.equals(left[i], right[i])) {
            return false;
        }
    }
    return true;
};
Property.isConstant = function (property) {
    return !defined(property) || property.isConstant;
};
Property.getValueOrUndefined = function (property, time, result) {
    return defined(property) ? property.getValue(time, result) : undefined;
};
Property.getValueOrDefault = function (property, time, valueDefault, result) {
    return defined(property) ? defaultValue(property.getValue(time, result), valueDefault) : valueDefault;
};
Property.getValueOrClonedDefault = function (property, time, valueDefault, result) {
    var value;
    if (defined(property)) {
        value = property.getValue(time, result);
    }
    if (!defined(value)) {
        value = valueDefault.clone(value);
    }
    return value;
};
module.exports = Property;
},{"../Core/DeveloperError":123,"../Core/Iso8601":167,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245}],322:[function(require,module,exports){
var Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), RectangleGeometry = require('../Core/RectangleGeometry'), RectangleOutlineGeometry = require('../Core/RectangleOutlineGeometry'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var scratchColor = new Color();
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.rectangle = undefined;
    this.closeBottom = undefined;
    this.closeTop = undefined;
    this.height = undefined;
    this.extrudedHeight = undefined;
    this.granularity = undefined;
    this.stRotation = undefined;
    this.rotation = undefined;
};
var RectangleGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(RectangleGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._isClosed = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'rectangle', entity.rectangle, undefined);
};
defineProperties(RectangleGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(RectangleGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: {
        get: function () {
            return this._isClosed;
        }
    },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
RectangleGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
RectangleGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
RectangleGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new RectangleGeometry(this._options),
        attributes: attributes
    });
};
RectangleGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: new RectangleOutlineGeometry(this._options),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
RectangleGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
RectangleGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
RectangleGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'rectangle')) {
        return;
    }
    var rectangle = this._entity.rectangle;
    if (!defined(rectangle)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = rectangle.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = rectangle.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var coordinates = rectangle.coordinates;
    var show = rectangle.show;
    if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || !defined(coordinates)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(rectangle.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(rectangle.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(rectangle.outlineColor, defaultOutlineColor) : undefined;
    var height = rectangle.height;
    var extrudedHeight = rectangle.extrudedHeight;
    var granularity = rectangle.granularity;
    var stRotation = rectangle.stRotation;
    var rotation = rectangle.rotation;
    var outlineWidth = rectangle.outlineWidth;
    var closeBottom = rectangle.closeBottom;
    var closeTop = rectangle.closeTop;
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    if (!coordinates.isConstant || !Property.isConstant(height) || !Property.isConstant(extrudedHeight) || !Property.isConstant(granularity) || !Property.isConstant(stRotation) || !Property.isConstant(rotation) || !Property.isConstant(outlineWidth) || !Property.isConstant(closeBottom) || !Property.isConstant(closeTop)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.rectangle = coordinates.getValue(Iso8601.MINIMUM_VALUE, options.rectangle);
        options.height = defined(height) ? height.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.extrudedHeight = defined(extrudedHeight) ? extrudedHeight.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.stRotation = defined(stRotation) ? stRotation.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.rotation = defined(rotation) ? rotation.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.closeBottom = defined(closeBottom) ? closeBottom.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.closeTop = defined(closeTop) ? closeTop.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._isClosed = defined(extrudedHeight) && defined(options.closeTop) && defined(options.closeBottom) && options.closeTop && options.closeBottom;
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
RectangleGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var primitives = this._primitives;
    primitives.remove(this._primitive);
    primitives.remove(this._outlinePrimitive);
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var rectangle = entity.rectangle;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(rectangle.show, time, true)) {
        return;
    }
    var options = this._options;
    var coordinates = Property.getValueOrUndefined(rectangle.coordinates, time, options.rectangle);
    if (!defined(coordinates)) {
        return;
    }
    options.rectangle = coordinates;
    options.height = Property.getValueOrUndefined(rectangle.height, time);
    options.extrudedHeight = Property.getValueOrUndefined(rectangle.extrudedHeight, time);
    options.granularity = Property.getValueOrUndefined(rectangle.granularity, time);
    options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, time);
    options.rotation = Property.getValueOrUndefined(rectangle.rotation, time);
    options.closeBottom = Property.getValueOrUndefined(rectangle.closeBottom, time);
    options.closeTop = Property.getValueOrUndefined(rectangle.closeTop, time);
    if (Property.getValueOrDefault(rectangle.fill, time, true)) {
        var material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, this._material);
        this._material = material;
        var appearance = new MaterialAppearance({
                material: material,
                translucent: material.isTranslucent(),
                closed: defined(options.extrudedHeight)
            });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new RectangleGeometry(options)
            }),
            appearance: appearance,
            asynchronous: false
        }));
    }
    if (Property.getValueOrDefault(rectangle.outline, time, false)) {
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        var outlineColor = Property.getValueOrClonedDefault(rectangle.outlineColor, time, Color.BLACK, scratchColor);
        var outlineWidth = Property.getValueOrDefault(rectangle.outlineWidth, 1);
        var translucent = outlineColor.alpha !== 1;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new RectangleOutlineGeometry(options),
                attributes: { color: ColorGeometryInstanceAttribute.fromColor(outlineColor) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: translucent,
                renderState: { lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    var primitives = this._primitives;
    primitives.removeAndDestroy(this._primitive);
    primitives.removeAndDestroy(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = RectangleGeometryUpdater;
},{"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/RectangleGeometry":202,"../Core/RectangleOutlineGeometry":204,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],323:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var RectangleGraphics = function () {
    this._show = undefined;
    this._showSubscription = undefined;
    this._material = undefined;
    this._materialSubscription = undefined;
    this._coordinates = undefined;
    this._coordinatesSubscription = undefined;
    this._height = undefined;
    this._heightSubscription = undefined;
    this._extrudedHeight = undefined;
    this._extrudedHeightSubscription = undefined;
    this._granularity = undefined;
    this._granularitySubscription = undefined;
    this._stRotation = undefined;
    this._stRotationSubscription = undefined;
    this._rotation = undefined;
    this._rotationSubscription = undefined;
    this._closeTop = undefined;
    this._closeTopSubscription = undefined;
    this._closeBottom = undefined;
    this._closeBottomSubscription = undefined;
    this._fill = undefined;
    this._fillSubscription = undefined;
    this._outline = undefined;
    this._outlineSubscription = undefined;
    this._outlineColor = undefined;
    this._outlineColorSubscription = undefined;
    this._outlineWidth = undefined;
    this._outlineWidthSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(RectangleGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    show: createPropertyDescriptor('show'),
    coordinates: createPropertyDescriptor('coordinates'),
    material: createPropertyDescriptor('material'),
    height: createPropertyDescriptor('height'),
    extrudedHeight: createPropertyDescriptor('extrudedHeight'),
    granularity: createPropertyDescriptor('granularity'),
    stRotation: createPropertyDescriptor('stRotation'),
    rotation: createPropertyDescriptor('rotation'),
    fill: createPropertyDescriptor('fill'),
    outline: createPropertyDescriptor('outline'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth'),
    closeTop: createPropertyDescriptor('closeTop'),
    closeBottom: createPropertyDescriptor('closeBottom')
});
RectangleGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new RectangleGraphics();
    }
    result.show = this.show;
    result.coordinates = this.coordinates;
    result.material = this.material;
    result.height = this.height;
    result.extrudedHeight = this.extrudedHeight;
    result.granularity = this.granularity;
    result.stRotation = this.stRotation;
    result.rotation = this.rotation;
    result.fill = this.fill;
    result.outline = this.outline;
    result.outlineColor = this.outlineColor;
    result.outlineWidth = this.outlineWidth;
    result.closeTop = this.closeTop;
    result.closeBottom = this.closeBottom;
    return result;
};
RectangleGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.show = defaultValue(this.show, source.show);
    this.coordinates = defaultValue(this.coordinates, source.coordinates);
    this.material = defaultValue(this.material, source.material);
    this.height = defaultValue(this.height, source.height);
    this.extrudedHeight = defaultValue(this.extrudedHeight, source.extrudedHeight);
    this.granularity = defaultValue(this.granularity, source.granularity);
    this.stRotation = defaultValue(this.stRotation, source.stRotation);
    this.rotation = defaultValue(this.rotation, source.rotation);
    this.fill = defaultValue(this.fill, source.fill);
    this.outline = defaultValue(this.outline, source.outline);
    this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
    this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
    this.closeTop = defaultValue(this.closeTop, source.closeTop);
    this.closeBottom = defaultValue(this.closeBottom, source.closeBottom);
};
module.exports = RectangleGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],324:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), RuntimeError = require('../Core/RuntimeError'), Property = require('./Property');
'use strict';
function resolveEntity(that) {
    var entityIsResolved = true;
    if (that._resolveEntity) {
        var targetEntity = that._targetCollection.getById(that._targetId);
        if (defined(targetEntity)) {
            targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);
            that._targetEntity = targetEntity;
            that._resolveEntity = false;
        } else {
            targetEntity = that._targetEntity;
            entityIsResolved = false;
        }
        if (!defined(targetEntity)) {
            throw new RuntimeError('target entity "' + that._targetId + '" could not be resolved.');
        }
    }
    return entityIsResolved;
}
function resolve(that) {
    var targetProperty = that._targetProperty;
    if (that._resolveProperty) {
        var entityIsResolved = resolveEntity(that);
        var names = that._targetPropertyNames;
        targetProperty = that._targetEntity;
        var length = names.length;
        for (var i = 0; i < length && defined(targetProperty); i++) {
            targetProperty = targetProperty[names[i]];
        }
        if (defined(targetProperty)) {
            that._targetProperty = targetProperty;
            that._resolveProperty = !entityIsResolved;
        } else if (!defined(that._targetProperty)) {
            throw new RuntimeError('targetProperty "' + that._targetId + '.' + names.join('.') + '" could not be resolved.');
        }
    }
    return targetProperty;
}
var ReferenceProperty = function (targetCollection, targetId, targetPropertyNames) {
    if (!defined(targetCollection)) {
        throw new DeveloperError('targetCollection is required.');
    }
    if (!defined(targetId) || targetId === '') {
        throw new DeveloperError('targetId is required.');
    }
    if (!defined(targetPropertyNames) || targetPropertyNames.length === 0) {
        throw new DeveloperError('targetPropertyNames is required.');
    }
    for (var i = 0; i < targetPropertyNames.length; i++) {
        var item = targetPropertyNames[i];
        if (!defined(item) || item === '') {
            throw new DeveloperError('reference contains invalid properties.');
        }
    }
    this._targetCollection = targetCollection;
    this._targetId = targetId;
    this._targetPropertyNames = targetPropertyNames;
    this._targetProperty = undefined;
    this._targetEntity = undefined;
    this._definitionChanged = new Event();
    this._resolveEntity = true;
    this._resolveProperty = true;
    targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);
};
defineProperties(ReferenceProperty.prototype, {
    isConstant: {
        get: function () {
            return Property.isConstant(resolve(this));
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    referenceFrame: {
        get: function () {
            return resolve(this).referenceFrame;
        }
    },
    targetId: {
        get: function () {
            return this._targetId;
        }
    },
    targetCollection: {
        get: function () {
            return this._targetCollection;
        }
    },
    targetPropertyNames: {
        get: function () {
            return this._targetPropertyNames;
        }
    },
    resolvedProperty: {
        get: function () {
            return resolve(this);
        }
    }
});
ReferenceProperty.fromString = function (targetCollection, referenceString) {
    if (!defined(targetCollection)) {
        throw new DeveloperError('targetCollection is required.');
    }
    if (!defined(referenceString)) {
        throw new DeveloperError('referenceString is required.');
    }
    var identifier;
    var values = [];
    var inIdentifier = true;
    var isEscaped = false;
    var token = '';
    for (var i = 0; i < referenceString.length; ++i) {
        var c = referenceString.charAt(i);
        if (isEscaped) {
            token += c;
            isEscaped = false;
        } else if (c === '\\') {
            isEscaped = true;
        } else if (inIdentifier && c === '#') {
            identifier = token;
            inIdentifier = false;
            token = '';
        } else if (!inIdentifier && c === '.') {
            values.push(token);
            token = '';
        } else {
            token += c;
        }
    }
    values.push(token);
    return new ReferenceProperty(targetCollection, identifier, values);
};
ReferenceProperty.prototype.getValue = function (time, result) {
    return resolve(this).getValue(time, result);
};
ReferenceProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
    return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);
};
ReferenceProperty.prototype.getType = function (time) {
    return resolve(this).getType(time);
};
ReferenceProperty.prototype.equals = function (other) {
    if (this === other) {
        return true;
    }
    var names = this._targetPropertyNames;
    var otherNames = other._targetPropertyNames;
    if (this._targetCollection !== other._targetCollection || this._targetId !== other._targetId || names.length !== otherNames.length) {
        return false;
    }
    var length = this._targetPropertyNames.length;
    for (var i = 0; i < length; i++) {
        if (names[i] !== otherNames[i]) {
            return false;
        }
    }
    return true;
};
ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function (targetEntity, name, value, oldValue) {
    if (this._targetPropertyNames[0] === name) {
        this._resolveProperty = true;
        this._definitionChanged.raiseEvent(this);
    }
};
ReferenceProperty.prototype._onCollectionChanged = function (collection, added, removed) {
    var targetEntity = this._targetEntity;
    if (defined(targetEntity)) {
        if (removed.indexOf(targetEntity) !== -1) {
            targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);
            this._resolveEntity = true;
            this._resolveProperty = true;
        } else if (this._resolveEntity) {
            resolve(this);
            if (!this._resolveEntity) {
                this._definitionChanged.raiseEvent(this);
            }
        }
    }
};
module.exports = ReferenceProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/RuntimeError":207,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321}],325:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), ReferenceFrame = require('../Core/ReferenceFrame'), PositionProperty = require('./PositionProperty'), Property = require('./Property'), SampledProperty = require('./SampledProperty');
'use strict';
var SampledPositionProperty = function (referenceFrame, numberOfDerivatives) {
    numberOfDerivatives = defaultValue(numberOfDerivatives, 0);
    var derivativeTypes;
    if (numberOfDerivatives > 0) {
        derivativeTypes = new Array(numberOfDerivatives);
        for (var i = 0; i < numberOfDerivatives; i++) {
            derivativeTypes[i] = Cartesian3;
        }
    }
    this._numberOfDerivatives = numberOfDerivatives;
    this._property = new SampledProperty(Cartesian3, derivativeTypes);
    this._definitionChanged = new Event();
    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
    this._property._definitionChanged.addEventListener(function () {
        this._definitionChanged.raiseEvent(this);
    }, this);
};
defineProperties(SampledPositionProperty.prototype, {
    isConstant: {
        get: function () {
            return this._property.isConstant;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    referenceFrame: {
        get: function () {
            return this._referenceFrame;
        }
    },
    interpolationDegree: {
        get: function () {
            return this._property.interpolationDegree;
        }
    },
    interpolationAlgorithm: {
        get: function () {
            return this._property.interpolationAlgorithm;
        }
    },
    numberOfDerivatives: {
        get: function () {
            return this._numberOfDerivatives;
        }
    },
    forwardExtrapolationType: {
        get: function () {
            return this._property.forwardExtrapolationType;
        },
        set: function (value) {
            this._property.forwardExtrapolationType = value;
        }
    },
    forwardExtrapolationDuration: {
        get: function () {
            return this._property.forwardExtrapolationDuration;
        },
        set: function (value) {
            this._property.forwardExtrapolationDuration = value;
        }
    },
    backwardExtrapolationType: {
        get: function () {
            return this._property.backwardExtrapolationType;
        },
        set: function (value) {
            this._property.backwardExtrapolationType = value;
        }
    },
    backwardExtrapolationDuration: {
        get: function () {
            return this._property.backwardExtrapolationDuration;
        },
        set: function (value) {
            this._property.backwardExtrapolationDuration = value;
        }
    }
});
SampledPositionProperty.prototype.getValue = function (time, result) {
    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
};
SampledPositionProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!defined(referenceFrame)) {
        throw new DeveloperError('referenceFrame is required.');
    }
    result = this._property.getValue(time, result);
    if (defined(result)) {
        return PositionProperty.convertToReferenceFrame(time, result, this._referenceFrame, referenceFrame, result);
    }
    return undefined;
};
SampledPositionProperty.prototype.setInterpolationOptions = function (options) {
    this._property.setInterpolationOptions(options);
};
SampledPositionProperty.prototype.addSample = function (time, position, derivatives) {
    var numberOfDerivatives = this._numberOfDerivatives;
    if (numberOfDerivatives > 0 && (!defined(derivatives) || derivatives.length !== numberOfDerivatives)) {
        throw new DeveloperError('derivatives length must be equal to the number of derivatives.');
    }
    this._property.addSample(time, position, derivatives);
};
SampledPositionProperty.prototype.addSamples = function (times, positions, derivatives) {
    this._property.addSamples(times, positions, derivatives);
};
SampledPositionProperty.prototype.addSamplesPackedArray = function (data, epoch) {
    this._property.addSamplesPackedArray(data, epoch);
};
SampledPositionProperty.prototype.equals = function (other) {
    return this === other || Property.equals(this._property, other._property) && this._referenceFrame === other._referenceFrame;
};
module.exports = SampledPositionProperty;
},{"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/ReferenceFrame":205,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./PositionProperty":319,"./Property":321,"./SampledProperty":326}],326:[function(require,module,exports){
var binarySearch = require('../Core/binarySearch'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), ExtrapolationType = require('../Core/ExtrapolationType'), JulianDate = require('../Core/JulianDate'), LinearApproximation = require('../Core/LinearApproximation');
'use strict';
var PackableNumber = {
        packedLength: 1,
        pack: function (value, array, startingIndex) {
            startingIndex = defaultValue(startingIndex, 0);
            array[startingIndex] = value;
        },
        unpack: function (array, startingIndex, result) {
            startingIndex = defaultValue(startingIndex, 0);
            return array[startingIndex];
        }
    };
function arrayInsert(array, startIndex, items) {
    var i;
    var arrayLength = array.length;
    var itemsLength = items.length;
    var newLength = arrayLength + itemsLength;
    array.length = newLength;
    if (arrayLength !== startIndex) {
        var q = arrayLength - 1;
        for (i = newLength - 1; i >= startIndex; i--) {
            array[i] = array[q--];
        }
    }
    for (i = 0; i < itemsLength; i++) {
        array[startIndex++] = items[i];
    }
}
function convertDate(date, epoch) {
    if (date instanceof JulianDate) {
        return date;
    }
    if (typeof date === 'string') {
        return JulianDate.fromIso8601(date);
    }
    return JulianDate.addSeconds(epoch, date, new JulianDate());
}
var timesSpliceArgs = [];
var valuesSpliceArgs = [];
var mergeNewSamples = function (epoch, times, values, newData, packedLength) {
    var newDataIndex = 0;
    var i;
    var prevItem;
    var timesInsertionPoint;
    var valuesInsertionPoint;
    var currentTime;
    var nextTime;
    while (newDataIndex < newData.length) {
        currentTime = convertDate(newData[newDataIndex], epoch);
        timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);
        var timesSpliceArgsCount = 0;
        var valuesSpliceArgsCount = 0;
        if (timesInsertionPoint < 0) {
            timesInsertionPoint = ~timesInsertionPoint;
            valuesInsertionPoint = timesInsertionPoint * packedLength;
            prevItem = undefined;
            nextTime = times[timesInsertionPoint];
            while (newDataIndex < newData.length) {
                currentTime = convertDate(newData[newDataIndex], epoch);
                if (defined(prevItem) && JulianDate.compare(prevItem, currentTime) >= 0 || defined(nextTime) && JulianDate.compare(currentTime, nextTime) >= 0) {
                    break;
                }
                timesSpliceArgs[timesSpliceArgsCount++] = currentTime;
                newDataIndex = newDataIndex + 1;
                for (i = 0; i < packedLength; i++) {
                    valuesSpliceArgs[valuesSpliceArgsCount++] = newData[newDataIndex];
                    newDataIndex = newDataIndex + 1;
                }
                prevItem = currentTime;
            }
            if (timesSpliceArgsCount > 0) {
                valuesSpliceArgs.length = valuesSpliceArgsCount;
                arrayInsert(values, valuesInsertionPoint, valuesSpliceArgs);
                timesSpliceArgs.length = timesSpliceArgsCount;
                arrayInsert(times, timesInsertionPoint, timesSpliceArgs);
            }
        } else {
            for (i = 0; i < packedLength; i++) {
                newDataIndex++;
                values[timesInsertionPoint * packedLength + i] = newData[newDataIndex];
            }
            newDataIndex++;
        }
    }
};
var SampledProperty = function (type, derivativeTypes) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var innerType = type;
    if (innerType === Number) {
        innerType = PackableNumber;
    }
    var packedLength = innerType.packedLength;
    var packedInterpolationLength = defaultValue(innerType.packedInterpolationLength, packedLength);
    var inputOrder = 0;
    var innerDerivativeTypes;
    if (defined(derivativeTypes)) {
        var length = derivativeTypes.length;
        innerDerivativeTypes = new Array(length);
        for (var i = 0; i < length; i++) {
            var derivativeType = derivativeTypes[i];
            if (derivativeType === Number) {
                derivativeType = PackableNumber;
            }
            var derivativePackedLength = derivativeType.packedLength;
            packedLength += derivativePackedLength;
            packedInterpolationLength += defaultValue(derivativeType.packedInterpolationLength, derivativePackedLength);
            innerDerivativeTypes[i] = derivativeType;
        }
        inputOrder = length;
    }
    this._type = type;
    this._innerType = innerType;
    this._interpolationDegree = 1;
    this._interpolationAlgorithm = LinearApproximation;
    this._numberOfPoints = 0;
    this._times = [];
    this._values = [];
    this._xTable = [];
    this._yTable = [];
    this._packedLength = packedLength;
    this._packedInterpolationLength = packedInterpolationLength;
    this._updateTableLength = true;
    this._interpolationResult = new Array(packedInterpolationLength);
    this._definitionChanged = new Event();
    this._derivativeTypes = derivativeTypes;
    this._innerDerivativeTypes = innerDerivativeTypes;
    this._inputOrder = inputOrder;
    this._forwardExtrapolationType = ExtrapolationType.NONE;
    this._forwardExtrapolationDuration = 0;
    this._backwardExtrapolationType = ExtrapolationType.NONE;
    this._backwardExtrapolationDuration = 0;
};
defineProperties(SampledProperty.prototype, {
    isConstant: {
        get: function () {
            return this._values.length === 0;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    type: {
        get: function () {
            return this._type;
        }
    },
    derivativeTypes: {
        get: function () {
            return this._derivativeTypes;
        }
    },
    interpolationDegree: {
        get: function () {
            return this._interpolationDegree;
        }
    },
    interpolationAlgorithm: {
        get: function () {
            return this._interpolationAlgorithm;
        }
    },
    forwardExtrapolationType: {
        get: function () {
            return this._forwardExtrapolationType;
        },
        set: function (value) {
            if (this._forwardExtrapolationType !== value) {
                this._forwardExtrapolationType = value;
                this._definitionChanged.raiseEvent(this);
            }
        }
    },
    forwardExtrapolationDuration: {
        get: function () {
            return this._forwardExtrapolationDuration;
        },
        set: function (value) {
            if (this._forwardExtrapolationDuration !== value) {
                this._forwardExtrapolationDuration = value;
                this._definitionChanged.raiseEvent(this);
            }
        }
    },
    backwardExtrapolationType: {
        get: function () {
            return this._backwardExtrapolationType;
        },
        set: function (value) {
            if (this._backwardExtrapolationType !== value) {
                this._backwardExtrapolationType = value;
                this._definitionChanged.raiseEvent(this);
            }
        }
    },
    backwardExtrapolationDuration: {
        get: function () {
            return this._backwardExtrapolationDuration;
        },
        set: function (value) {
            if (this._backwardExtrapolationDuration !== value) {
                this._backwardExtrapolationDuration = value;
                this._definitionChanged.raiseEvent(this);
            }
        }
    }
});
SampledProperty.prototype.getValue = function (time, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var timeout;
    var innerType = this._innerType;
    var times = this._times;
    var values = this._values;
    var index = binarySearch(times, time, JulianDate.compare);
    if (index < 0) {
        index = ~index;
        if (index === 0) {
            var startTime = times[index];
            timeout = this._backwardExtrapolationDuration;
            if (this._backwardExtrapolationType === ExtrapolationType.NONE || timeout !== 0 && JulianDate.secondsDifference(startTime, time) > timeout) {
                return undefined;
            }
            if (this._backwardExtrapolationType === ExtrapolationType.HOLD) {
                return innerType.unpack(this._values, 0, result);
            }
        }
        if (index >= times.length) {
            index = times.length - 1;
            var endTime = times[index];
            timeout = this._forwardExtrapolationDuration;
            if (this._forwardExtrapolationType === ExtrapolationType.NONE || timeout !== 0 && JulianDate.secondsDifference(time, endTime) > timeout) {
                return undefined;
            }
            if (this._forwardExtrapolationType === ExtrapolationType.HOLD) {
                index = times.length - 1;
                return innerType.unpack(this._values, index * innerType.packedLength, result);
            }
        }
        var xTable = this._xTable;
        var yTable = this._yTable;
        var interpolationAlgorithm = this._interpolationAlgorithm;
        var packedInterpolationLength = this._packedInterpolationLength;
        var inputOrder = this._inputOrder;
        if (this._updateTableLength) {
            this._updateTableLength = false;
            var numberOfPoints = Math.min(interpolationAlgorithm.getRequiredDataPoints(this._interpolationDegree, inputOrder), times.length);
            if (numberOfPoints !== this._numberOfPoints) {
                this._numberOfPoints = numberOfPoints;
                xTable.length = numberOfPoints;
                yTable.length = numberOfPoints * packedInterpolationLength;
            }
        }
        var degree = this._numberOfPoints - 1;
        if (degree < 1) {
            return undefined;
        }
        var firstIndex = 0;
        var lastIndex = times.length - 1;
        var pointsInCollection = lastIndex - firstIndex + 1;
        if (pointsInCollection < degree + 1) {
        } else {
            var computedFirstIndex = index - (degree / 2 | 0) - 1;
            if (computedFirstIndex < firstIndex) {
                computedFirstIndex = firstIndex;
            }
            var computedLastIndex = computedFirstIndex + degree;
            if (computedLastIndex > lastIndex) {
                computedLastIndex = lastIndex;
                computedFirstIndex = computedLastIndex - degree;
                if (computedFirstIndex < firstIndex) {
                    computedFirstIndex = firstIndex;
                }
            }
            firstIndex = computedFirstIndex;
            lastIndex = computedLastIndex;
        }
        var length = lastIndex - firstIndex + 1;
        for (var i = 0; i < length; ++i) {
            xTable[i] = JulianDate.secondsDifference(times[firstIndex + i], times[lastIndex]);
        }
        if (!defined(innerType.convertPackedArrayForInterpolation)) {
            var destinationIndex = 0;
            var packedLength = this._packedLength;
            var sourceIndex = firstIndex * packedLength;
            var stop = (lastIndex + 1) * packedLength;
            while (sourceIndex < stop) {
                yTable[destinationIndex] = values[sourceIndex];
                sourceIndex++;
                destinationIndex++;
            }
        } else {
            innerType.convertPackedArrayForInterpolation(values, firstIndex, lastIndex, yTable);
        }
        var x = JulianDate.secondsDifference(time, times[lastIndex]);
        var interpolationResult;
        if (inputOrder === 0 || !defined(interpolationAlgorithm.interpolate)) {
            interpolationResult = interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, packedInterpolationLength, this._interpolationResult);
        } else {
            var yStride = Math.floor(packedInterpolationLength / (inputOrder + 1));
            interpolationResult = interpolationAlgorithm.interpolate(x, xTable, yTable, yStride, inputOrder, inputOrder, this._interpolationResult);
        }
        if (!defined(innerType.unpackInterpolationResult)) {
            return innerType.unpack(interpolationResult, 0, result);
        }
        return innerType.unpackInterpolationResult(interpolationResult, values, firstIndex, lastIndex, result);
    }
    return innerType.unpack(this._values, index * this._packedLength, result);
};
SampledProperty.prototype.setInterpolationOptions = function (options) {
    if (!defined(options)) {
        throw new DeveloperError('options is required.');
    }
    var valuesChanged = false;
    var interpolationAlgorithm = options.interpolationAlgorithm;
    var interpolationDegree = options.interpolationDegree;
    if (this._interpolationAlgorithm !== interpolationAlgorithm) {
        this._interpolationAlgorithm = interpolationAlgorithm;
        valuesChanged = true;
    }
    if (this._interpolationDegree !== interpolationDegree) {
        this._interpolationDegree = interpolationDegree;
        valuesChanged = true;
    }
    if (valuesChanged) {
        this._updateTableLength = true;
        this._definitionChanged.raiseEvent(this);
    }
};
SampledProperty.prototype.addSample = function (time, value, derivatives) {
    var innerDerivativeTypes = this._innerDerivativeTypes;
    var hasDerivatives = defined(innerDerivativeTypes);
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!defined(value)) {
        throw new DeveloperError('value is required.');
    }
    if (hasDerivatives && !defined(derivatives)) {
        throw new DeveloperError('derivatives is required.');
    }
    var innerType = this._innerType;
    var data = [];
    data.push(time);
    innerType.pack(value, data, data.length);
    if (hasDerivatives) {
        var derivativesLength = innerDerivativeTypes.length;
        for (var x = 0; x < derivativesLength; x++) {
            innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
        }
    }
    mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
    this._updateTableLength = true;
    this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.addSamples = function (times, values, derivativeValues) {
    var innerDerivativeTypes = this._innerDerivativeTypes;
    var hasDerivatives = defined(innerDerivativeTypes);
    if (!defined(times)) {
        throw new DeveloperError('times is required.');
    }
    if (!defined(values)) {
        throw new DeveloperError('values is required.');
    }
    if (times.length !== values.length) {
        throw new DeveloperError('times and values must be the same length.');
    }
    if (hasDerivatives && (!defined(derivativeValues) || derivativeValues.length !== times.length)) {
        throw new DeveloperError('times and derivativeValues must be the same length.');
    }
    var innerType = this._innerType;
    var length = times.length;
    var data = [];
    for (var i = 0; i < length; i++) {
        data.push(times[i]);
        innerType.pack(values[i], data, data.length);
        if (hasDerivatives) {
            var derivatives = derivativeValues[i];
            var derivativesLength = innerDerivativeTypes.length;
            for (var x = 0; x < derivativesLength; x++) {
                innerDerivativeTypes[x].pack(derivatives[x], data, data.length);
            }
        }
    }
    mergeNewSamples(undefined, this._times, this._values, data, this._packedLength);
    this._updateTableLength = true;
    this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.addSamplesPackedArray = function (packedSamples, epoch) {
    if (!defined(packedSamples)) {
        throw new DeveloperError('packedSamples is required.');
    }
    mergeNewSamples(epoch, this._times, this._values, packedSamples, this._packedLength);
    this._updateTableLength = true;
    this._definitionChanged.raiseEvent(this);
};
SampledProperty.prototype.equals = function (other) {
    if (this === other) {
        return true;
    }
    if (!defined(other)) {
        return false;
    }
    if (this._type !== other._type || this._interpolationDegree !== other._interpolationDegree || this._interpolationAlgorithm !== other._interpolationAlgorithm) {
        return false;
    }
    var derivativeTypes = this._derivativeTypes;
    var hasDerivatives = defined(derivativeTypes);
    var otherDerivativeTypes = other._derivativeTypes;
    var otherHasDerivatives = defined(otherDerivativeTypes);
    if (hasDerivatives !== otherHasDerivatives) {
        return false;
    }
    var i;
    var length;
    if (hasDerivatives) {
        length = derivativeTypes.length;
        if (length !== otherDerivativeTypes.length) {
            return false;
        }
        for (i = 0; i < length; i++) {
            if (derivativeTypes[i] !== otherDerivativeTypes[i]) {
                return false;
            }
        }
    }
    var times = this._times;
    var otherTimes = other._times;
    length = times.length;
    if (length !== otherTimes.length) {
        return false;
    }
    for (i = 0; i < length; i++) {
        if (!JulianDate.equals(times[i], otherTimes[i])) {
            return false;
        }
    }
    var values = this._values;
    var otherValues = other._values;
    for (i = 0; i < length; i++) {
        if (values[i] !== otherValues[i]) {
            return false;
        }
    }
    return true;
};
SampledProperty._mergeNewSamples = mergeNewSamples;
module.exports = SampledProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/ExtrapolationType":140,"../Core/JulianDate":168,"../Core/LinearApproximation":172,"../Core/binarySearch":238,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245}],327:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defined = require('../Core/defined'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), Primitive = require('../Scene/Primitive');
'use strict';
var colorScratch = new Color();
var Batch = function (primitives, translucent, appearanceType, closed) {
    this.translucent = translucent;
    this.appearanceType = appearanceType;
    this.closed = closed;
    this.primitives = primitives;
    this.createPrimitive = false;
    this.primitive = undefined;
    this.oldPrimitive = undefined;
    this.geometry = new AssociativeArray();
    this.updaters = new AssociativeArray();
    this.updatersWithAttributes = new AssociativeArray();
    this.attributes = new AssociativeArray();
    this.itemsToRemove = [];
};
Batch.prototype.add = function (updater, instance) {
    var id = updater.entity.id;
    this.createPrimitive = true;
    this.geometry.set(id, instance);
    this.updaters.set(id, updater);
    if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant) {
        this.updatersWithAttributes.set(id, updater);
    }
};
Batch.prototype.remove = function (updater) {
    var id = updater.entity.id;
    this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;
    this.updaters.remove(id);
    this.updatersWithAttributes.remove(id);
};
Batch.prototype.update = function (time) {
    var show = true;
    var isUpdated = true;
    var removedCount = 0;
    var primitive = this.primitive;
    var primitives = this.primitives;
    if (this.createPrimitive) {
        this.attributes.removeAll();
        if (defined(primitive)) {
            if (primitive.ready) {
                this.oldPrimitive = primitive;
            } else {
                primitives.remove(primitive);
            }
            show = false;
        }
        var geometry = this.geometry.values;
        if (geometry.length > 0) {
            primitive = new Primitive({
                asynchronous: true,
                geometryInstances: geometry,
                appearance: new this.appearanceType({
                    translucent: this.translucent,
                    closed: this.closed
                })
            });
            primitive.show = show;
            primitives.add(primitive);
            isUpdated = false;
        }
        this.primitive = primitive;
        this.createPrimitive = false;
    } else if (defined(primitive) && primitive.ready) {
        if (defined(this.oldPrimitive)) {
            primitives.remove(this.oldPrimitive);
            this.oldPrimitive = undefined;
            primitive.show = true;
        }
        var updatersWithAttributes = this.updatersWithAttributes.values;
        var length = updatersWithAttributes.length;
        for (var i = 0; i < length; i++) {
            var updater = updatersWithAttributes[i];
            var instance = this.geometry.get(updater.entity.id);
            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }
            if (!updater.fillMaterialProperty.isConstant) {
                var colorProperty = updater.fillMaterialProperty.color;
                colorProperty.getValue(time, colorScratch);
                if (!Color.equals(attributes._lastColor, colorScratch)) {
                    attributes._lastColor = Color.clone(colorScratch, attributes._lastColor);
                    attributes.color = ColorGeometryInstanceAttribute.toValue(colorScratch, attributes.color);
                    if (this.translucent && attributes.color[3] === 255 || !this.translucent && attributes.color[3] !== 255) {
                        this.itemsToRemove[removedCount++] = updater;
                    }
                }
            }
            if (!updater.hasConstantFill) {
                show = updater.isFilled(time);
                if (show !== attributes._lastShow) {
                    attributes._lastShow = show;
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }
            }
        }
    } else if (defined(primitive) && !primitive.ready) {
        isUpdated = false;
    }
    this.itemsToRemove.length = removedCount;
    return isUpdated;
};
Batch.prototype.removeAllPrimitives = function () {
    var primitive = this.primitive;
    if (defined(primitive)) {
        this.primitives.remove(primitive);
        this.primitive = undefined;
        this.geometry.removeAll();
        this.updaters.removeAll();
    }
};
var StaticGeometryColorBatch = function (primitives, appearanceType, closed) {
    this._solidBatch = new Batch(primitives, false, appearanceType, closed);
    this._translucentBatch = new Batch(primitives, true, appearanceType, closed);
};
StaticGeometryColorBatch.prototype.add = function (time, updater) {
    var instance = updater.createFillGeometryInstance(time);
    if (instance.attributes.color.value[3] === 255) {
        this._solidBatch.add(updater, instance);
    } else {
        this._translucentBatch.add(updater, instance);
    }
};
StaticGeometryColorBatch.prototype.remove = function (updater) {
    if (!this._solidBatch.remove(updater)) {
        this._translucentBatch.remove(updater);
    }
};
StaticGeometryColorBatch.prototype.update = function (time) {
    var i;
    var updater;
    var isUpdated = this._solidBatch.update(time);
    isUpdated = this._translucentBatch.update(time) && isUpdated;
    var itemsToRemove = this._solidBatch.itemsToRemove;
    var solidsToMoveLength = itemsToRemove.length;
    if (solidsToMoveLength > 0) {
        for (i = 0; i < solidsToMoveLength; i++) {
            updater = itemsToRemove[i];
            this._solidBatch.remove(updater);
            this._translucentBatch.add(updater, updater.createFillGeometryInstance(time));
        }
    }
    itemsToRemove = this._translucentBatch.itemsToRemove;
    var translucentToMoveLength = itemsToRemove.length;
    if (translucentToMoveLength > 0) {
        for (i = 0; i < translucentToMoveLength; i++) {
            updater = itemsToRemove[i];
            this._translucentBatch.remove(updater);
            this._solidBatch.add(updater, updater.createFillGeometryInstance(time));
        }
    }
    if (solidsToMoveLength > 0 || translucentToMoveLength > 0) {
        isUpdated = this._solidBatch.update(time) && isUpdated;
        isUpdated = this._translucentBatch.update(time) && isUpdated;
    }
    return isUpdated;
};
StaticGeometryColorBatch.prototype.removeAllPrimitives = function () {
    this._solidBatch.removeAllPrimitives();
    this._translucentBatch.removeAllPrimitives();
};
module.exports = StaticGeometryColorBatch;
},{"../Core/AssociativeArray":93,"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defined":245,"../Scene/Primitive":428}],328:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), defined = require('../Core/defined'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), Primitive = require('../Scene/Primitive'), MaterialProperty = require('./MaterialProperty');
'use strict';
var Batch = function (primitives, appearanceType, materialProperty, closed) {
    this.primitives = primitives;
    this.appearanceType = appearanceType;
    this.materialProperty = materialProperty;
    this.closed = closed;
    this.updaters = new AssociativeArray();
    this.createPrimitive = true;
    this.primitive = undefined;
    this.oldPrimitive = undefined;
    this.geometry = new AssociativeArray();
    this.material = undefined;
    this.updatersWithAttributes = new AssociativeArray();
    this.attributes = new AssociativeArray();
    this.invalidated = false;
    this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);
};
Batch.prototype.onMaterialChanged = function () {
    this.invalidated = true;
};
Batch.prototype.isMaterial = function (updater) {
    var material = this.materialProperty;
    var updaterMaterial = updater.fillMaterialProperty;
    if (updaterMaterial === material) {
        return true;
    }
    if (defined(material)) {
        return material.equals(updaterMaterial);
    }
    return false;
};
Batch.prototype.add = function (time, updater) {
    var id = updater.entity.id;
    this.updaters.set(id, updater);
    this.geometry.set(id, updater.createFillGeometryInstance(time));
    if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant) {
        this.updatersWithAttributes.set(id, updater);
    }
    this.createPrimitive = true;
};
Batch.prototype.remove = function (updater) {
    var id = updater.entity.id;
    this.createPrimitive = this.updaters.remove(id);
    this.geometry.remove(id);
    this.updatersWithAttributes.remove(id);
    return this.createPrimitive;
};
Batch.prototype.update = function (time) {
    var show = true;
    var isUpdated = true;
    var primitive = this.primitive;
    var primitives = this.primitives;
    var geometries = this.geometry.values;
    if (this.createPrimitive) {
        if (defined(primitive)) {
            if (primitive.ready) {
                this.oldPrimitive = primitive;
            } else {
                primitives.remove(primitive);
            }
            show = false;
        }
        if (geometries.length > 0) {
            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);
            primitive = new Primitive({
                asynchronous: true,
                geometryInstances: geometries,
                appearance: new this.appearanceType({
                    material: this.material,
                    translucent: this.material.isTranslucent(),
                    closed: this.closed
                })
            });
            primitive.show = show;
            primitives.add(primitive);
            isUpdated = false;
        }
        this.primitive = primitive;
        this.createPrimitive = false;
    } else if (defined(primitive) && primitive.ready) {
        if (defined(this.oldPrimitive)) {
            primitives.remove(this.oldPrimitive);
            this.oldPrimitive = undefined;
            primitive.show = true;
        }
        this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);
        this.primitive.appearance.material = this.material;
        var updatersWithAttributes = this.updatersWithAttributes.values;
        var length = updatersWithAttributes.length;
        for (var i = 0; i < length; i++) {
            var updater = updatersWithAttributes[i];
            var instance = this.geometry.get(updater.entity.id);
            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }
            if (!updater.hasConstantFill) {
                show = updater.isFilled(time);
                if (show !== attributes._lastShow) {
                    attributes._lastShow = show;
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }
            }
        }
    } else if (defined(primitive) && !primitive.ready) {
        isUpdated = false;
    }
    return isUpdated;
};
Batch.prototype.destroy = function (time) {
    var primitive = this.primitive;
    var primitives = this.primitives;
    if (defined(primitive)) {
        primitives.remove(primitive);
    }
    this.removeMaterialSubscription();
};
var StaticGeometryPerMaterialBatch = function (primitives, appearanceType, closed) {
    this._items = [];
    this._primitives = primitives;
    this._appearanceType = appearanceType;
    this._closed = closed;
};
StaticGeometryPerMaterialBatch.prototype.add = function (time, updater) {
    var items = this._items;
    var length = items.length;
    for (var i = 0; i < length; i++) {
        var item = items[i];
        if (item.isMaterial(updater)) {
            item.add(time, updater);
            return;
        }
    }
    var batch = new Batch(this._primitives, this._appearanceType, updater.fillMaterialProperty, this._closed);
    batch.add(time, updater);
    items.push(batch);
};
StaticGeometryPerMaterialBatch.prototype.remove = function (updater) {
    var items = this._items;
    var length = items.length;
    for (var i = length - 1; i >= 0; i--) {
        var item = items[i];
        if (item.remove(updater)) {
            if (item.updaters.length === 0) {
                items.splice(i, 1);
                item.destroy();
            }
            break;
        }
    }
};
StaticGeometryPerMaterialBatch.prototype.update = function (time) {
    var i;
    var items = this._items;
    var length = items.length;
    for (i = length - 1; i >= 0; i--) {
        var item = items[i];
        if (item.invalidated) {
            items.splice(i, 1);
            var updaters = item.updaters.values;
            var updatersLength = updaters.length;
            for (var h = 0; h < updatersLength; h++) {
                this.add(time, updaters[h]);
            }
            item.destroy();
        }
    }
    var isUpdated = true;
    for (i = 0; i < length; i++) {
        isUpdated = items[i].update(time) && isUpdated;
    }
    return isUpdated;
};
StaticGeometryPerMaterialBatch.prototype.removeAllPrimitives = function () {
    var items = this._items;
    var length = items.length;
    for (var i = 0; i < length; i++) {
        items[i].destroy();
    }
    this._items.length = 0;
};
module.exports = StaticGeometryPerMaterialBatch;
},{"../Core/AssociativeArray":93,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defined":245,"../Scene/Primitive":428,"./MaterialProperty":305}],329:[function(require,module,exports){
var AssociativeArray = require('../Core/AssociativeArray'), Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defined = require('../Core/defined'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive');
'use strict';
var Batch = function (primitives, translucent, width) {
    this.translucent = translucent;
    this.primitives = primitives;
    this.createPrimitive = false;
    this.primitive = undefined;
    this.oldPrimitive = undefined;
    this.geometry = new AssociativeArray();
    this.updaters = new AssociativeArray();
    this.updatersWithAttributes = new AssociativeArray();
    this.attributes = new AssociativeArray();
    this.itemsToRemove = [];
    this.width = width;
};
Batch.prototype.add = function (updater, instance) {
    var id = updater.entity.id;
    this.createPrimitive = true;
    this.geometry.set(id, instance);
    this.updaters.set(id, updater);
    if (!updater.hasConstantOutline || !updater.outlineColorProperty.isConstant) {
        this.updatersWithAttributes.set(id, updater);
    }
};
Batch.prototype.remove = function (updater) {
    var id = updater.entity.id;
    this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;
    this.updaters.remove(id);
    this.updatersWithAttributes.remove(id);
};
var colorScratch = new Color();
Batch.prototype.update = function (time) {
    var show = true;
    var isUpdated = true;
    var removedCount = 0;
    var primitive = this.primitive;
    var primitives = this.primitives;
    if (this.createPrimitive) {
        this.attributes.removeAll();
        if (defined(primitive)) {
            if (primitive.ready) {
                this.oldPrimitive = primitive;
            } else {
                primitives.remove(primitive);
            }
            show = false;
        }
        var geometry = this.geometry.values;
        if (geometry.length > 0) {
            primitive = new Primitive({
                asynchronous: true,
                geometryInstances: geometry,
                appearance: new PerInstanceColorAppearance({
                    flat: true,
                    translucent: this.translucent,
                    renderState: { lineWidth: this.width }
                })
            });
            primitives.add(primitive);
            isUpdated = false;
            primitive.show = show;
        }
        this.primitive = primitive;
        this.createPrimitive = false;
    } else if (defined(primitive) && primitive.ready) {
        if (defined(this.oldPrimitive)) {
            primitives.remove(this.oldPrimitive);
            this.oldPrimitive = undefined;
            primitive.show = true;
        }
        var updatersWithAttributes = this.updatersWithAttributes.values;
        var length = updatersWithAttributes.length;
        for (var i = 0; i < length; i++) {
            var updater = updatersWithAttributes[i];
            var instance = this.geometry.get(updater.entity.id);
            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }
            if (!updater.outlineColorProperty.isConstant) {
                var outlineColorProperty = updater.outlineColorProperty;
                outlineColorProperty.getValue(time, colorScratch);
                if (!Color.equals(attributes._lastColor, colorScratch)) {
                    attributes._lastColor = Color.clone(colorScratch, attributes._lastColor);
                    attributes.color = ColorGeometryInstanceAttribute.toValue(colorScratch, attributes.color);
                    if (this.translucent && attributes.color[3] === 255 || !this.translucent && attributes.color[3] !== 255) {
                        this.itemsToRemove[removedCount++] = updater;
                    }
                }
            }
            if (!updater.hasConstantOutline) {
                show = updater.isOutlineVisible(time);
                if (show !== attributes._lastShow) {
                    attributes._lastShow = show;
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }
            }
        }
    } else if (defined(primitive) && !primitive.ready) {
        isUpdated = false;
    }
    this.itemsToRemove.length = removedCount;
    return isUpdated;
};
Batch.prototype.removeAllPrimitives = function () {
    var primitive = this.primitive;
    if (defined(primitive)) {
        this.primitives.remove(primitive);
        this.primitive = undefined;
        this.geometry.removeAll();
        this.updaters.removeAll();
    }
};
var StaticOutlineGeometryBatch = function (primitives, scene) {
    this._primitives = primitives;
    this._scene = scene;
    this._solidBatches = new AssociativeArray();
    this._translucentBatches = new AssociativeArray();
};
StaticOutlineGeometryBatch.prototype.add = function (time, updater) {
    var instance = updater.createOutlineGeometryInstance(time);
    var width = this._scene.clampLineWidth(updater.outlineWidth);
    var batches;
    var batch;
    if (instance.attributes.color.value[3] === 255) {
        batches = this._solidBatches;
        batch = batches.get(width);
        if (!defined(batch)) {
            batch = new Batch(this._primitives, false, width);
            batches.set(width, batch);
        }
        batch.add(updater, instance);
    } else {
        batches = this._translucentBatches;
        batch = batches.get(width);
        if (!defined(batch)) {
            batch = new Batch(this._primitives, true, width);
            batches.set(width, batch);
        }
        batch.add(updater, instance);
    }
};
StaticOutlineGeometryBatch.prototype.remove = function (updater) {
    var i;
    var solidBatches = this._solidBatches.values;
    var solidBatchesLength = solidBatches.length;
    for (i = 0; i < solidBatchesLength; i++) {
        if (solidBatches[i].remove(updater)) {
            return;
        }
    }
    var translucentBatches = this._translucentBatches.values;
    var translucentBatchesLength = translucentBatches.length;
    for (i = 0; i < translucentBatchesLength; i++) {
        if (translucentBatches.remove(updater)) {
            return;
        }
    }
};
StaticOutlineGeometryBatch.prototype.update = function (time) {
    var i;
    var x;
    var updater;
    var batch;
    var solidBatches = this._solidBatches.values;
    var solidBatchesLength = solidBatches.length;
    var translucentBatches = this._translucentBatches.values;
    var translucentBatchesLength = translucentBatches.length;
    var itemsToRemove;
    var isUpdated = true;
    var needUpdate = false;
    do {
        needUpdate = false;
        for (x = 0; x < solidBatchesLength; x++) {
            batch = solidBatches[x];
            isUpdated = batch.update(time);
            itemsToRemove = batch.itemsToRemove;
            var solidsToMoveLength = itemsToRemove.length;
            if (solidsToMoveLength > 0) {
                needUpdate = true;
                for (i = 0; i < solidsToMoveLength; i++) {
                    updater = itemsToRemove[i];
                    batch.remove(updater);
                    this.add(time, updater);
                }
            }
        }
        for (x = 0; x < translucentBatchesLength; x++) {
            batch = translucentBatches[x];
            isUpdated = batch.update(time);
            itemsToRemove = batch.itemsToRemove;
            var translucentToMoveLength = itemsToRemove.length;
            if (translucentToMoveLength > 0) {
                needUpdate = true;
                for (i = 0; i < translucentToMoveLength; i++) {
                    updater = itemsToRemove[i];
                    batch.remove(updater);
                    this.add(time, updater);
                }
            }
        }
    } while (needUpdate);
    return isUpdated;
};
StaticOutlineGeometryBatch.prototype.removeAllPrimitives = function () {
    var i;
    var solidBatches = this._solidBatches.values;
    var solidBatchesLength = solidBatches.length;
    for (i = 0; i < solidBatchesLength; i++) {
        solidBatches[i].removeAllPrimitives();
    }
    var translucentBatches = this._translucentBatches.values;
    var translucentBatchesLength = translucentBatches.length;
    for (i = 0; i < translucentBatchesLength; i++) {
        translucentBatches[i].removeAllPrimitives();
    }
};
module.exports = StaticOutlineGeometryBatch;
},{"../Core/AssociativeArray":93,"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/ShowGeometryInstanceAttribute":210,"../Core/defined":245,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428}],330:[function(require,module,exports){
var Color = require('../Core/Color'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor'), Property = require('./Property'), StripeOrientation = require('./StripeOrientation');
'use strict';
var defaultOrientation = StripeOrientation.HORIZONTAL;
var defaultEvenColor = Color.WHITE;
var defaultOddColor = Color.BLACK;
var defaultOffset = 0;
var defaultRepeat = 1;
var StripeMaterialProperty = function () {
    this._definitionChanged = new Event();
    this._orientation = undefined;
    this._orientationSubscription = undefined;
    this._evenColor = undefined;
    this._evenColorSubscription = undefined;
    this._oddColor = undefined;
    this._oddColorSubscription = undefined;
    this._offset = undefined;
    this._offsetSubscription = undefined;
    this._repeat = undefined;
    this._repeatSubscription = undefined;
};
defineProperties(StripeMaterialProperty.prototype, {
    isConstant: {
        get: function () {
            return Property.isConstant(this._orientation) && Property.isConstant(this._evenColor) && Property.isConstant(this._oddColor) && Property.isConstant(this._offset) && Property.isConstant(this._repeat);
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    orientation: createPropertyDescriptor('orientation'),
    evenColor: createPropertyDescriptor('evenColor'),
    oddColor: createPropertyDescriptor('oddColor'),
    offset: createPropertyDescriptor('offset'),
    repeat: createPropertyDescriptor('repeat')
});
StripeMaterialProperty.prototype.getType = function (time) {
    return 'Stripe';
};
StripeMaterialProperty.prototype.getValue = function (time, result) {
    if (!defined(result)) {
        result = {};
    }
    result.horizontal = Property.getValueOrDefault(this._orientation, time, defaultOrientation) === StripeOrientation.HORIZONTAL;
    result.evenColor = Property.getValueOrClonedDefault(this._evenColor, time, defaultEvenColor, result.evenColor);
    result.oddColor = Property.getValueOrClonedDefault(this._oddColor, time, defaultOddColor, result.oddColor);
    result.offset = Property.getValueOrDefault(this._offset, time, defaultOffset);
    result.repeat = Property.getValueOrDefault(this._repeat, time, defaultRepeat);
    return result;
};
StripeMaterialProperty.prototype.equals = function (other) {
    return this === other || other instanceof StripeMaterialProperty && Property.equals(this._orientation, other._orientation) && Property.equals(this._evenColor, other._evenColor) && Property.equals(this._oddColor, other._oddColor) && Property.equals(this._offset, other._offset) && Property.equals(this._repeat, other._repeat);
};
module.exports = StripeMaterialProperty;
},{"../Core/Color":111,"../Core/Event":138,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321,"./StripeOrientation":331,"./createPropertyDescriptor":336}],331:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var StripeOrientation = {
        HORIZONTAL: 0,
        VERTICAL: 1
    };
module.exports = freezeObject(StripeOrientation);
},{"../Core/freezeObject":249}],332:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), ReferenceFrame = require('../Core/ReferenceFrame'), TimeIntervalCollection = require('../Core/TimeIntervalCollection'), PositionProperty = require('./PositionProperty'), Property = require('./Property');
'use strict';
var TimeIntervalCollectionPositionProperty = function (referenceFrame) {
    this._definitionChanged = new Event();
    this._intervals = new TimeIntervalCollection();
    this._intervals.changedEvent.addEventListener(TimeIntervalCollectionPositionProperty.prototype._intervalsChanged, this);
    this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);
};
defineProperties(TimeIntervalCollectionPositionProperty.prototype, {
    isConstant: {
        get: function () {
            return this._intervals.isEmpty;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    intervals: {
        get: function () {
            return this._intervals;
        }
    },
    referenceFrame: {
        get: function () {
            return this._referenceFrame;
        }
    }
});
TimeIntervalCollectionPositionProperty.prototype.getValue = function (time, result) {
    return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);
};
TimeIntervalCollectionPositionProperty.prototype.getValueInReferenceFrame = function (time, referenceFrame, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!defined(referenceFrame)) {
        throw new DeveloperError('referenceFrame is required.');
    }
    var position = this._intervals.findDataForIntervalContainingDate(time);
    if (defined(position)) {
        return PositionProperty.convertToReferenceFrame(time, position, this._referenceFrame, referenceFrame, result);
    }
    return undefined;
};
TimeIntervalCollectionPositionProperty.prototype.equals = function (other) {
    return this === other || other instanceof TimeIntervalCollectionPositionProperty && this._intervals.equals(other._intervals, Property.equals) && this._referenceFrame === other._referenceFrame;
};
TimeIntervalCollectionPositionProperty.prototype._intervalsChanged = function () {
    this._definitionChanged.raiseEvent(this);
};
module.exports = TimeIntervalCollectionPositionProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/ReferenceFrame":205,"../Core/TimeIntervalCollection":223,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./PositionProperty":319,"./Property":321}],333:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), TimeIntervalCollection = require('../Core/TimeIntervalCollection'), Property = require('./Property');
'use strict';
var TimeIntervalCollectionProperty = function () {
    this._definitionChanged = new Event();
    this._intervals = new TimeIntervalCollection();
    this._intervals.changedEvent.addEventListener(TimeIntervalCollectionProperty.prototype._intervalsChanged, this);
};
defineProperties(TimeIntervalCollectionProperty.prototype, {
    isConstant: {
        get: function () {
            return this._intervals.isEmpty;
        }
    },
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    intervals: {
        get: function () {
            return this._intervals;
        }
    }
});
TimeIntervalCollectionProperty.prototype.getValue = function (time, result) {
    if (!defined(time)) {
        throw new DeveloperError('time is required');
    }
    var value = this._intervals.findDataForIntervalContainingDate(time);
    if (defined(value) && typeof value.clone === 'function') {
        return value.clone(result);
    }
    return value;
};
TimeIntervalCollectionProperty.prototype.equals = function (other) {
    return this === other || other instanceof TimeIntervalCollectionProperty && this._intervals.equals(other._intervals, Property.equals);
};
TimeIntervalCollectionProperty.prototype._intervalsChanged = function () {
    this._definitionChanged.raiseEvent(this);
};
module.exports = TimeIntervalCollectionProperty;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/TimeIntervalCollection":223,"../Core/defineProperties":244,"../Core/defined":245,"./Property":321}],334:[function(require,module,exports){
var Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeometryInstance = require('../Core/GeometryInstance'), Iso8601 = require('../Core/Iso8601'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), WallGeometry = require('../Core/WallGeometry'), WallOutlineGeometry = require('../Core/WallOutlineGeometry'), MaterialAppearance = require('../Scene/MaterialAppearance'), PerInstanceColorAppearance = require('../Scene/PerInstanceColorAppearance'), Primitive = require('../Scene/Primitive'), ColorMaterialProperty = require('./ColorMaterialProperty'), ConstantProperty = require('./ConstantProperty'), MaterialProperty = require('./MaterialProperty'), Property = require('./Property');
'use strict';
var defaultMaterial = ColorMaterialProperty.fromColor(Color.WHITE);
var defaultShow = new ConstantProperty(true);
var defaultFill = new ConstantProperty(true);
var defaultOutline = new ConstantProperty(false);
var defaultOutlineColor = new ConstantProperty(Color.BLACK);
var scratchColor = new Color();
var GeometryOptions = function (entity) {
    this.id = entity;
    this.vertexFormat = undefined;
    this.positions = undefined;
    this.minimumHeights = undefined;
    this.maximumHeights = undefined;
    this.granularity = undefined;
};
var WallGeometryUpdater = function (entity, scene) {
    if (!defined(entity)) {
        throw new DeveloperError('entity is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    this._entity = entity;
    this._scene = scene;
    this._entitySubscription = entity.definitionChanged.addEventListener(WallGeometryUpdater.prototype._onEntityPropertyChanged, this);
    this._fillEnabled = false;
    this._dynamic = false;
    this._outlineEnabled = false;
    this._geometryChanged = new Event();
    this._showProperty = undefined;
    this._materialProperty = undefined;
    this._hasConstantOutline = true;
    this._showOutlineProperty = undefined;
    this._outlineColorProperty = undefined;
    this._outlineWidth = 1;
    this._options = new GeometryOptions(entity);
    this._onEntityPropertyChanged(entity, 'wall', entity.wall, undefined);
};
defineProperties(WallGeometryUpdater, {
    perInstanceColorAppearanceType: { value: PerInstanceColorAppearance },
    materialAppearanceType: { value: MaterialAppearance }
});
defineProperties(WallGeometryUpdater.prototype, {
    entity: {
        get: function () {
            return this._entity;
        }
    },
    fillEnabled: {
        get: function () {
            return this._fillEnabled;
        }
    },
    hasConstantFill: {
        get: function () {
            return !this._fillEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._fillProperty);
        }
    },
    fillMaterialProperty: {
        get: function () {
            return this._materialProperty;
        }
    },
    outlineEnabled: {
        get: function () {
            return this._outlineEnabled;
        }
    },
    hasConstantOutline: {
        get: function () {
            return !this._outlineEnabled || !defined(this._entity.availability) && Property.isConstant(this._showProperty) && Property.isConstant(this._showOutlineProperty);
        }
    },
    outlineColorProperty: {
        get: function () {
            return this._outlineColorProperty;
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        }
    },
    isDynamic: {
        get: function () {
            return this._dynamic;
        }
    },
    isClosed: {
        get: function () {
            return false;
        }
    },
    geometryChanged: {
        get: function () {
            return this._geometryChanged;
        }
    }
});
WallGeometryUpdater.prototype.isOutlineVisible = function (time) {
    var entity = this._entity;
    return this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
};
WallGeometryUpdater.prototype.isFilled = function (time) {
    var entity = this._entity;
    return this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
};
WallGeometryUpdater.prototype.createFillGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._fillEnabled) {
        throw new DeveloperError('This instance does not represent a filled geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var attributes;
    var color;
    var show = new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
    if (this._materialProperty instanceof ColorMaterialProperty) {
        var currentColor = Color.WHITE;
        if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
            currentColor = this._materialProperty.color.getValue(time);
        }
        color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        attributes = {
            show: show,
            color: color
        };
    } else {
        attributes = { show: show };
    }
    return new GeometryInstance({
        id: entity,
        geometry: new WallGeometry(this._options),
        attributes: attributes
    });
};
WallGeometryUpdater.prototype.createOutlineGeometryInstance = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    if (!this._outlineEnabled) {
        throw new DeveloperError('This instance does not represent an outlined geometry.');
    }
    var entity = this._entity;
    var isAvailable = entity.isAvailable(time);
    var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK);
    return new GeometryInstance({
        id: entity,
        geometry: new WallOutlineGeometry(this._options),
        attributes: {
            show: new ShowGeometryInstanceAttribute(isAvailable && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color: ColorGeometryInstanceAttribute.fromColor(outlineColor)
        }
    });
};
WallGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
WallGeometryUpdater.prototype.destroy = function () {
    this._entitySubscription();
    destroyObject(this);
};
WallGeometryUpdater.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {
    if (!(propertyName === 'availability' || propertyName === 'wall')) {
        return;
    }
    var wall = this._entity.wall;
    if (!defined(wall)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var fillProperty = wall.fill;
    var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;
    var outlineProperty = wall.outline;
    var outlineEnabled = defined(outlineProperty);
    if (outlineEnabled && outlineProperty.isConstant) {
        outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
    }
    if (!fillEnabled && !outlineEnabled) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var positions = wall.positions;
    var show = wall.show;
    if (defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE) || !defined(positions)) {
        if (this._fillEnabled || this._outlineEnabled) {
            this._fillEnabled = false;
            this._outlineEnabled = false;
            this._geometryChanged.raiseEvent(this);
        }
        return;
    }
    var material = defaultValue(wall.material, defaultMaterial);
    var isColorMaterial = material instanceof ColorMaterialProperty;
    this._materialProperty = material;
    this._fillProperty = defaultValue(fillProperty, defaultFill);
    this._showProperty = defaultValue(show, defaultShow);
    this._showOutlineProperty = defaultValue(wall.outline, defaultOutline);
    this._outlineColorProperty = outlineEnabled ? defaultValue(wall.outlineColor, defaultOutlineColor) : undefined;
    var minimumHeights = wall.minimumHeights;
    var maximumHeights = wall.maximumHeights;
    var outlineWidth = wall.outlineWidth;
    var granularity = wall.granularity;
    this._fillEnabled = fillEnabled;
    this._outlineEnabled = outlineEnabled;
    if (!positions.isConstant || !Property.isConstant(minimumHeights) || !Property.isConstant(maximumHeights) || !Property.isConstant(outlineWidth) || !Property.isConstant(granularity)) {
        if (!this._dynamic) {
            this._dynamic = true;
            this._geometryChanged.raiseEvent(this);
        }
    } else {
        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.positions = positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);
        options.minimumHeights = defined(minimumHeights) ? minimumHeights.getValue(Iso8601.MINIMUM_VALUE, options.minimumHeights) : undefined;
        options.maximumHeights = defined(maximumHeights) ? maximumHeights.getValue(Iso8601.MINIMUM_VALUE, options.maximumHeights) : undefined;
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1;
        this._dynamic = false;
        this._geometryChanged.raiseEvent(this);
    }
};
WallGeometryUpdater.prototype.createDynamicUpdater = function (primitives) {
    if (!this._dynamic) {
        throw new DeveloperError('This instance does not represent dynamic geometry.');
    }
    if (!defined(primitives)) {
        throw new DeveloperError('primitives is required.');
    }
    return new DynamicGeometryUpdater(primitives, this);
};
var DynamicGeometryUpdater = function (primitives, geometryUpdater) {
    this._primitives = primitives;
    this._primitive = undefined;
    this._outlinePrimitive = undefined;
    this._geometryUpdater = geometryUpdater;
    this._options = new GeometryOptions(geometryUpdater._entity);
};
DynamicGeometryUpdater.prototype.update = function (time) {
    if (!defined(time)) {
        throw new DeveloperError('time is required.');
    }
    var primitives = this._primitives;
    primitives.removeAndDestroy(this._primitive);
    primitives.removeAndDestroy(this._outlinePrimitive);
    var geometryUpdater = this._geometryUpdater;
    var entity = geometryUpdater._entity;
    var wall = entity.wall;
    if (!entity.isAvailable(time) || !Property.getValueOrDefault(wall.show, time, true)) {
        return;
    }
    var options = this._options;
    var positions = Property.getValueOrUndefined(wall.positions, time, options.positions);
    if (!defined(positions)) {
        return;
    }
    options.positions = positions;
    options.minimumHeights = Property.getValueOrUndefined(wall.minimumHeights, time, options.minimumHeights);
    options.maximumHeights = Property.getValueOrUndefined(wall.maximumHeights, time, options.maximumHeights);
    options.granularity = Property.getValueOrUndefined(wall.granularity, time);
    if (Property.getValueOrDefault(wall.fill, time, true)) {
        var material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, this._material);
        this._material = material;
        var appearance = new MaterialAppearance({
                material: material,
                translucent: material.isTranslucent(),
                closed: defined(options.extrudedHeight)
            });
        options.vertexFormat = appearance.vertexFormat;
        this._primitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new WallGeometry(options)
            }),
            appearance: appearance,
            asynchronous: false
        }));
    }
    if (Property.getValueOrDefault(wall.outline, time, false)) {
        options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
        var outlineColor = Property.getValueOrClonedDefault(wall.outlineColor, time, Color.BLACK, scratchColor);
        var outlineWidth = Property.getValueOrDefault(wall.outlineWidth, 1);
        var translucent = outlineColor.alpha !== 1;
        this._outlinePrimitive = primitives.add(new Primitive({
            geometryInstances: new GeometryInstance({
                id: entity,
                geometry: new WallOutlineGeometry(options),
                attributes: { color: ColorGeometryInstanceAttribute.fromColor(outlineColor) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: translucent,
                renderState: { lineWidth: geometryUpdater._scene.clampLineWidth(outlineWidth) }
            }),
            asynchronous: false
        }));
    }
};
DynamicGeometryUpdater.prototype.isDestroyed = function () {
    return false;
};
DynamicGeometryUpdater.prototype.destroy = function () {
    var primitives = this._primitives;
    primitives.removeAndDestroy(this._primitive);
    primitives.removeAndDestroy(this._outlinePrimitive);
    destroyObject(this);
};
module.exports = WallGeometryUpdater;
},{"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeometryInstance":148,"../Core/Iso8601":167,"../Core/ShowGeometryInstanceAttribute":210,"../Core/WallGeometry":230,"../Core/WallOutlineGeometry":232,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Scene/MaterialAppearance":405,"../Scene/PerInstanceColorAppearance":420,"../Scene/Primitive":428,"./ColorMaterialProperty":278,"./ConstantProperty":283,"./MaterialProperty":305,"./Property":321}],335:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), createPropertyDescriptor = require('./createPropertyDescriptor');
'use strict';
var WallGraphics = function () {
    this._show = undefined;
    this._showSubscription = undefined;
    this._material = undefined;
    this._materialSubscription = undefined;
    this._positions = undefined;
    this._positionsSubscription = undefined;
    this._minimumHeights = undefined;
    this._minimumHeightsSubscription = undefined;
    this._maximumHeights = undefined;
    this._maximumHeightsSubscription = undefined;
    this._granularity = undefined;
    this._granularitySubscription = undefined;
    this._fill = undefined;
    this._fillSubscription = undefined;
    this._outline = undefined;
    this._outlineSubscription = undefined;
    this._outlineColor = undefined;
    this._outlineColorSubscription = undefined;
    this._outlineWidth = undefined;
    this._outlineWidthSubscription = undefined;
    this._definitionChanged = new Event();
};
defineProperties(WallGraphics.prototype, {
    definitionChanged: {
        get: function () {
            return this._definitionChanged;
        }
    },
    show: createPropertyDescriptor('show'),
    material: createPropertyDescriptor('material'),
    positions: createPropertyDescriptor('positions'),
    minimumHeights: createPropertyDescriptor('minimumHeights'),
    maximumHeights: createPropertyDescriptor('maximumHeights'),
    granularity: createPropertyDescriptor('granularity'),
    fill: createPropertyDescriptor('fill'),
    outline: createPropertyDescriptor('outline'),
    outlineColor: createPropertyDescriptor('outlineColor'),
    outlineWidth: createPropertyDescriptor('outlineWidth')
});
WallGraphics.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new WallGraphics();
    }
    result.show = this.show;
    result.material = this.material;
    result.positions = this.positions;
    result.minimumHeights = this.minimumHeights;
    result.maximumHeights = this.maximumHeights;
    result.granularity = this.granularity;
    result.fill = this.fill;
    result.outline = this.outline;
    result.outlineColor = this.outlineColor;
    result.outlineWidth = this.outlineWidth;
    return result;
};
WallGraphics.prototype.merge = function (source) {
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    this.show = defaultValue(this.show, source.show);
    this.material = defaultValue(this.material, source.material);
    this.positions = defaultValue(this.positions, source.positions);
    this.minimumHeights = defaultValue(this.minimumHeights, source.minimumHeights);
    this.maximumHeights = defaultValue(this.maximumHeights, source.maximumHeights);
    this.granularity = defaultValue(this.granularity, source.granularity);
    this.fill = defaultValue(this.fill, source.fill);
    this.outline = defaultValue(this.outline, source.outline);
    this.outlineColor = defaultValue(this.outlineColor, source.outlineColor);
    this.outlineWidth = defaultValue(this.outlineWidth, source.outlineWidth);
};
module.exports = WallGraphics;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./createPropertyDescriptor":336}],336:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined');
'use strict';
function createProperty(name, privateName, subscriptionName, configurable) {
    return {
        configurable: configurable,
        get: function () {
            return this[privateName];
        },
        set: function (value) {
            var oldValue = this[privateName];
            var subscription = this[subscriptionName];
            if (defined(subscription)) {
                subscription();
                this[subscriptionName] = undefined;
            }
            if (oldValue !== value) {
                this[privateName] = value;
                this._definitionChanged.raiseEvent(this, name, value, oldValue);
            }
            if (defined(value) && defined(value.definitionChanged)) {
                this[subscriptionName] = value.definitionChanged.addEventListener(function () {
                    this._definitionChanged.raiseEvent(this, name, value, value);
                }, this);
            }
        }
    };
}
function createPropertyDescriptor(name, configurable) {
    return createProperty(name, '_' + name, '_' + name + 'Subscription', defaultValue(configurable, false));
}
module.exports = createPropertyDescriptor;
},{"../Core/defaultValue":243,"../Core/defined":245}],337:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defineProperties = require('../Core/defineProperties'), Matrix4 = require('../Core/Matrix4');
'use strict';
var viewerPositionWCScratch = new Cartesian3();
var AutomaticUniform = function (options) {
    this._size = options.size;
    this._datatype = options.datatype;
    this.getValue = options.getValue;
};
defineProperties(AutomaticUniform.prototype, {
    size: {
        get: function () {
            return this._size;
        }
    },
    datatype: {
        get: function () {
            return this._datatype;
        }
    }
});
if (typeof WebGLRenderingContext === 'undefined') {
    return {};
}
var datatypeToGlsl = {};
datatypeToGlsl[WebGLRenderingContext.FLOAT] = 'float';
datatypeToGlsl[WebGLRenderingContext.FLOAT_VEC2] = 'vec2';
datatypeToGlsl[WebGLRenderingContext.FLOAT_VEC3] = 'vec3';
datatypeToGlsl[WebGLRenderingContext.FLOAT_VEC4] = 'vec4';
datatypeToGlsl[WebGLRenderingContext.INT] = 'int';
datatypeToGlsl[WebGLRenderingContext.INT_VEC2] = 'ivec2';
datatypeToGlsl[WebGLRenderingContext.INT_VEC3] = 'ivec3';
datatypeToGlsl[WebGLRenderingContext.INT_VEC4] = 'ivec4';
datatypeToGlsl[WebGLRenderingContext.BOOL] = 'bool';
datatypeToGlsl[WebGLRenderingContext.BOOL_VEC2] = 'bvec2';
datatypeToGlsl[WebGLRenderingContext.BOOL_VEC3] = 'bvec3';
datatypeToGlsl[WebGLRenderingContext.BOOL_VEC4] = 'bvec4';
datatypeToGlsl[WebGLRenderingContext.FLOAT_MAT2] = 'mat2';
datatypeToGlsl[WebGLRenderingContext.FLOAT_MAT3] = 'mat3';
datatypeToGlsl[WebGLRenderingContext.FLOAT_MAT4] = 'mat4';
datatypeToGlsl[WebGLRenderingContext.SAMPLER_2D] = 'sampler2D';
datatypeToGlsl[WebGLRenderingContext.SAMPLER_CUBE] = 'samplerCube';
AutomaticUniform.prototype.getDeclaration = function (name) {
    var declaration = 'uniform ' + datatypeToGlsl[this._datatype] + ' ' + name;
    var size = this._size;
    if (size === 1) {
        declaration += ';';
    } else {
        declaration += '[' + size.toString() + '];';
    }
    return declaration;
};
var AutomaticUniforms = {
        czm_viewport: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC4,
            getValue: function (uniformState) {
                return uniformState.viewportCartesian4;
            }
        }),
        czm_viewportOrthographic: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.viewportOrthographic;
            }
        }),
        czm_viewportTransformation: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.viewportTransformation;
            }
        }),
        czm_model: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.model;
            }
        }),
        czm_inverseModel: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseModel;
            }
        }),
        czm_view: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.view;
            }
        }),
        czm_view3D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.view3D;
            }
        }),
        czm_viewRotation: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.viewRotation;
            }
        }),
        czm_viewRotation3D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.viewRotation3D;
            }
        }),
        czm_inverseView: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseView;
            }
        }),
        czm_inverseView3D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseView3D;
            }
        }),
        czm_inverseViewRotation: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.inverseViewRotation;
            }
        }),
        czm_inverseViewRotation3D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.inverseViewRotation3D;
            }
        }),
        czm_projection: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.projection;
            }
        }),
        czm_inverseProjection: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseProjection;
            }
        }),
        czm_inverseProjectionOIT: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseProjectionOIT;
            }
        }),
        czm_infiniteProjection: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.infiniteProjection;
            }
        }),
        czm_modelView: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.modelView;
            }
        }),
        czm_modelView3D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.modelView3D;
            }
        }),
        czm_modelViewRelativeToEye: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.modelViewRelativeToEye;
            }
        }),
        czm_inverseModelView: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseModelView;
            }
        }),
        czm_inverseModelView3D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseModelView3D;
            }
        }),
        czm_viewProjection: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.viewProjection;
            }
        }),
        czm_inverseViewProjection: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseViewProjection;
            }
        }),
        czm_modelViewProjection: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.modelViewProjection;
            }
        }),
        czm_inverseModelViewProjection: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.inverseModelViewProjection;
            }
        }),
        czm_modelViewProjectionRelativeToEye: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.modelViewProjectionRelativeToEye;
            }
        }),
        czm_modelViewInfiniteProjection: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT4,
            getValue: function (uniformState) {
                return uniformState.modelViewInfiniteProjection;
            }
        }),
        czm_normal: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.normal;
            }
        }),
        czm_normal3D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.normal3D;
            }
        }),
        czm_inverseNormal: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.inverseNormal;
            }
        }),
        czm_inverseNormal3D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.inverseNormal3D;
            }
        }),
        czm_eyeHeight2D: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC2,
            getValue: function (uniformState) {
                return uniformState.eyeHeight2D;
            }
        }),
        czm_entireFrustum: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC2,
            getValue: function (uniformState) {
                return uniformState.entireFrustum;
            }
        }),
        czm_currentFrustum: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC2,
            getValue: function (uniformState) {
                return uniformState.currentFrustum;
            }
        }),
        czm_sunPositionWC: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC3,
            getValue: function (uniformState) {
                return uniformState.sunPositionWC;
            }
        }),
        czm_sunPositionColumbusView: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC3,
            getValue: function (uniformState) {
                return uniformState.sunPositionColumbusView;
            }
        }),
        czm_sunDirectionEC: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC3,
            getValue: function (uniformState) {
                return uniformState.sunDirectionEC;
            }
        }),
        czm_sunDirectionWC: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC3,
            getValue: function (uniformState) {
                return uniformState.sunDirectionWC;
            }
        }),
        czm_moonDirectionEC: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC3,
            getValue: function (uniformState) {
                return uniformState.moonDirectionEC;
            }
        }),
        czm_encodedCameraPositionMCHigh: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC3,
            getValue: function (uniformState) {
                return uniformState.encodedCameraPositionMCHigh;
            }
        }),
        czm_encodedCameraPositionMCLow: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC3,
            getValue: function (uniformState) {
                return uniformState.encodedCameraPositionMCLow;
            }
        }),
        czm_viewerPositionWC: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_VEC3,
            getValue: function (uniformState) {
                return Matrix4.getTranslation(uniformState.inverseView, viewerPositionWCScratch);
            }
        }),
        czm_frameNumber: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT,
            getValue: function (uniformState) {
                return uniformState.frameState.frameNumber;
            }
        }),
        czm_morphTime: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT,
            getValue: function (uniformState) {
                return uniformState.frameState.morphTime;
            }
        }),
        czm_sceneMode: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT,
            getValue: function (uniformState) {
                return uniformState.frameState.mode;
            }
        }),
        czm_temeToPseudoFixed: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT_MAT3,
            getValue: function (uniformState) {
                return uniformState.temeToPseudoFixedMatrix;
            }
        }),
        czm_resolutionScale: new AutomaticUniform({
            size: 1,
            datatype: WebGLRenderingContext.FLOAT,
            getValue: function (uniformState) {
                return uniformState.resolutionScale;
            }
        })
    };
module.exports = AutomaticUniforms;
},{"../Core/Cartesian3":102,"../Core/Matrix4":177,"../Core/defineProperties":244}],338:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError');
'use strict';
var Buffer = function (gl, bufferTarget, sizeInBytes, usage, buffer) {
    this._gl = gl;
    this._bufferTarget = bufferTarget;
    this._sizeInBytes = sizeInBytes;
    this._usage = usage;
    this._buffer = buffer;
    this.vertexArrayDestroyable = true;
};
defineProperties(Buffer.prototype, {
    sizeInBytes: {
        get: function () {
            return this._sizeInBytes;
        }
    },
    usage: {
        get: function () {
            return this._usage;
        }
    }
});
Buffer.prototype._getBuffer = function () {
    return this._buffer;
};
Buffer.prototype.copyFromArrayView = function (arrayView, offsetInBytes) {
    offsetInBytes = defaultValue(offsetInBytes, 0);
    if (!arrayView) {
        throw new DeveloperError('arrayView is required.');
    }
    if (offsetInBytes + arrayView.byteLength > this._sizeInBytes) {
        throw new DeveloperError('This buffer is not large enough.');
    }
    var gl = this._gl;
    var target = this._bufferTarget;
    gl.bindBuffer(target, this._buffer);
    gl.bufferSubData(target, offsetInBytes, arrayView);
    gl.bindBuffer(target, null);
};
Buffer.prototype.isDestroyed = function () {
    return false;
};
Buffer.prototype.destroy = function () {
    this._gl.deleteBuffer(this._buffer);
    return destroyObject(this);
};
module.exports = Buffer;
},{"../Core/DeveloperError":123,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/destroyObject":247}],339:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var BufferUsage = {
        STREAM_DRAW: 35040,
        STATIC_DRAW: 35044,
        DYNAMIC_DRAW: 35048,
        validate: function (bufferUsage) {
            return bufferUsage === BufferUsage.STREAM_DRAW || bufferUsage === BufferUsage.STATIC_DRAW || bufferUsage === BufferUsage.DYNAMIC_DRAW;
        }
    };
module.exports = freezeObject(BufferUsage);
},{"../Core/freezeObject":249}],340:[function(require,module,exports){
var Color = require('../Core/Color'), defaultValue = require('../Core/defaultValue'), freezeObject = require('../Core/freezeObject');
'use strict';
var ClearCommand = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.color = options.color;
    this.depth = options.depth;
    this.stencil = options.stencil;
    this.renderState = options.renderState;
    this.framebuffer = options.framebuffer;
    this.owner = options.owner;
};
ClearCommand.ALL = freezeObject(new ClearCommand({
    color: new Color(0, 0, 0, 0),
    depth: 1,
    stencil: 0
}));
ClearCommand.prototype.execute = function (context, passState) {
    context.clear(this, passState);
};
module.exports = ClearCommand;
},{"../Core/Color":111,"../Core/defaultValue":243,"../Core/freezeObject":249}],341:[function(require,module,exports){
var clone = require('../Core/clone'), Color = require('../Core/Color'), ComponentDatatype = require('../Core/ComponentDatatype'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Geometry = require('../Core/Geometry'), GeometryAttribute = require('../Core/GeometryAttribute'), IndexDatatype = require('../Core/IndexDatatype'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), PixelFormat = require('../Core/PixelFormat'), PrimitiveType = require('../Core/PrimitiveType'), RuntimeError = require('../Core/RuntimeError'), ViewportQuadVS = require('../Shaders/ViewportQuadVS'), Buffer = require('./Buffer'), BufferUsage = require('./BufferUsage'), ClearCommand = require('./ClearCommand'), CubeMap = require('./CubeMap'), DrawCommand = require('./DrawCommand'), Framebuffer = require('./Framebuffer'), PassState = require('./PassState'), PickFramebuffer = require('./PickFramebuffer'), PixelDatatype = require('./PixelDatatype'), Renderbuffer = require('./Renderbuffer'), RenderbufferFormat = require('./RenderbufferFormat'), RenderState = require('./RenderState'), ShaderCache = require('./ShaderCache'), Texture = require('./Texture'), TextureMagnificationFilter = require('./TextureMagnificationFilter'), TextureMinificationFilter = require('./TextureMinificationFilter'), TextureWrap = require('./TextureWrap'), UniformState = require('./UniformState'), VertexArray = require('./VertexArray');
'use strict';
function errorToString(gl, error) {
    var message = 'WebGL Error:  ';
    switch (error) {
    case gl.INVALID_ENUM:
        message += 'INVALID_ENUM';
        break;
    case gl.INVALID_VALUE:
        message += 'INVALID_VALUE';
        break;
    case gl.INVALID_OPERATION:
        message += 'INVALID_OPERATION';
        break;
    case gl.OUT_OF_MEMORY:
        message += 'OUT_OF_MEMORY';
        break;
    case gl.CONTEXT_LOST_WEBGL:
        message += 'CONTEXT_LOST_WEBGL lost';
        break;
    default:
        message += 'Unknown (' + error + ')';
    }
    return message;
}
function createErrorMessage(gl, glFunc, glFuncArguments, error) {
    var message = errorToString(gl, error) + ': ' + glFunc.name + '(';
    for (var i = 0; i < glFuncArguments.length; ++i) {
        if (i !== 0) {
            message += ', ';
        }
        message += glFuncArguments[i];
    }
    message += ');';
    return message;
}
function throwOnError(gl, glFunc, glFuncArguments) {
    var error = gl.getError();
    if (error !== gl.NO_ERROR) {
        throw new RuntimeError(createErrorMessage(gl, glFunc, glFuncArguments, error));
    }
}
function makeGetterSetter(gl, propertyName, logFunc) {
    return {
        get: function () {
            var value = gl[propertyName];
            logFunc(gl, 'get: ' + propertyName, value);
            return gl[propertyName];
        },
        set: function (value) {
            gl[propertyName] = value;
            logFunc(gl, 'set: ' + propertyName, value);
        }
    };
}
function wrapGL(gl, logFunc) {
    if (!logFunc) {
        return gl;
    }
    function wrapFunction(property) {
        return function () {
            var result = property.apply(gl, arguments);
            logFunc(gl, property, arguments);
            return result;
        };
    }
    var glWrapper = {};
    for (var propertyName in gl) {
        var property = gl[propertyName];
        if (typeof property === 'function') {
            glWrapper[propertyName] = wrapFunction(property);
        } else {
            Object.defineProperty(glWrapper, propertyName, makeGetterSetter(gl, propertyName, logFunc));
        }
    }
    return glWrapper;
}
function getExtension(gl, names) {
    var length = names.length;
    for (var i = 0; i < length; ++i) {
        var extension = gl.getExtension(names[i]);
        if (extension) {
            return extension;
        }
    }
    return undefined;
}
var Context = function (canvas, options) {
    if (typeof WebGLRenderingContext === 'undefined') {
        throw new RuntimeError('The browser does not support WebGL.  Visit http://get.webgl.org.');
    }
    if (!defined(canvas)) {
        throw new DeveloperError('canvas is required.');
    }
    this._canvas = canvas;
    options = clone(options, true);
    options = defaultValue(options, {});
    options.allowTextureFilterAnisotropic = defaultValue(options.allowTextureFilterAnisotropic, true);
    var webglOptions = defaultValue(options.webgl, {});
    webglOptions.alpha = defaultValue(webglOptions.alpha, false);
    webglOptions.stencil = defaultValue(webglOptions.stencil, false);
    webglOptions.failIfMajorPerformanceCaveat = defaultValue(webglOptions.failIfMajorPerformanceCaveat, true);
    this._originalGLContext = canvas.getContext('webgl', webglOptions) || canvas.getContext('experimental-webgl', webglOptions) || undefined;
    if (!defined(this._originalGLContext)) {
        throw new RuntimeError('The browser supports WebGL, but initialization failed.');
    }
    this._id = createGuid();
    this.validateFramebuffer = false;
    this.validateShaderProgram = false;
    this.logShaderCompilation = false;
    this._throwOnWebGLError = false;
    this._shaderCache = new ShaderCache(this);
    var gl = this._gl = this._originalGLContext;
    this._version = gl.getParameter(gl.VERSION);
    this._shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
    this._vendor = gl.getParameter(gl.VENDOR);
    this._renderer = gl.getParameter(gl.RENDERER);
    this._redBits = gl.getParameter(gl.RED_BITS);
    this._greenBits = gl.getParameter(gl.GREEN_BITS);
    this._blueBits = gl.getParameter(gl.BLUE_BITS);
    this._alphaBits = gl.getParameter(gl.ALPHA_BITS);
    this._depthBits = gl.getParameter(gl.DEPTH_BITS);
    this._stencilBits = gl.getParameter(gl.STENCIL_BITS);
    this._maximumCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    this._maximumCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    this._maximumFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    this._maximumTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this._maximumRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
    this._maximumTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    this._maximumVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS);
    this._maximumVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    this._maximumVertexTextureImageUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    this._maximumVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    this._aliasedLineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
    this._aliasedPointSizeRange = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
    this._maximumViewportDimensions = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
    this._antialias = gl.getContextAttributes().antialias;
    this._standardDerivatives = getExtension(gl, ['OES_standard_derivatives']);
    this._elementIndexUint = getExtension(gl, ['OES_element_index_uint']);
    this._depthTexture = getExtension(gl, [
        'WEBGL_depth_texture',
        'WEBKIT_WEBGL_depth_texture'
    ]);
    this._textureFloat = getExtension(gl, ['OES_texture_float']);
    var textureFilterAnisotropic = options.allowTextureFilterAnisotropic ? getExtension(gl, [
            'EXT_texture_filter_anisotropic',
            'WEBKIT_EXT_texture_filter_anisotropic'
        ]) : undefined;
    this._textureFilterAnisotropic = textureFilterAnisotropic;
    this._maximumTextureFilterAnisotropy = defined(textureFilterAnisotropic) ? gl.getParameter(textureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    this._vertexArrayObject = getExtension(gl, ['OES_vertex_array_object']);
    this._fragDepth = getExtension(gl, ['EXT_frag_depth']);
    this._drawBuffers = getExtension(gl, ['WEBGL_draw_buffers']);
    this._maximumDrawBuffers = defined(this._drawBuffers) ? gl.getParameter(this._drawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
    this._maximumColorAttachments = defined(this._drawBuffers) ? gl.getParameter(this._drawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;
    this._debugShaders = getExtension(gl, ['WEBGL_debug_shaders']);
    var cc = gl.getParameter(gl.COLOR_CLEAR_VALUE);
    this._clearColor = new Color(cc[0], cc[1], cc[2], cc[3]);
    this._clearDepth = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
    this._clearStencil = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
    var us = new UniformState();
    var ps = new PassState(this);
    var rs = this.createRenderState();
    this._defaultPassState = ps;
    this._defaultRenderState = rs;
    this._defaultTexture = undefined;
    this._defaultCubeMap = undefined;
    this._us = us;
    this._currentRenderState = rs;
    this._currentFramebuffer = undefined;
    this._maxFrameTextureUnitIndex = 0;
    this._pickObjects = {};
    this._nextPickColor = new Uint32Array(1);
    this.options = options;
    this.cache = {};
    RenderState.apply(gl, rs, ps);
};
var defaultFramebufferMarker = {};
defineProperties(Context.prototype, {
    id: {
        get: function () {
            return this._id;
        }
    },
    canvas: {
        get: function () {
            return this._canvas;
        }
    },
    shaderCache: {
        get: function () {
            return this._shaderCache;
        }
    },
    uniformState: {
        get: function () {
            return this._us;
        }
    },
    version: {
        get: function () {
            return this._version;
        }
    },
    shadingLanguageVersion: {
        get: function () {
            return this._shadingLanguageVersion;
        }
    },
    vendor: {
        get: function () {
            return this._vendor;
        }
    },
    renderer: {
        get: function () {
            return this._renderer;
        }
    },
    redBits: {
        get: function () {
            return this._redBits;
        }
    },
    greenBits: {
        get: function () {
            return this._greenBits;
        }
    },
    blueBits: {
        get: function () {
            return this._blueBits;
        }
    },
    alphaBits: {
        get: function () {
            return this._alphaBits;
        }
    },
    depthBits: {
        get: function () {
            return this._depthBits;
        }
    },
    stencilBits: {
        get: function () {
            return this._stencilBits;
        }
    },
    maximumCombinedTextureImageUnits: {
        get: function () {
            return this._maximumCombinedTextureImageUnits;
        }
    },
    maximumCubeMapSize: {
        get: function () {
            return this._maximumCubeMapSize;
        }
    },
    maximumFragmentUniformVectors: {
        get: function () {
            return this._maximumFragmentUniformVectors;
        }
    },
    maximumTextureImageUnits: {
        get: function () {
            return this._maximumTextureImageUnits;
        }
    },
    maximumRenderbufferSize: {
        get: function () {
            return this._maximumRenderbufferSize;
        }
    },
    maximumTextureSize: {
        get: function () {
            return this._maximumTextureSize;
        }
    },
    maximumVaryingVectors: {
        get: function () {
            return this._maximumVaryingVectors;
        }
    },
    maximumVertexAttributes: {
        get: function () {
            return this._maximumVertexAttributes;
        }
    },
    maximumVertexTextureImageUnits: {
        get: function () {
            return this._maximumVertexTextureImageUnits;
        }
    },
    maximumVertexUniformVectors: {
        get: function () {
            return this._maximumVertexUniformVectors;
        }
    },
    minimumAliasedLineWidth: {
        get: function () {
            return this._aliasedLineWidthRange[0];
        }
    },
    maximumAliasedLineWidth: {
        get: function () {
            return this._aliasedLineWidthRange[1];
        }
    },
    minimumAliasedPointSize: {
        get: function () {
            return this._aliasedPointSizeRange[0];
        }
    },
    maximumAliasedPointSize: {
        get: function () {
            return this._aliasedPointSizeRange[1];
        }
    },
    maximumViewportWidth: {
        get: function () {
            return this._maximumViewportDimensions[0];
        }
    },
    maximumViewportHeight: {
        get: function () {
            return this._maximumViewportDimensions[1];
        }
    },
    antialias: {
        get: function () {
            return this._antialias;
        }
    },
    standardDerivatives: {
        get: function () {
            return !!this._standardDerivatives;
        }
    },
    elementIndexUint: {
        get: function () {
            return !!this._elementIndexUint;
        }
    },
    depthTexture: {
        get: function () {
            return !!this._depthTexture;
        }
    },
    floatingPointTexture: {
        get: function () {
            return !!this._textureFloat;
        }
    },
    textureFilterAnisotropic: {
        get: function () {
            return !!this._textureFilterAnisotropic;
        }
    },
    maximumTextureFilterAnisotropy: {
        get: function () {
            return this._maximumTextureFilterAnisotropy;
        }
    },
    vertexArrayObject: {
        get: function () {
            return !!this._vertexArrayObject;
        }
    },
    fragmentDepth: {
        get: function () {
            return !!this._fragDepth;
        }
    },
    drawBuffers: {
        get: function () {
            return !!this._drawBuffers;
        }
    },
    maximumDrawBuffers: {
        get: function () {
            return this._maximumDrawBuffers;
        }
    },
    maximumColorAttachments: {
        get: function () {
            return this._maximumColorAttachments;
        }
    },
    debugShaders: {
        get: function () {
            return this._debugShaders;
        }
    },
    throwOnWebGLError: {
        get: function () {
            return this._throwOnWebGLError;
        },
        set: function (value) {
            this._throwOnWebGLError = value;
            this._gl = wrapGL(this._originalGLContext, value ? throwOnError : null);
        }
    },
    defaultTexture: {
        get: function () {
            if (this._defaultTexture === undefined) {
                this._defaultTexture = this.createTexture2D({
                    source: {
                        width: 1,
                        height: 1,
                        arrayBufferView: new Uint8Array([
                            255,
                            255,
                            255,
                            255
                        ])
                    }
                });
            }
            return this._defaultTexture;
        }
    },
    defaultCubeMap: {
        get: function () {
            if (this._defaultCubeMap === undefined) {
                var face = {
                        width: 1,
                        height: 1,
                        arrayBufferView: new Uint8Array([
                            255,
                            255,
                            255,
                            255
                        ])
                    };
                this._defaultCubeMap = this.createCubeMap({
                    source: {
                        positiveX: face,
                        negativeX: face,
                        positiveY: face,
                        negativeY: face,
                        positiveZ: face,
                        negativeZ: face
                    }
                });
            }
            return this._defaultCubeMap;
        }
    },
    drawingBufferHeight: {
        get: function () {
            return this._gl.drawingBufferHeight;
        }
    },
    drawingBufferWidth: {
        get: function () {
            return this._gl.drawingBufferWidth;
        }
    },
    defaultFramebuffer: {
        get: function () {
            return defaultFramebufferMarker;
        }
    }
});
Context.prototype.replaceShaderProgram = function (shaderProgram, vertexShaderSource, fragmentShaderSource, attributeLocations) {
    return this._shaderCache.replaceShaderProgram(shaderProgram, vertexShaderSource, fragmentShaderSource, attributeLocations);
};
Context.prototype.createShaderProgram = function (vertexShaderSource, fragmentShaderSource, attributeLocations) {
    return this._shaderCache.getShaderProgram(vertexShaderSource, fragmentShaderSource, attributeLocations);
};
function createBuffer(gl, bufferTarget, typedArrayOrSizeInBytes, usage) {
    var sizeInBytes;
    if (typeof typedArrayOrSizeInBytes === 'number') {
        sizeInBytes = typedArrayOrSizeInBytes;
    } else if (typeof typedArrayOrSizeInBytes === 'object' && typeof typedArrayOrSizeInBytes.byteLength === 'number') {
        sizeInBytes = typedArrayOrSizeInBytes.byteLength;
    } else {
        throw new DeveloperError('typedArrayOrSizeInBytes must be either a typed array or a number.');
    }
    if (sizeInBytes <= 0) {
        throw new DeveloperError('typedArrayOrSizeInBytes must be greater than zero.');
    }
    if (!BufferUsage.validate(usage)) {
        throw new DeveloperError('usage is invalid.');
    }
    var buffer = gl.createBuffer();
    gl.bindBuffer(bufferTarget, buffer);
    gl.bufferData(bufferTarget, typedArrayOrSizeInBytes, usage);
    gl.bindBuffer(bufferTarget, null);
    return new Buffer(gl, bufferTarget, sizeInBytes, usage, buffer);
}
Context.prototype.createVertexBuffer = function (typedArrayOrSizeInBytes, usage) {
    return createBuffer(this._gl, this._gl.ARRAY_BUFFER, typedArrayOrSizeInBytes, usage);
};
Context.prototype.createIndexBuffer = function (typedArrayOrSizeInBytes, usage, indexDatatype) {
    if (!IndexDatatype.validate(indexDatatype)) {
        throw new DeveloperError('Invalid indexDatatype.');
    }
    if (indexDatatype === IndexDatatype.UNSIGNED_INT && !this.elementIndexUint) {
        throw new DeveloperError('IndexDatatype.UNSIGNED_INT requires OES_element_index_uint, which is not supported on this system.  Check context.elementIndexUint.');
    }
    var bytesPerIndex = IndexDatatype.getSizeInBytes(indexDatatype);
    var gl = this._gl;
    var buffer = createBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, typedArrayOrSizeInBytes, usage);
    var numberOfIndices = buffer.sizeInBytes / bytesPerIndex;
    defineProperties(buffer, {
        indexDatatype: {
            get: function () {
                return indexDatatype;
            }
        },
        bytesPerIndex: {
            get: function () {
                return bytesPerIndex;
            }
        },
        numberOfIndices: {
            get: function () {
                return numberOfIndices;
            }
        }
    });
    return buffer;
};
Context.prototype.createVertexArray = function (attributes, indexBuffer) {
    return new VertexArray(this._gl, this._vertexArrayObject, attributes, indexBuffer);
};
Context.prototype.createTexture2D = function (options) {
    return new Texture(this, options);
};
Context.prototype.createTexture2DFromFramebuffer = function (pixelFormat, framebufferXOffset, framebufferYOffset, width, height, framebuffer) {
    var gl = this._gl;
    pixelFormat = defaultValue(pixelFormat, PixelFormat.RGB);
    framebufferXOffset = defaultValue(framebufferXOffset, 0);
    framebufferYOffset = defaultValue(framebufferYOffset, 0);
    width = defaultValue(width, gl.drawingBufferWidth);
    height = defaultValue(height, gl.drawingBufferHeight);
    if (!PixelFormat.validate(pixelFormat)) {
        throw new DeveloperError('Invalid pixelFormat.');
    }
    if (PixelFormat.isDepthFormat(pixelFormat)) {
        throw new DeveloperError('pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.');
    }
    if (framebufferXOffset < 0) {
        throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
    }
    if (framebufferYOffset < 0) {
        throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
    }
    if (framebufferXOffset + width > gl.drawingBufferWidth) {
        throw new DeveloperError('framebufferXOffset + width must be less than or equal to drawingBufferWidth');
    }
    if (framebufferYOffset + height > gl.drawingBufferHeight) {
        throw new DeveloperError('framebufferYOffset + height must be less than or equal to drawingBufferHeight.');
    }
    var texture = new Texture(this, {
            width: width,
            height: height,
            pixelFormat: pixelFormat,
            source: {
                framebuffer: defined(framebuffer) ? framebuffer : this.defaultFramebuffer,
                xOffset: framebufferXOffset,
                yOffset: framebufferYOffset,
                width: width,
                height: height
            }
        });
    return texture;
};
Context.prototype.createCubeMap = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var source = options.source;
    var width;
    var height;
    if (defined(source)) {
        var faces = [
                source.positiveX,
                source.negativeX,
                source.positiveY,
                source.negativeY,
                source.positiveZ,
                source.negativeZ
            ];
        if (!faces[0] || !faces[1] || !faces[2] || !faces[3] || !faces[4] || !faces[5]) {
            throw new DeveloperError('options.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.');
        }
        width = faces[0].width;
        height = faces[0].height;
        for (var i = 1; i < 6; ++i) {
            if (Number(faces[i].width) !== width || Number(faces[i].height) !== height) {
                throw new DeveloperError('Each face in options.source must have the same width and height.');
            }
        }
    } else {
        width = options.width;
        height = options.height;
    }
    var size = width;
    var pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);
    var pixelDatatype = defaultValue(options.pixelDatatype, PixelDatatype.UNSIGNED_BYTE);
    if (!defined(width) || !defined(height)) {
        throw new DeveloperError('options requires a source field to create an initialized cube map or width and height fields to create a blank cube map.');
    }
    if (width !== height) {
        throw new DeveloperError('Width must equal height.');
    }
    if (size <= 0) {
        throw new DeveloperError('Width and height must be greater than zero.');
    }
    if (size > this._maximumCubeMapSize) {
        throw new DeveloperError('Width and height must be less than or equal to the maximum cube map size (' + this._maximumCubeMapSize + ').  Check maximumCubeMapSize.');
    }
    if (!PixelFormat.validate(pixelFormat)) {
        throw new DeveloperError('Invalid options.pixelFormat.');
    }
    if (PixelFormat.isDepthFormat(pixelFormat)) {
        throw new DeveloperError('options.pixelFormat cannot be DEPTH_COMPONENT or DEPTH_STENCIL.');
    }
    if (!PixelDatatype.validate(pixelDatatype)) {
        throw new DeveloperError('Invalid options.pixelDatatype.');
    }
    if (pixelDatatype === PixelDatatype.FLOAT && !this.floatingPointTexture) {
        throw new DeveloperError('When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.');
    }
    var preMultiplyAlpha = options.preMultiplyAlpha || (pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE);
    var flipY = defaultValue(options.flipY, true);
    var gl = this._gl;
    var textureTarget = gl.TEXTURE_CUBE_MAP;
    var texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(textureTarget, texture);
    function createFace(target, sourceFace) {
        if (sourceFace.arrayBufferView) {
            gl.texImage2D(target, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, sourceFace.arrayBufferView);
        } else {
            gl.texImage2D(target, 0, pixelFormat, pixelFormat, pixelDatatype, sourceFace);
        }
    }
    if (defined(source)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_X, source.positiveX);
        createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, source.negativeX);
        createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, source.positiveY);
        createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, source.negativeY);
        createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, source.positiveZ);
        createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, source.negativeZ);
    } else {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
    }
    gl.bindTexture(textureTarget, null);
    return new CubeMap(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY);
};
Context.prototype.createFramebuffer = function (options) {
    return new Framebuffer(this._gl, this._maximumColorAttachments, options);
};
Context.prototype.createRenderbuffer = function (options) {
    var gl = this._gl;
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var format = defaultValue(options.format, RenderbufferFormat.RGBA4);
    var width = defined(options.width) ? options.width : gl.drawingBufferWidth;
    var height = defined(options.height) ? options.height : gl.drawingBufferHeight;
    if (!RenderbufferFormat.validate(format)) {
        throw new DeveloperError('Invalid format.');
    }
    if (width <= 0) {
        throw new DeveloperError('Width must be greater than zero.');
    }
    if (width > this.maximumRenderbufferSize) {
        throw new DeveloperError('Width must be less than or equal to the maximum renderbuffer size (' + this.maximumRenderbufferSize + ').  Check maximumRenderbufferSize.');
    }
    if (height <= 0) {
        throw new DeveloperError('Height must be greater than zero.');
    }
    if (height > this.maximumRenderbufferSize) {
        throw new DeveloperError('Height must be less than or equal to the maximum renderbuffer size (' + this.maximumRenderbufferSize + ').  Check maximumRenderbufferSize.');
    }
    return new Renderbuffer(gl, format, width, height);
};
var nextRenderStateId = 0;
var renderStateCache = {};
Context.prototype.createRenderState = function (renderState) {
    var partialKey = JSON.stringify(renderState);
    var cachedState = renderStateCache[partialKey];
    if (defined(cachedState)) {
        return cachedState;
    }
    var states = new RenderState(this, renderState);
    var fullKey = JSON.stringify(states);
    cachedState = renderStateCache[fullKey];
    if (!defined(cachedState)) {
        states.id = nextRenderStateId++;
        cachedState = states;
        renderStateCache[fullKey] = cachedState;
    }
    renderStateCache[partialKey] = cachedState;
    return cachedState;
};
Context.prototype.createSampler = function (sampler) {
    var s = {
            wrapS: defaultValue(sampler.wrapS, TextureWrap.CLAMP_TO_EDGE),
            wrapT: defaultValue(sampler.wrapT, TextureWrap.CLAMP_TO_EDGE),
            minificationFilter: defaultValue(sampler.minificationFilter, TextureMinificationFilter.LINEAR),
            magnificationFilter: defaultValue(sampler.magnificationFilter, TextureMagnificationFilter.LINEAR),
            maximumAnisotropy: defined(sampler.maximumAnisotropy) ? sampler.maximumAnisotropy : 1
        };
    if (!TextureWrap.validate(s.wrapS)) {
        throw new DeveloperError('Invalid sampler.wrapS.');
    }
    if (!TextureWrap.validate(s.wrapT)) {
        throw new DeveloperError('Invalid sampler.wrapT.');
    }
    if (!TextureMinificationFilter.validate(s.minificationFilter)) {
        throw new DeveloperError('Invalid sampler.minificationFilter.');
    }
    if (!TextureMagnificationFilter.validate(s.magnificationFilter)) {
        throw new DeveloperError('Invalid sampler.magnificationFilter.');
    }
    if (s.maximumAnisotropy < 1) {
        throw new DeveloperError('sampler.maximumAnisotropy must be greater than or equal to one.');
    }
    return s;
};
function validateFramebuffer(context, framebuffer) {
    if (context.validateFramebuffer) {
        var gl = context._gl;
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
            var message;
            switch (status) {
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                message = 'Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.';
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                message = 'Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.';
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                message = 'Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.';
                break;
            case gl.FRAMEBUFFER_UNSUPPORTED:
                message = 'Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.';
                break;
            }
            throw new DeveloperError(message);
        }
    }
}
function applyRenderState(context, renderState, passState) {
    var previousState = context._currentRenderState;
    if (previousState !== renderState) {
        context._currentRenderState = renderState;
        RenderState.partialApply(context._gl, previousState, renderState, passState);
    }
}
var scratchBackBufferArray;
if (typeof WebGLRenderingContext !== 'undefined') {
    scratchBackBufferArray = [WebGLRenderingContext.BACK];
}
function bindFramebuffer(context, framebuffer) {
    if (framebuffer !== context._currentFramebuffer) {
        context._currentFramebuffer = framebuffer;
        var buffers = scratchBackBufferArray;
        if (defined(framebuffer)) {
            framebuffer._bind();
            validateFramebuffer(context, framebuffer);
            buffers = framebuffer._getActiveColorAttachments();
        } else {
            var gl = context._gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        if (context.drawBuffers) {
            context._drawBuffers.drawBuffersWEBGL(buffers);
        }
    }
}
var defaultClearCommand = new ClearCommand();
Context.prototype.clear = function (clearCommand, passState) {
    clearCommand = defaultValue(clearCommand, defaultClearCommand);
    passState = defaultValue(passState, this._defaultPassState);
    var gl = this._gl;
    var bitmask = 0;
    var c = clearCommand.color;
    var d = clearCommand.depth;
    var s = clearCommand.stencil;
    if (defined(c)) {
        if (!Color.equals(this._clearColor, c)) {
            Color.clone(c, this._clearColor);
            gl.clearColor(c.red, c.green, c.blue, c.alpha);
        }
        bitmask |= gl.COLOR_BUFFER_BIT;
    }
    if (defined(d)) {
        if (d !== this._clearDepth) {
            this._clearDepth = d;
            gl.clearDepth(d);
        }
        bitmask |= gl.DEPTH_BUFFER_BIT;
    }
    if (defined(s)) {
        if (s !== this._clearStencil) {
            this._clearStencil = s;
            gl.clearStencil(s);
        }
        bitmask |= gl.STENCIL_BUFFER_BIT;
    }
    var rs = defaultValue(clearCommand.renderState, this._defaultRenderState);
    applyRenderState(this, rs, passState);
    var framebuffer = defaultValue(clearCommand.framebuffer, passState.framebuffer);
    bindFramebuffer(this, framebuffer);
    gl.clear(bitmask);
};
function beginDraw(context, framebuffer, drawCommand, passState, renderState, shaderProgram) {
    var rs = defaultValue(defaultValue(renderState, drawCommand.renderState), context._defaultRenderState);
    if (defined(framebuffer) && rs.depthTest) {
        if (rs.depthTest.enabled && !framebuffer.hasDepthAttachment) {
            throw new DeveloperError('The depth test can not be enabled (drawCommand.renderState.depthTest.enabled) because the framebuffer (drawCommand.framebuffer) does not have a depth or depth-stencil renderbuffer.');
        }
    }
    bindFramebuffer(context, framebuffer);
    var sp = defaultValue(shaderProgram, drawCommand.shaderProgram);
    sp._bind();
    context._maxFrameTextureUnitIndex = Math.max(context._maxFrameTextureUnitIndex, sp.maximumTextureUnitIndex);
    applyRenderState(context, rs, passState);
}
function continueDraw(context, drawCommand, shaderProgram) {
    var primitiveType = drawCommand.primitiveType;
    var va = drawCommand.vertexArray;
    var offset = drawCommand.offset;
    var count = drawCommand.count;
    if (!PrimitiveType.validate(primitiveType)) {
        throw new DeveloperError('drawCommand.primitiveType is required and must be valid.');
    }
    if (!defined(va)) {
        throw new DeveloperError('drawCommand.vertexArray is required.');
    }
    if (offset < 0) {
        throw new DeveloperError('drawCommand.offset must be omitted or greater than or equal to zero.');
    }
    if (count < 0) {
        throw new DeveloperError('drawCommand.count must be omitted or greater than or equal to zero.');
    }
    context._us.model = defaultValue(drawCommand.modelMatrix, Matrix4.IDENTITY);
    var sp = defaultValue(shaderProgram, drawCommand.shaderProgram);
    sp._setUniforms(drawCommand.uniformMap, context._us, context.validateShaderProgram);
    var indexBuffer = va.indexBuffer;
    if (defined(indexBuffer)) {
        offset = offset * indexBuffer.bytesPerIndex;
        count = defaultValue(count, indexBuffer.numberOfIndices);
        va._bind();
        context._gl.drawElements(primitiveType, count, indexBuffer.indexDatatype, offset);
        va._unBind();
    } else {
        count = defaultValue(count, va.numberOfVertices);
        va._bind();
        context._gl.drawArrays(primitiveType, offset, count);
        va._unBind();
    }
}
Context.prototype.draw = function (drawCommand, passState, renderState, shaderProgram) {
    if (!defined(drawCommand)) {
        throw new DeveloperError('drawCommand is required.');
    }
    if (!defined(drawCommand.shaderProgram)) {
        throw new DeveloperError('drawCommand.shaderProgram is required.');
    }
    passState = defaultValue(passState, this._defaultPassState);
    var framebuffer = defaultValue(drawCommand.framebuffer, passState.framebuffer);
    beginDraw(this, framebuffer, drawCommand, passState, renderState, shaderProgram);
    continueDraw(this, drawCommand, shaderProgram);
};
Context.prototype.endFrame = function () {
    var gl = this._gl;
    gl.useProgram(null);
    this._currentFramebuffer = undefined;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    var buffers = scratchBackBufferArray;
    if (this.drawBuffers) {
        this._drawBuffers.drawBuffersWEBGL(scratchBackBufferArray);
    }
    var length = this._maxFrameTextureUnitIndex;
    this._maxFrameTextureUnitIndex = 0;
    for (var i = 0; i < length; ++i) {
        gl.activeTexture(gl.TEXTURE0 + i);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    }
};
Context.prototype.readPixels = function (readState) {
    var gl = this._gl;
    readState = readState || {};
    var x = Math.max(readState.x || 0, 0);
    var y = Math.max(readState.y || 0, 0);
    var width = readState.width || gl.drawingBufferWidth;
    var height = readState.height || gl.drawingBufferHeight;
    var framebuffer = readState.framebuffer;
    if (width <= 0) {
        throw new DeveloperError('readState.width must be greater than zero.');
    }
    if (height <= 0) {
        throw new DeveloperError('readState.height must be greater than zero.');
    }
    var pixels = new Uint8Array(4 * width * height);
    bindFramebuffer(this, framebuffer);
    gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    return pixels;
};
function computeNumberOfVertices(attribute) {
    return attribute.values.length / attribute.componentsPerAttribute;
}
function computeAttributeSizeInBytes(attribute) {
    return ComponentDatatype.getSizeInBytes(attribute.componentDatatype) * attribute.componentsPerAttribute;
}
function interleaveAttributes(attributes) {
    var j;
    var name;
    var attribute;
    var names = [];
    for (name in attributes) {
        if (attributes.hasOwnProperty(name) && defined(attributes[name]) && defined(attributes[name].values)) {
            names.push(name);
            if (attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {
                attributes[name].componentDatatype = ComponentDatatype.FLOAT;
                attributes[name].values = ComponentDatatype.createTypedArray(ComponentDatatype.FLOAT, attributes[name].values);
            }
        }
    }
    var numberOfVertices;
    var namesLength = names.length;
    if (namesLength > 0) {
        numberOfVertices = computeNumberOfVertices(attributes[names[0]]);
        for (j = 1; j < namesLength; ++j) {
            var currentNumberOfVertices = computeNumberOfVertices(attributes[names[j]]);
            if (currentNumberOfVertices !== numberOfVertices) {
                throw new RuntimeError('Each attribute list must have the same number of vertices.  ' + 'Attribute ' + names[j] + ' has a different number of vertices ' + '(' + currentNumberOfVertices.toString() + ')' + ' than attribute ' + names[0] + ' (' + numberOfVertices.toString() + ').');
            }
        }
    }
    names.sort(function (left, right) {
        return ComponentDatatype.getSizeInBytes(attributes[right].componentDatatype) - ComponentDatatype.getSizeInBytes(attributes[left].componentDatatype);
    });
    var vertexSizeInBytes = 0;
    var offsetsInBytes = {};
    for (j = 0; j < namesLength; ++j) {
        name = names[j];
        attribute = attributes[name];
        offsetsInBytes[name] = vertexSizeInBytes;
        vertexSizeInBytes += computeAttributeSizeInBytes(attribute);
    }
    if (vertexSizeInBytes > 0) {
        var maxComponentSizeInBytes = ComponentDatatype.getSizeInBytes(attributes[names[0]].componentDatatype);
        var remainder = vertexSizeInBytes % maxComponentSizeInBytes;
        if (remainder !== 0) {
            vertexSizeInBytes += maxComponentSizeInBytes - remainder;
        }
        var vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;
        var buffer = new ArrayBuffer(vertexBufferSizeInBytes);
        var views = {};
        for (j = 0; j < namesLength; ++j) {
            name = names[j];
            var sizeInBytes = ComponentDatatype.getSizeInBytes(attributes[name].componentDatatype);
            views[name] = {
                pointer: ComponentDatatype.createTypedArray(attributes[name].componentDatatype, buffer),
                index: offsetsInBytes[name] / sizeInBytes,
                strideInComponentType: vertexSizeInBytes / sizeInBytes
            };
        }
        for (j = 0; j < numberOfVertices; ++j) {
            for (var n = 0; n < namesLength; ++n) {
                name = names[n];
                attribute = attributes[name];
                var values = attribute.values;
                var view = views[name];
                var pointer = view.pointer;
                var numberOfComponents = attribute.componentsPerAttribute;
                for (var k = 0; k < numberOfComponents; ++k) {
                    pointer[view.index + k] = values[j * numberOfComponents + k];
                }
                view.index += view.strideInComponentType;
            }
        }
        return {
            buffer: buffer,
            offsetsInBytes: offsetsInBytes,
            vertexSizeInBytes: vertexSizeInBytes
        };
    }
    return undefined;
}
Context.prototype.createVertexArrayFromGeometry = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var geometry = defaultValue(options.geometry, defaultValue.EMPTY_OBJECT);
    var bufferUsage = defaultValue(options.bufferUsage, BufferUsage.DYNAMIC_DRAW);
    var attributeLocations = defaultValue(options.attributeLocations, defaultValue.EMPTY_OBJECT);
    var interleave = defaultValue(options.interleave, false);
    var createdVAAttributes = options.vertexArrayAttributes;
    var name;
    var attribute;
    var vertexBuffer;
    var vaAttributes = defined(createdVAAttributes) ? createdVAAttributes : [];
    var attributes = geometry.attributes;
    if (interleave) {
        var interleavedAttributes = interleaveAttributes(attributes);
        if (defined(interleavedAttributes)) {
            vertexBuffer = this.createVertexBuffer(interleavedAttributes.buffer, bufferUsage);
            var offsetsInBytes = interleavedAttributes.offsetsInBytes;
            var strideInBytes = interleavedAttributes.vertexSizeInBytes;
            for (name in attributes) {
                if (attributes.hasOwnProperty(name) && defined(attributes[name])) {
                    attribute = attributes[name];
                    if (defined(attribute.values)) {
                        vaAttributes.push({
                            index: attributeLocations[name],
                            vertexBuffer: vertexBuffer,
                            componentDatatype: attribute.componentDatatype,
                            componentsPerAttribute: attribute.componentsPerAttribute,
                            normalize: attribute.normalize,
                            offsetInBytes: offsetsInBytes[name],
                            strideInBytes: strideInBytes
                        });
                    } else {
                        vaAttributes.push({
                            index: attributeLocations[name],
                            value: attribute.value,
                            componentDatatype: attribute.componentDatatype,
                            normalize: attribute.normalize
                        });
                    }
                }
            }
        }
    } else {
        for (name in attributes) {
            if (attributes.hasOwnProperty(name) && defined(attributes[name])) {
                attribute = attributes[name];
                var componentDatatype = attribute.componentDatatype;
                if (componentDatatype === ComponentDatatype.DOUBLE) {
                    componentDatatype = ComponentDatatype.FLOAT;
                }
                vertexBuffer = undefined;
                if (defined(attribute.values)) {
                    vertexBuffer = this.createVertexBuffer(ComponentDatatype.createTypedArray(componentDatatype, attribute.values), bufferUsage);
                }
                vaAttributes.push({
                    index: attributeLocations[name],
                    vertexBuffer: vertexBuffer,
                    value: attribute.value,
                    componentDatatype: componentDatatype,
                    componentsPerAttribute: attribute.componentsPerAttribute,
                    normalize: attribute.normalize
                });
            }
        }
    }
    var indexBuffer;
    var indices = geometry.indices;
    if (defined(indices)) {
        if (Geometry.computeNumberOfVertices(geometry) > CesiumMath.SIXTY_FOUR_KILOBYTES && this.elementIndexUint) {
            indexBuffer = this.createIndexBuffer(new Uint32Array(indices), bufferUsage, IndexDatatype.UNSIGNED_INT);
        } else {
            indexBuffer = this.createIndexBuffer(new Uint16Array(indices), bufferUsage, IndexDatatype.UNSIGNED_SHORT);
        }
    }
    return this.createVertexArray(vaAttributes, indexBuffer);
};
var viewportQuadAttributeLocations = {
        position: 0,
        textureCoordinates: 1
    };
Context.prototype.createViewportQuadCommand = function (fragmentShaderSource, overrides) {
    var vertexArray = this.cache.viewportQuad_vertexArray;
    if (!defined(vertexArray)) {
        var geometry = new Geometry({
                attributes: {
                    position: new GeometryAttribute({
                        componentDatatype: ComponentDatatype.FLOAT,
                        componentsPerAttribute: 2,
                        values: [
                            -1,
                            -1,
                            1,
                            -1,
                            1,
                            1,
                            -1,
                            1
                        ]
                    }),
                    textureCoordinates: new GeometryAttribute({
                        componentDatatype: ComponentDatatype.FLOAT,
                        componentsPerAttribute: 2,
                        values: [
                            0,
                            0,
                            1,
                            0,
                            1,
                            1,
                            0,
                            1
                        ]
                    })
                },
                indices: new Uint16Array([
                    0,
                    1,
                    2,
                    0,
                    2,
                    3
                ]),
                primitiveType: PrimitiveType.TRIANGLES
            });
        vertexArray = this.createVertexArrayFromGeometry({
            geometry: geometry,
            attributeLocations: {
                position: 0,
                textureCoordinates: 1
            },
            bufferUsage: BufferUsage.STATIC_DRAW,
            interleave: true
        });
        this.cache.viewportQuad_vertexArray = vertexArray;
    }
    overrides = defaultValue(overrides, defaultValue.EMPTY_OBJECT);
    return new DrawCommand({
        vertexArray: vertexArray,
        primitiveType: PrimitiveType.TRIANGLES,
        renderState: overrides.renderState,
        shaderProgram: this.createShaderProgram(ViewportQuadVS, fragmentShaderSource, viewportQuadAttributeLocations),
        uniformMap: overrides.uniformMap,
        owner: overrides.owner,
        framebuffer: overrides.framebuffer
    });
};
Context.prototype.createPickFramebuffer = function () {
    return new PickFramebuffer(this);
};
Context.prototype.getObjectByPickColor = function (pickColor) {
    if (!defined(pickColor)) {
        throw new DeveloperError('pickColor is required.');
    }
    return this._pickObjects[pickColor.toRgba()];
};
function PickId(pickObjects, key, color) {
    this._pickObjects = pickObjects;
    this.key = key;
    this.color = color;
}
defineProperties(PickId.prototype, {
    object: {
        get: function () {
            return this._pickObjects[this.key];
        },
        set: function (value) {
            this._pickObjects[this.key] = value;
        }
    }
});
PickId.prototype.destroy = function () {
    delete this._pickObjects[this.key];
    return undefined;
};
Context.prototype.createPickId = function (object) {
    if (!defined(object)) {
        throw new DeveloperError('object is required.');
    }
    ++this._nextPickColor[0];
    var key = this._nextPickColor[0];
    if (key === 0) {
        throw new RuntimeError('Out of unique Pick IDs.');
    }
    this._pickObjects[key] = object;
    return new PickId(this._pickObjects, key, Color.fromRgba(key));
};
Context.prototype.isDestroyed = function () {
    return false;
};
Context.prototype.destroy = function () {
    var cache = this.cache;
    for (var property in cache) {
        if (cache.hasOwnProperty(property)) {
            var propertyValue = cache[property];
            if (defined(propertyValue.destroy)) {
                propertyValue.destroy();
            }
        }
    }
    this._shaderCache = this._shaderCache.destroy();
    this._defaultTexture = this._defaultTexture && this._defaultTexture.destroy();
    this._defaultCubeMap = this._defaultCubeMap && this._defaultCubeMap.destroy();
    return destroyObject(this);
};
module.exports = Context;
},{"../Core/Color":111,"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/Geometry":145,"../Core/GeometryAttribute":146,"../Core/IndexDatatype":162,"../Core/Math":174,"../Core/Matrix4":177,"../Core/PixelFormat":181,"../Core/PrimitiveType":193,"../Core/RuntimeError":207,"../Core/clone":240,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Shaders/ViewportQuadVS":585,"./Buffer":338,"./BufferUsage":339,"./ClearCommand":340,"./CubeMap":342,"./DrawCommand":344,"./Framebuffer":345,"./PassState":347,"./PickFramebuffer":348,"./PixelDatatype":349,"./RenderState":350,"./Renderbuffer":351,"./RenderbufferFormat":352,"./ShaderCache":353,"./Texture":356,"./TextureMagnificationFilter":357,"./TextureMinificationFilter":358,"./TextureWrap":359,"./UniformState":362,"./VertexArray":363}],342:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), CesiumMath = require('../Core/Math'), CubeMapFace = require('./CubeMapFace'), MipmapHint = require('./MipmapHint'), PixelDatatype = require('./PixelDatatype'), TextureMagnificationFilter = require('./TextureMagnificationFilter'), TextureMinificationFilter = require('./TextureMinificationFilter'), TextureWrap = require('./TextureWrap');
'use strict';
var CubeMap = function (gl, textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY) {
    this._gl = gl;
    this._textureFilterAnisotropic = textureFilterAnisotropic;
    this._textureTarget = textureTarget;
    this._texture = texture;
    this._pixelFormat = pixelFormat;
    this._pixelDatatype = pixelDatatype;
    this._size = size;
    this._preMultiplyAlpha = preMultiplyAlpha;
    this._flipY = flipY;
    this._sampler = undefined;
    this._positiveX = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_X, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY);
    this._negativeX = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY);
    this._positiveY = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY);
    this._negativeY = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY);
    this._positiveZ = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY);
    this._negativeZ = new CubeMapFace(gl, texture, textureTarget, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY);
    this.sampler = undefined;
};
defineProperties(CubeMap.prototype, {
    positiveX: {
        get: function () {
            return this._positiveX;
        }
    },
    negativeX: {
        get: function () {
            return this._negativeX;
        }
    },
    positiveY: {
        get: function () {
            return this._positiveY;
        }
    },
    negativeY: {
        get: function () {
            return this._negativeY;
        }
    },
    positiveZ: {
        get: function () {
            return this._positiveZ;
        }
    },
    negativeZ: {
        get: function () {
            return this._negativeZ;
        }
    },
    sampler: {
        get: function () {
            return this._sampler;
        },
        set: function (sampler) {
            var samplerDefined = true;
            if (!defined(sampler)) {
                samplerDefined = false;
                var minFilter = TextureMinificationFilter.LINEAR;
                var magFilter = TextureMagnificationFilter.LINEAR;
                if (this._pixelDatatype === PixelDatatype.FLOAT) {
                    minFilter = TextureMinificationFilter.NEAREST;
                    magFilter = TextureMagnificationFilter.NEAREST;
                }
                sampler = {
                    wrapS: TextureWrap.CLAMP_TO_EDGE,
                    wrapT: TextureWrap.CLAMP_TO_EDGE,
                    minificationFilter: minFilter,
                    magnificationFilter: magFilter,
                    maximumAnisotropy: 1
                };
            }
            if (this._pixelDatatype === PixelDatatype.FLOAT) {
                if (sampler.minificationFilter !== TextureMinificationFilter.NEAREST && sampler.minificationFilter !== TextureMinificationFilter.NEAREST_MIPMAP_NEAREST) {
                    throw new DeveloperError('Only NEAREST and NEAREST_MIPMAP_NEAREST minification filters are supported for floating point textures.');
                }
                if (sampler.magnificationFilter !== TextureMagnificationFilter.NEAREST) {
                    throw new DeveloperError('Only the NEAREST magnification filter is supported for floating point textures.');
                }
            }
            var gl = this._gl;
            var target = this._textureTarget;
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(target, this._texture);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, sampler.minificationFilter);
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, sampler.magnificationFilter);
            gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
            gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
            if (defined(this._textureFilterAnisotropic)) {
                gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maximumAnisotropy);
            }
            gl.bindTexture(target, null);
            this._sampler = !samplerDefined ? undefined : {
                wrapS: sampler.wrapS,
                wrapT: sampler.wrapT,
                minificationFilter: sampler.minificationFilter,
                magnificationFilter: sampler.magnificationFilter,
                maximumAnisotropy: sampler.maximumAnisotropy
            };
        }
    },
    pixelFormat: {
        get: function () {
            return this._pixelFormat;
        }
    },
    pixelDatatype: {
        get: function () {
            return this._pixelDatatype;
        }
    },
    width: {
        get: function () {
            return this._size;
        }
    },
    height: {
        get: function () {
            return this._size;
        }
    },
    preMultiplyAlpha: {
        get: function () {
            return this._preMultiplyAlpha;
        }
    },
    flipY: {
        get: function () {
            return this._flipY;
        }
    },
    _target: {
        get: function () {
            return this._textureTarget;
        }
    }
});
CubeMap.prototype.generateMipmap = function (hint) {
    hint = defaultValue(hint, MipmapHint.DONT_CARE);
    if (this._size > 1 && !CesiumMath.isPowerOfTwo(this._size)) {
        throw new DeveloperError('width and height must be a power of two to call generateMipmap().');
    }
    if (!MipmapHint.validate(hint)) {
        throw new DeveloperError('hint is invalid.');
    }
    var gl = this._gl;
    var target = this._textureTarget;
    gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.generateMipmap(target);
    gl.bindTexture(target, null);
};
CubeMap.prototype.isDestroyed = function () {
    return false;
};
CubeMap.prototype.destroy = function () {
    this._gl.deleteTexture(this._texture);
    this._positiveX = destroyObject(this._positiveX);
    this._negativeX = destroyObject(this._negativeX);
    this._positiveY = destroyObject(this._positiveY);
    this._negativeY = destroyObject(this._negativeY);
    this._positiveZ = destroyObject(this._positiveZ);
    this._negativeZ = destroyObject(this._negativeZ);
    return destroyObject(this);
};
module.exports = CubeMap;
},{"../Core/DeveloperError":123,"../Core/Math":174,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"./CubeMapFace":343,"./MipmapHint":346,"./PixelDatatype":349,"./TextureMagnificationFilter":357,"./TextureMinificationFilter":358,"./TextureWrap":359}],343:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), PixelDatatype = require('./PixelDatatype');
'use strict';
var CubeMapFace = function (gl, texture, textureTarget, targetFace, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY) {
    this._gl = gl;
    this._texture = texture;
    this._textureTarget = textureTarget;
    this._targetFace = targetFace;
    this._pixelFormat = pixelFormat;
    this._pixelDatatype = pixelDatatype;
    this._size = size;
    this._preMultiplyAlpha = preMultiplyAlpha;
    this._flipY = flipY;
};
defineProperties(CubeMapFace.prototype, {
    pixelFormat: {
        get: function () {
            return this._pixelFormat;
        }
    },
    pixelDatatype: {
        get: function () {
            return this._pixelDatatype;
        }
    },
    _target: {
        get: function () {
            return this._targetFace;
        }
    }
});
CubeMapFace.prototype.copyFrom = function (source, xOffset, yOffset) {
    xOffset = defaultValue(xOffset, 0);
    yOffset = defaultValue(yOffset, 0);
    if (!source) {
        throw new DeveloperError('source is required.');
    }
    if (xOffset < 0) {
        throw new DeveloperError('xOffset must be greater than or equal to zero.');
    }
    if (yOffset < 0) {
        throw new DeveloperError('yOffset must be greater than or equal to zero.');
    }
    if (xOffset + source.width > this._size) {
        throw new DeveloperError('xOffset + source.width must be less than or equal to width.');
    }
    if (yOffset + source.height > this._size) {
        throw new DeveloperError('yOffset + source.height must be less than or equal to height.');
    }
    var gl = this._gl;
    var target = this._textureTarget;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this._flipY);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    if (source.arrayBufferView) {
        gl.texSubImage2D(this._targetFace, 0, xOffset, yOffset, source.width, source.height, this._pixelFormat, this._pixelDatatype, source.arrayBufferView);
    } else {
        gl.texSubImage2D(this._targetFace, 0, xOffset, yOffset, this._pixelFormat, this._pixelDatatype, source);
    }
    gl.bindTexture(target, null);
};
CubeMapFace.prototype.copyFromFramebuffer = function (xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
    xOffset = defaultValue(xOffset, 0);
    yOffset = defaultValue(yOffset, 0);
    framebufferXOffset = defaultValue(framebufferXOffset, 0);
    framebufferYOffset = defaultValue(framebufferYOffset, 0);
    width = defaultValue(width, this._size);
    height = defaultValue(height, this._size);
    if (xOffset < 0) {
        throw new DeveloperError('xOffset must be greater than or equal to zero.');
    }
    if (yOffset < 0) {
        throw new DeveloperError('yOffset must be greater than or equal to zero.');
    }
    if (framebufferXOffset < 0) {
        throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
    }
    if (framebufferYOffset < 0) {
        throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
    }
    if (xOffset + width > this._size) {
        throw new DeveloperError('xOffset + source.width must be less than or equal to width.');
    }
    if (yOffset + height > this._size) {
        throw new DeveloperError('yOffset + source.height must be less than or equal to height.');
    }
    if (this._pixelDatatype === PixelDatatype.FLOAT) {
        throw new DeveloperError('Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.');
    }
    var gl = this._gl;
    var target = this._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.copyTexSubImage2D(this._targetFace, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
    gl.bindTexture(target, null);
};
module.exports = CubeMapFace;
},{"../Core/DeveloperError":123,"../Core/defaultValue":243,"../Core/defineProperties":244,"./PixelDatatype":349}],344:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), PrimitiveType = require('../Core/PrimitiveType');
'use strict';
var DrawCommand = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.boundingVolume = options.boundingVolume;
    this.cull = defaultValue(options.cull, true);
    this.modelMatrix = options.modelMatrix;
    this.primitiveType = defaultValue(options.primitiveType, PrimitiveType.TRIANGLES);
    this.vertexArray = options.vertexArray;
    this.count = options.count;
    this.offset = defaultValue(options.offset, 0);
    this.shaderProgram = options.shaderProgram;
    this.uniformMap = options.uniformMap;
    this.renderState = options.renderState;
    this.framebuffer = options.framebuffer;
    this.pass = options.pass;
    this.executeInClosestFrustum = defaultValue(options.executeInClosestFrustum, false);
    this.owner = options.owner;
    this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);
    this.debugOverlappingFrustums = 0;
    this.oit = undefined;
};
DrawCommand.prototype.execute = function (context, passState, renderState, shaderProgram) {
    context.draw(this, passState, renderState, shaderProgram);
};
module.exports = DrawCommand;
},{"../Core/PrimitiveType":193,"../Core/defaultValue":243}],345:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), PixelFormat = require('../Core/PixelFormat');
'use strict';
function attachTexture(framebuffer, attachment, texture) {
    var gl = framebuffer._gl;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, texture._target, texture._texture, 0);
}
function attachRenderbuffer(framebuffer, attachment, renderbuffer) {
    var gl = framebuffer._gl;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
}
var Framebuffer = function (gl, maximumColorAttachments, options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._gl = gl;
    this._framebuffer = gl.createFramebuffer();
    this._colorTextures = [];
    this._colorRenderbuffers = [];
    this._activeColorAttachments = [];
    this._depthTexture = undefined;
    this._depthRenderbuffer = undefined;
    this._stencilRenderbuffer = undefined;
    this._depthStencilTexture = undefined;
    this._depthStencilRenderbuffer = undefined;
    this.destroyAttachments = defaultValue(options.destroyAttachments, true);
    if (defined(options.colorTextures) && defined(options.colorRenderbuffers)) {
        throw new DeveloperError('Cannot have both color texture and color renderbuffer attachments.');
    }
    if (defined(options.depthTexture) && defined(options.depthRenderbuffer)) {
        throw new DeveloperError('Cannot have both a depth texture and depth renderbuffer attachment.');
    }
    if (defined(options.depthStencilTexture) && defined(options.depthStencilRenderbuffer)) {
        throw new DeveloperError('Cannot have both a depth-stencil texture and depth-stencil renderbuffer attachment.');
    }
    var depthAttachment = defined(options.depthTexture) || defined(options.depthRenderbuffer);
    var depthStencilAttachment = defined(options.depthStencilTexture) || defined(options.depthStencilRenderbuffer);
    if (depthAttachment && depthStencilAttachment) {
        throw new DeveloperError('Cannot have both a depth and depth-stencil attachment.');
    }
    if (defined(options.stencilRenderbuffer) && depthStencilAttachment) {
        throw new DeveloperError('Cannot have both a stencil and depth-stencil attachment.');
    }
    if (depthAttachment && defined(options.stencilRenderbuffer)) {
        throw new DeveloperError('Cannot have both a depth and stencil attachment.');
    }
    this._bind();
    var texture;
    var renderbuffer;
    var i;
    var length;
    var attachmentEnum;
    if (defined(options.colorTextures)) {
        var textures = options.colorTextures;
        length = this._colorTextures.length = this._activeColorAttachments.length = textures.length;
        if (length > maximumColorAttachments) {
            throw new DeveloperError('The number of color attachments exceeds the number supported.');
        }
        for (i = 0; i < length; ++i) {
            texture = textures[i];
            if (!PixelFormat.isColorFormat(texture.pixelFormat)) {
                throw new DeveloperError('The color-texture pixel-format must be a color format.');
            }
            attachmentEnum = this._gl.COLOR_ATTACHMENT0 + i;
            attachTexture(this, attachmentEnum, texture);
            this._activeColorAttachments[i] = attachmentEnum;
            this._colorTextures[i] = texture;
        }
    }
    if (defined(options.colorRenderbuffers)) {
        var renderbuffers = options.colorRenderbuffers;
        length = this._colorRenderbuffers.length = this._activeColorAttachments.length = renderbuffers.length;
        if (length > maximumColorAttachments) {
            throw new DeveloperError('The number of color attachments exceeds the number supported.');
        }
        for (i = 0; i < length; ++i) {
            renderbuffer = renderbuffers[i];
            attachmentEnum = this._gl.COLOR_ATTACHMENT0 + i;
            attachRenderbuffer(this, attachmentEnum, renderbuffer);
            this._activeColorAttachments[i] = attachmentEnum;
            this._colorRenderbuffers[i] = renderbuffer;
        }
    }
    if (defined(options.depthTexture)) {
        texture = options.depthTexture;
        if (texture.pixelFormat !== PixelFormat.DEPTH_COMPONENT) {
            throw new DeveloperError('The depth-texture pixel-format must be DEPTH_COMPONENT.');
        }
        attachTexture(this, this._gl.DEPTH_ATTACHMENT, texture);
        this._depthTexture = texture;
    }
    if (defined(options.depthRenderbuffer)) {
        renderbuffer = options.depthRenderbuffer;
        attachRenderbuffer(this, this._gl.DEPTH_ATTACHMENT, renderbuffer);
        this._depthRenderbuffer = renderbuffer;
    }
    if (defined(options.stencilRenderbuffer)) {
        renderbuffer = options.stencilRenderbuffer;
        attachRenderbuffer(this, this._gl.STENCIL_ATTACHMENT, renderbuffer);
        this._stencilRenderbuffer = renderbuffer;
    }
    if (defined(options.depthStencilTexture)) {
        texture = options.depthStencilTexture;
        if (texture.pixelFormat !== PixelFormat.DEPTH_STENCIL) {
            throw new DeveloperError('The depth-stencil pixel-format must be DEPTH_STENCIL.');
        }
        attachTexture(this, this._gl.DEPTH_STENCIL_ATTACHMENT, texture);
        this._depthStencilTexture = texture;
    }
    if (defined(options.depthStencilRenderbuffer)) {
        renderbuffer = options.depthStencilRenderbuffer;
        attachRenderbuffer(this, this._gl.DEPTH_STENCIL_ATTACHMENT, renderbuffer);
        this._depthStencilRenderbuffer = renderbuffer;
    }
    this._unBind();
};
defineProperties(Framebuffer.prototype, {
    status: {
        get: function () {
            this._bind();
            var status = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);
            this._unBind();
            return status;
        }
    },
    numberOfColorAttachments: {
        get: function () {
            return this._activeColorAttachments.length;
        }
    },
    depthTexture: {
        get: function () {
            return this._depthTexture;
        }
    },
    depthRenderbuffer: {
        get: function () {
            return this._depthRenderbuffer;
        }
    },
    stencilRenderbuffer: {
        get: function () {
            return this._stencilRenderbuffer;
        }
    },
    depthStencilTexture: {
        get: function () {
            return this._depthStencilTexture;
        }
    },
    depthStencilRenderbuffer: {
        get: function () {
            return this._depthStencilRenderbuffer;
        }
    },
    hasDepthAttachment: {
        get: function () {
            return !!(this.depthTexture || this.depthRenderbuffer || this.depthStencilTexture || this.depthStencilRenderbuffer);
        }
    }
});
Framebuffer.prototype._bind = function () {
    var gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
};
Framebuffer.prototype._unBind = function () {
    var gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};
Framebuffer.prototype._getActiveColorAttachments = function () {
    return this._activeColorAttachments;
};
Framebuffer.prototype.getColorTexture = function (index) {
    if (!defined(index) || index < 0 || index >= this._colorTextures.length) {
        throw new DeveloperError('index is required, must be greater than or equal to zero and must be less than the number of color attachments.');
    }
    return this._colorTextures[index];
};
Framebuffer.prototype.getColorRenderbuffer = function (index) {
    if (!defined(index) || index < 0 || index >= this._colorRenderbuffers.length) {
        throw new DeveloperError('index is required, must be greater than or equal to zero and must be less than the number of color attachments.');
    }
    return this._colorRenderbuffers[index];
};
Framebuffer.prototype.isDestroyed = function () {
    return false;
};
Framebuffer.prototype.destroy = function () {
    if (this.destroyAttachments) {
        var i = 0;
        var textures = this._colorTextures;
        var length = textures.length;
        for (; i < length; ++i) {
            var texture = textures[i];
            if (defined(texture)) {
                texture.destroy();
            }
        }
        var renderbuffers = this._colorRenderbuffers;
        length = renderbuffers.length;
        for (i = 0; i < length; ++i) {
            var renderbuffer = renderbuffers[i];
            if (defined(renderbuffer)) {
                renderbuffer.destroy();
            }
        }
        this._depthTexture = this._depthTexture && this._depthTexture.destroy();
        this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy();
        this._stencilRenderbuffer = this._stencilRenderbuffer && this._stencilRenderbuffer.destroy();
        this._depthStencilTexture = this._depthStencilTexture && this._depthStencilTexture.destroy();
        this._depthStencilRenderbuffer = this._depthStencilRenderbuffer && this._depthStencilRenderbuffer.destroy();
    }
    this._gl.deleteFramebuffer(this._framebuffer);
    return destroyObject(this);
};
module.exports = Framebuffer;
},{"../Core/DeveloperError":123,"../Core/PixelFormat":181,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247}],346:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var MipmapHint = {
        DONT_CARE: 4352,
        FASTEST: 4353,
        NICEST: 4354,
        validate: function (mipmapHint) {
            return mipmapHint === MipmapHint.DONT_CARE || mipmapHint === MipmapHint.FASTEST || mipmapHint === MipmapHint.NICEST;
        }
    };
module.exports = freezeObject(MipmapHint);
},{"../Core/freezeObject":249}],347:[function(require,module,exports){
'use strict';
var PassState = function (context) {
    this.context = context;
    this.framebuffer = undefined;
    this.blendingEnabled = undefined;
    this.scissorTest = undefined;
};
module.exports = PassState;
},{}],348:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), Color = require('../Core/Color'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), PassState = require('./PassState'), RenderbufferFormat = require('./RenderbufferFormat');
'use strict';
var PickFramebuffer = function (context) {
    var passState = new PassState(context);
    passState.blendingEnabled = false;
    passState.scissorTest = {
        enabled: true,
        rectangle: new BoundingRectangle()
    };
    this._context = context;
    this._fb = undefined;
    this._passState = passState;
    this._width = 0;
    this._height = 0;
};
PickFramebuffer.prototype.begin = function (screenSpaceRectangle) {
    var context = this._context;
    var width = context.drawingBufferWidth;
    var height = context.drawingBufferHeight;
    BoundingRectangle.clone(screenSpaceRectangle, this._passState.scissorTest.rectangle);
    if (!defined(this._fb) || this._width !== width || this._height !== height) {
        this._width = width;
        this._height = height;
        this._fb = this._fb && this._fb.destroy();
        this._fb = context.createFramebuffer({
            colorTextures: [context.createTexture2D({
                    width: width,
                    height: height
                })],
            depthRenderbuffer: context.createRenderbuffer({ format: RenderbufferFormat.DEPTH_COMPONENT16 })
        });
        this._passState.framebuffer = this._fb;
    }
    return this._passState;
};
var colorScratch = new Color();
PickFramebuffer.prototype.end = function (screenSpaceRectangle) {
    var width = defaultValue(screenSpaceRectangle.width, 1);
    var height = defaultValue(screenSpaceRectangle.height, 1);
    var context = this._context;
    var pixels = context.readPixels({
            x: screenSpaceRectangle.x,
            y: screenSpaceRectangle.y,
            width: width,
            height: height,
            framebuffer: this._fb
        });
    var max = Math.max(width, height);
    var length = max * max;
    var halfWidth = Math.floor(width * 0.5);
    var halfHeight = Math.floor(height * 0.5);
    var x = 0;
    var y = 0;
    var dx = 0;
    var dy = -1;
    for (var i = 0; i < length; ++i) {
        if (-halfWidth <= x && x <= halfWidth && -halfHeight <= y && y <= halfHeight) {
            var index = 4 * ((halfHeight - y) * width + x + halfWidth);
            colorScratch.red = Color.byteToFloat(pixels[index]);
            colorScratch.green = Color.byteToFloat(pixels[index + 1]);
            colorScratch.blue = Color.byteToFloat(pixels[index + 2]);
            colorScratch.alpha = Color.byteToFloat(pixels[index + 3]);
            var object = context.getObjectByPickColor(colorScratch);
            if (defined(object)) {
                return object;
            }
        }
        if (x === y || x < 0 && -x === y || x > 0 && x === 1 - y) {
            var temp = dx;
            dx = -dy;
            dy = temp;
        }
        x += dx;
        y += dy;
    }
    return undefined;
};
PickFramebuffer.prototype.isDestroyed = function () {
    return false;
};
PickFramebuffer.prototype.destroy = function () {
    this._fb = this._fb && this._fb.destroy();
    return destroyObject(this);
};
module.exports = PickFramebuffer;
},{"../Core/BoundingRectangle":97,"../Core/Color":111,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"./PassState":347,"./RenderbufferFormat":352}],349:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var PixelDatatype = {
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123,
        UNSIGNED_INT: 5125,
        FLOAT: 5126,
        UNSIGNED_INT_24_8_WEBGL: 34042,
        UNSIGNED_SHORT_4_4_4_4: 32819,
        UNSIGNED_SHORT_5_5_5_1: 32820,
        UNSIGNED_SHORT_5_6_5: 33635,
        validate: function (pixelDatatype) {
            return pixelDatatype === PixelDatatype.UNSIGNED_BYTE || pixelDatatype === PixelDatatype.UNSIGNED_SHORT || pixelDatatype === PixelDatatype.UNSIGNED_INT || pixelDatatype === PixelDatatype.FLOAT || pixelDatatype === PixelDatatype.UNSIGNED_INT_24_8_WEBGL || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_4_4_4_4 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_5_5_1 || pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_6_5;
        }
    };
module.exports = freezeObject(PixelDatatype);
},{"../Core/freezeObject":249}],350:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), Color = require('../Core/Color'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), RuntimeError = require('../Core/RuntimeError'), WindingOrder = require('../Core/WindingOrder');
'use strict';
function validateBlendEquation(blendEquation) {
    return blendEquation === WebGLRenderingContext.FUNC_ADD || blendEquation === WebGLRenderingContext.FUNC_SUBTRACT || blendEquation === WebGLRenderingContext.FUNC_REVERSE_SUBTRACT;
}
function validateBlendFunction(blendFunction) {
    return blendFunction === WebGLRenderingContext.ZERO || blendFunction === WebGLRenderingContext.ONE || blendFunction === WebGLRenderingContext.SRC_COLOR || blendFunction === WebGLRenderingContext.ONE_MINUS_SRC_COLOR || blendFunction === WebGLRenderingContext.DST_COLOR || blendFunction === WebGLRenderingContext.ONE_MINUS_DST_COLOR || blendFunction === WebGLRenderingContext.SRC_ALPHA || blendFunction === WebGLRenderingContext.ONE_MINUS_SRC_ALPHA || blendFunction === WebGLRenderingContext.DST_ALPHA || blendFunction === WebGLRenderingContext.ONE_MINUS_DST_ALPHA || blendFunction === WebGLRenderingContext.CONSTANT_COLOR || blendFunction === WebGLRenderingContext.ONE_MINUS_CONSTANT_COLOR || blendFunction === WebGLRenderingContext.CONSTANT_ALPHA || blendFunction === WebGLRenderingContext.ONE_MINUS_CONSTANT_ALPHA || blendFunction === WebGLRenderingContext.SRC_ALPHA_SATURATE;
}
function validateCullFace(cullFace) {
    return cullFace === WebGLRenderingContext.FRONT || cullFace === WebGLRenderingContext.BACK || cullFace === WebGLRenderingContext.FRONT_AND_BACK;
}
function validateDepthFunction(depthFunction) {
    return depthFunction === WebGLRenderingContext.NEVER || depthFunction === WebGLRenderingContext.LESS || depthFunction === WebGLRenderingContext.EQUAL || depthFunction === WebGLRenderingContext.LEQUAL || depthFunction === WebGLRenderingContext.GREATER || depthFunction === WebGLRenderingContext.NOTEQUAL || depthFunction === WebGLRenderingContext.GEQUAL || depthFunction === WebGLRenderingContext.ALWAYS;
}
function validateStencilFunction(stencilFunction) {
    return stencilFunction === WebGLRenderingContext.NEVER || stencilFunction === WebGLRenderingContext.LESS || stencilFunction === WebGLRenderingContext.EQUAL || stencilFunction === WebGLRenderingContext.LEQUAL || stencilFunction === WebGLRenderingContext.GREATER || stencilFunction === WebGLRenderingContext.NOTEQUAL || stencilFunction === WebGLRenderingContext.GEQUAL || stencilFunction === WebGLRenderingContext.ALWAYS;
}
function validateStencilOperation(stencilOperation) {
    return stencilOperation === WebGLRenderingContext.ZERO || stencilOperation === WebGLRenderingContext.KEEP || stencilOperation === WebGLRenderingContext.REPLACE || stencilOperation === WebGLRenderingContext.INCR || stencilOperation === WebGLRenderingContext.DECR || stencilOperation === WebGLRenderingContext.INVERT || stencilOperation === WebGLRenderingContext.INCREMENT_WRAP || stencilOperation === WebGLRenderingContext.DECR_WRAP;
}
var RenderState = function (context, renderState) {
    var rs = defaultValue(renderState, {});
    var cull = defaultValue(rs.cull, {});
    var polygonOffset = defaultValue(rs.polygonOffset, {});
    var scissorTest = defaultValue(rs.scissorTest, {});
    var scissorTestRectangle = defaultValue(scissorTest.rectangle, {});
    var depthRange = defaultValue(rs.depthRange, {});
    var depthTest = defaultValue(rs.depthTest, {});
    var colorMask = defaultValue(rs.colorMask, {});
    var blending = defaultValue(rs.blending, {});
    var blendingColor = defaultValue(blending.color, {});
    var stencilTest = defaultValue(rs.stencilTest, {});
    var stencilTestFrontOperation = defaultValue(stencilTest.frontOperation, {});
    var stencilTestBackOperation = defaultValue(stencilTest.backOperation, {});
    var sampleCoverage = defaultValue(rs.sampleCoverage, {});
    var viewport = rs.viewport;
    this.frontFace = defaultValue(rs.frontFace, WindingOrder.COUNTER_CLOCKWISE);
    this.cull = {
        enabled: defaultValue(cull.enabled, false),
        face: defaultValue(cull.face, WebGLRenderingContext.BACK)
    };
    this.lineWidth = defaultValue(rs.lineWidth, 1);
    this.polygonOffset = {
        enabled: defaultValue(polygonOffset.enabled, false),
        factor: defaultValue(polygonOffset.factor, 0),
        units: defaultValue(polygonOffset.units, 0)
    };
    this.scissorTest = {
        enabled: defaultValue(scissorTest.enabled, false),
        rectangle: BoundingRectangle.clone(scissorTestRectangle)
    };
    this.depthRange = {
        near: defaultValue(depthRange.near, 0),
        far: defaultValue(depthRange.far, 1)
    };
    this.depthTest = {
        enabled: defaultValue(depthTest.enabled, false),
        func: defaultValue(depthTest.func, WebGLRenderingContext.LESS)
    };
    this.colorMask = {
        red: defaultValue(colorMask.red, true),
        green: defaultValue(colorMask.green, true),
        blue: defaultValue(colorMask.blue, true),
        alpha: defaultValue(colorMask.alpha, true)
    };
    this.depthMask = defaultValue(rs.depthMask, true);
    this.stencilMask = defaultValue(rs.stencilMask, ~0);
    this.blending = {
        enabled: defaultValue(blending.enabled, false),
        color: new Color(defaultValue(blendingColor.red, 0), defaultValue(blendingColor.green, 0), defaultValue(blendingColor.blue, 0), defaultValue(blendingColor.alpha, 0)),
        equationRgb: defaultValue(blending.equationRgb, WebGLRenderingContext.FUNC_ADD),
        equationAlpha: defaultValue(blending.equationAlpha, WebGLRenderingContext.FUNC_ADD),
        functionSourceRgb: defaultValue(blending.functionSourceRgb, WebGLRenderingContext.ONE),
        functionSourceAlpha: defaultValue(blending.functionSourceAlpha, WebGLRenderingContext.ONE),
        functionDestinationRgb: defaultValue(blending.functionDestinationRgb, WebGLRenderingContext.ZERO),
        functionDestinationAlpha: defaultValue(blending.functionDestinationAlpha, WebGLRenderingContext.ZERO)
    };
    this.stencilTest = {
        enabled: defaultValue(stencilTest.enabled, false),
        frontFunction: defaultValue(stencilTest.frontFunction, WebGLRenderingContext.ALWAYS),
        backFunction: defaultValue(stencilTest.backFunction, WebGLRenderingContext.ALWAYS),
        reference: defaultValue(stencilTest.reference, 0),
        mask: defaultValue(stencilTest.mask, ~0),
        frontOperation: {
            fail: defaultValue(stencilTestFrontOperation.fail, WebGLRenderingContext.KEEP),
            zFail: defaultValue(stencilTestFrontOperation.zFail, WebGLRenderingContext.KEEP),
            zPass: defaultValue(stencilTestFrontOperation.zPass, WebGLRenderingContext.KEEP)
        },
        backOperation: {
            fail: defaultValue(stencilTestBackOperation.fail, WebGLRenderingContext.KEEP),
            zFail: defaultValue(stencilTestBackOperation.zFail, WebGLRenderingContext.KEEP),
            zPass: defaultValue(stencilTestBackOperation.zPass, WebGLRenderingContext.KEEP)
        }
    };
    this.sampleCoverage = {
        enabled: defaultValue(sampleCoverage.enabled, false),
        value: defaultValue(sampleCoverage.value, 1),
        invert: defaultValue(sampleCoverage.invert, false)
    };
    this.viewport = defined(viewport) ? new BoundingRectangle(viewport.x, viewport.y, !defined(viewport.width) ? context.drawingBufferWidth : viewport.width, !defined(viewport.height) ? context.drawingBufferHeight : viewport.height) : undefined;
    if (this.lineWidth < context.minimumAliasedLineWidth || this.lineWidth > context.maximumAliasedLineWidth) {
        throw new RuntimeError('renderState.lineWidth is out of range.  Check minimumAliasedLineWidth and maximumAliasedLineWidth.');
    }
    if (!WindingOrder.validate(this.frontFace)) {
        throw new DeveloperError('Invalid renderState.frontFace.');
    }
    if (!validateCullFace(this.cull.face)) {
        throw new DeveloperError('Invalid renderState.cull.face.');
    }
    if (this.scissorTest.rectangle.width < 0 || this.scissorTest.rectangle.height < 0) {
        throw new DeveloperError('renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero.');
    }
    if (this.depthRange.near > this.depthRange.far) {
        throw new DeveloperError('renderState.depthRange.near can not be greater than renderState.depthRange.far.');
    }
    if (this.depthRange.near < 0) {
        throw new DeveloperError('renderState.depthRange.near must be greater than or equal to zero.');
    }
    if (this.depthRange.far > 1) {
        throw new DeveloperError('renderState.depthRange.far must be less than or equal to one.');
    }
    if (!validateDepthFunction(this.depthTest.func)) {
        throw new DeveloperError('Invalid renderState.depthTest.func.');
    }
    if (this.blending.color.red < 0 || this.blending.color.red > 1 || this.blending.color.green < 0 || this.blending.color.green > 1 || this.blending.color.blue < 0 || this.blending.color.blue > 1 || this.blending.color.alpha < 0 || this.blending.color.alpha > 1) {
        throw new DeveloperError('renderState.blending.color components must be greater than or equal to zero and less than or equal to one.');
    }
    if (!validateBlendEquation(this.blending.equationRgb)) {
        throw new DeveloperError('Invalid renderState.blending.equationRgb.');
    }
    if (!validateBlendEquation(this.blending.equationAlpha)) {
        throw new DeveloperError('Invalid renderState.blending.equationAlpha.');
    }
    if (!validateBlendFunction(this.blending.functionSourceRgb)) {
        throw new DeveloperError('Invalid renderState.blending.functionSourceRgb.');
    }
    if (!validateBlendFunction(this.blending.functionSourceAlpha)) {
        throw new DeveloperError('Invalid renderState.blending.functionSourceAlpha.');
    }
    if (!validateBlendFunction(this.blending.functionDestinationRgb)) {
        throw new DeveloperError('Invalid renderState.blending.functionDestinationRgb.');
    }
    if (!validateBlendFunction(this.blending.functionDestinationAlpha)) {
        throw new DeveloperError('Invalid renderState.blending.functionDestinationAlpha.');
    }
    if (!validateStencilFunction(this.stencilTest.frontFunction)) {
        throw new DeveloperError('Invalid renderState.stencilTest.frontFunction.');
    }
    if (!validateStencilFunction(this.stencilTest.backFunction)) {
        throw new DeveloperError('Invalid renderState.stencilTest.backFunction.');
    }
    if (!validateStencilOperation(this.stencilTest.frontOperation.fail)) {
        throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.fail.');
    }
    if (!validateStencilOperation(this.stencilTest.frontOperation.zFail)) {
        throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.zFail.');
    }
    if (!validateStencilOperation(this.stencilTest.frontOperation.zPass)) {
        throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.zPass.');
    }
    if (!validateStencilOperation(this.stencilTest.backOperation.fail)) {
        throw new DeveloperError('Invalid renderState.stencilTest.backOperation.fail.');
    }
    if (!validateStencilOperation(this.stencilTest.backOperation.zFail)) {
        throw new DeveloperError('Invalid renderState.stencilTest.backOperation.zFail.');
    }
    if (!validateStencilOperation(this.stencilTest.backOperation.zPass)) {
        throw new DeveloperError('Invalid renderState.stencilTest.backOperation.zPass.');
    }
    if (defined(this.viewport)) {
        if (this.viewport.width < 0) {
            throw new DeveloperError('renderState.viewport.width must be greater than or equal to zero.');
        }
        if (this.viewport.height < 0) {
            throw new DeveloperError('renderState.viewport.height must be greater than or equal to zero.');
        }
        if (this.viewport.width > context.maximumViewportWidth) {
            throw new RuntimeError('renderState.viewport.width must be less than or equal to the maximum viewport width (' + this.maximumViewportWidth.toString() + ').  Check maximumViewportWidth.');
        }
        if (this.viewport.height > context.maximumViewportHeight) {
            throw new RuntimeError('renderState.viewport.height must be less than or equal to the maximum viewport height (' + this.maximumViewportHeight.toString() + ').  Check maximumViewportHeight.');
        }
    }
    this.id = 0;
    this._applyFunctions = [];
};
function enableOrDisable(gl, glEnum, enable) {
    if (enable) {
        gl.enable(glEnum);
    } else {
        gl.disable(glEnum);
    }
}
function applyFrontFace(gl, renderState) {
    gl.frontFace(renderState.frontFace);
}
function applyCull(gl, renderState) {
    var cull = renderState.cull;
    var enabled = cull.enabled;
    enableOrDisable(gl, gl.CULL_FACE, enabled);
    if (enabled) {
        gl.cullFace(cull.face);
    }
}
function applyLineWidth(gl, renderState) {
    gl.lineWidth(renderState.lineWidth);
}
function applyPolygonOffset(gl, renderState) {
    var polygonOffset = renderState.polygonOffset;
    var enabled = polygonOffset.enabled;
    enableOrDisable(gl, gl.POLYGON_OFFSET_FILL, enabled);
    if (enabled) {
        gl.polygonOffset(polygonOffset.factor, polygonOffset.units);
    }
}
function applyScissorTest(gl, renderState, passState) {
    var scissorTest = renderState.scissorTest;
    var enabled = defined(passState.scissorTest) ? passState.scissorTest.enabled : scissorTest.enabled;
    enableOrDisable(gl, gl.SCISSOR_TEST, enabled);
    if (enabled) {
        var rectangle = defined(passState.scissorTest) ? passState.scissorTest.rectangle : scissorTest.rectangle;
        gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    }
}
function applyDepthRange(gl, renderState) {
    var depthRange = renderState.depthRange;
    gl.depthRange(depthRange.near, depthRange.far);
}
function applyDepthTest(gl, renderState) {
    var depthTest = renderState.depthTest;
    var enabled = depthTest.enabled;
    enableOrDisable(gl, gl.DEPTH_TEST, enabled);
    if (enabled) {
        gl.depthFunc(depthTest.func);
    }
}
function applyColorMask(gl, renderState) {
    var colorMask = renderState.colorMask;
    gl.colorMask(colorMask.red, colorMask.green, colorMask.blue, colorMask.alpha);
}
function applyDepthMask(gl, renderState) {
    gl.depthMask(renderState.depthMask);
}
function applyStencilMask(gl, renderState) {
    gl.stencilMask(renderState.stencilMask);
}
var applyBlendingColor = function (gl, color) {
    gl.blendColor(color.red, color.green, color.blue, color.alpha);
};
function applyBlending(gl, renderState, passState) {
    var blending = renderState.blending;
    var enabled = defined(passState.blendingEnabled) ? passState.blendingEnabled : blending.enabled;
    enableOrDisable(gl, gl.BLEND, enabled);
    if (enabled) {
        applyBlendingColor(gl, blending.color);
        gl.blendEquationSeparate(blending.equationRgb, blending.equationAlpha);
        gl.blendFuncSeparate(blending.functionSourceRgb, blending.functionDestinationRgb, blending.functionSourceAlpha, blending.functionDestinationAlpha);
    }
}
function applyStencilTest(gl, renderState) {
    var stencilTest = renderState.stencilTest;
    var enabled = stencilTest.enabled;
    enableOrDisable(gl, gl.STENCIL_TEST, enabled);
    if (enabled) {
        var frontFunction = stencilTest.frontFunction;
        var backFunction = stencilTest.backFunction;
        var reference = stencilTest.reference;
        var mask = stencilTest.mask;
        gl.stencilFunc(stencilTest.frontFunction, stencilTest.reference, stencilTest.mask);
        gl.stencilFuncSeparate(gl.BACK, backFunction, reference, mask);
        gl.stencilFuncSeparate(gl.FRONT, frontFunction, reference, mask);
        var frontOperation = stencilTest.frontOperation;
        var frontOperationFail = frontOperation.fail;
        var frontOperationZFail = frontOperation.zFail;
        var frontOperationZPass = frontOperation.zPass;
        gl.stencilOpSeparate(gl.FRONT, frontOperationFail, frontOperationZFail, frontOperationZPass);
        var backOperation = stencilTest.backOperation;
        var backOperationFail = backOperation.fail;
        var backOperationZFail = backOperation.zFail;
        var backOperationZPass = backOperation.zPass;
        gl.stencilOpSeparate(gl.BACK, backOperationFail, backOperationZFail, backOperationZPass);
    }
}
var applySampleCoverage = function (gl, renderState) {
    var sampleCoverage = renderState.sampleCoverage;
    var enabled = sampleCoverage.enabled;
    enableOrDisable(gl, gl.SAMPLE_COVERAGE, enabled);
    if (enabled) {
        gl.sampleCoverage(sampleCoverage.value, sampleCoverage.invert);
    }
};
var scratchViewport = new BoundingRectangle();
function applyViewport(gl, renderState, passState) {
    var viewport = renderState.viewport;
    if (!defined(viewport)) {
        viewport = scratchViewport;
        viewport.width = passState.context.drawingBufferWidth;
        viewport.height = passState.context.drawingBufferHeight;
    }
    passState.context.uniformState.viewport = viewport;
    gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
}
RenderState.apply = function (gl, renderState, passState) {
    applyFrontFace(gl, renderState);
    applyCull(gl, renderState);
    applyLineWidth(gl, renderState);
    applyPolygonOffset(gl, renderState);
    applyScissorTest(gl, renderState, passState);
    applyDepthRange(gl, renderState);
    applyDepthTest(gl, renderState);
    applyColorMask(gl, renderState);
    applyDepthMask(gl, renderState);
    applyStencilMask(gl, renderState);
    applyBlending(gl, renderState, passState);
    applyStencilTest(gl, renderState);
    applySampleCoverage(gl, renderState);
    applyViewport(gl, renderState, passState);
};
function createFuncs(previousState, nextState) {
    var funcs = [];
    if (previousState.frontFace !== nextState.frontFace) {
        funcs.push(applyFrontFace);
    }
    if (previousState.cull.enabled !== nextState.cull.enabled || previousState.cull.face !== nextState.cull.face) {
        funcs.push(applyCull);
    }
    if (previousState.lineWidth !== nextState.lineWidth) {
        funcs.push(applyLineWidth);
    }
    if (previousState.polygonOffset.enabled !== nextState.polygonOffset.enabled || previousState.polygonOffset.factor !== nextState.polygonOffset.factor || previousState.polygonOffset.units !== nextState.polygonOffset.units) {
        funcs.push(applyPolygonOffset);
    }
    funcs.push(applyScissorTest);
    if (previousState.depthRange.near !== nextState.depthRange.near || previousState.depthRange.far !== nextState.depthRange.far) {
        funcs.push(applyDepthRange);
    }
    if (previousState.depthTest.enabled !== nextState.depthTest.enabled || previousState.depthTest.func !== nextState.depthTest.func) {
        funcs.push(applyDepthTest);
    }
    if (previousState.colorMask.red !== nextState.colorMask.red || previousState.colorMask.green !== nextState.colorMask.green || previousState.colorMask.blue !== nextState.colorMask.blue || previousState.colorMask.alpha !== nextState.colorMask.alpha) {
        funcs.push(applyColorMask);
    }
    if (previousState.depthMask !== nextState.depthMask) {
        funcs.push(applyDepthMask);
    }
    funcs.push(applyBlending);
    if (previousState.stencilMask !== nextState.stencilMask) {
        funcs.push(applyStencilMask);
    }
    if (previousState.stencilTest.enabled !== nextState.stencilTest.enabled || previousState.stencilTest.frontFunction !== nextState.stencilTest.frontFunction || previousState.stencilTest.backFunction !== nextState.stencilTest.backFunction || previousState.stencilTest.reference !== nextState.stencilTest.reference || previousState.stencilTest.mask !== nextState.stencilTest.mask || previousState.stencilTest.frontOperation.fail !== nextState.stencilTest.frontOperation.fail || previousState.stencilTest.frontOperation.zFail !== nextState.stencilTest.frontOperation.zFail || previousState.stencilTest.backOperation.fail !== nextState.stencilTest.backOperation.fail || previousState.stencilTest.backOperation.zFail !== nextState.stencilTest.backOperation.zFail || previousState.stencilTest.backOperation.zPass !== nextState.stencilTest.backOperation.zPass) {
        funcs.push(applyStencilTest);
    }
    if (previousState.sampleCoverage.enabled !== nextState.sampleCoverage.enabled || previousState.sampleCoverage.value !== nextState.sampleCoverage.value || previousState.sampleCoverage.invert !== nextState.sampleCoverage.invert) {
        funcs.push(applySampleCoverage);
    }
    funcs.push(applyViewport);
    return funcs;
}
RenderState.partialApply = function (gl, previousState, nextState, passState) {
    var funcs = nextState._applyFunctions[previousState.id];
    if (!defined(funcs)) {
        funcs = createFuncs(previousState, nextState);
        nextState._applyFunctions[previousState.id] = funcs;
    }
    var len = funcs.length;
    for (var i = 0; i < len; ++i) {
        funcs[i](gl, nextState, passState);
    }
};
RenderState.clone = function (renderState) {
    if (!defined(renderState)) {
        throw new DeveloperError('renderState is required.');
    }
    return {
        frontFace: renderState.frontFace,
        cull: {
            enabled: renderState.cull.enabled,
            face: renderState.cull.face
        },
        lineWidth: renderState.lineWidth,
        polygonOffset: {
            enabled: renderState.polygonOffset.enabled,
            factor: renderState.polygonOffset.factor,
            units: renderState.polygonOffset.units
        },
        scissorTest: {
            enabled: renderState.scissorTest.enabled,
            rectangle: BoundingRectangle.clone(renderState.scissorTest.rectangle)
        },
        depthRange: {
            near: renderState.depthRange.near,
            far: renderState.depthRange.far
        },
        depthTest: {
            enabled: renderState.depthTest.enabled,
            func: renderState.depthTest.func
        },
        colorMask: {
            red: renderState.colorMask.red,
            green: renderState.colorMask.green,
            blue: renderState.colorMask.blue,
            alpha: renderState.colorMask.alpha
        },
        depthMask: renderState.depthMask,
        stencilMask: renderState.stencilMask,
        blending: {
            enabled: renderState.blending.enabled,
            color: Color.clone(renderState.blending.color),
            equationRgb: renderState.blending.equationRgb,
            equationAlpha: renderState.blending.equationAlpha,
            functionSourceRgb: renderState.blending.functionSourceRgb,
            functionSourceAlpha: renderState.blending.functionSourceAlpha,
            functionDestinationRgb: renderState.blending.functionDestinationRgb,
            functionDestinationAlpha: renderState.blending.functionDestinationAlpha
        },
        stencilTest: {
            enabled: renderState.stencilTest.enabled,
            frontFunction: renderState.stencilTest.frontFunction,
            backFunction: renderState.stencilTest.backFunction,
            reference: renderState.stencilTest.reference,
            mask: renderState.stencilTest.mask,
            frontOperation: {
                fail: renderState.stencilTest.frontOperation.fail,
                zFail: renderState.stencilTest.frontOperation.zFail,
                zPass: renderState.stencilTest.frontOperation.zPass
            },
            backOperation: {
                fail: renderState.stencilTest.backOperation.fail,
                zFail: renderState.stencilTest.backOperation.zFail,
                zPass: renderState.stencilTest.backOperation.zPass
            }
        },
        sampleCoverage: {
            enabled: renderState.sampleCoverage.enabled,
            value: renderState.sampleCoverage.value,
            invert: renderState.sampleCoverage.invert
        },
        viewport: defined(renderState.viewport) ? BoundingRectangle.clone(renderState.viewport) : undefined
    };
};
module.exports = RenderState;
},{"../Core/BoundingRectangle":97,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/RuntimeError":207,"../Core/WindingOrder":235,"../Core/defaultValue":243,"../Core/defined":245}],351:[function(require,module,exports){
var defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject');
'use strict';
function Renderbuffer(gl, format, width, height) {
    this._gl = gl;
    this._format = format;
    this._width = width;
    this._height = height;
    this._renderbuffer = this._gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
}
defineProperties(Renderbuffer.prototype, {
    format: {
        get: function () {
            return this._format;
        }
    },
    width: {
        get: function () {
            return this._width;
        }
    },
    height: {
        get: function () {
            return this._height;
        }
    }
});
Renderbuffer.prototype._getRenderbuffer = function () {
    return this._renderbuffer;
};
Renderbuffer.prototype.isDestroyed = function () {
    return false;
};
Renderbuffer.prototype.destroy = function () {
    this._gl.deleteRenderbuffer(this._renderbuffer);
    return destroyObject(this);
};
module.exports = Renderbuffer;
},{"../Core/defineProperties":244,"../Core/destroyObject":247}],352:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var RenderbufferFormat = {
        RGBA4: 32854,
        RGB5_A1: 32855,
        RGB565: 36194,
        DEPTH_COMPONENT16: 33189,
        STENCIL_INDEX8: 36168,
        DEPTH_STENCIL: 34041,
        validate: function (renderbufferFormat) {
            return renderbufferFormat === RenderbufferFormat.RGBA4 || renderbufferFormat === RenderbufferFormat.RGB5_A1 || renderbufferFormat === RenderbufferFormat.RGB565 || renderbufferFormat === RenderbufferFormat.DEPTH_COMPONENT16 || renderbufferFormat === RenderbufferFormat.STENCIL_INDEX8 || renderbufferFormat === RenderbufferFormat.DEPTH_STENCIL;
        }
    };
module.exports = freezeObject(RenderbufferFormat);
},{"../Core/freezeObject":249}],353:[function(require,module,exports){
var defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), ShaderProgram = require('./ShaderProgram'), ShaderSource = require('./ShaderSource');
'use strict';
var ShaderCache = function (context) {
    this._context = context;
    this._shaders = {};
    this._shadersToRelease = {};
};
ShaderCache.prototype.replaceShaderProgram = function (shaderProgram, vertexShaderSource, fragmentShaderSource, attributeLocations) {
    if (defined(shaderProgram)) {
        shaderProgram.destroy();
    }
    return this.getShaderProgram(vertexShaderSource, fragmentShaderSource, attributeLocations);
};
ShaderCache.prototype.getShaderProgram = function (vertexShaderSource, fragmentShaderSource, attributeLocations) {
    if (typeof vertexShaderSource === 'string') {
        vertexShaderSource = new ShaderSource({ sources: [vertexShaderSource] });
    }
    if (typeof fragmentShaderSource === 'string') {
        fragmentShaderSource = new ShaderSource({ sources: [fragmentShaderSource] });
    }
    var vertexShaderText = vertexShaderSource.createCombinedVertexShader();
    var fragmentShaderText = fragmentShaderSource.createCombinedFragmentShader();
    var keyword = vertexShaderText + fragmentShaderText + JSON.stringify(attributeLocations);
    var cachedShader;
    if (this._shaders[keyword]) {
        cachedShader = this._shaders[keyword];
        delete this._shadersToRelease[keyword];
    } else {
        var context = this._context;
        var shaderProgram = new ShaderProgram({
                gl: context._gl,
                logShaderCompilation: context.logShaderCompilation,
                debugShaders: context.debugShaders,
                vertexShaderSource: vertexShaderSource,
                vertexShaderText: vertexShaderText,
                fragmentShaderSource: fragmentShaderSource,
                fragmentShaderText: fragmentShaderText,
                attributeLocations: attributeLocations
            });
        cachedShader = {
            cache: this,
            shaderProgram: shaderProgram,
            keyword: keyword,
            count: 0
        };
        shaderProgram._cachedShader = cachedShader;
        this._shaders[keyword] = cachedShader;
    }
    ++cachedShader.count;
    return cachedShader.shaderProgram;
};
ShaderCache.prototype.destroyReleasedShaderPrograms = function () {
    var shadersToRelease = this._shadersToRelease;
    for (var keyword in shadersToRelease) {
        if (shadersToRelease.hasOwnProperty(keyword)) {
            var cachedShader = shadersToRelease[keyword];
            delete this._shaders[cachedShader.keyword];
            cachedShader.shaderProgram.finalDestroy();
        }
    }
    this._shadersToRelease = {};
};
ShaderCache.prototype.releaseShaderProgram = function (shaderProgram) {
    if (shaderProgram) {
        var cachedShader = shaderProgram._cachedShader;
        if (cachedShader && --cachedShader.count === 0) {
            this._shadersToRelease[cachedShader.keyword] = cachedShader;
        }
    }
};
ShaderCache.prototype.isDestroyed = function () {
    return false;
};
ShaderCache.prototype.destroy = function () {
    var shaders = this._shaders;
    for (var keyword in shaders) {
        if (shaders.hasOwnProperty(keyword)) {
            shaders[keyword].shaderProgram.finalDestroy();
        }
    }
    return destroyObject(this);
};
module.exports = ShaderCache;
},{"../Core/defined":245,"../Core/destroyObject":247,"./ShaderProgram":354,"./ShaderSource":355}],354:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), RuntimeError = require('../Core/RuntimeError'), AutomaticUniforms = require('./AutomaticUniforms'), Uniform = require('./Uniform'), UniformArray = require('./UniformArray');
'use strict';
var nextShaderProgramId = 0;
var ShaderProgram = function (options) {
    this._gl = options.gl;
    this._logShaderCompilation = options.logShaderCompilation;
    this._debugShaders = options.debugShaders;
    this._attributeLocations = options.attributeLocations;
    this._program = undefined;
    this._numberOfVertexAttributes = undefined;
    this._vertexAttributes = undefined;
    this._uniformsByName = undefined;
    this._uniforms = undefined;
    this._automaticUniforms = undefined;
    this._manualUniforms = undefined;
    this._cachedShader = undefined;
    this.maximumTextureUnitIndex = undefined;
    this._vertexShaderSource = options.vertexShaderSource;
    this._vertexShaderText = options.vertexShaderText;
    this._fragmentShaderSource = options.fragmentShaderSource;
    this._fragmentShaderText = options.fragmentShaderText;
    this.id = nextShaderProgramId++;
};
defineProperties(ShaderProgram.prototype, {
    vertexShaderSource: {
        get: function () {
            return this._vertexShaderSource;
        }
    },
    fragmentShaderSource: {
        get: function () {
            return this._fragmentShaderSource;
        }
    },
    vertexAttributes: {
        get: function () {
            initialize(this);
            return this._vertexAttributes;
        }
    },
    numberOfVertexAttributes: {
        get: function () {
            initialize(this);
            return this._numberOfVertexAttributes;
        }
    },
    allUniforms: {
        get: function () {
            initialize(this);
            return this._uniformsByName;
        }
    }
});
var consolePrefix = '[Cesium WebGL] ';
function createAndLinkProgram(gl, shader) {
    var vsSource = shader._vertexShaderText;
    var fsSource = shader._fragmentShaderText;
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vsSource);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fsSource);
    gl.compileShader(fragmentShader);
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    var attributeLocations = shader._attributeLocations;
    if (defined(attributeLocations)) {
        for (var attribute in attributeLocations) {
            if (attributeLocations.hasOwnProperty(attribute)) {
                gl.bindAttribLocation(program, attributeLocations[attribute], attribute);
            }
        }
    }
    gl.linkProgram(program);
    var log;
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var debugShaders = shader._debugShaders;
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            log = gl.getShaderInfoLog(fragmentShader);
            console.error(consolePrefix + 'Fragment shader compile log: ' + log);
            if (defined(debugShaders)) {
                var fragmentSourceTranslation = debugShaders.getTranslatedShaderSource(fragmentShader);
                if (fragmentSourceTranslation !== '') {
                    console.error(consolePrefix + 'Translated fragment shader source:\n' + fragmentSourceTranslation);
                } else {
                    console.error(consolePrefix + 'Fragment shader translation failed.');
                }
            }
            gl.deleteProgram(program);
            throw new RuntimeError('Fragment shader failed to compile.  Compile log: ' + log);
        }
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            log = gl.getShaderInfoLog(vertexShader);
            console.error(consolePrefix + 'Vertex shader compile log: ' + log);
            if (defined(debugShaders)) {
                var vertexSourceTranslation = debugShaders.getTranslatedShaderSource(vertexShader);
                if (vertexSourceTranslation !== '') {
                    console.error(consolePrefix + 'Translated vertex shader source:\n' + vertexSourceTranslation);
                } else {
                    console.error(consolePrefix + 'Vertex shader translation failed.');
                }
            }
            gl.deleteProgram(program);
            throw new RuntimeError('Vertex shader failed to compile.  Compile log: ' + log);
        }
        log = gl.getProgramInfoLog(program);
        console.error(consolePrefix + 'Shader program link log: ' + log);
        if (defined(debugShaders)) {
            console.error(consolePrefix + 'Translated vertex shader source:\n' + debugShaders.getTranslatedShaderSource(vertexShader));
            console.error(consolePrefix + 'Translated fragment shader source:\n' + debugShaders.getTranslatedShaderSource(fragmentShader));
        }
        gl.deleteProgram(program);
        throw new RuntimeError('Program failed to link.  Link log: ' + log);
    }
    var logShaderCompilation = shader._logShaderCompilation;
    if (logShaderCompilation) {
        log = gl.getShaderInfoLog(vertexShader);
        if (defined(log) && log.length > 0) {
            console.log(consolePrefix + 'Vertex shader compile log: ' + log);
        }
    }
    if (logShaderCompilation) {
        log = gl.getShaderInfoLog(fragmentShader);
        if (defined(log) && log.length > 0) {
            console.log(consolePrefix + 'Fragment shader compile log: ' + log);
        }
    }
    if (logShaderCompilation) {
        log = gl.getProgramInfoLog(program);
        if (defined(log) && log.length > 0) {
            console.log(consolePrefix + 'Shader program link log: ' + log);
        }
    }
    return program;
}
function findVertexAttributes(gl, program, numberOfAttributes) {
    var attributes = {};
    for (var i = 0; i < numberOfAttributes; ++i) {
        var attr = gl.getActiveAttrib(program, i);
        var location = gl.getAttribLocation(program, attr.name);
        attributes[attr.name] = {
            name: attr.name,
            type: attr.type,
            index: location
        };
    }
    return attributes;
}
function findUniforms(gl, program) {
    var uniformsByName = {};
    var uniforms = [];
    var samplerUniforms = [];
    var numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < numberOfUniforms; ++i) {
        var activeUniform = gl.getActiveUniform(program, i);
        var suffix = '[0]';
        var uniformName = activeUniform.name.indexOf(suffix, activeUniform.name.length - suffix.length) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;
        if (uniformName.indexOf('gl_') !== 0) {
            if (activeUniform.name.indexOf('[') < 0) {
                var location = gl.getUniformLocation(program, uniformName);
                if (location !== null) {
                    var uniform = new Uniform(gl, activeUniform, uniformName, location);
                    uniformsByName[uniformName] = uniform;
                    uniforms.push(uniform);
                    if (uniform._setSampler) {
                        samplerUniforms.push(uniform);
                    }
                }
            } else {
                var uniformArray;
                var locations;
                var value;
                var loc;
                var indexOfBracket = uniformName.indexOf('[');
                if (indexOfBracket >= 0) {
                    uniformArray = uniformsByName[uniformName.slice(0, indexOfBracket)];
                    if (!defined(uniformArray)) {
                        continue;
                    }
                    locations = uniformArray._locations;
                    if (locations.length <= 1) {
                        value = uniformArray.value;
                        loc = gl.getUniformLocation(program, uniformName);
                        if (loc !== null) {
                            locations.push(loc);
                            value.push(gl.getUniform(program, loc));
                        }
                    }
                } else {
                    locations = [];
                    for (var j = 0; j < activeUniform.size; ++j) {
                        loc = gl.getUniformLocation(program, uniformName + '[' + j + ']');
                        if (loc !== null) {
                            locations.push(loc);
                        }
                    }
                    uniformArray = new UniformArray(gl, activeUniform, uniformName, locations);
                    uniformsByName[uniformName] = uniformArray;
                    uniforms.push(uniformArray);
                    if (uniformArray._setSampler) {
                        samplerUniforms.push(uniformArray);
                    }
                }
            }
        }
    }
    return {
        uniformsByName: uniformsByName,
        uniforms: uniforms,
        samplerUniforms: samplerUniforms
    };
}
function partitionUniforms(uniforms) {
    var automaticUniforms = [];
    var manualUniforms = [];
    for (var uniform in uniforms) {
        if (uniforms.hasOwnProperty(uniform)) {
            var automaticUniform = AutomaticUniforms[uniform];
            if (automaticUniform) {
                automaticUniforms.push({
                    uniform: uniforms[uniform],
                    automaticUniform: automaticUniform
                });
            } else {
                manualUniforms.push(uniforms[uniform]);
            }
        }
    }
    return {
        automaticUniforms: automaticUniforms,
        manualUniforms: manualUniforms
    };
}
function setSamplerUniforms(gl, program, samplerUniforms) {
    gl.useProgram(program);
    var textureUnitIndex = 0;
    var length = samplerUniforms.length;
    for (var i = 0; i < length; ++i) {
        textureUnitIndex = samplerUniforms[i]._setSampler(textureUnitIndex);
    }
    gl.useProgram(null);
    return textureUnitIndex;
}
function initialize(shader) {
    if (defined(shader._program)) {
        return;
    }
    var gl = shader._gl;
    var program = createAndLinkProgram(gl, shader, shader._debugShaders);
    var numberOfVertexAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    var uniforms = findUniforms(gl, program);
    var partitionedUniforms = partitionUniforms(uniforms.uniformsByName);
    shader._program = program;
    shader._numberOfVertexAttributes = numberOfVertexAttributes;
    shader._vertexAttributes = findVertexAttributes(gl, program, numberOfVertexAttributes);
    shader._uniformsByName = uniforms.uniformsByName;
    shader._uniforms = uniforms.uniforms;
    shader._automaticUniforms = partitionedUniforms.automaticUniforms;
    shader._manualUniforms = partitionedUniforms.manualUniforms;
    shader.maximumTextureUnitIndex = setSamplerUniforms(gl, program, uniforms.samplerUniforms);
}
ShaderProgram.prototype._bind = function () {
    initialize(this);
    this._gl.useProgram(this._program);
};
ShaderProgram.prototype._setUniforms = function (uniformMap, uniformState, validate) {
    var len;
    var i;
    if (defined(uniformMap)) {
        var manualUniforms = this._manualUniforms;
        len = manualUniforms.length;
        for (i = 0; i < len; ++i) {
            var mu = manualUniforms[i];
            mu.value = uniformMap[mu.name]();
        }
    }
    var automaticUniforms = this._automaticUniforms;
    len = automaticUniforms.length;
    for (i = 0; i < len; ++i) {
        var au = automaticUniforms[i];
        au.uniform.value = au.automaticUniform.getValue(uniformState);
    }
    var uniforms = this._uniforms;
    len = uniforms.length;
    for (i = 0; i < len; ++i) {
        uniforms[i]._set();
    }
    if (validate) {
        var gl = this._gl;
        var program = this._program;
        gl.validateProgram(program);
        if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
            throw new DeveloperError('Program validation failed.  Program info log: ' + gl.getProgramInfoLog(program));
        }
    }
};
ShaderProgram.prototype.isDestroyed = function () {
    return false;
};
ShaderProgram.prototype.destroy = function () {
    this._cachedShader.cache.releaseShaderProgram(this);
    return undefined;
};
ShaderProgram.prototype.finalDestroy = function () {
    this._gl.deleteProgram(this._program);
    return destroyObject(this);
};
module.exports = ShaderProgram;
},{"../Core/DeveloperError":123,"../Core/RuntimeError":207,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"./AutomaticUniforms":337,"./Uniform":360,"./UniformArray":361}],355:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), CzmBuiltins = require('../Shaders/Builtin/CzmBuiltins'), AutomaticUniforms = require('./AutomaticUniforms');
'use strict';
function removeComments(source) {
    return source.replace(/\/\*\*[\s\S]*?\*\//gm, function (match) {
        var numberOfLines = match.match(/\n/gm).length;
        var replacement = '';
        for (var lineNumber = 0; lineNumber < numberOfLines; ++lineNumber) {
            replacement += '\n';
        }
        return replacement;
    });
}
function getDependencyNode(name, glslSource, nodes) {
    var dependencyNode;
    for (var i = 0; i < nodes.length; ++i) {
        if (nodes[i].name === name) {
            dependencyNode = nodes[i];
        }
    }
    if (!defined(dependencyNode)) {
        glslSource = removeComments(glslSource);
        dependencyNode = {
            name: name,
            glslSource: glslSource,
            dependsOn: [],
            requiredBy: [],
            evaluated: false
        };
        nodes.push(dependencyNode);
    }
    return dependencyNode;
}
function generateDependencies(currentNode, dependencyNodes) {
    if (currentNode.evaluated) {
        return;
    }
    currentNode.evaluated = true;
    var czmMatches = currentNode.glslSource.match(/\bczm_[a-zA-Z0-9_]*/g);
    if (defined(czmMatches) && czmMatches !== null) {
        czmMatches = czmMatches.filter(function (elem, pos) {
            return czmMatches.indexOf(elem) === pos;
        });
        czmMatches.forEach(function (element) {
            if (element !== currentNode.name && ShaderSource._czmBuiltinsAndUniforms.hasOwnProperty(element)) {
                var referencedNode = getDependencyNode(element, ShaderSource._czmBuiltinsAndUniforms[element], dependencyNodes);
                currentNode.dependsOn.push(referencedNode);
                referencedNode.requiredBy.push(currentNode);
                generateDependencies(referencedNode, dependencyNodes);
            }
        });
    }
}
function sortDependencies(dependencyNodes) {
    var nodesWithoutIncomingEdges = [];
    var allNodes = [];
    while (dependencyNodes.length > 0) {
        var node = dependencyNodes.pop();
        allNodes.push(node);
        if (node.requiredBy.length === 0) {
            nodesWithoutIncomingEdges.push(node);
        }
    }
    while (nodesWithoutIncomingEdges.length > 0) {
        var currentNode = nodesWithoutIncomingEdges.shift();
        dependencyNodes.push(currentNode);
        for (var i = 0; i < currentNode.dependsOn.length; ++i) {
            var referencedNode = currentNode.dependsOn[i];
            var index = referencedNode.requiredBy.indexOf(currentNode);
            referencedNode.requiredBy.splice(index, 1);
            if (referencedNode.requiredBy.length === 0) {
                nodesWithoutIncomingEdges.push(referencedNode);
            }
        }
    }
    var badNodes = [];
    for (var j = 0; j < allNodes.length; ++j) {
        if (allNodes[j].requiredBy.length !== 0) {
            badNodes.push(allNodes[j]);
        }
    }
    if (badNodes.length !== 0) {
        var message = 'A circular dependency was found in the following built-in functions/structs/constants: \n';
        for (j = 0; j < badNodes.length; ++j) {
            message = message + badNodes[j].name + '\n';
        }
        throw new DeveloperError(message);
    }
}
function getBuiltinsAndAutomaticUniforms(shaderSource) {
    var dependencyNodes = [];
    var root = getDependencyNode('main', shaderSource, dependencyNodes);
    generateDependencies(root, dependencyNodes);
    sortDependencies(dependencyNodes);
    var builtinsSource = '';
    for (var i = dependencyNodes.length - 1; i >= 0; --i) {
        builtinsSource = builtinsSource + dependencyNodes[i].glslSource + '\n';
    }
    return builtinsSource.replace(root.glslSource, '');
}
function combineShader(shaderSource, isFragmentShader) {
    var i;
    var length;
    var combinedSources = '';
    var sources = shaderSource.sources;
    if (defined(sources)) {
        for (i = 0, length = sources.length; i < length; ++i) {
            combinedSources += '\n#line 0\n' + sources[i];
        }
    }
    combinedSources = removeComments(combinedSources);
    var version;
    combinedSources = combinedSources.replace(/#version\s+(.*?)\n/gm, function (match, group1) {
        if (defined(version) && version !== group1) {
            throw new DeveloperError('inconsistent versions found: ' + version + ' and ' + group1);
        }
        version = group1;
        return '\n';
    });
    var pickColorQualifier = shaderSource.pickColorQualifier;
    if (defined(pickColorQualifier)) {
        combinedSources = combinedSources.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, 'void czm_old_main()');
        combinedSources += '\n' + pickColorQualifier + ' vec4 czm_pickColor;\nvoid main()\n{\n    czm_old_main();\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n    gl_FragColor = czm_pickColor;\n}';
    }
    var result = '';
    if (defined(version)) {
        result = '#version ' + version;
    }
    if (isFragmentShader) {
        result += '#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\n\n';
    }
    var defines = shaderSource.defines;
    if (defined(defines)) {
        for (i = 0, length = defines.length; i < length; ++i) {
            var define = defines[i];
            if (define.length !== 0) {
                result += '#define ' + define + '\n';
            }
        }
    }
    if (shaderSource.includeBuiltIns) {
        result += getBuiltinsAndAutomaticUniforms(combinedSources);
    }
    result += '\n#line 0\n';
    result += combinedSources;
    return result;
}
var ShaderSource = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var pickColorQualifier = options.pickColorQualifier;
    if (defined(pickColorQualifier) && pickColorQualifier !== 'uniform' && pickColorQualifier !== 'varying') {
        throw new DeveloperError('options.pickColorQualifier must be \'uniform\' or \'varying\'.');
    }
    this.defines = defined(options.defines) ? options.defines.slice(0) : [];
    this.sources = defined(options.sources) ? options.sources.slice(0) : [];
    this.pickColorQualifier = pickColorQualifier;
    this.includeBuiltIns = defaultValue(options.includeBuiltIns, true);
};
ShaderSource.prototype.clone = function () {
    return new ShaderSource({
        sources: this.sources,
        defines: this.defines,
        pickColorQuantifier: this.pickColorQualifier,
        includeBuiltIns: this.includeBuiltIns
    });
};
ShaderSource.prototype.createCombinedVertexShader = function () {
    return combineShader(this, false);
};
ShaderSource.prototype.createCombinedFragmentShader = function () {
    return combineShader(this, true);
};
ShaderSource._czmBuiltinsAndUniforms = {};
for (var builtinName in CzmBuiltins) {
    if (CzmBuiltins.hasOwnProperty(builtinName)) {
        ShaderSource._czmBuiltinsAndUniforms[builtinName] = CzmBuiltins[builtinName];
    }
}
for (var uniformName in AutomaticUniforms) {
    if (AutomaticUniforms.hasOwnProperty(uniformName)) {
        var uniform = AutomaticUniforms[uniformName];
        if (typeof uniform.getDeclaration === 'function') {
            ShaderSource._czmBuiltinsAndUniforms[uniformName] = uniform.getDeclaration(uniformName);
        }
    }
}
module.exports = ShaderSource;
},{"../Core/DeveloperError":123,"../Core/defaultValue":243,"../Core/defined":245,"../Shaders/Builtin/CzmBuiltins":501,"./AutomaticUniforms":337}],356:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), CesiumMath = require('../Core/Math'), PixelFormat = require('../Core/PixelFormat'), MipmapHint = require('./MipmapHint'), PixelDatatype = require('./PixelDatatype'), TextureMagnificationFilter = require('./TextureMagnificationFilter'), TextureMinificationFilter = require('./TextureMinificationFilter'), TextureWrap = require('./TextureWrap');
'use strict';
var Texture = function (context, options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var source = options.source;
    var width = defined(source) ? source.width : options.width;
    var height = defined(source) ? source.height : options.height;
    var pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);
    var pixelDatatype = defaultValue(options.pixelDatatype, PixelDatatype.UNSIGNED_BYTE);
    if (!defined(width) || !defined(height)) {
        throw new DeveloperError('options requires a source field to create an initialized texture or width and height fields to create a blank texture.');
    }
    if (width <= 0) {
        throw new DeveloperError('Width must be greater than zero.');
    }
    if (width > context._maximumTextureSize) {
        throw new DeveloperError('Width must be less than or equal to the maximum texture size (' + context._maximumTextureSize + ').  Check maximumTextureSize.');
    }
    if (height <= 0) {
        throw new DeveloperError('Height must be greater than zero.');
    }
    if (height > context._maximumTextureSize) {
        throw new DeveloperError('Height must be less than or equal to the maximum texture size (' + context._maximumTextureSize + ').  Check maximumTextureSize.');
    }
    if (!PixelFormat.validate(pixelFormat)) {
        throw new DeveloperError('Invalid options.pixelFormat.');
    }
    if (!PixelDatatype.validate(pixelDatatype)) {
        throw new DeveloperError('Invalid options.pixelDatatype.');
    }
    if (pixelFormat === PixelFormat.DEPTH_COMPONENT && (pixelDatatype !== PixelDatatype.UNSIGNED_SHORT && pixelDatatype !== PixelDatatype.UNSIGNED_INT)) {
        throw new DeveloperError('When options.pixelFormat is DEPTH_COMPONENT, options.pixelDatatype must be UNSIGNED_SHORT or UNSIGNED_INT.');
    }
    if (pixelFormat === PixelFormat.DEPTH_STENCIL && pixelDatatype !== PixelDatatype.UNSIGNED_INT_24_8_WEBGL) {
        throw new DeveloperError('When options.pixelFormat is DEPTH_STENCIL, options.pixelDatatype must be UNSIGNED_INT_24_8_WEBGL.');
    }
    if (pixelDatatype === PixelDatatype.FLOAT && !context.floatingPointTexture) {
        throw new DeveloperError('When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.');
    }
    if (PixelFormat.isDepthFormat(pixelFormat)) {
        if (defined(source)) {
            throw new DeveloperError('When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, source cannot be provided.');
        }
        if (!context.depthTexture) {
            throw new DeveloperError('When options.pixelFormat is DEPTH_COMPONENT or DEPTH_STENCIL, this WebGL implementation must support WEBGL_depth_texture.  Check context.depthTexture.');
        }
    }
    var preMultiplyAlpha = options.preMultiplyAlpha || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE;
    var flipY = defaultValue(options.flipY, true);
    var gl = context._gl;
    var textureTarget = gl.TEXTURE_2D;
    var texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(textureTarget, texture);
    if (defined(source)) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        if (defined(source.arrayBufferView)) {
            gl.texImage2D(textureTarget, 0, pixelFormat, width, height, 0, pixelFormat, pixelDatatype, source.arrayBufferView);
        } else if (defined(source.framebuffer)) {
            if (source.framebuffer !== context.defaultFramebuffer) {
                source.framebuffer._bind();
            }
            gl.copyTexImage2D(textureTarget, 0, pixelFormat, source.xOffset, source.yOffset, width, height, 0);
            if (source.framebuffer !== context.defaultFramebuffer) {
                source.framebuffer._unBind();
            }
        } else {
            gl.texImage2D(textureTarget, 0, pixelFormat, pixelFormat, pixelDatatype, source);
        }
    } else {
        gl.texImage2D(textureTarget, 0, pixelFormat, width, height, 0, pixelFormat, pixelDatatype, null);
    }
    gl.bindTexture(textureTarget, null);
    this._context = context;
    this._textureFilterAnisotropic = context._textureFilterAnisotropic;
    this._textureTarget = textureTarget;
    this._texture = texture;
    this._pixelFormat = pixelFormat;
    this._pixelDatatype = pixelDatatype;
    this._width = width;
    this._height = height;
    this._dimensions = new Cartesian2(width, height);
    this._preMultiplyAlpha = preMultiplyAlpha;
    this._flipY = flipY;
    this._sampler = undefined;
    this.sampler = undefined;
};
defineProperties(Texture.prototype, {
    sampler: {
        get: function () {
            return this._sampler;
        },
        set: function (sampler) {
            var samplerDefined = true;
            if (!defined(sampler)) {
                samplerDefined = false;
                var minFilter = TextureMinificationFilter.LINEAR;
                var magFilter = TextureMagnificationFilter.LINEAR;
                if (this._pixelDatatype === PixelDatatype.FLOAT) {
                    minFilter = TextureMinificationFilter.NEAREST;
                    magFilter = TextureMagnificationFilter.NEAREST;
                }
                sampler = {
                    wrapS: TextureWrap.CLAMP_TO_EDGE,
                    wrapT: TextureWrap.CLAMP_TO_EDGE,
                    minificationFilter: minFilter,
                    magnificationFilter: magFilter,
                    maximumAnisotropy: 1
                };
            }
            if (this._pixelDatatype === PixelDatatype.FLOAT) {
                if (sampler.minificationFilter !== TextureMinificationFilter.NEAREST && sampler.minificationFilter !== TextureMinificationFilter.NEAREST_MIPMAP_NEAREST) {
                    throw new DeveloperError('Only NEAREST and NEAREST_MIPMAP_NEAREST minification filters are supported for floating point textures.');
                }
                if (sampler.magnificationFilter !== TextureMagnificationFilter.NEAREST) {
                    throw new DeveloperError('Only the NEAREST magnification filter is supported for floating point textures.');
                }
            }
            var gl = this._context._gl;
            var target = this._textureTarget;
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(target, this._texture);
            gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, sampler.minificationFilter);
            gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, sampler.magnificationFilter);
            gl.texParameteri(target, gl.TEXTURE_WRAP_S, sampler.wrapS);
            gl.texParameteri(target, gl.TEXTURE_WRAP_T, sampler.wrapT);
            if (defined(this._textureFilterAnisotropic)) {
                gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, sampler.maximumAnisotropy);
            }
            gl.bindTexture(target, null);
            this._sampler = !samplerDefined ? undefined : {
                wrapS: sampler.wrapS,
                wrapT: sampler.wrapT,
                minificationFilter: sampler.minificationFilter,
                magnificationFilter: sampler.magnificationFilter,
                maximumAnisotropy: sampler.maximumAnisotropy
            };
        }
    },
    pixelFormat: {
        get: function () {
            return this._pixelFormat;
        }
    },
    pixelDatatype: {
        get: function () {
            return this._pixelDatatype;
        }
    },
    dimensions: {
        get: function () {
            return this._dimensions;
        }
    },
    preMultiplyAlpha: {
        get: function () {
            return this._preMultiplyAlpha;
        }
    },
    flipY: {
        get: function () {
            return this._flipY;
        }
    },
    width: {
        get: function () {
            return this._width;
        }
    },
    height: {
        get: function () {
            return this._height;
        }
    },
    _target: {
        get: function () {
            return this._textureTarget;
        }
    }
});
Texture.prototype.copyFrom = function (source, xOffset, yOffset) {
    xOffset = defaultValue(xOffset, 0);
    yOffset = defaultValue(yOffset, 0);
    if (!defined(source)) {
        throw new DeveloperError('source is required.');
    }
    if (PixelFormat.isDepthFormat(this._pixelFormat)) {
        throw new DeveloperError('Cannot call copyFrom when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.');
    }
    if (xOffset < 0) {
        throw new DeveloperError('xOffset must be greater than or equal to zero.');
    }
    if (yOffset < 0) {
        throw new DeveloperError('yOffset must be greater than or equal to zero.');
    }
    if (xOffset + source.width > this._width) {
        throw new DeveloperError('xOffset + source.width must be less than or equal to width.');
    }
    if (yOffset + source.height > this._height) {
        throw new DeveloperError('yOffset + source.height must be less than or equal to height.');
    }
    var gl = this._context._gl;
    var target = this._textureTarget;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this._flipY);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    if (source.arrayBufferView) {
        gl.texSubImage2D(target, 0, xOffset, yOffset, source.width, source.height, this._pixelFormat, this._pixelDatatype, source.arrayBufferView);
    } else {
        gl.texSubImage2D(target, 0, xOffset, yOffset, this._pixelFormat, this._pixelDatatype, source);
    }
    gl.bindTexture(target, null);
};
Texture.prototype.copyFromFramebuffer = function (xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
    xOffset = defaultValue(xOffset, 0);
    yOffset = defaultValue(yOffset, 0);
    framebufferXOffset = defaultValue(framebufferXOffset, 0);
    framebufferYOffset = defaultValue(framebufferYOffset, 0);
    width = defaultValue(width, this._width);
    height = defaultValue(height, this._height);
    if (PixelFormat.isDepthFormat(this._pixelFormat)) {
        throw new DeveloperError('Cannot call copyFromFramebuffer when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.');
    }
    if (this._pixelDatatype === PixelDatatype.FLOAT) {
        throw new DeveloperError('Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.');
    }
    if (xOffset < 0) {
        throw new DeveloperError('xOffset must be greater than or equal to zero.');
    }
    if (yOffset < 0) {
        throw new DeveloperError('yOffset must be greater than or equal to zero.');
    }
    if (framebufferXOffset < 0) {
        throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
    }
    if (framebufferYOffset < 0) {
        throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
    }
    if (xOffset + width > this._width) {
        throw new DeveloperError('xOffset + width must be less than or equal to width.');
    }
    if (yOffset + height > this._height) {
        throw new DeveloperError('yOffset + height must be less than or equal to height.');
    }
    var gl = this._context._gl;
    var target = this._textureTarget;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.copyTexSubImage2D(target, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
    gl.bindTexture(target, null);
};
Texture.prototype.generateMipmap = function (hint) {
    hint = defaultValue(hint, MipmapHint.DONT_CARE);
    if (PixelFormat.isDepthFormat(this._pixelFormat)) {
        throw new DeveloperError('Cannot call generateMipmap when the texture pixel format is DEPTH_COMPONENT or DEPTH_STENCIL.');
    }
    if (this._width > 1 && !CesiumMath.isPowerOfTwo(this._width)) {
        throw new DeveloperError('width must be a power of two to call generateMipmap().');
    }
    if (this._height > 1 && !CesiumMath.isPowerOfTwo(this._height)) {
        throw new DeveloperError('height must be a power of two to call generateMipmap().');
    }
    if (!MipmapHint.validate(hint)) {
        throw new DeveloperError('hint is invalid.');
    }
    var gl = this._context._gl;
    var target = this._textureTarget;
    gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(target, this._texture);
    gl.generateMipmap(target);
    gl.bindTexture(target, null);
};
Texture.prototype.isDestroyed = function () {
    return false;
};
Texture.prototype.destroy = function () {
    this._context._gl.deleteTexture(this._texture);
    return destroyObject(this);
};
module.exports = Texture;
},{"../Core/Cartesian2":101,"../Core/DeveloperError":123,"../Core/Math":174,"../Core/PixelFormat":181,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"./MipmapHint":346,"./PixelDatatype":349,"./TextureMagnificationFilter":357,"./TextureMinificationFilter":358,"./TextureWrap":359}],357:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var TextureMagnificationFilter = {
        NEAREST: 9728,
        LINEAR: 9729,
        validate: function (textureMagnificationFilter) {
            return textureMagnificationFilter === TextureMagnificationFilter.NEAREST || textureMagnificationFilter === TextureMagnificationFilter.LINEAR;
        }
    };
module.exports = freezeObject(TextureMagnificationFilter);
},{"../Core/freezeObject":249}],358:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var TextureMinificationFilter = {
        NEAREST: 9728,
        LINEAR: 9729,
        NEAREST_MIPMAP_NEAREST: 9984,
        LINEAR_MIPMAP_NEAREST: 9985,
        NEAREST_MIPMAP_LINEAR: 9986,
        LINEAR_MIPMAP_LINEAR: 9987,
        validate: function (textureMinificationFilter) {
            return textureMinificationFilter === TextureMinificationFilter.NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;
        }
    };
module.exports = freezeObject(TextureMinificationFilter);
},{"../Core/freezeObject":249}],359:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var TextureWrap = {
        CLAMP_TO_EDGE: 33071,
        REPEAT: 10497,
        MIRRORED_REPEAT: 33648,
        validate: function (textureWrap) {
            return textureWrap === TextureWrap.CLAMP_TO_EDGE || textureWrap === TextureWrap.REPEAT || textureWrap === TextureWrap.MIRRORED_REPEAT;
        }
    };
module.exports = freezeObject(TextureWrap);
},{"../Core/freezeObject":249}],360:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), FeatureDetection = require('../Core/FeatureDetection'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Color = require('../Core/Color'), Matrix2 = require('../Core/Matrix2'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), RuntimeError = require('../Core/RuntimeError');
'use strict';
var scratchUniformMatrix2;
var scratchUniformMatrix3;
var scratchUniformMatrix4;
if (FeatureDetection.supportsTypedArrays()) {
    scratchUniformMatrix2 = new Float32Array(4);
    scratchUniformMatrix3 = new Float32Array(9);
    scratchUniformMatrix4 = new Float32Array(16);
}
var Uniform = function (gl, activeUniform, uniformName, location) {
    this.value = undefined;
    this._value = undefined;
    this._gl = gl;
    this._activeUniform = activeUniform;
    this._uniformName = uniformName;
    this._location = location;
    this.textureUnitIndex = undefined;
    var set;
    switch (activeUniform.type) {
    case gl.FLOAT:
        set = this.setFloat;
        break;
    case gl.FLOAT_VEC2:
        set = this.setFloatVec2;
        break;
    case gl.FLOAT_VEC3:
        set = this.setFloatVec3;
        break;
    case gl.FLOAT_VEC4:
        set = this.setFloatVec4;
        break;
    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
        set = this.setSampler;
        break;
    case gl.INT:
    case gl.BOOL:
        set = this.setInt;
        break;
    case gl.INT_VEC2:
    case gl.BOOL_VEC2:
        set = this.setIntVec2;
        break;
    case gl.INT_VEC3:
    case gl.BOOL_VEC3:
        set = this.setIntVec3;
        break;
    case gl.INT_VEC4:
    case gl.BOOL_VEC4:
        set = this.setIntVec4;
        break;
    case gl.FLOAT_MAT2:
        set = this.setMat2;
        break;
    case gl.FLOAT_MAT3:
        set = this.setMat3;
        break;
    case gl.FLOAT_MAT4:
        set = this.setMat4;
        break;
    default:
        throw new RuntimeError('Unrecognized uniform type: ' + activeUniform.type + ' for uniform "' + uniformName + '".');
    }
    this._set = set;
    if (activeUniform.type === gl.SAMPLER_2D || activeUniform.type === gl.SAMPLER_CUBE) {
        this._setSampler = function (textureUnitIndex) {
            this.textureUnitIndex = textureUnitIndex;
            gl.uniform1i(location, textureUnitIndex);
            return textureUnitIndex + 1;
        };
    }
};
defineProperties(Uniform.prototype, {
    name: {
        get: function () {
            return this._uniformName;
        }
    },
    datatype: {
        get: function () {
            return this._activeUniform.type;
        }
    }
});
Uniform.prototype.setFloat = function () {
    if (this.value !== this._value) {
        this._value = this.value;
        this._gl.uniform1f(this._location, this.value);
    }
};
Uniform.prototype.setFloatVec2 = function () {
    var v = this.value;
    if (!Cartesian2.equals(v, this._value)) {
        this._value = Cartesian2.clone(v, this._value);
        this._gl.uniform2f(this._location, v.x, v.y);
    }
};
Uniform.prototype.setFloatVec3 = function () {
    var v = this.value;
    if (defined(v.red)) {
        if (!Color.equals(v, this._value)) {
            this._value = Color.clone(v, this._value);
            this._gl.uniform3f(this._location, v.red, v.green, v.blue);
        }
    } else if (defined(v.x)) {
        if (!Cartesian3.equals(v, this._value)) {
            this._value = Cartesian3.clone(v, this._value);
            this._gl.uniform3f(this._location, v.x, v.y, v.z);
        }
    } else {
        throw new DeveloperError('Invalid vec3 value for uniform "' + this._activethis.name + '".');
    }
};
Uniform.prototype.setFloatVec4 = function () {
    var v = this.value;
    if (defined(v.red)) {
        if (!Color.equals(v, this._value)) {
            this._value = Color.clone(v, this._value);
            this._gl.uniform4f(this._location, v.red, v.green, v.blue, v.alpha);
        }
    } else if (defined(v.x)) {
        if (!Cartesian4.equals(v, this._value)) {
            this._value = Cartesian4.clone(v, this._value);
            this._gl.uniform4f(this._location, v.x, v.y, v.z, v.w);
        }
    } else {
        throw new DeveloperError('Invalid vec4 value for uniform "' + this._activethis.name + '".');
    }
};
Uniform.prototype.setSampler = function () {
    var gl = this._gl;
    gl.activeTexture(gl.TEXTURE0 + this.textureUnitIndex);
    gl.bindTexture(this.value._target, this.value._texture);
};
Uniform.prototype.setInt = function () {
    if (this.value !== this._value) {
        this._value = this.value;
        this._gl.uniform1i(this._location, this.value);
    }
};
Uniform.prototype.setIntVec2 = function () {
    var v = this.value;
    if (!Cartesian2.equals(v, this._value)) {
        this._value = Cartesian2.clone(v, this._value);
        this._gl.uniform2i(this._location, v.x, v.y);
    }
};
Uniform.prototype.setIntVec3 = function () {
    var v = this.value;
    if (!Cartesian3.equals(v, this._value)) {
        this._value = Cartesian3.clone(v, this._value);
        this._gl.uniform3i(this._location, v.x, v.y, v.z);
    }
};
Uniform.prototype.setIntVec4 = function () {
    var v = this.value;
    if (!Cartesian4.equals(v, this._value)) {
        this._value = Cartesian4.clone(v, this._value);
        this._gl.uniform4i(this._location, v.x, v.y, v.z, v.w);
    }
};
Uniform.prototype.setMat2 = function () {
    var v = this.value;
    if (!Matrix2.equals(v, this._value)) {
        this._value = Matrix2.clone(v, this._value);
        this._gl.uniformMatrix2fv(this._location, false, Matrix2.toArray(this.value, scratchUniformMatrix2));
    }
};
Uniform.prototype.setMat3 = function () {
    var v = this.value;
    if (!Matrix3.equals(v, this._value)) {
        this._value = Matrix3.clone(v, this._value);
        this._gl.uniformMatrix3fv(this._location, false, Matrix3.toArray(this.value, scratchUniformMatrix3));
    }
};
Uniform.prototype.setMat4 = function () {
    var v = this.value;
    if (!Matrix4.equals(v, this._value)) {
        this._value = Matrix4.clone(v, this._value);
        this._gl.uniformMatrix4fv(this._location, false, Matrix4.toArray(this.value, scratchUniformMatrix4));
    }
};
module.exports = Uniform;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/FeatureDetection":141,"../Core/Matrix2":175,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/RuntimeError":207,"../Core/defineProperties":244,"../Core/defined":245}],361:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), FeatureDetection = require('../Core/FeatureDetection'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Color = require('../Core/Color'), Matrix2 = require('../Core/Matrix2'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), RuntimeError = require('../Core/RuntimeError');
'use strict';
var scratchUniformMatrix2;
var scratchUniformMatrix3;
var scratchUniformMatrix4;
if (FeatureDetection.supportsTypedArrays()) {
    scratchUniformMatrix2 = new Float32Array(4);
    scratchUniformMatrix3 = new Float32Array(9);
    scratchUniformMatrix4 = new Float32Array(16);
}
var UniformArray = function (gl, activeUniform, uniformName, locations) {
    this._gl = gl;
    this._activeUniform = activeUniform;
    this._uniformName = uniformName;
    this.value = new Array(locations.length);
    this._value = new Array(locations.length);
    this._locations = locations;
    this.textureUnitIndex = undefined;
    var set;
    switch (activeUniform.type) {
    case gl.FLOAT:
        set = this.setFloat;
        break;
    case gl.FLOAT_VEC2:
        set = this.setFloatVec2;
        break;
    case gl.FLOAT_VEC3:
        set = this.setFloatVec3;
        break;
    case gl.FLOAT_VEC4:
        set = this.setFloatVec4;
        break;
    case gl.SAMPLER_2D:
    case gl.SAMPLER_CUBE:
        set = this.setSampler;
        break;
    case gl.INT:
    case gl.BOOL:
        set = this.setInt;
        break;
    case gl.INT_VEC2:
    case gl.BOOL_VEC2:
        set = this.setIntVec2;
        break;
    case gl.INT_VEC3:
    case gl.BOOL_VEC3:
        set = this.setIntVec3;
        break;
    case gl.INT_VEC4:
    case gl.BOOL_VEC4:
        set = this.setIntVec4;
        break;
    case gl.FLOAT_MAT2:
        set = this.setMat2;
        break;
    case gl.FLOAT_MAT3:
        set = this.setMat3;
        break;
    case gl.FLOAT_MAT4:
        set = this.setMat4;
        break;
    default:
        throw new RuntimeError('Unrecognized uniform type: ' + activeUniform.type + ' for uniform "' + uniformName + '".');
    }
    this._set = set;
    if (activeUniform.type === gl.SAMPLER_2D || activeUniform.type === gl.SAMPLER_CUBE) {
        this._setSampler = function (textureUnitIndex) {
            this.textureUnitIndex = textureUnitIndex;
            var length = locations.length;
            for (var i = 0; i < length; ++i) {
                var index = textureUnitIndex + i;
                gl.uniform1i(locations[i], index);
            }
            return textureUnitIndex + length;
        };
    }
};
defineProperties(UniformArray.prototype, {
    name: {
        get: function () {
            return this._uniformName;
        }
    },
    datatype: {
        get: function () {
            return this._activeUniform.type;
        }
    }
});
UniformArray.prototype.setFloat = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (v !== _value[i]) {
            _value[i] = v;
            gl.uniform1f(locations[i], v);
        }
    }
};
UniformArray.prototype.setFloatVec2 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (!Cartesian2.equals(v, _value[i])) {
            _value[i] = Cartesian2.clone(v, _value[i]);
            gl.uniform2f(locations[i], v.x, v.y);
        }
    }
};
UniformArray.prototype.setFloatVec3 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (defined(v.red)) {
            if (!Color.equals(v, _value[i])) {
                _value[i] = Color.clone(v, _value[i]);
                gl.uniform3f(locations[i], v.red, v.green, v.blue);
            }
        } else if (defined(v.x)) {
            if (!Cartesian3.equals(v, _value[i])) {
                _value[i] = Cartesian3.clone(v, _value[i]);
                gl.uniform3f(locations[i], v.x, v.y, v.z);
            }
        } else {
            throw new DeveloperError('Invalid vec3 value.');
        }
    }
};
UniformArray.prototype.setFloatVec4 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (defined(v.red)) {
            if (!Color.equals(v, _value[i])) {
                _value[i] = Color.clone(v, _value[i]);
                gl.uniform4f(locations[i], v.red, v.green, v.blue, v.alpha);
            }
        } else if (defined(v.x)) {
            if (!Cartesian4.equals(v, _value[i])) {
                _value[i] = Cartesian4.clone(v, _value[i]);
                gl.uniform4f(locations[i], v.x, v.y, v.z, v.w);
            }
        } else {
            throw new DeveloperError('Invalid vec4 value.');
        }
    }
};
UniformArray.prototype.setSampler = function () {
    var gl = this._gl;
    var locations = this._locations;
    var textureUnitIndex = gl.TEXTURE0 + this.textureUnitIndex;
    var value = this.value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        gl.activeTexture(textureUnitIndex + i);
        gl.bindTexture(v._target, v._texture);
    }
};
UniformArray.prototype.setInt = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (v !== _value[i]) {
            _value[i] = v;
            gl.uniform1i(locations[i], v);
        }
    }
};
UniformArray.prototype.setIntVec2 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (!Cartesian2.equals(v, _value[i])) {
            _value[i] = Cartesian2.clone(v, _value[i]);
            gl.uniform2i(locations[i], v.x, v.y);
        }
    }
};
UniformArray.prototype.setIntVec3 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (!Cartesian3.equals(v, _value[i])) {
            _value[i] = Cartesian3.clone(v, _value[i]);
            gl.uniform3i(locations[i], v.x, v.y, v.z);
        }
    }
};
UniformArray.prototype.setIntVec4 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (!Cartesian4.equals(v, _value[i])) {
            _value[i] = Cartesian4.clone(v, _value[i]);
            gl.uniform4i(locations[i], v.x, v.y, v.z, v.w);
        }
    }
};
UniformArray.prototype.setMat2 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (!Matrix2.equals(v, _value[i])) {
            _value[i] = Matrix2.clone(v, _value[i]);
            gl.uniformMatrix2fv(locations[i], false, Matrix2.toArray(v, scratchUniformMatrix2));
        }
    }
};
UniformArray.prototype.setMat3 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (!Matrix3.equals(v, _value[i])) {
            _value[i] = Matrix3.clone(v, _value[i]);
            gl.uniformMatrix3fv(locations[i], false, Matrix3.toArray(value[i], scratchUniformMatrix3));
        }
    }
};
UniformArray.prototype.setMat4 = function () {
    var gl = this._gl;
    var locations = this._locations;
    var value = this.value;
    var _value = this._value;
    var length = value.length;
    for (var i = 0; i < length; ++i) {
        var v = value[i];
        if (!Matrix4.equals(v, _value[i])) {
            _value[i] = Matrix4.clone(v, _value[i]);
            gl.uniformMatrix4fv(locations[i], false, Matrix4.toArray(value[i], scratchUniformMatrix4));
        }
    }
};
module.exports = UniformArray;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/FeatureDetection":141,"../Core/Matrix2":175,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/RuntimeError":207,"../Core/defineProperties":244,"../Core/defined":245}],362:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Cartographic = require('../Core/Cartographic'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), EncodedCartesian3 = require('../Core/EncodedCartesian3'), CesiumMath = require('../Core/Math'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), Simon1994PlanetaryPositions = require('../Core/Simon1994PlanetaryPositions'), Transforms = require('../Core/Transforms'), SceneMode = require('../Scene/SceneMode');
'use strict';
var UniformState = function () {
    this._viewport = new BoundingRectangle();
    this._viewportCartesian4 = new Cartesian4();
    this._viewportDirty = false;
    this._viewportOrthographicMatrix = Matrix4.clone(Matrix4.IDENTITY);
    this._viewportTransformation = Matrix4.clone(Matrix4.IDENTITY);
    this._model = Matrix4.clone(Matrix4.IDENTITY);
    this._view = Matrix4.clone(Matrix4.IDENTITY);
    this._inverseView = Matrix4.clone(Matrix4.IDENTITY);
    this._projection = Matrix4.clone(Matrix4.IDENTITY);
    this._infiniteProjection = Matrix4.clone(Matrix4.IDENTITY);
    this._entireFrustum = new Cartesian2();
    this._currentFrustum = new Cartesian2();
    this._frameState = undefined;
    this._temeToPseudoFixed = Matrix3.clone(Matrix4.IDENTITY);
    this._view3DDirty = true;
    this._view3D = new Matrix4();
    this._inverseView3DDirty = true;
    this._inverseView3D = new Matrix4();
    this._inverseModelDirty = true;
    this._inverseModel = new Matrix4();
    this._inverseTransposeModelDirty = true;
    this._inverseTransposeModel = new Matrix3();
    this._viewRotation = new Matrix3();
    this._inverseViewRotation = new Matrix3();
    this._viewRotation3D = new Matrix3();
    this._inverseViewRotation3D = new Matrix3();
    this._inverseProjectionDirty = true;
    this._inverseProjection = new Matrix4();
    this._inverseProjectionOITDirty = true;
    this._inverseProjectionOIT = new Matrix4();
    this._modelViewDirty = true;
    this._modelView = new Matrix4();
    this._modelView3DDirty = true;
    this._modelView3D = new Matrix4();
    this._modelViewRelativeToEyeDirty = true;
    this._modelViewRelativeToEye = new Matrix4();
    this._inverseModelViewDirty = true;
    this._inverseModelView = new Matrix4();
    this._inverseModelView3DDirty = true;
    this._inverseModelView3D = new Matrix4();
    this._viewProjectionDirty = true;
    this._viewProjection = new Matrix4();
    this._inverseViewProjectionDirty = true;
    this._inverseViewProjection = new Matrix4();
    this._modelViewProjectionDirty = true;
    this._modelViewProjection = new Matrix4();
    this._inverseModelViewProjectionDirty = true;
    this._inverseModelViewProjection = new Matrix4();
    this._modelViewProjectionRelativeToEyeDirty = true;
    this._modelViewProjectionRelativeToEye = new Matrix4();
    this._modelViewInfiniteProjectionDirty = true;
    this._modelViewInfiniteProjection = new Matrix4();
    this._normalDirty = true;
    this._normal = new Matrix3();
    this._normal3DDirty = true;
    this._normal3D = new Matrix3();
    this._inverseNormalDirty = true;
    this._inverseNormal = new Matrix3();
    this._inverseNormal3DDirty = true;
    this._inverseNormal3D = new Matrix3();
    this._encodedCameraPositionMCDirty = true;
    this._encodedCameraPositionMC = new EncodedCartesian3();
    this._cameraPosition = new Cartesian3();
    this._sunPositionWC = new Cartesian3();
    this._sunPositionColumbusView = new Cartesian3();
    this._sunDirectionWC = new Cartesian3();
    this._sunDirectionEC = new Cartesian3();
    this._moonDirectionEC = new Cartesian3();
    this._mode = undefined;
    this._mapProjection = undefined;
    this._cameraDirection = new Cartesian3();
    this._cameraRight = new Cartesian3();
    this._cameraUp = new Cartesian3();
    this._frustum2DWidth = 0;
    this._eyeHeight2D = new Cartesian2();
    this._resolutionScale = 1;
};
defineProperties(UniformState.prototype, {
    frameState: {
        get: function () {
            return this._frameState;
        }
    },
    viewport: {
        get: function () {
            return this._viewport;
        },
        set: function (viewport) {
            if (!BoundingRectangle.equals(viewport, this._viewport)) {
                BoundingRectangle.clone(viewport, this._viewport);
                var v = this._viewport;
                var vc = this._viewportCartesian4;
                vc.x = v.x;
                vc.y = v.y;
                vc.z = v.width;
                vc.w = v.height;
                this._viewportDirty = true;
            }
        }
    },
    viewportCartesian4: {
        get: function () {
            return this._viewportCartesian4;
        }
    },
    viewportOrthographic: {
        get: function () {
            cleanViewport(this);
            return this._viewportOrthographicMatrix;
        }
    },
    viewportTransformation: {
        get: function () {
            cleanViewport(this);
            return this._viewportTransformation;
        }
    },
    model: {
        get: function () {
            return this._model;
        },
        set: function (matrix) {
            Matrix4.clone(matrix, this._model);
            this._modelView3DDirty = true;
            this._inverseModelView3DDirty = true;
            this._inverseModelDirty = true;
            this._inverseTransposeModelDirty = true;
            this._modelViewDirty = true;
            this._inverseModelViewDirty = true;
            this._viewProjectionDirty = true;
            this._inverseViewProjectionDirty = true;
            this._modelViewRelativeToEyeDirty = true;
            this._inverseModelViewDirty = true;
            this._modelViewProjectionDirty = true;
            this._inverseModelViewProjectionDirty = true;
            this._modelViewProjectionRelativeToEyeDirty = true;
            this._modelViewInfiniteProjectionDirty = true;
            this._normalDirty = true;
            this._inverseNormalDirty = true;
            this._normal3DDirty = true;
            this._inverseNormal3DDirty = true;
            this._encodedCameraPositionMCDirty = true;
        }
    },
    inverseModel: {
        get: function () {
            if (this._inverseModelDirty) {
                this._inverseModelDirty = false;
                Matrix4.inverse(this._model, this._inverseModel);
            }
            return this._inverseModel;
        }
    },
    inverseTranposeModel: {
        get: function () {
            var m = this._inverseTransposeModel;
            if (this._inverseTransposeModelDirty) {
                this._inverseTransposeModelDirty = false;
                Matrix4.getRotation(this.inverseModel, m);
                Matrix3.transpose(m, m);
            }
            return m;
        }
    },
    view: {
        get: function () {
            return this._view;
        }
    },
    view3D: {
        get: function () {
            if (this._view3DDirty) {
                if (this._mode === SceneMode.SCENE3D) {
                    Matrix4.clone(this._view, this._view3D);
                } else {
                    view2Dto3D(this._cameraPosition, this._cameraDirection, this._cameraRight, this._cameraUp, this._frustum2DWidth, this._mode, this._mapProjection, this._view3D);
                }
                Matrix4.getRotation(this._view3D, this._viewRotation3D);
                this._view3DDirty = false;
            }
            return this._view3D;
        }
    },
    viewRotation: {
        get: function () {
            return this._viewRotation;
        }
    },
    viewRotation3D: {
        get: function () {
            var view3D = this.view3D;
            return this._viewRotation3D;
        }
    },
    inverseView: {
        get: function () {
            return this._inverseView;
        }
    },
    inverseView3D: {
        get: function () {
            if (this._inverseView3DDirty) {
                Matrix4.inverseTransformation(this.view3D, this._inverseView3D);
                Matrix4.getRotation(this._inverseView3D, this._inverseViewRotation3D);
                this._inverseView3DDirty = false;
            }
            return this._inverseView3D;
        }
    },
    inverseViewRotation: {
        get: function () {
            return this._inverseViewRotation;
        }
    },
    inverseViewRotation3D: {
        get: function () {
            var inverseView = this.inverseView3D;
            return this._inverseViewRotation3D;
        }
    },
    projection: {
        get: function () {
            return this._projection;
        }
    },
    inverseProjection: {
        get: function () {
            cleanInverseProjection(this);
            return this._inverseProjection;
        }
    },
    inverseProjectionOIT: {
        get: function () {
            cleanInverseProjectionOIT(this);
            return this._inverseProjectionOIT;
        }
    },
    infiniteProjection: {
        get: function () {
            return this._infiniteProjection;
        }
    },
    modelView: {
        get: function () {
            cleanModelView(this);
            return this._modelView;
        }
    },
    modelView3D: {
        get: function () {
            cleanModelView3D(this);
            return this._modelView3D;
        }
    },
    modelViewRelativeToEye: {
        get: function () {
            cleanModelViewRelativeToEye(this);
            return this._modelViewRelativeToEye;
        }
    },
    inverseModelView: {
        get: function () {
            cleanInverseModelView(this);
            return this._inverseModelView;
        }
    },
    inverseModelView3D: {
        get: function () {
            cleanInverseModelView3D(this);
            return this._inverseModelView3D;
        }
    },
    viewProjection: {
        get: function () {
            cleanViewProjection(this);
            return this._viewProjection;
        }
    },
    inverseViewProjection: {
        get: function () {
            cleanInverseViewProjection(this);
            return this._inverseViewProjection;
        }
    },
    modelViewProjection: {
        get: function () {
            cleanModelViewProjection(this);
            return this._modelViewProjection;
        }
    },
    inverseModelViewProjection: {
        get: function () {
            cleanInverseModelViewProjection(this);
            return this._inverseModelViewProjection;
        }
    },
    modelViewProjectionRelativeToEye: {
        get: function () {
            cleanModelViewProjectionRelativeToEye(this);
            return this._modelViewProjectionRelativeToEye;
        }
    },
    modelViewInfiniteProjection: {
        get: function () {
            cleanModelViewInfiniteProjection(this);
            return this._modelViewInfiniteProjection;
        }
    },
    normal: {
        get: function () {
            cleanNormal(this);
            return this._normal;
        }
    },
    normal3D: {
        get: function () {
            cleanNormal3D(this);
            return this._normal3D;
        }
    },
    inverseNormal: {
        get: function () {
            cleanInverseNormal(this);
            return this._inverseNormal;
        }
    },
    inverseNormal3D: {
        get: function () {
            cleanInverseNormal3D(this);
            return this._inverseNormal3D;
        }
    },
    entireFrustum: {
        get: function () {
            return this._entireFrustum;
        }
    },
    currentFrustum: {
        get: function () {
            return this._currentFrustum;
        }
    },
    eyeHeight2D: {
        get: function () {
            return this._eyeHeight2D;
        }
    },
    sunPositionWC: {
        get: function () {
            return this._sunPositionWC;
        }
    },
    sunPositionColumbusView: {
        get: function () {
            return this._sunPositionColumbusView;
        }
    },
    sunDirectionWC: {
        get: function () {
            return this._sunDirectionWC;
        }
    },
    sunDirectionEC: {
        get: function () {
            return this._sunDirectionEC;
        }
    },
    moonDirectionEC: {
        get: function () {
            return this._moonDirectionEC;
        }
    },
    encodedCameraPositionMCHigh: {
        get: function () {
            cleanEncodedCameraPositionMC(this);
            return this._encodedCameraPositionMC.high;
        }
    },
    encodedCameraPositionMCLow: {
        get: function () {
            cleanEncodedCameraPositionMC(this);
            return this._encodedCameraPositionMC.low;
        }
    },
    temeToPseudoFixedMatrix: {
        get: function () {
            return this._temeToPseudoFixed;
        }
    },
    resolutionScale: {
        get: function () {
            return this._resolutionScale;
        }
    }
});
function setView(uniformState, matrix) {
    Matrix4.clone(matrix, uniformState._view);
    Matrix4.getRotation(matrix, uniformState._viewRotation);
    uniformState._view3DDirty = true;
    uniformState._inverseView3DDirty = true;
    uniformState._modelViewDirty = true;
    uniformState._modelView3DDirty = true;
    uniformState._modelViewRelativeToEyeDirty = true;
    uniformState._inverseModelViewDirty = true;
    uniformState._inverseModelView3DDirty = true;
    uniformState._viewProjectionDirty = true;
    uniformState._modelViewProjectionDirty = true;
    uniformState._modelViewProjectionRelativeToEyeDirty = true;
    uniformState._modelViewInfiniteProjectionDirty = true;
    uniformState._normalDirty = true;
    uniformState._inverseNormalDirty = true;
    uniformState._normal3DDirty = true;
    uniformState._inverseNormal3DDirty = true;
}
function setInverseView(uniformState, matrix) {
    Matrix4.clone(matrix, uniformState._inverseView);
    Matrix4.getRotation(matrix, uniformState._inverseViewRotation);
}
function setProjection(uniformState, matrix) {
    Matrix4.clone(matrix, uniformState._projection);
    uniformState._inverseProjectionDirty = true;
    uniformState._inverseProjectionOITDirty = true;
    uniformState._viewProjectionDirty = true;
    uniformState._modelViewProjectionDirty = true;
    uniformState._modelViewProjectionRelativeToEyeDirty = true;
}
function setInfiniteProjection(uniformState, matrix) {
    Matrix4.clone(matrix, uniformState._infiniteProjection);
    uniformState._modelViewInfiniteProjectionDirty = true;
}
function setCamera(uniformState, camera) {
    Cartesian3.clone(camera.positionWC, uniformState._cameraPosition);
    Cartesian3.clone(camera.directionWC, uniformState._cameraDirection);
    Cartesian3.clone(camera.rightWC, uniformState._cameraRight);
    Cartesian3.clone(camera.upWC, uniformState._cameraUp);
    uniformState._encodedCameraPositionMCDirty = true;
}
var transformMatrix = new Matrix3();
var sunCartographicScratch = new Cartographic();
function setSunAndMoonDirections(uniformState, frameState) {
    if (!defined(Transforms.computeIcrfToFixedMatrix(frameState.time, transformMatrix))) {
        transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(frameState.time, transformMatrix);
    }
    var position = Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(frameState.time, uniformState._sunPositionWC);
    Matrix3.multiplyByVector(transformMatrix, position, position);
    Cartesian3.normalize(position, uniformState._sunDirectionWC);
    position = Matrix3.multiplyByVector(uniformState.viewRotation3D, position, uniformState._sunDirectionEC);
    Cartesian3.normalize(position, position);
    position = Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(frameState.time, uniformState._moonDirectionEC);
    Matrix3.multiplyByVector(transformMatrix, position, position);
    Matrix3.multiplyByVector(uniformState.viewRotation3D, position, position);
    Cartesian3.normalize(position, position);
    var projection = frameState.mapProjection;
    var ellipsoid = projection.ellipsoid;
    var sunCartographic = ellipsoid.cartesianToCartographic(uniformState._sunPositionWC, sunCartographicScratch);
    projection.project(sunCartographic, uniformState._sunPositionColumbusView);
}
UniformState.prototype.updateFrustum = function (frustum) {
    setProjection(this, frustum.projectionMatrix);
    if (defined(frustum.infiniteProjectionMatrix)) {
        setInfiniteProjection(this, frustum.infiniteProjectionMatrix);
    }
    this._currentFrustum.x = frustum.near;
    this._currentFrustum.y = frustum.far;
};
UniformState.prototype.update = function (context, frameState) {
    this._mode = frameState.mode;
    this._mapProjection = frameState.mapProjection;
    var canvas = context._canvas;
    this._resolutionScale = canvas.width / canvas.clientWidth;
    var camera = frameState.camera;
    setView(this, camera.viewMatrix);
    setInverseView(this, camera.inverseViewMatrix);
    setCamera(this, camera);
    if (frameState.mode === SceneMode.SCENE2D) {
        this._frustum2DWidth = camera.frustum.right - camera.frustum.left;
        this._eyeHeight2D.x = this._frustum2DWidth * 0.5;
        this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x;
    } else {
        this._frustum2DWidth = 0;
        this._eyeHeight2D.x = 0;
        this._eyeHeight2D.y = 0;
    }
    setSunAndMoonDirections(this, frameState);
    this._entireFrustum.x = camera.frustum.near;
    this._entireFrustum.y = camera.frustum.far;
    this.updateFrustum(camera.frustum);
    this._frameState = frameState;
    this._temeToPseudoFixed = Transforms.computeTemeToPseudoFixedMatrix(frameState.time, this._temeToPseudoFixed);
};
function cleanViewport(uniformState) {
    if (uniformState._viewportDirty) {
        var v = uniformState._viewport;
        Matrix4.computeOrthographicOffCenter(v.x, v.x + v.width, v.y, v.y + v.height, 0, 1, uniformState._viewportOrthographicMatrix);
        Matrix4.computeViewportTransformation(v, 0, 1, uniformState._viewportTransformation);
        uniformState._viewportDirty = false;
    }
}
function cleanInverseProjection(uniformState) {
    if (uniformState._inverseProjectionDirty) {
        uniformState._inverseProjectionDirty = false;
        Matrix4.inverse(uniformState._projection, uniformState._inverseProjection);
    }
}
function cleanInverseProjectionOIT(uniformState) {
    if (uniformState._inverseProjectionOITDirty) {
        uniformState._inverseProjectionOITDirty = false;
        if (uniformState._mode !== SceneMode.SCENE2D && uniformState._mode !== SceneMode.MORPHING) {
            Matrix4.inverse(uniformState._projection, uniformState._inverseProjectionOIT);
        } else {
            Matrix4.clone(Matrix4.IDENTITY, uniformState._inverseProjectionOIT);
        }
    }
}
function cleanModelView(uniformState) {
    if (uniformState._modelViewDirty) {
        uniformState._modelViewDirty = false;
        Matrix4.multiplyTransformation(uniformState._view, uniformState._model, uniformState._modelView);
    }
}
function cleanModelView3D(uniformState) {
    if (uniformState._modelView3DDirty) {
        uniformState._modelView3DDirty = false;
        Matrix4.multiplyTransformation(uniformState.view3D, uniformState._model, uniformState._modelView3D);
    }
}
function cleanInverseModelView(uniformState) {
    if (uniformState._inverseModelViewDirty) {
        uniformState._inverseModelViewDirty = false;
        Matrix4.inverse(uniformState.modelView, uniformState._inverseModelView);
    }
}
function cleanInverseModelView3D(uniformState) {
    if (uniformState._inverseModelView3DDirty) {
        uniformState._inverseModelView3DDirty = false;
        Matrix4.inverse(uniformState.modelView3D, uniformState._inverseModelView3D);
    }
}
function cleanViewProjection(uniformState) {
    if (uniformState._viewProjectionDirty) {
        uniformState._viewProjectionDirty = false;
        Matrix4.multiply(uniformState._projection, uniformState._view, uniformState._viewProjection);
    }
}
function cleanInverseViewProjection(uniformState) {
    if (uniformState._inverseViewProjectionDirty) {
        uniformState._inverseViewProjectionDirty = false;
        Matrix4.inverse(uniformState.viewProjection, uniformState._inverseViewProjection);
    }
}
function cleanModelViewProjection(uniformState) {
    if (uniformState._modelViewProjectionDirty) {
        uniformState._modelViewProjectionDirty = false;
        Matrix4.multiply(uniformState._projection, uniformState.modelView, uniformState._modelViewProjection);
    }
}
function cleanModelViewRelativeToEye(uniformState) {
    if (uniformState._modelViewRelativeToEyeDirty) {
        uniformState._modelViewRelativeToEyeDirty = false;
        var mv = uniformState.modelView;
        var mvRte = uniformState._modelViewRelativeToEye;
        mvRte[0] = mv[0];
        mvRte[1] = mv[1];
        mvRte[2] = mv[2];
        mvRte[3] = mv[3];
        mvRte[4] = mv[4];
        mvRte[5] = mv[5];
        mvRte[6] = mv[6];
        mvRte[7] = mv[7];
        mvRte[8] = mv[8];
        mvRte[9] = mv[9];
        mvRte[10] = mv[10];
        mvRte[11] = mv[11];
        mvRte[12] = 0;
        mvRte[13] = 0;
        mvRte[14] = 0;
        mvRte[15] = mv[15];
    }
}
function cleanInverseModelViewProjection(uniformState) {
    if (uniformState._inverseModelViewProjectionDirty) {
        uniformState._inverseModelViewProjectionDirty = false;
        Matrix4.inverse(uniformState.modelViewProjection, uniformState._inverseModelViewProjection);
    }
}
function cleanModelViewProjectionRelativeToEye(uniformState) {
    if (uniformState._modelViewProjectionRelativeToEyeDirty) {
        uniformState._modelViewProjectionRelativeToEyeDirty = false;
        Matrix4.multiply(uniformState._projection, uniformState.modelViewRelativeToEye, uniformState._modelViewProjectionRelativeToEye);
    }
}
function cleanModelViewInfiniteProjection(uniformState) {
    if (uniformState._modelViewInfiniteProjectionDirty) {
        uniformState._modelViewInfiniteProjectionDirty = false;
        Matrix4.multiply(uniformState._infiniteProjection, uniformState.modelView, uniformState._modelViewInfiniteProjection);
    }
}
function cleanNormal(uniformState) {
    if (uniformState._normalDirty) {
        uniformState._normalDirty = false;
        var m = uniformState._normal;
        Matrix4.getRotation(uniformState.inverseModelView, m);
        Matrix3.transpose(m, m);
    }
}
function cleanNormal3D(uniformState) {
    if (uniformState._normal3DDirty) {
        uniformState._normal3DDirty = false;
        var m = uniformState._normal3D;
        Matrix4.getRotation(uniformState.inverseModelView3D, m);
        Matrix3.transpose(m, m);
    }
}
function cleanInverseNormal(uniformState) {
    if (uniformState._inverseNormalDirty) {
        uniformState._inverseNormalDirty = false;
        Matrix4.getRotation(uniformState.inverseModelView, uniformState._inverseNormal);
    }
}
function cleanInverseNormal3D(uniformState) {
    if (uniformState._inverseNormal3DDirty) {
        uniformState._inverseNormal3DDirty = false;
        Matrix4.getRotation(uniformState.inverseModelView3D, uniformState._inverseNormal3D);
    }
}
var cameraPositionMC = new Cartesian3();
function cleanEncodedCameraPositionMC(uniformState) {
    if (uniformState._encodedCameraPositionMCDirty) {
        uniformState._encodedCameraPositionMCDirty = false;
        Matrix4.multiplyByPoint(uniformState.inverseModel, uniformState._cameraPosition, cameraPositionMC);
        EncodedCartesian3.fromCartesian(cameraPositionMC, uniformState._encodedCameraPositionMC);
    }
}
var view2Dto3DPScratch = new Cartesian3();
var view2Dto3DRScratch = new Cartesian3();
var view2Dto3DUScratch = new Cartesian3();
var view2Dto3DDScratch = new Cartesian3();
var view2Dto3DCartographicScratch = new Cartographic();
var view2Dto3DCartesian3Scratch = new Cartesian3();
var view2Dto3DMatrix4Scratch = new Matrix4();
function view2Dto3D(position2D, direction2D, right2D, up2D, frustum2DWidth, mode, projection, result) {
    var p = view2Dto3DPScratch;
    p.x = position2D.y;
    p.y = position2D.z;
    p.z = position2D.x;
    var r = view2Dto3DRScratch;
    r.x = right2D.y;
    r.y = right2D.z;
    r.z = right2D.x;
    var u = view2Dto3DUScratch;
    u.x = up2D.y;
    u.y = up2D.z;
    u.z = up2D.x;
    var d = view2Dto3DDScratch;
    d.x = direction2D.y;
    d.y = direction2D.z;
    d.z = direction2D.x;
    if (mode === SceneMode.SCENE2D) {
        p.z = frustum2DWidth * 0.5;
    }
    var cartographic = projection.unproject(p, view2Dto3DCartographicScratch);
    cartographic.longitude = CesiumMath.clamp(cartographic.longitude, -Math.PI, Math.PI);
    cartographic.latitude = CesiumMath.clamp(cartographic.latitude, -CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);
    var ellipsoid = projection.ellipsoid;
    var position3D = ellipsoid.cartographicToCartesian(cartographic, view2Dto3DCartesian3Scratch);
    var enuToFixed = Transforms.eastNorthUpToFixedFrame(position3D, ellipsoid, view2Dto3DMatrix4Scratch);
    Matrix4.multiplyByPointAsVector(enuToFixed, r, r);
    Matrix4.multiplyByPointAsVector(enuToFixed, u, u);
    Matrix4.multiplyByPointAsVector(enuToFixed, d, d);
    if (!defined(result)) {
        result = new Matrix4();
    }
    result[0] = r.x;
    result[1] = u.x;
    result[2] = -d.x;
    result[3] = 0;
    result[4] = r.y;
    result[5] = u.y;
    result[6] = -d.y;
    result[7] = 0;
    result[8] = r.z;
    result[9] = u.z;
    result[10] = -d.z;
    result[11] = 0;
    result[12] = -Cartesian3.dot(r, position3D);
    result[13] = -Cartesian3.dot(u, position3D);
    result[14] = Cartesian3.dot(d, position3D);
    result[15] = 1;
    return result;
}
module.exports = UniformState;
},{"../Core/BoundingRectangle":97,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Cartographic":104,"../Core/EncodedCartesian3":137,"../Core/Math":174,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/Simon1994PlanetaryPositions":211,"../Core/Transforms":226,"../Core/defineProperties":244,"../Core/defined":245,"../Scene/SceneMode":438}],363:[function(require,module,exports){
var ComponentDatatype = require('../Core/ComponentDatatype'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError');
'use strict';
function addAttribute(attributes, attribute, index) {
    var hasVertexBuffer = defined(attribute.vertexBuffer);
    var hasValue = defined(attribute.value);
    var componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;
    if (!hasVertexBuffer && !hasValue) {
        throw new DeveloperError('attribute must have a vertexBuffer or a value.');
    }
    if (hasVertexBuffer && hasValue) {
        throw new DeveloperError('attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.');
    }
    if (componentsPerAttribute !== 1 && componentsPerAttribute !== 2 && componentsPerAttribute !== 3 && componentsPerAttribute !== 4) {
        if (hasValue) {
            throw new DeveloperError('attribute.value.length must be in the range [1, 4].');
        }
        throw new DeveloperError('attribute.componentsPerAttribute must be in the range [1, 4].');
    }
    if (defined(attribute.componentDatatype) && !ComponentDatatype.validate(attribute.componentDatatype)) {
        throw new DeveloperError('attribute must have a valid componentDatatype or not specify it.');
    }
    if (defined(attribute.strideInBytes) && attribute.strideInBytes > 255) {
        throw new DeveloperError('attribute must have a strideInBytes less than or equal to 255 or not specify it.');
    }
    var attr = {
            index: defaultValue(attribute.index, index),
            enabled: defaultValue(attribute.enabled, true),
            vertexBuffer: attribute.vertexBuffer,
            value: hasValue ? attribute.value.slice(0) : undefined,
            componentsPerAttribute: componentsPerAttribute,
            componentDatatype: defaultValue(attribute.componentDatatype, ComponentDatatype.FLOAT),
            normalize: defaultValue(attribute.normalize, false),
            offsetInBytes: defaultValue(attribute.offsetInBytes, 0),
            strideInBytes: defaultValue(attribute.strideInBytes, 0)
        };
    if (hasVertexBuffer) {
        attr.vertexAttrib = function (gl) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());
            gl.vertexAttribPointer(this.index, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes);
            gl.enableVertexAttribArray(this.index);
        };
        attr.disableVertexAttribArray = function (gl) {
            gl.disableVertexAttribArray(this.index);
        };
    } else {
        switch (attr.componentsPerAttribute) {
        case 1:
            attr.vertexAttrib = function (gl) {
                gl.vertexAttrib1fv(this.index, this.value);
            };
            break;
        case 2:
            attr.vertexAttrib = function (gl) {
                gl.vertexAttrib2fv(this.index, this.value);
            };
            break;
        case 3:
            attr.vertexAttrib = function (gl) {
                gl.vertexAttrib3fv(this.index, this.value);
            };
            break;
        case 4:
            attr.vertexAttrib = function (gl) {
                gl.vertexAttrib4fv(this.index, this.value);
            };
            break;
        }
        attr.disableVertexAttribArray = function (gl) {
        };
    }
    attributes.push(attr);
}
function bind(gl, attributes, indexBuffer) {
    for (var i = 0; i < attributes.length; ++i) {
        var attribute = attributes[i];
        if (attribute.enabled) {
            attribute.vertexAttrib(gl);
        }
    }
    if (defined(indexBuffer)) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer._getBuffer());
    }
}
var VertexArray = function (gl, vertexArrayObject, attributes, indexBuffer) {
    if (!defined(attributes)) {
        throw new DeveloperError('attributes is required.');
    }
    var i;
    var vaAttributes = [];
    var numberOfVertices = 1;
    for (i = 0; i < attributes.length; ++i) {
        addAttribute(vaAttributes, attributes[i], i);
    }
    for (i = 0; i < vaAttributes.length; ++i) {
        var attribute = vaAttributes[i];
        if (defined(attribute.vertexBuffer)) {
            var bytes = attribute.strideInBytes || attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(attribute.componentDatatype);
            numberOfVertices = attribute.vertexBuffer.sizeInBytes / bytes;
            break;
        }
    }
    var uniqueIndices = {};
    for (var j = 0; j < vaAttributes.length; ++j) {
        var index = vaAttributes[j].index;
        if (uniqueIndices[index]) {
            throw new DeveloperError('Index ' + index + ' is used by more than one attribute.');
        }
        uniqueIndices[index] = true;
    }
    var vao;
    if (defined(vertexArrayObject)) {
        vao = vertexArrayObject.createVertexArrayOES();
        vertexArrayObject.bindVertexArrayOES(vao);
        bind(gl, vaAttributes, indexBuffer);
        vertexArrayObject.bindVertexArrayOES(null);
    }
    this._numberOfVertices = numberOfVertices;
    this._gl = gl;
    this._vaoExtension = vertexArrayObject;
    this._vao = vao;
    this._attributes = vaAttributes;
    this._indexBuffer = indexBuffer;
};
defineProperties(VertexArray.prototype, {
    numberOfAttributes: {
        get: function () {
            return this._attributes.length;
        }
    },
    numberOfVertices: {
        get: function () {
            return this._numberOfVertices;
        }
    },
    indexBuffer: {
        get: function () {
            return this._indexBuffer;
        }
    }
});
VertexArray.prototype.getAttribute = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    return this._attributes[index];
};
VertexArray.prototype._bind = function () {
    if (defined(this._vao)) {
        this._vaoExtension.bindVertexArrayOES(this._vao);
    } else {
        bind(this._gl, this._attributes, this._indexBuffer);
    }
};
VertexArray.prototype._unBind = function () {
    if (defined(this._vao)) {
        this._vaoExtension.bindVertexArrayOES(null);
    } else {
        var attributes = this._attributes;
        var gl = this._gl;
        for (var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.enabled) {
                attribute.disableVertexAttribArray(gl);
            }
        }
        if (this._indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
    }
};
VertexArray.prototype.isDestroyed = function () {
    return false;
};
VertexArray.prototype.destroy = function () {
    var attributes = this._attributes;
    for (var i = 0; i < attributes.length; ++i) {
        var vertexBuffer = attributes[i].vertexBuffer;
        if (defined(vertexBuffer) && !vertexBuffer.isDestroyed() && vertexBuffer.vertexArrayDestroyable) {
            vertexBuffer.destroy();
        }
    }
    var indexBuffer = this._indexBuffer;
    if (defined(indexBuffer) && !indexBuffer.isDestroyed() && indexBuffer.vertexArrayDestroyable) {
        indexBuffer.destroy();
    }
    if (defined(this._vao)) {
        this._vaoExtension.deleteVertexArrayOES(this._vao);
    }
    return destroyObject(this);
};
module.exports = VertexArray;
},{"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247}],364:[function(require,module,exports){
var ComponentDatatype = require('../Core/ComponentDatatype'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), CesiumMath = require('../Core/Math'), BufferUsage = require('./BufferUsage');
'use strict';
var VertexArrayFacade = function (context, attributes, sizeInVertices) {
    if (!context) {
        throw new DeveloperError('context is required.');
    }
    if (!attributes || attributes.length === 0) {
        throw new DeveloperError('At least one attribute is required.');
    }
    var attrs = VertexArrayFacade._verifyAttributes(attributes);
    sizeInVertices = sizeInVertices || 0;
    var precreatedAttributes = [];
    var attributesByUsage = {};
    var attributesForUsage;
    var usage;
    var length = attrs.length;
    for (var i = 0; i < length; ++i) {
        var attribute = attrs[i];
        if (attribute.vertexBuffer) {
            precreatedAttributes.push(attribute);
            continue;
        }
        usage = attribute.usage;
        attributesForUsage = attributesByUsage[usage];
        if (!defined(attributesForUsage)) {
            attributesForUsage = attributesByUsage[usage] = [];
        }
        attributesForUsage.push(attribute);
    }
    function compare(left, right) {
        return ComponentDatatype.getSizeInBytes(right.componentDatatype) - ComponentDatatype.getSizeInBytes(left.componentDatatype);
    }
    this._buffersByUsage = {};
    this._allBuffers = [];
    for (usage in attributesByUsage) {
        if (attributesByUsage.hasOwnProperty(usage)) {
            attributesForUsage = attributesByUsage[usage];
            attributesForUsage.sort(compare);
            var vertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(attributesForUsage);
            var usageEnum;
            switch (Number(usage)) {
            case BufferUsage.STATIC_DRAW:
                usageEnum = BufferUsage.STATIC_DRAW;
                break;
            case BufferUsage.STREAM_DRAW:
                usageEnum = BufferUsage.STREAM_DRAW;
                break;
            case BufferUsage.DYNAMIC_DRAW:
                usageEnum = BufferUsage.DYNAMIC_DRAW;
                break;
            }
            var buffer = {
                    vertexSizeInBytes: vertexSizeInBytes,
                    vertexBuffer: undefined,
                    usage: usageEnum,
                    needsCommit: false,
                    arrayBuffer: undefined,
                    arrayViews: VertexArrayFacade._createArrayViews(attributesForUsage, vertexSizeInBytes)
                };
            this._buffersByUsage[usage] = buffer;
            this._allBuffers.push(buffer);
        }
    }
    this._size = 0;
    this._precreated = precreatedAttributes;
    this._context = context;
    this.writers = undefined;
    this.va = undefined;
    this.resize(sizeInVertices);
};
VertexArrayFacade._verifyAttributes = function (attributes) {
    var attrs = [];
    for (var i = 0; i < attributes.length; ++i) {
        var attribute = attributes[i];
        var attr = {
                index: defaultValue(attribute.index, i),
                enabled: defaultValue(attribute.enabled, true),
                componentsPerAttribute: attribute.componentsPerAttribute,
                componentDatatype: attribute.componentDatatype || ComponentDatatype.FLOAT,
                normalize: attribute.normalize || false,
                vertexBuffer: attribute.vertexBuffer,
                usage: attribute.usage || BufferUsage.STATIC_DRAW
            };
        attrs.push(attr);
        if (attr.componentsPerAttribute !== 1 && attr.componentsPerAttribute !== 2 && attr.componentsPerAttribute !== 3 && attr.componentsPerAttribute !== 4) {
            throw new DeveloperError('attribute.componentsPerAttribute must be in the range [1, 4].');
        }
        var datatype = attr.componentDatatype;
        if (!ComponentDatatype.validate(datatype)) {
            throw new DeveloperError('Attribute must have a valid componentDatatype or not specify it.');
        }
        if (!BufferUsage.validate(attr.usage)) {
            throw new DeveloperError('Attribute must have a valid usage or not specify it.');
        }
    }
    var uniqueIndices = new Array(attrs.length);
    for (var j = 0; j < attrs.length; ++j) {
        var currentAttr = attrs[j];
        var index = currentAttr.index;
        if (uniqueIndices[index]) {
            throw new DeveloperError('Index ' + index + ' is used by more than one attribute.');
        }
        uniqueIndices[index] = true;
    }
    return attrs;
};
VertexArrayFacade._vertexSizeInBytes = function (attributes) {
    var sizeInBytes = 0;
    var length = attributes.length;
    for (var i = 0; i < length; ++i) {
        var attribute = attributes[i];
        sizeInBytes += attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(attribute.componentDatatype);
    }
    var maxComponentSizeInBytes = length > 0 ? ComponentDatatype.getSizeInBytes(attributes[0].componentDatatype) : 0;
    var remainder = maxComponentSizeInBytes > 0 ? sizeInBytes % maxComponentSizeInBytes : 0;
    var padding = remainder === 0 ? 0 : maxComponentSizeInBytes - remainder;
    sizeInBytes += padding;
    return sizeInBytes;
};
VertexArrayFacade._createArrayViews = function (attributes, vertexSizeInBytes) {
    var views = [];
    var offsetInBytes = 0;
    var length = attributes.length;
    for (var i = 0; i < length; ++i) {
        var attribute = attributes[i];
        var componentDatatype = attribute.componentDatatype;
        views.push({
            index: attribute.index,
            enabled: attribute.enabled,
            componentsPerAttribute: attribute.componentsPerAttribute,
            componentDatatype: componentDatatype,
            normalize: attribute.normalize,
            offsetInBytes: offsetInBytes,
            vertexSizeInComponentType: vertexSizeInBytes / ComponentDatatype.getSizeInBytes(componentDatatype),
            view: undefined
        });
        offsetInBytes += attribute.componentsPerAttribute * ComponentDatatype.getSizeInBytes(componentDatatype);
    }
    return views;
};
VertexArrayFacade.prototype.resize = function (sizeInVertices) {
    this._size = sizeInVertices;
    var allBuffers = this._allBuffers;
    this.writers = [];
    for (var i = 0, len = allBuffers.length; i < len; ++i) {
        var buffer = allBuffers[i];
        VertexArrayFacade._resize(buffer, this._size);
        VertexArrayFacade._appendWriters(this.writers, buffer);
    }
    destroyVA(this);
};
VertexArrayFacade._resize = function (buffer, size) {
    if (buffer.vertexSizeInBytes > 0) {
        var arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);
        if (defined(buffer.arrayBuffer)) {
            var destView = new Uint8Array(arrayBuffer);
            var sourceView = new Uint8Array(buffer.arrayBuffer);
            var sourceLength = sourceView.length;
            for (var j = 0; j < sourceLength; ++j) {
                destView[j] = sourceView[j];
            }
        }
        var views = buffer.arrayViews;
        var length = views.length;
        for (var i = 0; i < length; ++i) {
            var view = views[i];
            view.view = ComponentDatatype.createArrayBufferView(view.componentDatatype, arrayBuffer, view.offsetInBytes);
        }
        buffer.arrayBuffer = arrayBuffer;
    }
};
var createWriters = [
        function (buffer, view, vertexSizeInComponentType) {
            return function (index, attribute) {
                view[index * vertexSizeInComponentType] = attribute;
                buffer.needsCommit = true;
            };
        },
        function (buffer, view, vertexSizeInComponentType) {
            return function (index, component0, component1) {
                var i = index * vertexSizeInComponentType;
                view[i] = component0;
                view[i + 1] = component1;
                buffer.needsCommit = true;
            };
        },
        function (buffer, view, vertexSizeInComponentType) {
            return function (index, component0, component1, component2) {
                var i = index * vertexSizeInComponentType;
                view[i] = component0;
                view[i + 1] = component1;
                view[i + 2] = component2;
                buffer.needsCommit = true;
            };
        },
        function (buffer, view, vertexSizeInComponentType) {
            return function (index, component0, component1, component2, component3) {
                var i = index * vertexSizeInComponentType;
                view[i] = component0;
                view[i + 1] = component1;
                view[i + 2] = component2;
                view[i + 3] = component3;
                buffer.needsCommit = true;
            };
        }
    ];
VertexArrayFacade._appendWriters = function (writers, buffer) {
    var arrayViews = buffer.arrayViews;
    var length = arrayViews.length;
    for (var i = 0; i < length; ++i) {
        var arrayView = arrayViews[i];
        writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);
    }
};
VertexArrayFacade.prototype.commit = function (indexBuffer) {
    var recreateVA = false;
    var allBuffers = this._allBuffers;
    var buffer;
    for (var i = 0, len = allBuffers.length; i < len; ++i) {
        buffer = allBuffers[i];
        recreateVA = commit(this, buffer) || recreateVA;
    }
    if (recreateVA || !defined(this.va)) {
        var buffersByUsage = this._buffersByUsage;
        destroyVA(this);
        var va = this.va = [];
        var numberOfVertexArrays = Math.ceil(this._size / CesiumMath.SIXTY_FOUR_KILOBYTES);
        for (var k = 0; k < numberOfVertexArrays; ++k) {
            var attributes = [];
            for (var usage in buffersByUsage) {
                if (buffersByUsage.hasOwnProperty(usage)) {
                    buffer = buffersByUsage[usage];
                    VertexArrayFacade._appendAttributes(attributes, buffer, k * (buffer.vertexSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES));
                }
            }
            attributes = attributes.concat(this._precreated);
            va.push({
                va: this._context.createVertexArray(attributes, indexBuffer),
                indicesCount: 1.5 * (k !== numberOfVertexArrays - 1 ? CesiumMath.SIXTY_FOUR_KILOBYTES : this._size % CesiumMath.SIXTY_FOUR_KILOBYTES)
            });
        }
    }
};
function commit(vertexArrayFacade, buffer) {
    if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {
        buffer.needsCommit = false;
        var vertexBuffer = buffer.vertexBuffer;
        var vertexBufferSizeInBytes = vertexArrayFacade._size * buffer.vertexSizeInBytes;
        var vertexBufferDefined = defined(vertexBuffer);
        if (!vertexBufferDefined || vertexBuffer.sizeInBytes < vertexBufferSizeInBytes) {
            if (vertexBufferDefined) {
                vertexBuffer.destroy();
            }
            buffer.vertexBuffer = vertexArrayFacade._context.createVertexBuffer(buffer.arrayBuffer, buffer.usage);
            buffer.vertexBuffer.vertexArrayDestroyable = false;
            return true;
        }
        buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);
    }
    return false;
}
VertexArrayFacade._appendAttributes = function (attributes, buffer, vertexBufferOffset) {
    var arrayViews = buffer.arrayViews;
    var length = arrayViews.length;
    for (var i = 0; i < length; ++i) {
        var view = arrayViews[i];
        attributes.push({
            index: view.index,
            enabled: view.enabled,
            componentsPerAttribute: view.componentsPerAttribute,
            componentDatatype: view.componentDatatype,
            normalize: view.normalize,
            vertexBuffer: buffer.vertexBuffer,
            offsetInBytes: vertexBufferOffset + view.offsetInBytes,
            strideInBytes: buffer.vertexSizeInBytes
        });
    }
};
VertexArrayFacade.prototype.subCommit = function (offsetInVertices, lengthInVertices) {
    if (offsetInVertices < 0 || offsetInVertices >= this._size) {
        throw new DeveloperError('offsetInVertices must be greater than or equal to zero and less than the vertex array size.');
    }
    if (offsetInVertices + lengthInVertices > this._size) {
        throw new DeveloperError('offsetInVertices + lengthInVertices cannot exceed the vertex array size.');
    }
    var allBuffers = this._allBuffers;
    for (var i = 0, len = allBuffers.length; i < len; ++i) {
        subCommit(allBuffers[i], offsetInVertices, lengthInVertices);
    }
};
function subCommit(buffer, offsetInVertices, lengthInVertices) {
    if (buffer.needsCommit && buffer.vertexSizeInBytes > 0) {
        var byteOffset = buffer.vertexSizeInBytes * offsetInVertices;
        var byteLength = buffer.vertexSizeInBytes * lengthInVertices;
        buffer.vertexBuffer.copyFromArrayView(new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength), byteOffset);
    }
}
VertexArrayFacade.prototype.endSubCommits = function () {
    var allBuffers = this._allBuffers;
    for (var i = 0, len = allBuffers.length; i < len; ++i) {
        allBuffers[i].needsCommit = false;
    }
};
function destroyVA(vertexArrayFacade) {
    var va = vertexArrayFacade.va;
    if (!defined(va)) {
        return;
    }
    var length = va.length;
    for (var i = 0; i < length; ++i) {
        va[i].va.destroy();
    }
    vertexArrayFacade.va = undefined;
}
VertexArrayFacade.prototype.isDestroyed = function () {
    return false;
};
VertexArrayFacade.prototype.destroy = function () {
    var allBuffers = this._allBuffers;
    for (var i = 0, len = allBuffers.length; i < len; ++i) {
        var buffer = allBuffers[i];
        buffer.vertexBuffer = buffer.vertexBuffer && buffer.vertexBuffer.destroy();
    }
    destroyVA(this);
    return destroyObject(this);
};
module.exports = VertexArrayFacade;
},{"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/Math":174,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"./BufferUsage":339}],365:[function(require,module,exports){
var defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), loadImage = require('../Core/loadImage'), when = require('../ThirdParty/when');
'use strict';
var loadCubeMap = function (context, urls, allowCrossOrigin) {
    if (!defined(context)) {
        throw new DeveloperError('context is required.');
    }
    if (!defined(urls) || !defined(urls.positiveX) || !defined(urls.negativeX) || !defined(urls.positiveY) || !defined(urls.negativeY) || !defined(urls.positiveZ) || !defined(urls.negativeZ)) {
        throw new DeveloperError('urls is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.');
    }
    var facePromises = [
            loadImage(urls.positiveX, allowCrossOrigin),
            loadImage(urls.negativeX, allowCrossOrigin),
            loadImage(urls.positiveY, allowCrossOrigin),
            loadImage(urls.negativeY, allowCrossOrigin),
            loadImage(urls.positiveZ, allowCrossOrigin),
            loadImage(urls.negativeZ, allowCrossOrigin)
        ];
    return when.all(facePromises, function (images) {
        return context.createCubeMap({
            source: {
                positiveX: images[0],
                negativeX: images[1],
                positiveY: images[2],
                negativeY: images[3],
                positiveZ: images[4],
                negativeZ: images[5]
            }
        });
    });
};
module.exports = loadCubeMap;
},{"../Core/DeveloperError":123,"../Core/defined":245,"../Core/loadImage":259,"../ThirdParty/when":596}],366:[function(require,module,exports){
var clone = require('../Core/clone'), combine = require('../Core/combine'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), BlendingState = require('./BlendingState'), CullFace = require('./CullFace');
'use strict';
var Appearance = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.material = options.material;
    this.translucent = defaultValue(options.translucent, true);
    this._vertexShaderSource = options.vertexShaderSource;
    this._fragmentShaderSource = options.fragmentShaderSource;
    this._renderState = options.renderState;
    this._closed = defaultValue(options.closed, false);
};
defineProperties(Appearance.prototype, {
    vertexShaderSource: {
        get: function () {
            return this._vertexShaderSource;
        }
    },
    fragmentShaderSource: {
        get: function () {
            return this._fragmentShaderSource;
        }
    },
    renderState: {
        get: function () {
            return this._renderState;
        }
    },
    closed: {
        get: function () {
            return this._closed;
        }
    }
});
Appearance.prototype.getFragmentShaderSource = function () {
    var parts = [];
    if (this.flat) {
        parts.push('#define FLAT');
    }
    if (this.faceForward) {
        parts.push('#define FACE_FORWARD');
    }
    if (defined(this.material)) {
        parts.push(this.material.shaderSource);
    }
    parts.push(this.fragmentShaderSource);
    return parts.join('\n');
};
Appearance.prototype.isTranslucent = function () {
    return defined(this.material) && this.material.isTranslucent() || !defined(this.material) && this.translucent;
};
Appearance.prototype.getRenderState = function () {
    var translucent = this.isTranslucent();
    var rs = clone(this.renderState, false);
    if (translucent) {
        rs.depthMask = false;
        rs.blending = BlendingState.ALPHA_BLEND;
    } else {
        rs.depthMask = true;
    }
    return rs;
};
Appearance.getDefaultRenderState = function (translucent, closed, existing) {
    var rs = { depthTest: { enabled: true } };
    if (translucent) {
        rs.depthMask = false;
        rs.blending = BlendingState.ALPHA_BLEND;
    }
    if (closed) {
        rs.cull = {
            enabled: true,
            face: CullFace.BACK
        };
    }
    if (defined(existing)) {
        rs = combine(existing, rs, true);
    }
    return rs;
};
module.exports = Appearance;
},{"../Core/clone":240,"../Core/combine":241,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./BlendingState":374,"./CullFace":380}],367:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Credit = require('../Core/Credit'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeographicProjection = require('../Core/GeographicProjection'), GeographicTilingScheme = require('../Core/GeographicTilingScheme'), jsonp = require('../Core/jsonp'), Rectangle = require('../Core/Rectangle'), TileProviderError = require('../Core/TileProviderError'), WebMercatorProjection = require('../Core/WebMercatorProjection'), WebMercatorTilingScheme = require('../Core/WebMercatorTilingScheme'), when = require('../ThirdParty/when'), DiscardMissingTileImagePolicy = require('./DiscardMissingTileImagePolicy'), ImageryProvider = require('./ImageryProvider');
'use strict';
var ArcGisMapServerImageryProvider = function ArcGisMapServerImageryProvider(options) {
    options = defaultValue(options, {});
    if (!defined(options.url)) {
        throw new DeveloperError('options.url is required.');
    }
    this._url = options.url;
    this._tileDiscardPolicy = options.tileDiscardPolicy;
    this._proxy = options.proxy;
    this._tileWidth = undefined;
    this._tileHeight = undefined;
    this._maximumLevel = undefined;
    this._tilingScheme = undefined;
    this._credit = undefined;
    this._useTiles = defaultValue(options.usePreCachedTilesIfAvailable, true);
    this._rectangle = undefined;
    this._errorEvent = new Event();
    this._ready = false;
    var that = this;
    var metadataError;
    function metadataSuccess(data) {
        var tileInfo = data.tileInfo;
        if (!that._useTiles || !defined(tileInfo)) {
            that._tileWidth = 256;
            that._tileHeight = 256;
            that._tilingScheme = new GeographicTilingScheme();
            that._rectangle = that._tilingScheme.rectangle;
            that._useTiles = false;
        } else {
            that._tileWidth = tileInfo.rows;
            that._tileHeight = tileInfo.cols;
            if (tileInfo.spatialReference.wkid === 102100 || tileInfo.spatialReference.wkid === 102113) {
                that._tilingScheme = new WebMercatorTilingScheme();
            } else if (data.tileInfo.spatialReference.wkid === 4326) {
                that._tilingScheme = new GeographicTilingScheme();
            } else {
                var message = 'Tile spatial reference WKID ' + data.tileInfo.spatialReference.wkid + ' is not supported.';
                metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
                return;
            }
            that._maximumLevel = data.tileInfo.lods.length - 1;
            if (defined(data.fullExtent)) {
                var projection = that._tilingScheme.projection;
                if (defined(data.fullExtent.spatialReference) && defined(data.fullExtent.spatialReference.wkid)) {
                    if (data.fullExtent.spatialReference.wkid === 102100 || data.fullExtent.spatialReference.wkid === 102113) {
                        projection = new WebMercatorProjection();
                    } else if (data.fullExtent.spatialReference.wkid === 4326) {
                        projection = new GeographicProjection();
                    } else {
                        var extentMessage = 'fullExtent.spatialReference WKID ' + data.fullExtent.spatialReference.wkid + ' is not supported.';
                        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, extentMessage, undefined, undefined, undefined, requestMetadata);
                        return;
                    }
                }
                var sw = projection.unproject(new Cartesian2(data.fullExtent.xmin, data.fullExtent.ymin));
                var ne = projection.unproject(new Cartesian2(data.fullExtent.xmax, data.fullExtent.ymax));
                that._rectangle = new Rectangle(sw.longitude, sw.latitude, ne.longitude, ne.latitude);
            } else {
                that._rectangle = that._tilingScheme.rectangle;
            }
            if (!defined(that._tileDiscardPolicy)) {
                that._tileDiscardPolicy = new DiscardMissingTileImagePolicy({
                    missingImageUrl: buildImageUrl(that, 0, 0, that._maximumLevel),
                    pixelsToCheck: [
                        new Cartesian2(0, 0),
                        new Cartesian2(200, 20),
                        new Cartesian2(20, 200),
                        new Cartesian2(80, 110),
                        new Cartesian2(160, 130)
                    ],
                    disableCheckIfAllPixelsAreTransparent: true
                });
            }
            that._useTiles = true;
        }
        if (defined(data.copyrightText) && data.copyrightText.length > 0) {
            that._credit = new Credit(data.copyrightText);
        }
        that._ready = true;
        TileProviderError.handleSuccess(metadataError);
    }
    function metadataFailure(e) {
        var message = 'An error occurred while accessing ' + that._url + '.';
        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
    }
    function requestMetadata() {
        var metadata = jsonp(that._url, {
                parameters: { f: 'json' },
                proxy: that._proxy
            });
        when(metadata, metadataSuccess, metadataFailure);
    }
    requestMetadata();
};
function buildImageUrl(imageryProvider, x, y, level) {
    var url;
    if (imageryProvider._useTiles) {
        url = imageryProvider._url + '/tile/' + level + '/' + y + '/' + x;
    } else {
        var nativeRectangle = imageryProvider._tilingScheme.tileXYToNativeRectangle(x, y, level);
        var bbox = nativeRectangle.west + '%2C' + nativeRectangle.south + '%2C' + nativeRectangle.east + '%2C' + nativeRectangle.north;
        url = imageryProvider._url + '/export?';
        url += 'bbox=' + bbox;
        url += '&bboxSR=4326&size=256%2C256&imageSR=4326&format=png&transparent=true&f=image';
    }
    var proxy = imageryProvider._proxy;
    if (defined(proxy)) {
        url = proxy.getURL(url);
    }
    return url;
}
defineProperties(ArcGisMapServerImageryProvider.prototype, {
    url: {
        get: function () {
            return this._url;
        }
    },
    proxy: {
        get: function () {
            return this._proxy;
        }
    },
    tileWidth: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            return this._tileWidth;
        }
    },
    tileHeight: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            return this._tileHeight;
        }
    },
    maximumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            return this._maximumLevel;
        }
    },
    minimumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            return 0;
        }
    },
    tilingScheme: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            return this._tilingScheme;
        }
    },
    rectangle: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
            }
            return this._rectangle;
        }
    },
    tileDiscardPolicy: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            return this._tileDiscardPolicy;
        }
    },
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    credit: {
        get: function () {
            return this._credit;
        }
    },
    usingPrecachedTiles: {
        get: function () {
            return this._useTiles;
        }
    },
    hasAlphaChannel: {
        get: function () {
            return true;
        }
    }
});
ArcGisMapServerImageryProvider.prototype.getTileCredits = function (x, y, level) {
    return undefined;
};
ArcGisMapServerImageryProvider.prototype.requestImage = function (x, y, level) {
    if (!this._ready) {
        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }
    var url = buildImageUrl(this, x, y, level);
    return ImageryProvider.loadImage(this, url);
};
ArcGisMapServerImageryProvider.prototype.pickFeatures = function () {
    return undefined;
};
module.exports = ArcGisMapServerImageryProvider;
},{"../Core/Cartesian2":101,"../Core/Credit":118,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeographicProjection":143,"../Core/GeographicTilingScheme":144,"../Core/Rectangle":201,"../Core/TileProviderError":220,"../Core/WebMercatorProjection":233,"../Core/WebMercatorTilingScheme":234,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/jsonp":256,"../ThirdParty/when":596,"./DiscardMissingTileImagePolicy":383,"./ImageryProvider":399}],368:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Color = require('../Core/Color'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Matrix4 = require('../Core/Matrix4'), NearFarScalar = require('../Core/NearFarScalar'), HorizontalOrigin = require('./HorizontalOrigin'), SceneMode = require('./SceneMode'), SceneTransforms = require('./SceneTransforms'), VerticalOrigin = require('./VerticalOrigin');
'use strict';
var Billboard = function (options, billboardCollection) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (defined(options.scaleByDistance) && options.scaleByDistance.far <= options.scaleByDistance.near) {
        throw new DeveloperError('scaleByDistance.far must be greater than scaleByDistance.near.');
    }
    if (defined(options.translucencyByDistance) && options.translucencyByDistance.far <= options.translucencyByDistance.near) {
        throw new DeveloperError('translucencyByDistance.far must be greater than translucencyByDistance.near.');
    }
    if (defined(options.pixelOffsetScaleByDistance) && options.pixelOffsetScaleByDistance.far <= options.pixelOffsetScaleByDistance.near) {
        throw new DeveloperError('pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.');
    }
    this._show = defaultValue(options.show, true);
    this._position = Cartesian3.clone(defaultValue(options.position, Cartesian3.ZERO));
    this._actualPosition = Cartesian3.clone(this._position);
    this._pixelOffset = Cartesian2.clone(defaultValue(options.pixelOffset, Cartesian2.ZERO));
    this._translate = new Cartesian2(0, 0);
    this._eyeOffset = Cartesian3.clone(defaultValue(options.eyeOffset, Cartesian3.ZERO));
    this._verticalOrigin = defaultValue(options.verticalOrigin, VerticalOrigin.CENTER);
    this._horizontalOrigin = defaultValue(options.horizontalOrigin, HorizontalOrigin.CENTER);
    this._scale = defaultValue(options.scale, 1);
    this._color = Color.clone(defaultValue(options.color, Color.WHITE));
    this._rotation = defaultValue(options.rotation, 0);
    this._alignedAxis = Cartesian3.clone(defaultValue(options.alignedAxis, Cartesian3.ZERO));
    this._width = options.width;
    this._height = options.height;
    this._scaleByDistance = options.scaleByDistance;
    this._translucencyByDistance = options.translucencyByDistance;
    this._pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;
    this._id = options.id;
    this._collection = defaultValue(options.collection, billboardCollection);
    this._pickId = undefined;
    this._pickPrimitive = defaultValue(options._pickPrimitive, this);
    this._billboardCollection = billboardCollection;
    this._dirty = false;
    this._index = -1;
    this._imageIndex = -1;
    this._imageIndexPromise = undefined;
    this._imageId = undefined;
    this._image = undefined;
    this._imageSubRegion = undefined;
    this._imageWidth = undefined;
    this._imageHeight = undefined;
    var image = options.image;
    var imageId = options.imageId;
    if (defined(image)) {
        if (!defined(imageId)) {
            if (typeof image === 'string') {
                imageId = image;
            } else if (defined(image.src)) {
                imageId = image.src;
            } else {
                imageId = createGuid();
            }
        }
        this._imageId = imageId;
        this._image = image;
    }
    if (defined(options.imageSubRegion)) {
        this._imageId = imageId;
        this._imageSubRegion = options.imageSubRegion;
    }
    if (defined(this._billboardCollection._textureAtlas)) {
        this._loadImage();
    }
};
var SHOW_INDEX = Billboard.SHOW_INDEX = 0;
var POSITION_INDEX = Billboard.POSITION_INDEX = 1;
var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX = 2;
var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX = 3;
var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX = 4;
var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX = 5;
var SCALE_INDEX = Billboard.SCALE_INDEX = 6;
var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX = 7;
var COLOR_INDEX = Billboard.COLOR_INDEX = 8;
var ROTATION_INDEX = Billboard.ROTATION_INDEX = 9;
var ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX = 10;
var SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX = 11;
var TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX = 12;
var PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = 13;
Billboard.NUMBER_OF_PROPERTIES = 14;
function makeDirty(billboard, propertyChanged) {
    var billboardCollection = billboard._billboardCollection;
    if (defined(billboardCollection)) {
        billboardCollection._updateBillboard(billboard, propertyChanged);
        billboard._dirty = true;
    }
}
defineProperties(Billboard.prototype, {
    show: {
        get: function () {
            return this._show;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._show !== value) {
                this._show = value;
                makeDirty(this, SHOW_INDEX);
            }
        }
    },
    position: {
        get: function () {
            return this._position;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var position = this._position;
            if (!Cartesian3.equals(position, value)) {
                Cartesian3.clone(value, position);
                Cartesian3.clone(value, this._actualPosition);
                makeDirty(this, POSITION_INDEX);
            }
        }
    },
    pixelOffset: {
        get: function () {
            return this._pixelOffset;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var pixelOffset = this._pixelOffset;
            if (!Cartesian2.equals(pixelOffset, value)) {
                Cartesian2.clone(value, pixelOffset);
                makeDirty(this, PIXEL_OFFSET_INDEX);
            }
        }
    },
    scaleByDistance: {
        get: function () {
            return this._scaleByDistance;
        },
        set: function (value) {
            if (defined(value) && value.far <= value.near) {
                throw new DeveloperError('far distance must be greater than near distance.');
            }
            var scaleByDistance = this._scaleByDistance;
            if (!NearFarScalar.equals(scaleByDistance, value)) {
                this._scaleByDistance = NearFarScalar.clone(value, scaleByDistance);
                makeDirty(this, SCALE_BY_DISTANCE_INDEX);
            }
        }
    },
    translucencyByDistance: {
        get: function () {
            return this._translucencyByDistance;
        },
        set: function (value) {
            if (defined(value) && value.far <= value.near) {
                throw new DeveloperError('far distance must be greater than near distance.');
            }
            var translucencyByDistance = this._translucencyByDistance;
            if (!NearFarScalar.equals(translucencyByDistance, value)) {
                this._translucencyByDistance = NearFarScalar.clone(value, translucencyByDistance);
                makeDirty(this, TRANSLUCENCY_BY_DISTANCE_INDEX);
            }
        }
    },
    pixelOffsetScaleByDistance: {
        get: function () {
            return this._pixelOffsetScaleByDistance;
        },
        set: function (value) {
            if (defined(value) && value.far <= value.near) {
                throw new DeveloperError('far distance must be greater than near distance.');
            }
            var pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
            if (!NearFarScalar.equals(pixelOffsetScaleByDistance, value)) {
                this._pixelOffsetScaleByDistance = NearFarScalar.clone(value, pixelOffsetScaleByDistance);
                makeDirty(this, PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX);
            }
        }
    },
    eyeOffset: {
        get: function () {
            return this._eyeOffset;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var eyeOffset = this._eyeOffset;
            if (!Cartesian3.equals(eyeOffset, value)) {
                Cartesian3.clone(value, eyeOffset);
                makeDirty(this, EYE_OFFSET_INDEX);
            }
        }
    },
    horizontalOrigin: {
        get: function () {
            return this._horizontalOrigin;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._horizontalOrigin !== value) {
                this._horizontalOrigin = value;
                makeDirty(this, HORIZONTAL_ORIGIN_INDEX);
            }
        }
    },
    verticalOrigin: {
        get: function () {
            return this._verticalOrigin;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._verticalOrigin !== value) {
                this._verticalOrigin = value;
                makeDirty(this, VERTICAL_ORIGIN_INDEX);
            }
        }
    },
    scale: {
        get: function () {
            return this._scale;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._scale !== value) {
                this._scale = value;
                makeDirty(this, SCALE_INDEX);
            }
        }
    },
    color: {
        get: function () {
            return this._color;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var color = this._color;
            if (!Color.equals(color, value)) {
                Color.clone(value, color);
                makeDirty(this, COLOR_INDEX);
            }
        }
    },
    rotation: {
        get: function () {
            return this._rotation;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._rotation !== value) {
                this._rotation = value;
                makeDirty(this, ROTATION_INDEX);
            }
        }
    },
    alignedAxis: {
        get: function () {
            return this._alignedAxis;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var alignedAxis = this._alignedAxis;
            if (!Cartesian3.equals(alignedAxis, value)) {
                Cartesian3.clone(value, alignedAxis);
                makeDirty(this, ALIGNED_AXIS_INDEX);
            }
        }
    },
    width: {
        get: function () {
            return defaultValue(this._width, this._imageWidth);
        },
        set: function (value) {
            if (this._width !== value) {
                this._width = value;
                makeDirty(this, IMAGE_INDEX_INDEX);
            }
        }
    },
    height: {
        get: function () {
            return defaultValue(this._height, this._imageHeight);
        },
        set: function (value) {
            if (this._height !== value) {
                this._height = value;
                makeDirty(this, IMAGE_INDEX_INDEX);
            }
        }
    },
    id: {
        get: function () {
            return this._id;
        },
        set: function (value) {
            this._id = value;
            if (defined(this._pickId)) {
                this._pickId.object.id = value;
            }
        }
    },
    pickPrimitive: {
        get: function () {
            return this._pickPrimitive;
        },
        set: function (value) {
            this._pickPrimitive = value;
            if (defined(this._pickId)) {
                this._pickId.object.primitive = value;
            }
        }
    },
    image: {
        get: function () {
            return this._imageId;
        },
        set: function (value) {
            if (!defined(value)) {
                this._imageIndex = -1;
                this._imageSubRegion = undefined;
                this._imageId = undefined;
                this._image = undefined;
                this._imageIndexPromise = undefined;
                makeDirty(this, IMAGE_INDEX_INDEX);
            } else if (typeof value === 'string') {
                this.setImage(value, value);
            } else if (defined(value.src)) {
                this.setImage(value.src, value);
            } else {
                this.setImage(createGuid(), value);
            }
        }
    },
    ready: {
        get: function () {
            return this._imageIndex !== -1;
        }
    }
});
Billboard.prototype.getPickId = function (context) {
    if (!defined(this._pickId)) {
        this._pickId = context.createPickId({
            primitive: this._pickPrimitive,
            collection: this._collection,
            id: this._id
        });
    }
    return this._pickId;
};
Billboard.prototype._loadImage = function () {
    var atlas = this._billboardCollection._textureAtlas;
    var imageId = this._imageId;
    var image = this._image;
    var imageSubRegion = this._imageSubRegion;
    var imageIndexPromise;
    if (defined(image)) {
        imageIndexPromise = atlas.addImage(imageId, image);
    }
    if (defined(imageSubRegion)) {
        imageIndexPromise = atlas.addSubRegion(imageId, imageSubRegion);
    }
    this._imageIndexPromise = imageIndexPromise;
    if (!defined(imageIndexPromise)) {
        return;
    }
    var that = this;
    imageIndexPromise.then(function (index) {
        if (that._imageId !== imageId || that._image !== image || !BoundingRectangle.equals(that._imageSubRegion, imageSubRegion)) {
            return;
        }
        var textureCoordinates = atlas.textureCoordinates[index];
        that._imageWidth = atlas.texture.width * textureCoordinates.width;
        that._imageHeight = atlas.texture.height * textureCoordinates.height;
        that._imageIndex = index;
        that._ready = true;
        that._image = undefined;
        that._imageIndexPromise = undefined;
        makeDirty(that, IMAGE_INDEX_INDEX);
    }).otherwise(function (error) {
        console.error('Error loading image for billboard: ' + error);
        that._imageIndexPromise = undefined;
    });
};
Billboard.prototype.setImage = function (id, image) {
    if (!defined(id)) {
        throw new DeveloperError('id is required.');
    }
    if (!defined(image)) {
        throw new DeveloperError('image is required.');
    }
    if (this._imageId === id) {
        return;
    }
    this._imageIndex = -1;
    this._imageSubRegion = undefined;
    this._imageId = id;
    this._image = image;
    if (defined(this._billboardCollection._textureAtlas)) {
        this._loadImage();
    }
};
Billboard.prototype.setImageSubRegion = function (id, subRegion) {
    if (!defined(id)) {
        throw new DeveloperError('id is required.');
    }
    if (!defined(subRegion)) {
        throw new DeveloperError('subRegion is required.');
    }
    if (this._imageId === id && BoundingRectangle.equals(this._imageSubRegion, subRegion)) {
        return;
    }
    this._imageIndex = -1;
    this._imageId = id;
    this._imageSubRegion = BoundingRectangle.clone(subRegion);
    if (defined(this._billboardCollection._textureAtlas)) {
        this._loadImage();
    }
};
Billboard.prototype._setTranslate = function (value) {
    if (!defined(value)) {
        throw new DeveloperError('value is required.');
    }
    var translate = this._translate;
    if (!Cartesian2.equals(translate, value)) {
        Cartesian2.clone(value, translate);
        makeDirty(this, PIXEL_OFFSET_INDEX);
    }
};
Billboard.prototype._getActualPosition = function () {
    return this._actualPosition;
};
Billboard.prototype._setActualPosition = function (value) {
    Cartesian3.clone(value, this._actualPosition);
    makeDirty(this, POSITION_INDEX);
};
var tempCartesian3 = new Cartesian4();
Billboard._computeActualPosition = function (position, frameState, modelMatrix) {
    if (frameState.mode === SceneMode.SCENE3D) {
        return position;
    }
    Matrix4.multiplyByPoint(modelMatrix, position, tempCartesian3);
    return SceneTransforms.computeActualWgs84Position(frameState, tempCartesian3);
};
var scratchMatrix4 = new Matrix4();
var scratchCartesian4 = new Cartesian4();
var scrachEyeOffset = new Cartesian3();
var scratchCartesian2 = new Cartesian2();
var scratchComputePixelOffset = new Cartesian2();
Billboard._computeScreenSpacePosition = function (modelMatrix, position, eyeOffset, pixelOffset, scene) {
    var camera = scene.camera;
    var view = camera.viewMatrix;
    var projection = camera.frustum.projectionMatrix;
    var mv = Matrix4.multiplyTransformation(view, modelMatrix, scratchMatrix4);
    var positionEC = Matrix4.multiplyByVector(mv, Cartesian4.fromElements(position.x, position.y, position.z, 1, scratchCartesian4), scratchCartesian4);
    var zEyeOffset = Cartesian3.multiplyComponents(eyeOffset, Cartesian3.normalize(positionEC, scrachEyeOffset), scrachEyeOffset);
    positionEC.x += eyeOffset.x + zEyeOffset.x;
    positionEC.y += eyeOffset.y + zEyeOffset.y;
    positionEC.z += zEyeOffset.z;
    var positionCC = Matrix4.multiplyByVector(projection, positionEC, scratchCartesian4);
    var positionWC = SceneTransforms.clipToGLWindowCoordinates(scene, positionCC, new Cartesian2());
    pixelOffset = Cartesian2.clone(pixelOffset, scratchComputePixelOffset);
    pixelOffset.y = -pixelOffset.y;
    var po = Cartesian2.multiplyByScalar(pixelOffset, scene.context.uniformState.resolutionScale, scratchCartesian2);
    positionWC.x += po.x;
    positionWC.y += po.y;
    return positionWC;
};
var scratchPixelOffset = new Cartesian2(0, 0);
Billboard.prototype.computeScreenSpacePosition = function (scene) {
    var billboardCollection = this._billboardCollection;
    if (!defined(billboardCollection)) {
        throw new DeveloperError('Billboard must be in a collection.  Was it removed?');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    Cartesian2.clone(this._pixelOffset, scratchPixelOffset);
    Cartesian2.add(scratchPixelOffset, this._translate, scratchPixelOffset);
    var modelMatrix = billboardCollection.modelMatrix;
    var windowCoordinates = Billboard._computeScreenSpacePosition(modelMatrix, this._actualPosition, this._eyeOffset, scratchPixelOffset, scene);
    windowCoordinates.y = scene.canvas.clientHeight - windowCoordinates.y;
    return windowCoordinates;
};
Billboard.prototype.equals = function (other) {
    return this === other || defined(other) && this._show === other._show && this._scale === other._scale && this._verticalOrigin === other._verticalOrigin && this._horizontalOrigin === other._horizontalOrigin && this._id === other._id && this._imageId === other._imageId && BoundingRectangle.equals(this._imageSubRegion, other._imageSubRegion) && Cartesian3.equals(this._position, other._position) && Color.equals(this._color, other._color) && Cartesian2.equals(this._pixelOffset, other._pixelOffset) && Cartesian2.equals(this._translate, other._translate) && Cartesian3.equals(this._eyeOffset, other._eyeOffset) && NearFarScalar.equals(this._scaleByDistance, other._scaleByDistance) && NearFarScalar.equals(this._translucencyByDistance, other._translucencyByDistance) && NearFarScalar.equals(this._pixelOffsetScaleByDistance, other._pixelOffsetScaleByDistance);
};
Billboard.prototype._destroy = function () {
    this.image = undefined;
    this._pickId = this._pickId && this._pickId.destroy();
    this._billboardCollection = undefined;
};
module.exports = Billboard;
},{"../Core/BoundingRectangle":97,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Matrix4":177,"../Core/NearFarScalar":178,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./HorizontalOrigin":394,"./SceneMode":438,"./SceneTransforms":439,"./VerticalOrigin":454}],369:[function(require,module,exports){
var AttributeCompression = require('../Core/AttributeCompression'), BoundingSphere = require('../Core/BoundingSphere'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), ComponentDatatype = require('../Core/ComponentDatatype'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), EncodedCartesian3 = require('../Core/EncodedCartesian3'), IndexDatatype = require('../Core/IndexDatatype'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), BufferUsage = require('../Renderer/BufferUsage'), DrawCommand = require('../Renderer/DrawCommand'), ShaderSource = require('../Renderer/ShaderSource'), VertexArrayFacade = require('../Renderer/VertexArrayFacade'), BillboardCollectionFS = require('../Shaders/BillboardCollectionFS'), BillboardCollectionVS = require('../Shaders/BillboardCollectionVS'), Billboard = require('./Billboard'), BlendingState = require('./BlendingState'), HorizontalOrigin = require('./HorizontalOrigin'), Pass = require('./Pass'), SceneMode = require('./SceneMode'), TextureAtlas = require('./TextureAtlas');
'use strict';
var SHOW_INDEX = Billboard.SHOW_INDEX;
var POSITION_INDEX = Billboard.POSITION_INDEX;
var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;
var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;
var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;
var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;
var SCALE_INDEX = Billboard.SCALE_INDEX;
var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;
var COLOR_INDEX = Billboard.COLOR_INDEX;
var ROTATION_INDEX = Billboard.ROTATION_INDEX;
var ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX;
var SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX;
var TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX;
var PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;
var NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;
var attributeLocations = {
        positionHighAndScale: 0,
        positionLowAndRotation: 1,
        compressedAttribute0: 2,
        compressedAttribute1: 3,
        compressedAttribute2: 4,
        eyeOffset: 5,
        scaleByDistance: 6,
        pixelOffsetScaleByDistance: 7
    };
var BillboardCollection = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._textureAtlas = undefined;
    this._textureAtlasGUID = undefined;
    this._destroyTextureAtlas = true;
    this._sp = undefined;
    this._rs = undefined;
    this._vaf = undefined;
    this._spPick = undefined;
    this._billboards = [];
    this._billboardsToUpdate = [];
    this._billboardsToUpdateIndex = 0;
    this._billboardsRemoved = false;
    this._createVertexArray = false;
    this._shaderRotation = false;
    this._compiledShaderRotation = false;
    this._compiledShaderRotationPick = false;
    this._shaderAlignedAxis = false;
    this._compiledShaderAlignedAxis = false;
    this._compiledShaderAlignedAxisPick = false;
    this._shaderScaleByDistance = false;
    this._compiledShaderScaleByDistance = false;
    this._compiledShaderScaleByDistancePick = false;
    this._shaderTranslucencyByDistance = false;
    this._compiledShaderTranslucencyByDistance = false;
    this._compiledShaderTranslucencyByDistancePick = false;
    this._shaderPixelOffsetScaleByDistance = false;
    this._compiledShaderPixelOffsetScaleByDistance = false;
    this._compiledShaderPixelOffsetScaleByDistancePick = false;
    this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
    this._maxSize = 0;
    this._maxEyeOffset = 0;
    this._maxScale = 1;
    this._maxPixelOffset = 0;
    this._allHorizontalCenter = true;
    this._baseVolume = new BoundingSphere();
    this._baseVolumeWC = new BoundingSphere();
    this._baseVolume2D = new BoundingSphere();
    this._boundingVolume = new BoundingSphere();
    this._boundingVolumeDirty = false;
    this._colorCommands = [];
    this._pickCommands = [];
    this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));
    this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);
    this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);
    this._mode = SceneMode.SCENE3D;
    this._buffersUsage = [
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW,
        BufferUsage.STATIC_DRAW
    ];
    var that = this;
    this._uniforms = {
        u_atlas: function () {
            return that._textureAtlas.texture;
        }
    };
};
defineProperties(BillboardCollection.prototype, {
    length: {
        get: function () {
            removeBillboards(this);
            return this._billboards.length;
        }
    },
    textureAtlas: {
        get: function () {
            return this._textureAtlas;
        },
        set: function (value) {
            if (this._textureAtlas !== value) {
                this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
                this._textureAtlas = value;
                this._createVertexArray = true;
            }
        }
    },
    destroyTextureAtlas: {
        get: function () {
            return this._destroyTextureAtlas;
        },
        set: function (value) {
            this._destroyTextureAtlas = value;
        }
    }
});
BillboardCollection.prototype.add = function (billboard) {
    var b = new Billboard(billboard, this);
    b._index = this._billboards.length;
    this._billboards.push(b);
    this._createVertexArray = true;
    return b;
};
BillboardCollection.prototype.remove = function (billboard) {
    if (this.contains(billboard)) {
        this._billboards[billboard._index] = null;
        this._billboardsRemoved = true;
        this._createVertexArray = true;
        billboard._destroy();
        return true;
    }
    return false;
};
BillboardCollection.prototype.removeAll = function () {
    this._destroyBillboards();
    this._billboards = [];
    this._billboardsToUpdate = [];
    this._billboardsToUpdateIndex = 0;
    this._billboardsRemoved = false;
    this._createVertexArray = true;
};
function removeBillboards(billboardCollection) {
    if (billboardCollection._billboardsRemoved) {
        billboardCollection._billboardsRemoved = false;
        var newBillboards = [];
        var billboards = billboardCollection._billboards;
        var length = billboards.length;
        for (var i = 0, j = 0; i < length; ++i) {
            var billboard = billboards[i];
            if (billboard) {
                billboard._index = j++;
                newBillboards.push(billboard);
            }
        }
        billboardCollection._billboards = newBillboards;
    }
}
BillboardCollection.prototype._updateBillboard = function (billboard, propertyChanged) {
    if (!billboard._dirty) {
        this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;
    }
    ++this._propertiesChanged[propertyChanged];
};
BillboardCollection.prototype.contains = function (billboard) {
    return defined(billboard) && billboard._billboardCollection === this;
};
BillboardCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    removeBillboards(this);
    return this._billboards[index];
};
function getIndexBuffer(context) {
    var sixteenK = 16 * 1024;
    var indexBuffer = context.cache.billboardCollection_indexBuffer;
    if (defined(indexBuffer)) {
        return indexBuffer;
    }
    var length = sixteenK * 6;
    var indices = new Uint16Array(length);
    for (var i = 0, j = 0; i < length; i += 6, j += 4) {
        indices[i] = j;
        indices[i + 1] = j + 1;
        indices[i + 2] = j + 2;
        indices[i + 3] = j + 0;
        indices[i + 4] = j + 2;
        indices[i + 5] = j + 3;
    }
    indexBuffer = context.createIndexBuffer(indices, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
    indexBuffer.vertexArrayDestroyable = false;
    context.cache.billboardCollection_indexBuffer = indexBuffer;
    return indexBuffer;
}
BillboardCollection.prototype.computeNewBuffersUsage = function () {
    var buffersUsage = this._buffersUsage;
    var usageChanged = false;
    var properties = this._propertiesChanged;
    for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
        var newUsage = properties[k] === 0 ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;
        usageChanged = usageChanged || buffersUsage[k] !== newUsage;
        buffersUsage[k] = newUsage;
    }
    return usageChanged;
};
function createVAF(context, numberOfBillboards, buffersUsage) {
    return new VertexArrayFacade(context, [
        {
            index: attributeLocations.positionHighAndScale,
            componentsPerAttribute: 4,
            componentDatatype: ComponentDatatype.FLOAT,
            usage: buffersUsage[POSITION_INDEX]
        },
        {
            index: attributeLocations.positionLowAndRotation,
            componentsPerAttribute: 4,
            componentDatatype: ComponentDatatype.FLOAT,
            usage: buffersUsage[POSITION_INDEX]
        },
        {
            index: attributeLocations.compressedAttribute0,
            componentsPerAttribute: 4,
            componentDatatype: ComponentDatatype.FLOAT,
            usage: buffersUsage[PIXEL_OFFSET_INDEX]
        },
        {
            index: attributeLocations.compressedAttribute1,
            componentsPerAttribute: 4,
            componentDatatype: ComponentDatatype.FLOAT,
            usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX]
        },
        {
            index: attributeLocations.compressedAttribute2,
            componentsPerAttribute: 4,
            componentDatatype: ComponentDatatype.FLOAT,
            usage: buffersUsage[COLOR_INDEX]
        },
        {
            index: attributeLocations.eyeOffset,
            componentsPerAttribute: 3,
            componentDatatype: ComponentDatatype.FLOAT,
            usage: buffersUsage[EYE_OFFSET_INDEX]
        },
        {
            index: attributeLocations.scaleByDistance,
            componentsPerAttribute: 4,
            componentDatatype: ComponentDatatype.FLOAT,
            usage: buffersUsage[SCALE_BY_DISTANCE_INDEX]
        },
        {
            index: attributeLocations.pixelOffsetScaleByDistance,
            componentsPerAttribute: 4,
            componentDatatype: ComponentDatatype.FLOAT,
            usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]
        }
    ], 4 * numberOfBillboards);
}
var writePositionScratch = new EncodedCartesian3();
function writePositionScaleAndRotation(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
    var i = billboard._index * 4;
    var position = billboard._getActualPosition();
    if (billboardCollection._mode === SceneMode.SCENE3D) {
        BoundingSphere.expand(billboardCollection._baseVolume, position, billboardCollection._baseVolume);
        billboardCollection._boundingVolumeDirty = true;
    }
    EncodedCartesian3.fromCartesian(position, writePositionScratch);
    var scale = billboard.scale;
    var rotation = billboard.rotation;
    if (rotation !== 0) {
        billboardCollection._shaderRotation = true;
    }
    billboardCollection._maxScale = Math.max(billboardCollection._maxScale, scale);
    var positionHighWriter = vafWriters[attributeLocations.positionHighAndScale];
    var high = writePositionScratch.high;
    positionHighWriter(i + 0, high.x, high.y, high.z, scale);
    positionHighWriter(i + 1, high.x, high.y, high.z, scale);
    positionHighWriter(i + 2, high.x, high.y, high.z, scale);
    positionHighWriter(i + 3, high.x, high.y, high.z, scale);
    var positionLowWriter = vafWriters[attributeLocations.positionLowAndRotation];
    var low = writePositionScratch.low;
    positionLowWriter(i + 0, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 1, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 2, low.x, low.y, low.z, rotation);
    positionLowWriter(i + 3, low.x, low.y, low.z, rotation);
}
var scratchCartesian2 = new Cartesian2();
var UPPER_BOUND = 32768;
var LEFT_SHIFT16 = 65536;
var LEFT_SHIFT8 = 256;
var LEFT_SHIFT7 = 128;
var LEFT_SHIFT5 = 32;
var LEFT_SHIFT3 = 8;
var LEFT_SHIFT2 = 4;
var RIGHT_SHIFT8 = 1 / 256;
var LOWER_LEFT = 0;
var LOWER_RIGHT = 2;
var UPPER_RIGHT = 3;
var UPPER_LEFT = 1;
function writeCompressedAttrib0(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
    var i = billboard._index * 4;
    var pixelOffset = billboard.pixelOffset;
    var pixelOffsetX = pixelOffset.x;
    var pixelOffsetY = pixelOffset.y;
    var translate = billboard._translate;
    var translateX = translate.x;
    var translateY = translate.y;
    billboardCollection._maxPixelOffset = Math.max(billboardCollection._maxPixelOffset, Math.abs(pixelOffsetX + translateX), Math.abs(-pixelOffsetY + translateY));
    var horizontalOrigin = billboard.horizontalOrigin;
    var verticalOrigin = billboard.verticalOrigin;
    var show = billboard.show;
    if (billboard.color.alpha === 0) {
        show = false;
    }
    billboardCollection._allHorizontalCenter = billboardCollection._allHorizontalCenter && horizontalOrigin === HorizontalOrigin.CENTER;
    var bottomLeftX = 0;
    var bottomLeftY = 0;
    var width = 0;
    var height = 0;
    var index = billboard._imageIndex;
    if (index !== -1) {
        var imageRectangle = textureAtlasCoordinates[index];
        if (!defined(imageRectangle)) {
            throw new DeveloperError('Invalid billboard image index: ' + index);
        }
        bottomLeftX = imageRectangle.x;
        bottomLeftY = imageRectangle.y;
        width = imageRectangle.width;
        height = imageRectangle.height;
    }
    var topRightX = bottomLeftX + width;
    var topRightY = bottomLeftY + height;
    var compressed0 = Math.floor(CesiumMath.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT7;
    compressed0 += (horizontalOrigin + 1) * LEFT_SHIFT5;
    compressed0 += (verticalOrigin + 1) * LEFT_SHIFT3;
    compressed0 += (show ? 1 : 0) * LEFT_SHIFT2;
    var compressed1 = Math.floor(CesiumMath.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT8;
    var compressed2 = Math.floor(CesiumMath.clamp(translateX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * LEFT_SHIFT8;
    var tempTanslateY = (CesiumMath.clamp(translateY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * RIGHT_SHIFT8;
    var upperTranslateY = Math.floor(tempTanslateY);
    var lowerTranslateY = Math.floor((tempTanslateY - upperTranslateY) * LEFT_SHIFT8);
    compressed1 += upperTranslateY;
    compressed2 += lowerTranslateY;
    scratchCartesian2.x = bottomLeftX;
    scratchCartesian2.y = bottomLeftY;
    var compressedTexCoordsLL = AttributeCompression.compressTextureCoordinates(scratchCartesian2);
    scratchCartesian2.x = topRightX;
    var compressedTexCoordsLR = AttributeCompression.compressTextureCoordinates(scratchCartesian2);
    scratchCartesian2.y = topRightY;
    var compressedTexCoordsUR = AttributeCompression.compressTextureCoordinates(scratchCartesian2);
    scratchCartesian2.x = bottomLeftX;
    var compressedTexCoordsUL = AttributeCompression.compressTextureCoordinates(scratchCartesian2);
    var writer = vafWriters[attributeLocations.compressedAttribute0];
    writer(i + 0, compressed0 + LOWER_LEFT, compressed1, compressed2, compressedTexCoordsLL);
    writer(i + 1, compressed0 + LOWER_RIGHT, compressed1, compressed2, compressedTexCoordsLR);
    writer(i + 2, compressed0 + UPPER_RIGHT, compressed1, compressed2, compressedTexCoordsUR);
    writer(i + 3, compressed0 + UPPER_LEFT, compressed1, compressed2, compressedTexCoordsUL);
}
function writeCompressedAttrib1(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
    var i = billboard._index * 4;
    var alignedAxis = billboard.alignedAxis;
    if (!Cartesian3.equals(alignedAxis, Cartesian3.ZERO)) {
        billboardCollection._shaderAlignedAxis = true;
    }
    var near = 0;
    var nearValue = 1;
    var far = 1;
    var farValue = 1;
    var translucency = billboard.translucencyByDistance;
    if (defined(translucency)) {
        near = translucency.near;
        nearValue = translucency.nearValue;
        far = translucency.far;
        farValue = translucency.farValue;
        if (nearValue !== 1 || farValue !== 1) {
            billboardCollection._shaderTranslucencyByDistance = true;
        }
    }
    var width = 0;
    var index = billboard._imageIndex;
    if (index !== -1) {
        var imageRectangle = textureAtlasCoordinates[index];
        if (!defined(imageRectangle)) {
            throw new DeveloperError('Invalid billboard image index: ' + index);
        }
        width = imageRectangle.width;
    }
    var textureWidth = billboardCollection._textureAtlas.texture.width;
    var imageWidth = Math.ceil(defaultValue(billboard.width, textureWidth * width) * 0.5);
    billboardCollection._maxSize = Math.max(billboardCollection._maxSize, imageWidth);
    var compressed0 = CesiumMath.clamp(imageWidth, 0, LEFT_SHIFT16);
    var compressed1 = 0;
    if (Math.abs(Cartesian3.magnitudeSquared(alignedAxis) - 1) < CesiumMath.EPSILON6) {
        compressed1 = AttributeCompression.octEncodeFloat(alignedAxis);
    }
    nearValue = CesiumMath.clamp(nearValue, 0, 1);
    nearValue = nearValue === 1 ? 255 : nearValue * 255 | 0;
    compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;
    farValue = CesiumMath.clamp(farValue, 0, 1);
    farValue = farValue === 1 ? 255 : farValue * 255 | 0;
    compressed1 = compressed1 * LEFT_SHIFT8 + farValue;
    var writer = vafWriters[attributeLocations.compressedAttribute1];
    writer(i + 0, compressed0, compressed1, near, far);
    writer(i + 1, compressed0, compressed1, near, far);
    writer(i + 2, compressed0, compressed1, near, far);
    writer(i + 3, compressed0, compressed1, near, far);
}
function writeCompressedAttrib2(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
    var i = billboard._index * 4;
    var color = billboard.color;
    var pickColor = billboard.getPickId(context).color;
    var height = 0;
    var index = billboard._imageIndex;
    if (index !== -1) {
        var imageRectangle = textureAtlasCoordinates[index];
        if (!defined(imageRectangle)) {
            throw new DeveloperError('Invalid billboard image index: ' + index);
        }
        height = imageRectangle.height;
    }
    var dimensions = billboardCollection._textureAtlas.texture.dimensions;
    var imageHeight = Math.ceil(defaultValue(billboard.height, dimensions.y * height) * 0.5);
    billboardCollection._maxSize = Math.max(billboardCollection._maxSize, imageHeight);
    var red = Color.floatToByte(color.red);
    var green = Color.floatToByte(color.green);
    var blue = Color.floatToByte(color.blue);
    var compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
    red = Color.floatToByte(pickColor.red);
    green = Color.floatToByte(pickColor.green);
    blue = Color.floatToByte(pickColor.blue);
    var compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
    var compressed2 = Color.floatToByte(color.alpha) * LEFT_SHIFT8 + Color.floatToByte(pickColor.alpha);
    var writer = vafWriters[attributeLocations.compressedAttribute2];
    writer(i + 0, compressed0, compressed1, compressed2, imageHeight);
    writer(i + 1, compressed0, compressed1, compressed2, imageHeight);
    writer(i + 2, compressed0, compressed1, compressed2, imageHeight);
    writer(i + 3, compressed0, compressed1, compressed2, imageHeight);
}
function writeEyeOffset(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
    var i = billboard._index * 4;
    var eyeOffset = billboard.eyeOffset;
    billboardCollection._maxEyeOffset = Math.max(billboardCollection._maxEyeOffset, Math.abs(eyeOffset.x), Math.abs(eyeOffset.y), Math.abs(eyeOffset.z));
    var writer = vafWriters[attributeLocations.eyeOffset];
    writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffset.z);
    writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffset.z);
    writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffset.z);
    writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffset.z);
}
function writeScaleByDistance(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
    var i = billboard._index * 4;
    var writer = vafWriters[attributeLocations.scaleByDistance];
    var near = 0;
    var nearValue = 1;
    var far = 1;
    var farValue = 1;
    var scale = billboard.scaleByDistance;
    if (defined(scale)) {
        near = scale.near;
        nearValue = scale.nearValue;
        far = scale.far;
        farValue = scale.farValue;
        if (nearValue !== 1 || farValue !== 1) {
            billboardCollection._shaderScaleByDistance = true;
        }
    }
    writer(i + 0, near, nearValue, far, farValue);
    writer(i + 1, near, nearValue, far, farValue);
    writer(i + 2, near, nearValue, far, farValue);
    writer(i + 3, near, nearValue, far, farValue);
}
function writePixelOffsetScaleByDistance(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
    var i = billboard._index * 4;
    var writer = vafWriters[attributeLocations.pixelOffsetScaleByDistance];
    var near = 0;
    var nearValue = 1;
    var far = 1;
    var farValue = 1;
    var pixelOffsetScale = billboard.pixelOffsetScaleByDistance;
    if (defined(pixelOffsetScale)) {
        near = pixelOffsetScale.near;
        nearValue = pixelOffsetScale.nearValue;
        far = pixelOffsetScale.far;
        farValue = pixelOffsetScale.farValue;
        if (nearValue !== 1 || farValue !== 1) {
            billboardCollection._shaderPixelOffsetScaleByDistance = true;
        }
    }
    writer(i + 0, near, nearValue, far, farValue);
    writer(i + 1, near, nearValue, far, farValue);
    writer(i + 2, near, nearValue, far, farValue);
    writer(i + 3, near, nearValue, far, farValue);
}
function writeBillboard(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard) {
    writePositionScaleAndRotation(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
    writeCompressedAttrib0(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
    writeCompressedAttrib1(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
    writeCompressedAttrib2(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
    writeEyeOffset(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
    writeScaleByDistance(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
    writePixelOffsetScaleByDistance(billboardCollection, context, textureAtlasCoordinates, vafWriters, billboard);
}
function recomputeActualPositions(billboardCollection, billboards, length, frameState, modelMatrix, recomputeBoundingVolume) {
    var boundingVolume;
    if (frameState.mode === SceneMode.SCENE3D) {
        boundingVolume = billboardCollection._baseVolume;
        billboardCollection._boundingVolumeDirty = true;
    } else {
        boundingVolume = billboardCollection._baseVolume2D;
    }
    var positions = [];
    for (var i = 0; i < length; ++i) {
        var billboard = billboards[i];
        var position = billboard.position;
        var actualPosition = Billboard._computeActualPosition(position, frameState, modelMatrix);
        if (defined(actualPosition)) {
            billboard._setActualPosition(actualPosition);
            if (recomputeBoundingVolume) {
                positions.push(actualPosition);
            } else {
                BoundingSphere.expand(boundingVolume, actualPosition, boundingVolume);
            }
        }
    }
    if (recomputeBoundingVolume) {
        BoundingSphere.fromPoints(positions, boundingVolume);
    }
}
function updateMode(billboardCollection, frameState) {
    var mode = frameState.mode;
    var billboards = billboardCollection._billboards;
    var billboardsToUpdate = billboardCollection._billboardsToUpdate;
    var modelMatrix = billboardCollection._modelMatrix;
    if (billboardCollection._createVertexArray || billboardCollection._mode !== mode || mode !== SceneMode.SCENE3D && !Matrix4.equals(modelMatrix, billboardCollection.modelMatrix)) {
        billboardCollection._mode = mode;
        Matrix4.clone(billboardCollection.modelMatrix, modelMatrix);
        billboardCollection._createVertexArray = true;
        if (mode === SceneMode.SCENE3D || mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {
            recomputeActualPositions(billboardCollection, billboards, billboards.length, frameState, modelMatrix, true);
        }
    } else if (mode === SceneMode.MORPHING) {
        recomputeActualPositions(billboardCollection, billboards, billboards.length, frameState, modelMatrix, true);
    } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {
        recomputeActualPositions(billboardCollection, billboardsToUpdate, billboardCollection._billboardsToUpdateIndex, frameState, modelMatrix, false);
    }
}
var scratchDrawingBufferDimensions = new Cartesian2();
var scratchToCenter = new Cartesian3();
var scratchProj = new Cartesian3();
function updateBoundingVolume(collection, context, frameState, boundingVolume) {
    var camera = frameState.camera;
    var frustum = camera.frustum;
    var toCenter = Cartesian3.subtract(camera.positionWC, boundingVolume.center, scratchToCenter);
    var proj = Cartesian3.multiplyByScalar(camera.directionWC, Cartesian3.dot(toCenter, camera.directionWC), scratchProj);
    var distance = Math.max(0, Cartesian3.magnitude(proj) - boundingVolume.radius);
    scratchDrawingBufferDimensions.x = context.drawingBufferWidth;
    scratchDrawingBufferDimensions.y = context.drawingBufferHeight;
    var pixelSize = frustum.getPixelSize(scratchDrawingBufferDimensions, distance);
    var pixelScale = Math.max(pixelSize.x, pixelSize.y);
    var size = pixelScale * collection._maxScale * collection._maxSize * 2;
    if (collection._allHorizontalCenter) {
        size *= 0.5;
    }
    var offset = pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;
    boundingVolume.radius += size + offset;
}
BillboardCollection.prototype.update = function (context, frameState, commandList) {
    var billboards = this._billboards;
    var billboardsLength = billboards.length;
    var textureAtlas = this._textureAtlas;
    if (!defined(textureAtlas)) {
        textureAtlas = this._textureAtlas = new TextureAtlas({ context: context });
        for (var ii = 0; ii < billboardsLength; ++ii) {
            billboards[ii]._loadImage();
        }
    }
    var textureAtlasCoordinates = textureAtlas.textureCoordinates;
    if (textureAtlasCoordinates.length === 0) {
        return;
    }
    removeBillboards(this);
    updateMode(this, frameState);
    billboards = this._billboards;
    billboardsLength = billboards.length;
    var billboardsToUpdate = this._billboardsToUpdate;
    var billboardsToUpdateLength = this._billboardsToUpdateIndex;
    var properties = this._propertiesChanged;
    var textureAtlasGUID = textureAtlas.guid;
    var createVertexArray = this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;
    this._textureAtlasGUID = textureAtlasGUID;
    var vafWriters;
    var pass = frameState.passes;
    var picking = pass.pick;
    if (createVertexArray || !picking && this.computeNewBuffersUsage()) {
        this._createVertexArray = false;
        for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            properties[k] = 0;
        }
        this._vaf = this._vaf && this._vaf.destroy();
        if (billboardsLength > 0) {
            this._vaf = createVAF(context, billboardsLength, this._buffersUsage);
            vafWriters = this._vaf.writers;
            for (var i = 0; i < billboardsLength; ++i) {
                var billboard = this._billboards[i];
                billboard._dirty = false;
                writeBillboard(this, context, textureAtlasCoordinates, vafWriters, billboard);
            }
            this._vaf.commit(getIndexBuffer(context));
        }
        this._billboardsToUpdateIndex = 0;
    } else {
        if (billboardsToUpdateLength > 0) {
            var writers = [];
            if (properties[POSITION_INDEX] || properties[ROTATION_INDEX] || properties[SCALE_INDEX]) {
                writers.push(writePositionScaleAndRotation);
            }
            if (properties[IMAGE_INDEX_INDEX] || properties[PIXEL_OFFSET_INDEX] || properties[HORIZONTAL_ORIGIN_INDEX] || properties[VERTICAL_ORIGIN_INDEX] || properties[SHOW_INDEX]) {
                writers.push(writeCompressedAttrib0);
            }
            if (properties[IMAGE_INDEX_INDEX] || properties[ALIGNED_AXIS_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {
                writers.push(writeCompressedAttrib1);
            }
            if (properties[IMAGE_INDEX_INDEX] || properties[COLOR_INDEX]) {
                writers.push(writeCompressedAttrib2);
            }
            if (properties[EYE_OFFSET_INDEX]) {
                writers.push(writeEyeOffset);
            }
            if (properties[SCALE_BY_DISTANCE_INDEX]) {
                writers.push(writeScaleByDistance);
            }
            if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]) {
                writers.push(writePixelOffsetScaleByDistance);
            }
            vafWriters = this._vaf.writers;
            if (billboardsToUpdateLength / billboardsLength > 0.1) {
                for (var m = 0; m < billboardsToUpdateLength; ++m) {
                    var b = billboardsToUpdate[m];
                    b._dirty = false;
                    for (var n = 0; n < writers.length; ++n) {
                        writers[n](this, context, textureAtlasCoordinates, vafWriters, b);
                    }
                }
                this._vaf.commit(getIndexBuffer(context));
            } else {
                for (var h = 0; h < billboardsToUpdateLength; ++h) {
                    var bb = billboardsToUpdate[h];
                    bb._dirty = false;
                    for (var o = 0; o < writers.length; ++o) {
                        writers[o](this, context, textureAtlasCoordinates, vafWriters, bb);
                    }
                    this._vaf.subCommit(bb._index * 4, 4);
                }
                this._vaf.endSubCommits();
            }
            this._billboardsToUpdateIndex = 0;
        }
    }
    if (billboardsToUpdateLength > billboardsLength * 1.5) {
        billboardsToUpdate.length = billboardsLength;
    }
    if (!defined(this._vaf) || !defined(this._vaf.va)) {
        return;
    }
    if (this._boundingVolumeDirty) {
        this._boundingVolumeDirty = false;
        BoundingSphere.transform(this._baseVolume, this.modelMatrix, this._baseVolumeWC);
    }
    var boundingVolume;
    var modelMatrix = Matrix4.IDENTITY;
    if (frameState.mode === SceneMode.SCENE3D) {
        modelMatrix = this.modelMatrix;
        boundingVolume = BoundingSphere.clone(this._baseVolumeWC, this._boundingVolume);
    } else {
        boundingVolume = BoundingSphere.clone(this._baseVolume2D, this._boundingVolume);
    }
    updateBoundingVolume(this, context, frameState, boundingVolume);
    var va;
    var vaLength;
    var command;
    var j;
    var vs;
    var fs;
    if (pass.render) {
        var colorList = this._colorCommands;
        if (!defined(this._rs)) {
            this._rs = context.createRenderState({
                depthTest: { enabled: true },
                blending: BlendingState.ALPHA_BLEND
            });
        }
        if (!defined(this._sp) || this._shaderRotation && !this._compiledShaderRotation || this._shaderAlignedAxis && !this._compiledShaderAlignedAxis || this._shaderScaleByDistance && !this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance && !this._compiledShaderPixelOffsetScaleByDistance) {
            vs = new ShaderSource({ sources: [BillboardCollectionVS] });
            if (this._shaderRotation) {
                vs.defines.push('ROTATION');
            }
            if (this._shaderAlignedAxis) {
                vs.defines.push('ALIGNED_AXIS');
            }
            if (this._shaderScaleByDistance) {
                vs.defines.push('EYE_DISTANCE_SCALING');
            }
            if (this._shaderTranslucencyByDistance) {
                vs.defines.push('EYE_DISTANCE_TRANSLUCENCY');
            }
            if (this._shaderPixelOffsetScaleByDistance) {
                vs.defines.push('EYE_DISTANCE_PIXEL_OFFSET');
            }
            this._sp = context.replaceShaderProgram(this._sp, vs, BillboardCollectionFS, attributeLocations);
            this._compiledShaderRotation = this._shaderRotation;
            this._compiledShaderAlignedAxis = this._shaderAlignedAxis;
            this._compiledShaderScaleByDistance = this._shaderScaleByDistance;
            this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;
            this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance;
        }
        va = this._vaf.va;
        vaLength = va.length;
        colorList.length = vaLength;
        for (j = 0; j < vaLength; ++j) {
            command = colorList[j];
            if (!defined(command)) {
                command = colorList[j] = new DrawCommand({
                    pass: Pass.OPAQUE,
                    owner: this
                });
            }
            command.boundingVolume = boundingVolume;
            command.modelMatrix = modelMatrix;
            command.count = va[j].indicesCount;
            command.shaderProgram = this._sp;
            command.uniformMap = this._uniforms;
            command.vertexArray = va[j].va;
            command.renderState = this._rs;
            command.debugShowBoundingVolume = this.debugShowBoundingVolume;
            commandList.push(command);
        }
    }
    if (picking) {
        var pickList = this._pickCommands;
        if (!defined(this._spPick) || this._shaderRotation && !this._compiledShaderRotationPick || this._shaderAlignedAxis && !this._compiledShaderAlignedAxisPick || this._shaderScaleByDistance && !this._compiledShaderScaleByDistancePick || this._shaderTranslucencyByDistance && !this._compiledShaderTranslucencyByDistancePick || this._shaderPixelOffsetScaleByDistance && !this._compiledShaderPixelOffsetScaleByDistancePick) {
            vs = new ShaderSource({
                defines: ['RENDER_FOR_PICK'],
                sources: [BillboardCollectionVS]
            });
            if (this._shaderRotation) {
                vs.defines.push('ROTATION');
            }
            if (this._shaderAlignedAxis) {
                vs.defines.push('ALIGNED_AXIS');
            }
            if (this._shaderScaleByDistance) {
                vs.defines.push('EYE_DISTANCE_SCALING');
            }
            if (this._shaderTranslucencyByDistance) {
                vs.defines.push('EYE_DISTANCE_TRANSLUCENCY');
            }
            if (this._shaderPixelOffsetScaleByDistance) {
                vs.defines.push('EYE_DISTANCE_PIXEL_OFFSET');
            }
            fs = new ShaderSource({
                defines: ['RENDER_FOR_PICK'],
                sources: [BillboardCollectionFS]
            });
            this._spPick = context.replaceShaderProgram(this._spPick, vs, fs, attributeLocations);
            this._compiledShaderRotationPick = this._shaderRotation;
            this._compiledShaderAlignedAxisPick = this._shaderAlignedAxis;
            this._compiledShaderScaleByDistancePick = this._shaderScaleByDistance;
            this._compiledShaderTranslucencyByDistancePick = this._shaderTranslucencyByDistance;
            this._compiledShaderPixelOffsetScaleByDistancePick = this._shaderPixelOffsetScaleByDistance;
        }
        va = this._vaf.va;
        vaLength = va.length;
        pickList.length = vaLength;
        for (j = 0; j < vaLength; ++j) {
            command = pickList[j];
            if (!defined(command)) {
                command = pickList[j] = new DrawCommand({
                    pass: Pass.OPAQUE,
                    owner: this
                });
            }
            command.boundingVolume = boundingVolume;
            command.modelMatrix = modelMatrix;
            command.count = va[j].indicesCount;
            command.shaderProgram = this._spPick;
            command.uniformMap = this._uniforms;
            command.vertexArray = va[j].va;
            command.renderState = this._rs;
            commandList.push(command);
        }
    }
};
BillboardCollection.prototype.isDestroyed = function () {
    return false;
};
BillboardCollection.prototype.destroy = function () {
    this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
    this._sp = this._sp && this._sp.destroy();
    this._spPick = this._spPick && this._spPick.destroy();
    this._vaf = this._vaf && this._vaf.destroy();
    this._destroyBillboards();
    return destroyObject(this);
};
BillboardCollection.prototype._destroyBillboards = function () {
    var billboards = this._billboards;
    var length = billboards.length;
    for (var i = 0; i < length; ++i) {
        if (billboards[i]) {
            billboards[i]._destroy();
        }
    }
};
module.exports = BillboardCollection;
},{"../Core/AttributeCompression":94,"../Core/BoundingSphere":98,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Color":111,"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/EncodedCartesian3":137,"../Core/IndexDatatype":162,"../Core/Math":174,"../Core/Matrix4":177,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/BufferUsage":339,"../Renderer/DrawCommand":344,"../Renderer/ShaderSource":355,"../Renderer/VertexArrayFacade":364,"../Shaders/BillboardCollectionFS":473,"../Shaders/BillboardCollectionVS":474,"./Billboard":368,"./BlendingState":374,"./HorizontalOrigin":394,"./Pass":419,"./SceneMode":438,"./TextureAtlas":448}],370:[function(require,module,exports){
var BingMapsApi = require('../Core/BingMapsApi'), Cartesian2 = require('../Core/Cartesian2'), Credit = require('../Core/Credit'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), jsonp = require('../Core/jsonp'), CesiumMath = require('../Core/Math'), Rectangle = require('../Core/Rectangle'), TileProviderError = require('../Core/TileProviderError'), WebMercatorTilingScheme = require('../Core/WebMercatorTilingScheme'), when = require('../ThirdParty/when'), BingMapsStyle = require('./BingMapsStyle'), DiscardMissingTileImagePolicy = require('./DiscardMissingTileImagePolicy'), ImageryProvider = require('./ImageryProvider');
'use strict';
var BingMapsImageryProvider = function BingMapsImageryProvider(options) {
    options = defaultValue(options, {});
    if (!defined(options.url)) {
        throw new DeveloperError('options.url is required.');
    }
    this._key = BingMapsApi.getKey(options.key);
    this._url = options.url;
    this._tileProtocol = options.tileProtocol;
    this._mapStyle = defaultValue(options.mapStyle, BingMapsStyle.AERIAL);
    this._culture = defaultValue(options.culture, '');
    this._tileDiscardPolicy = options.tileDiscardPolicy;
    this._proxy = options.proxy;
    this._credit = new Credit('Bing Imagery', BingMapsImageryProvider._logoData, 'http://www.bing.com');
    this.defaultGamma = 1;
    if (this._mapStyle === BingMapsStyle.AERIAL || this._mapStyle === BingMapsStyle.AERIAL_WITH_LABELS) {
        this.defaultGamma = 1.3;
    }
    this._tilingScheme = new WebMercatorTilingScheme({
        numberOfLevelZeroTilesX: 2,
        numberOfLevelZeroTilesY: 2
    });
    this._tileWidth = undefined;
    this._tileHeight = undefined;
    this._maximumLevel = undefined;
    this._imageUrlTemplate = undefined;
    this._imageUrlSubdomains = undefined;
    this._errorEvent = new Event();
    this._ready = false;
    var metadataUrl = this._url + '/REST/v1/Imagery/Metadata/' + this._mapStyle + '?incl=ImageryProviders&key=' + this._key;
    var that = this;
    var metadataError;
    function metadataSuccess(data) {
        var resource = data.resourceSets[0].resources[0];
        that._tileWidth = resource.imageWidth;
        that._tileHeight = resource.imageHeight;
        that._maximumLevel = resource.zoomMax - 1;
        that._imageUrlSubdomains = resource.imageUrlSubdomains;
        that._imageUrlTemplate = resource.imageUrl.replace('{culture}', that._culture);
        var tileProtocol = that._tileProtocol;
        if (!defined(tileProtocol)) {
            var documentProtocol = document.location.protocol;
            tileProtocol = /^http/.test(documentProtocol) ? documentProtocol : 'http:';
        }
        that._imageUrlTemplate = that._imageUrlTemplate.replace(/^http:/, tileProtocol);
        if (!defined(that._tileDiscardPolicy)) {
            that._tileDiscardPolicy = new DiscardMissingTileImagePolicy({
                missingImageUrl: buildImageUrl(that, 0, 0, that._maximumLevel),
                pixelsToCheck: [
                    new Cartesian2(0, 0),
                    new Cartesian2(120, 140),
                    new Cartesian2(130, 160),
                    new Cartesian2(200, 50),
                    new Cartesian2(200, 200)
                ],
                disableCheckIfAllPixelsAreTransparent: true
            });
        }
        var attributionList = that._attributionList = resource.imageryProviders;
        if (!attributionList) {
            attributionList = that._attributionList = [];
        }
        for (var attributionIndex = 0, attributionLength = attributionList.length; attributionIndex < attributionLength; ++attributionIndex) {
            var attribution = attributionList[attributionIndex];
            attribution.credit = new Credit(attribution.attribution);
            var coverageAreas = attribution.coverageAreas;
            for (var areaIndex = 0, areaLength = attribution.coverageAreas.length; areaIndex < areaLength; ++areaIndex) {
                var area = coverageAreas[areaIndex];
                var bbox = area.bbox;
                area.bbox = new Rectangle(CesiumMath.toRadians(bbox[1]), CesiumMath.toRadians(bbox[0]), CesiumMath.toRadians(bbox[3]), CesiumMath.toRadians(bbox[2]));
            }
        }
        that._ready = true;
        TileProviderError.handleSuccess(metadataError);
    }
    function metadataFailure(e) {
        var message = 'An error occurred while accessing ' + metadataUrl + '.';
        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
    }
    function requestMetadata() {
        var metadata = jsonp(metadataUrl, {
                callbackParameterName: 'jsonp',
                proxy: that._proxy
            });
        when(metadata, metadataSuccess, metadataFailure);
    }
    requestMetadata();
};
defineProperties(BingMapsImageryProvider.prototype, {
    url: {
        get: function () {
            return this._url;
        }
    },
    proxy: {
        get: function () {
            return this._proxy;
        }
    },
    key: {
        get: function () {
            return this._key;
        }
    },
    mapStyle: {
        get: function () {
            return this._mapStyle;
        }
    },
    culture: {
        get: function () {
            return this._culture;
        }
    },
    tileWidth: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            return this._tileWidth;
        }
    },
    tileHeight: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            return this._tileHeight;
        }
    },
    maximumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            return this._maximumLevel;
        }
    },
    minimumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            return 0;
        }
    },
    tilingScheme: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            return this._tilingScheme;
        }
    },
    rectangle: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
            }
            return this._tilingScheme.rectangle;
        }
    },
    tileDiscardPolicy: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            return this._tileDiscardPolicy;
        }
    },
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    credit: {
        get: function () {
            return this._credit;
        }
    },
    hasAlphaChannel: {
        get: function () {
            return false;
        }
    }
});
var rectangleScratch = new Rectangle();
BingMapsImageryProvider.prototype.getTileCredits = function (x, y, level) {
    if (!this._ready) {
        throw new DeveloperError('getTileCredits must not be called before the imagery provider is ready.');
    }
    var rectangle = this._tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);
    return getRectangleAttribution(this._attributionList, level, rectangle);
};
BingMapsImageryProvider.prototype.requestImage = function (x, y, level) {
    if (!this._ready) {
        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }
    var url = buildImageUrl(this, x, y, level);
    return ImageryProvider.loadImage(this, url);
};
BingMapsImageryProvider.prototype.pickFeatures = function () {
    return undefined;
};
BingMapsImageryProvider._logoData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAAaCAYAAAAEy1RnAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH3gIDEgcPTMnXOQAAClZJREFUWMPdWGtsFNcV/u689uH1+sXaONhlWQzBENtxiUFBpBSLd60IpXHSNig4URtSYQUkRJNSi0igViVVVBJBaBsiAgKRQJSG8AgEHCCWU4iBCprY2MSgXfOI16y9D3s9Mzsztz9yB12WNU2i9Ecy0tHOzN4793zn3POdcy7BnRfJ8I7iB3SRDPeEExswLz8Y0DZIAYDIRGAgLQAm+7Xle31J3L3Anp1MZPY+BUBjorN332vgYhpgV1FRUd6TTz45ubq6OtDV1SXpuu5g//Oept9wNwlMyAi8IXDjyF245TsDTdivDMATCATGNDU1/WbhwoWPTZs2bWx1dXWhx+Oxrl+/PqTrus5t9W8KWEzjinTAYhro/xuBStwiIgBnJBLxKIoy1u/3V/r9/krDMMz3339/Z3t7e38ikUgCMDLEt8W+Q0cAI3McYTDDmZxh7DESG5Ni43jg9Gsa+X+OsxWxPSJTSj3JZFK5ZRVJErOzs8e6XC4fgGwALhbzDgAKU1hK28KEA6PMmTMn56233qpevnz5PQDcbJ7EzVUAuMrLy3MBeABkcWOEDELSyFe4y7iMoHkriZZlKYZh8ASHZDKpJJPJHAC5APIA5APIAeBlCjo5TwlpXnbOmTPHP3fu3KZVq1atZKBcDJQ9x7V48WJfc3Pzhp6enj+tXLnyR8w4MjdG4gyVDk7KICMClzKlLUrpbQMNw5AkScppbGz8cWdn57WjR4/2caw+DEBlYjO8wX1foZQWuN3uKZIklQD4G+fhlG0Yl8uVm5WVVW6app6dne0D0G8vnxbjJntHubCUOK/badZICyWanrJuAaeUknTQpmlKkUhEWbx48U8LCwtHhUKha+fPn+85fPhwV0tLyzUACSZx9jvMFhIByNFoVDEMw/qKB5HPvJfkUqBr9+7deklJyZ/j8bi5ffv2OAslieMLsG+m2DybT2QuzEQOsF5SUqJfvXo1yc2l6Xn6rgSRSCSEc+fOhVeuXLmwoqJixvTp0wcWLFgQ7unpudHR0dF97ty5z/fu3XseQJh5adjeerquy5ZlCalUivh8Pt8HH3ywzOPxyD09PZ81NjZ+2NnZaQEQx40b54vFYqaqquEVK1b4a2tr/WvWrDn18ssv144fP36SqqoD69ev371nz57rDLwAwHHkyJGfjRs3rtowDOv06dOnu7q6rs6bN2/s7Nmz9zIjDKenWoFZKg/AlMLCwl82Nzf/m3LX22+/fXb06NF/ALC8u7u7m6ZdkUhksL29/UpLS0vzunXrVgAoBzAaQBGAiY2NjUui0ei1RCLRFwwG/9PX19cVi8WCqqoOdHd3HysrK6sDMCccDl8IBoOtiqIsOnbs2D+i0eiV3t7ez8Ph8GeRSKRT07TB/v7+i1OnTp0HYBqABzs7O/+paVo0Fot1RyKRi/F4/Gp/f39XIpHoZnoUMn6wU+ZtRDaymwmxZFk2AWjvvvvuJ/F4PMn/n5+fn1VeXu6fOXNmbU1NzUOM4Bz8QqIoyg6HwxuLxfq3bdu2a+vWrW/09/dfKy0tffDVV199BEC20+n0ud3uQgBup9Pp83g8JYqieE+ePPnxxo0bt33xxRen8/Ly7n3hhRcWASh47bXX5pWVldWFw+GuXbt27XjzzTd3BoPBDq/XG1AUZRRHmAKPVfqaoKkgCCkA+oYNG84Eg0FHTU1N5ezZs8eWlJQ4CSF8/LvZYhJPQoQQpFKpwcrKyo1su9HBwUF99erVv588eXINgOOmacIwDEopdaZSKUIpxYkTJz6sr68/BMBav379RcMwZk2aNOl+AP+qq6t7xDTNVEVFxR+j0WgSAJk4ceKlTz/9tNzpdHpZvIvpjVW6pykhhBJCbkvwgiAQQogEQL558ybdtGlTsLm5OWJZdxZmlmWll5OUEEJN0zSGhob6GcOrALSzZ8/2apqWcLlc2axGACNRkRAimqaph0Kh68xIwwB0y7IMSZKcABz5+fkl8Xj8y2g0apOb5na7rYGBgS/JV54Q0qpAAoBKaS0jBWClg1ZVFeFw2AlgVF1dXeDpp5+eWVFRUVpcXOzgvQwAbrcbDJhdudlGpKZpGtx6JCcnRxIEQbQsS2PjbjM+AMvlchnMSBaXkr7ymCCIhmEYfMoVRVESBEHI0CaTTNubssUsQRBuubCtra33pZdeCk6YMCGwZs2aipqaGn9paWmuJEl3JP0bN258eeTIkRMABrm0YomiaImiKGVlZeWxLecAgBkzZvgdDkfWjRs3ggA0bpfpoiiahBCqKEqKAy2yULMA6MlkMp6Xl3cP1x2SWCwmFhQU+CmlFhfHNFOevpX4LcvSJUkyAeDQoUOh119//fpTTz01Zf78+UWBQCBHUZQ7yE/TNGPfvn0n33vvvSP79+//BECMeZsCMGRZNgRBgNPpHHXx4sVVDQ0Nf1+wYMGYJ554YikAevDgwUMA4oIgQJZlSggZdDqdBiGEZGdn6ww0tQlJURTT4/EMHz9+/MCjjz7622AwuHbZsmVbiouLvWvXrm1wOp3ZqVRqaKQTIInf1gAMl8ulU0q1CxcuBGOxmL5u3bryQCDgycrKEjORXGtra8eOHTsOHz169OyVK1cuA+hlRYrGlNRkWR7UNO2mYRiaz+cb3dLS8gYhhOi6Hj116tSOVatWHQNALcsaME0zLghClBDSZ9+zQsZ2SoJS2udwOKLPPffcvsrKyrJAIPDQ/v37txiGofX19V3r7e29UlBQMHqEVpjwnrYA6PF4PK6q6s2qqqqpZWVlitvtljOB7enpiWzbtu3wgQMHTre1tV0E0MeKkkGuIhMAqHv37u30er3Px+NxlyiKygMPPOAnhFiXLl0Kbd68uYPNsXbu3Lk6mUwaqqr2btmyZUdtbe3hd955pwvAEFNcO3jw4K/b2tqiqqpGIpGI4/HHH/9rQ0PDCa/XOyoSidDLly8PNTU1PcZ4QuNK1ju6NYHFRAGASXPnzv1Fa2vrxzTDpapqateuXR/Nnz+/SVGUhwFMBzCBFSLZLF75DsrJGpXRAH4EIABgPIBxAEoBFAPwARjFif1sNzZ25+VlOhaxufcCqAFQC+BhAPVLliz5XSqVUkOhUAuAKWnFyR3dlsw+fg+A+8eMGfPzTZs2bY9GozEb8JkzZ9qXLl36l+Li4l8B+AmAyQDGsGrOzfXNPGPawG2l85jksmcPm+vihH+2W1iF3bvZPN+sWbPuGx4eDrW3t+85fvz41o6OjmZN04Y0TYvV19cvYIbN5QqUjG2mwj5YAqDK4XDMe+aZZ55vbW09+sorr2yuqqpqYFatAuBn3uB7XzJCY297XeaUd2RoGzOJmHb6IjFj5D777LP3DQwMfDw8PBxSVbUvkUj0hEKhj1588cXH2O7zMSPdplumoxveMx5Zlj3jx4/39vb26gMDA4MsvgYZo+p8Pr7LqQX5Ds/U7d0jFxUVZS1atKg4Nzc317Isp67rZldXV6y5ufkmI78hFtcmrx8ZweMit6XsUs4+6kmlgbW+peLf9gyMZNCR374G0y/FxEzX8b/8+bkXEBxKFwAAAABJRU5ErkJggg==';
BingMapsImageryProvider.tileXYToQuadKey = function (x, y, level) {
    var quadkey = '';
    for (var i = level; i >= 0; --i) {
        var bitmask = 1 << i;
        var digit = 0;
        if ((x & bitmask) !== 0) {
            digit |= 1;
        }
        if ((y & bitmask) !== 0) {
            digit |= 2;
        }
        quadkey += digit;
    }
    return quadkey;
};
BingMapsImageryProvider.quadKeyToTileXY = function (quadkey) {
    var x = 0;
    var y = 0;
    var level = quadkey.length - 1;
    for (var i = level; i >= 0; --i) {
        var bitmask = 1 << i;
        var digit = +quadkey[level - i];
        if ((digit & 1) !== 0) {
            x |= bitmask;
        }
        if ((digit & 2) !== 0) {
            y |= bitmask;
        }
    }
    return {
        x: x,
        y: y,
        level: level
    };
};
function buildImageUrl(imageryProvider, x, y, level) {
    var imageUrl = imageryProvider._imageUrlTemplate;
    var quadkey = BingMapsImageryProvider.tileXYToQuadKey(x, y, level);
    imageUrl = imageUrl.replace('{quadkey}', quadkey);
    var subdomains = imageryProvider._imageUrlSubdomains;
    var subdomainIndex = (x + y + level) % subdomains.length;
    imageUrl = imageUrl.replace('{subdomain}', subdomains[subdomainIndex]);
    var proxy = imageryProvider._proxy;
    if (defined(proxy)) {
        imageUrl = proxy.getURL(imageUrl);
    }
    return imageUrl;
}
var intersectionScratch = new Rectangle();
function getRectangleAttribution(attributionList, level, rectangle) {
    ++level;
    var result = [];
    for (var attributionIndex = 0, attributionLength = attributionList.length; attributionIndex < attributionLength; ++attributionIndex) {
        var attribution = attributionList[attributionIndex];
        var coverageAreas = attribution.coverageAreas;
        var included = false;
        for (var areaIndex = 0, areaLength = attribution.coverageAreas.length; !included && areaIndex < areaLength; ++areaIndex) {
            var area = coverageAreas[areaIndex];
            if (level >= area.zoomMin && level <= area.zoomMax) {
                var intersection = Rectangle.intersection(rectangle, area.bbox, intersectionScratch);
                if (defined(intersection)) {
                    included = true;
                }
            }
        }
        if (included) {
            result.push(attribution.credit);
        }
    }
    return result;
}
module.exports = BingMapsImageryProvider;
},{"../Core/BingMapsApi":96,"../Core/Cartesian2":101,"../Core/Credit":118,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/Math":174,"../Core/Rectangle":201,"../Core/TileProviderError":220,"../Core/WebMercatorTilingScheme":234,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/jsonp":256,"../ThirdParty/when":596,"./BingMapsStyle":371,"./DiscardMissingTileImagePolicy":383,"./ImageryProvider":399}],371:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var BingMapsStyle = {
        AERIAL: 'Aerial',
        AERIAL_WITH_LABELS: 'AerialWithLabels',
        ROAD: 'Road',
        ORDNANCE_SURVEY: 'OrdnanceSurvey',
        COLLINS_BART: 'CollinsBart'
    };
module.exports = freezeObject(BingMapsStyle);
},{"../Core/freezeObject":249}],372:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var BlendEquation = {
        ADD: 32774,
        SUBTRACT: 32778,
        REVERSE_SUBTRACT: 32779
    };
module.exports = freezeObject(BlendEquation);
},{"../Core/freezeObject":249}],373:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var BlendFunction = {
        ZERO: 0,
        ONE: 1,
        SOURCE_COLOR: 768,
        ONE_MINUS_SOURCE_COLOR: 769,
        DESTINATION_COLOR: 774,
        ONE_MINUS_DESTINATION_COLOR: 775,
        SOURCE_ALPHA: 770,
        ONE_MINUS_SOURCE_ALPHA: 771,
        DESTINATION_ALPHA: 772,
        ONE_MINUS_DESTINATION_ALPHA: 773,
        CONSTANT_COLOR: 32769,
        ONE_MINUS_CONSTANT_COLOR: 32770,
        CONSTANT_ALPHA: 32771,
        ONE_MINUS_CONSTANT_ALPHA: 32772,
        SOURCE_ALPHA_SATURATE: 776
    };
module.exports = freezeObject(BlendFunction);
},{"../Core/freezeObject":249}],374:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject'), BlendEquation = require('./BlendEquation'), BlendFunction = require('./BlendFunction');
'use strict';
var BlendingState = {
        DISABLED: freezeObject({ enabled: false }),
        ALPHA_BLEND: freezeObject({
            enabled: true,
            equationRgb: BlendEquation.ADD,
            equationAlpha: BlendEquation.ADD,
            functionSourceRgb: BlendFunction.SOURCE_ALPHA,
            functionSourceAlpha: BlendFunction.SOURCE_ALPHA,
            functionDestinationRgb: BlendFunction.ONE_MINUS_SOURCE_ALPHA,
            functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA
        }),
        PRE_MULTIPLIED_ALPHA_BLEND: freezeObject({
            enabled: true,
            equationRgb: BlendEquation.ADD,
            equationAlpha: BlendEquation.ADD,
            functionSourceRgb: BlendFunction.ONE,
            functionSourceAlpha: BlendFunction.ONE,
            functionDestinationRgb: BlendFunction.ONE_MINUS_SOURCE_ALPHA,
            functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA
        }),
        ADDITIVE_BLEND: freezeObject({
            enabled: true,
            equationRgb: BlendEquation.ADD,
            equationAlpha: BlendEquation.ADD,
            functionSourceRgb: BlendFunction.SOURCE_ALPHA,
            functionSourceAlpha: BlendFunction.SOURCE_ALPHA,
            functionDestinationRgb: BlendFunction.ONE,
            functionDestinationAlpha: BlendFunction.ONE
        })
    };
module.exports = freezeObject(BlendingState);
},{"../Core/freezeObject":249,"./BlendEquation":372,"./BlendFunction":373}],375:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Cartographic = require('../Core/Cartographic'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), deprecationWarning = require('../Core/deprecationWarning'), DeveloperError = require('../Core/DeveloperError'), EasingFunction = require('../Core/EasingFunction'), Ellipsoid = require('../Core/Ellipsoid'), IntersectionTests = require('../Core/IntersectionTests'), CesiumMath = require('../Core/Math'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), Quaternion = require('../Core/Quaternion'), Ray = require('../Core/Ray'), Rectangle = require('../Core/Rectangle'), Transforms = require('../Core/Transforms'), CameraFlightPath = require('./CameraFlightPath'), PerspectiveFrustum = require('./PerspectiveFrustum'), SceneMode = require('./SceneMode');
'use strict';
var Camera = function (scene) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    this._scene = scene;
    this.transform = Matrix4.clone(Matrix4.IDENTITY);
    this._transform = Matrix4.clone(Matrix4.IDENTITY);
    this._invTransform = Matrix4.clone(Matrix4.IDENTITY);
    this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);
    this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);
    this.position = new Cartesian3();
    this._position = new Cartesian3();
    this._positionWC = new Cartesian3();
    this._positionCartographic = new Cartographic();
    this.direction = new Cartesian3();
    this._direction = new Cartesian3();
    this._directionWC = new Cartesian3();
    this.up = new Cartesian3();
    this._up = new Cartesian3();
    this._upWC = new Cartesian3();
    this.right = new Cartesian3();
    this._right = new Cartesian3();
    this._rightWC = new Cartesian3();
    this.frustum = new PerspectiveFrustum();
    this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;
    this.frustum.fov = CesiumMath.toRadians(60);
    this.defaultMoveAmount = 100000;
    this.defaultLookAmount = Math.PI / 60;
    this.defaultRotateAmount = Math.PI / 3600;
    this.defaultZoomAmount = 100000;
    this.constrainedAxis = undefined;
    this.maximumTranslateFactor = 1.5;
    this.maximumZoomFactor = 2.5;
    this._viewMatrix = new Matrix4();
    this._invViewMatrix = new Matrix4();
    updateViewMatrix(this);
    this._mode = SceneMode.SCENE3D;
    this._modeChanged = true;
    var projection = scene.mapProjection;
    this._projection = projection;
    this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO));
    this._max2Dfrustum = undefined;
    this.viewRectangle(Camera.DEFAULT_VIEW_RECTANGLE);
    var mag = Cartesian3.magnitude(this.position);
    mag += mag * Camera.DEFAULT_VIEW_FACTOR;
    Cartesian3.normalize(this.position, this.position);
    Cartesian3.multiplyByScalar(this.position, mag, this.position);
};
Camera.TRANSFORM_2D = new Matrix4(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
Camera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(Camera.TRANSFORM_2D, new Matrix4());
Camera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(-95, -20, -70, 90);
Camera.DEFAULT_VIEW_FACTOR = 0.5;
function updateViewMatrix(camera) {
    var r = camera._right;
    var u = camera._up;
    var d = camera._direction;
    var e = camera._position;
    var viewMatrix = camera._viewMatrix;
    viewMatrix[0] = r.x;
    viewMatrix[1] = u.x;
    viewMatrix[2] = -d.x;
    viewMatrix[3] = 0;
    viewMatrix[4] = r.y;
    viewMatrix[5] = u.y;
    viewMatrix[6] = -d.y;
    viewMatrix[7] = 0;
    viewMatrix[8] = r.z;
    viewMatrix[9] = u.z;
    viewMatrix[10] = -d.z;
    viewMatrix[11] = 0;
    viewMatrix[12] = -Cartesian3.dot(r, e);
    viewMatrix[13] = -Cartesian3.dot(u, e);
    viewMatrix[14] = Cartesian3.dot(d, e);
    viewMatrix[15] = 1;
    Matrix4.multiply(viewMatrix, camera._actualInvTransform, camera._viewMatrix);
    Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);
}
var scratchCartographic = new Cartographic();
var scratchCartesian3Projection = new Cartesian3();
var scratchCartesian3 = new Cartesian3();
var scratchCartesian4Origin = new Cartesian4();
var scratchCartesian4NewOrigin = new Cartesian4();
var scratchCartesian4NewXAxis = new Cartesian4();
var scratchCartesian4NewYAxis = new Cartesian4();
var scratchCartesian4NewZAxis = new Cartesian4();
function convertTransformForColumbusView(camera) {
    var projection = camera._projection;
    var ellipsoid = projection.ellipsoid;
    var origin = Matrix4.getColumn(camera._transform, 3, scratchCartesian4Origin);
    var cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);
    var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);
    var newOrigin = scratchCartesian4NewOrigin;
    newOrigin.x = projectedPosition.z;
    newOrigin.y = projectedPosition.x;
    newOrigin.z = projectedPosition.y;
    newOrigin.w = 1;
    var xAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 0, scratchCartesian3), origin, scratchCartesian3);
    ellipsoid.cartesianToCartographic(xAxis, cartographic);
    projection.project(cartographic, projectedPosition);
    var newXAxis = scratchCartesian4NewXAxis;
    newXAxis.x = projectedPosition.z;
    newXAxis.y = projectedPosition.x;
    newXAxis.z = projectedPosition.y;
    newXAxis.w = 0;
    Cartesian3.subtract(newXAxis, newOrigin, newXAxis);
    var yAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 1, scratchCartesian3), origin, scratchCartesian3);
    ellipsoid.cartesianToCartographic(yAxis, cartographic);
    projection.project(cartographic, projectedPosition);
    var newYAxis = scratchCartesian4NewYAxis;
    newYAxis.x = projectedPosition.z;
    newYAxis.y = projectedPosition.x;
    newYAxis.z = projectedPosition.y;
    newYAxis.w = 0;
    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);
    var newZAxis = scratchCartesian4NewZAxis;
    Cartesian3.cross(newXAxis, newYAxis, newZAxis);
    Cartesian3.normalize(newZAxis, newZAxis);
    Cartesian3.cross(newYAxis, newZAxis, newXAxis);
    Cartesian3.normalize(newXAxis, newXAxis);
    Cartesian3.cross(newZAxis, newXAxis, newYAxis);
    Cartesian3.normalize(newYAxis, newYAxis);
    Matrix4.setColumn(camera._actualTransform, 0, newXAxis, camera._actualTransform);
    Matrix4.setColumn(camera._actualTransform, 1, newYAxis, camera._actualTransform);
    Matrix4.setColumn(camera._actualTransform, 2, newZAxis, camera._actualTransform);
    Matrix4.setColumn(camera._actualTransform, 3, newOrigin, camera._actualTransform);
}
function convertTransformFor2D(camera) {
    var projection = camera._projection;
    var ellipsoid = projection.ellipsoid;
    var origin = Matrix4.getColumn(camera._transform, 3, scratchCartesian4Origin);
    var cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);
    var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);
    var newOrigin = scratchCartesian4NewOrigin;
    newOrigin.x = projectedPosition.z;
    newOrigin.y = projectedPosition.x;
    newOrigin.z = projectedPosition.y;
    newOrigin.w = 1;
    var newZAxis = Cartesian4.clone(Cartesian4.UNIT_X, scratchCartesian4NewZAxis);
    var xAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 0, scratchCartesian3), origin, scratchCartesian3);
    ellipsoid.cartesianToCartographic(xAxis, cartographic);
    projection.project(cartographic, projectedPosition);
    var newXAxis = scratchCartesian4NewXAxis;
    newXAxis.x = projectedPosition.z;
    newXAxis.y = projectedPosition.x;
    newXAxis.z = projectedPosition.y;
    newXAxis.w = 0;
    Cartesian3.subtract(newXAxis, newOrigin, newXAxis);
    newXAxis.x = 0;
    var newYAxis = scratchCartesian4NewYAxis;
    if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {
        Cartesian3.cross(newZAxis, newXAxis, newYAxis);
    } else {
        var yAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 1, scratchCartesian3), origin, scratchCartesian3);
        ellipsoid.cartesianToCartographic(yAxis, cartographic);
        projection.project(cartographic, projectedPosition);
        newYAxis.x = projectedPosition.z;
        newYAxis.y = projectedPosition.x;
        newYAxis.z = projectedPosition.y;
        newYAxis.w = 0;
        Cartesian3.subtract(newYAxis, newOrigin, newYAxis);
        newYAxis.x = 0;
        if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {
            Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);
            Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);
        }
    }
    Cartesian3.cross(newYAxis, newZAxis, newXAxis);
    Cartesian3.normalize(newXAxis, newXAxis);
    Cartesian3.cross(newZAxis, newXAxis, newYAxis);
    Cartesian3.normalize(newYAxis, newYAxis);
    Matrix4.setColumn(camera._actualTransform, 0, newXAxis, camera._actualTransform);
    Matrix4.setColumn(camera._actualTransform, 1, newYAxis, camera._actualTransform);
    Matrix4.setColumn(camera._actualTransform, 2, newZAxis, camera._actualTransform);
    Matrix4.setColumn(camera._actualTransform, 3, newOrigin, camera._actualTransform);
}
var scratchCartesian = new Cartesian3();
function updateMembers(camera) {
    var position = camera._position;
    var positionChanged = !Cartesian3.equals(position, camera.position);
    if (positionChanged) {
        position = Cartesian3.clone(camera.position, camera._position);
    }
    var direction = camera._direction;
    var directionChanged = !Cartesian3.equals(direction, camera.direction);
    if (directionChanged) {
        direction = Cartesian3.clone(camera.direction, camera._direction);
    }
    var up = camera._up;
    var upChanged = !Cartesian3.equals(up, camera.up);
    if (upChanged) {
        up = Cartesian3.clone(camera.up, camera._up);
    }
    var right = camera._right;
    var rightChanged = !Cartesian3.equals(right, camera.right);
    if (rightChanged) {
        right = Cartesian3.clone(camera.right, camera._right);
    }
    var transformChanged = !Matrix4.equals(camera._transform, camera.transform) || camera._modeChanged;
    if (transformChanged) {
        Matrix4.clone(camera.transform, camera._transform);
        Matrix4.inverseTransformation(camera._transform, camera._invTransform);
        if (camera._mode === SceneMode.COLUMBUS_VIEW || camera._mode === SceneMode.SCENE2D) {
            if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {
                Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);
            } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {
                convertTransformForColumbusView(camera);
            } else {
                convertTransformFor2D(camera);
            }
        } else {
            Matrix4.clone(camera._transform, camera._actualTransform);
        }
        Matrix4.inverseTransformation(camera._actualTransform, camera._actualInvTransform);
        camera._modeChanged = false;
    }
    var transform = camera._actualTransform;
    if (positionChanged || transformChanged) {
        camera._positionWC = Matrix4.multiplyByPoint(transform, position, camera._positionWC);
        var mode = camera._mode;
        if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {
            camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(camera._positionWC, camera._positionCartographic);
        } else {
            var positionENU = scratchCartesian;
            positionENU.x = camera._positionWC.y;
            positionENU.y = camera._positionWC.z;
            positionENU.z = camera._positionWC.x;
            if (mode === SceneMode.SCENE2D) {
                positionENU.z = (camera.frustum.right - camera.frustum.left) * 0.5;
            }
            camera._projection.unproject(positionENU, camera._positionCartographic);
        }
    }
    if (directionChanged || upChanged || rightChanged) {
        var det = Cartesian3.dot(direction, Cartesian3.cross(up, right, scratchCartesian));
        if (Math.abs(1 - det) > CesiumMath.EPSILON2) {
            direction = Cartesian3.normalize(direction, camera._direction);
            Cartesian3.clone(direction, camera.direction);
            var invUpMag = 1 / Cartesian3.magnitudeSquared(up);
            var scalar = Cartesian3.dot(up, direction) * invUpMag;
            var w0 = Cartesian3.multiplyByScalar(direction, scalar, scratchCartesian);
            up = Cartesian3.normalize(Cartesian3.subtract(up, w0, camera._up), camera._up);
            Cartesian3.clone(up, camera.up);
            right = Cartesian3.cross(direction, up, camera._right);
            Cartesian3.clone(right, camera.right);
        }
    }
    if (directionChanged || transformChanged) {
        camera._directionWC = Matrix4.multiplyByPointAsVector(transform, direction, camera._directionWC);
    }
    if (upChanged || transformChanged) {
        camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);
    }
    if (rightChanged || transformChanged) {
        camera._rightWC = Matrix4.multiplyByPointAsVector(transform, right, camera._rightWC);
    }
    if (positionChanged || directionChanged || upChanged || rightChanged || transformChanged) {
        updateViewMatrix(camera);
    }
}
var scratchHPRMatrix1 = new Matrix4();
var scratchHPRMatrix2 = new Matrix4();
defineProperties(Camera.prototype, {
    inverseTransform: {
        get: function () {
            updateMembers(this);
            return this._invTransform;
        }
    },
    viewMatrix: {
        get: function () {
            updateMembers(this);
            return this._viewMatrix;
        }
    },
    inverseViewMatrix: {
        get: function () {
            updateMembers(this);
            return this._invViewMatrix;
        }
    },
    positionCartographic: {
        get: function () {
            updateMembers(this);
            return this._positionCartographic;
        }
    },
    positionWC: {
        get: function () {
            updateMembers(this);
            return this._positionWC;
        }
    },
    directionWC: {
        get: function () {
            updateMembers(this);
            return this._directionWC;
        }
    },
    upWC: {
        get: function () {
            updateMembers(this);
            return this._upWC;
        }
    },
    rightWC: {
        get: function () {
            updateMembers(this);
            return this._rightWC;
        }
    },
    heading: {
        get: function () {
            if (this._mode !== SceneMode.MORPHING) {
                var origin = this.positionWC;
                var ellipsoid = this._projection.ellipsoid;
                var oldTransform = Matrix4.clone(this.transform, scratchHPRMatrix1);
                var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);
                this.setTransform(transform);
                var right = this.right;
                var direction = this.direction;
                var heading;
                if (Math.abs(direction.z) < Math.abs(right.z)) {
                    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;
                } else {
                    heading = Math.atan2(right.y, right.x);
                }
                this.setTransform(oldTransform);
                return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);
            }
            return undefined;
        },
        set: function (angle) {
            deprecationWarning('Camera.heading', 'Camera.heading was deprecated in Cesium 1.6. It will be removed in Cesium 1.7. Use Camera.setView.');
            if (!defined(angle)) {
                throw new DeveloperError('angle is required.');
            }
            if (this._mode !== SceneMode.MORPHING) {
                this.setView({ heading: angle });
            }
        }
    },
    pitch: {
        get: function () {
            if (this._mode === SceneMode.COLUMBUS_VIEW || this._mode === SceneMode.SCENE3D) {
                var origin = this.positionWC;
                var ellipsoid = this._projection.ellipsoid;
                var oldTransform = Matrix4.clone(this.transform, scratchHPRMatrix1);
                var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);
                this.setTransform(transform);
                var pitch = CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(this.direction.z);
                this.setTransform(oldTransform);
                return pitch;
            }
            return undefined;
        }
    },
    tilt: {
        get: function () {
            deprecationWarning('Camera.tilt', 'Camera.tilt was deprecated in Cesium 1.6. It will be removed in Cesium 1.7. Use Camera.pitch.');
            return this.pitch;
        },
        set: function (angle) {
            deprecationWarning('Camera.tilt', 'Camera.tilt was deprecated in Cesium 1.6. It will be removed in Cesium 1.7. Use Camera.setView.');
            if (!defined(angle)) {
                throw new DeveloperError('angle is required.');
            }
            if (this._mode === SceneMode.COLUMBUS_VIEW || this._mode === SceneMode.SCENE3D) {
                this.setView({ pitch: angle });
            }
        }
    },
    roll: {
        get: function () {
            if (this._mode === SceneMode.COLUMBUS_VIEW || this._mode === SceneMode.SCENE3D) {
                var origin = this.positionWC;
                var ellipsoid = this._projection.ellipsoid;
                var oldTransform = Matrix4.clone(this.transform, scratchHPRMatrix1);
                var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);
                this.setTransform(transform);
                var up = this.up;
                var right = this.right;
                var roll = Math.acos(-right.z) - CesiumMath.PI_OVER_TWO;
                if (up.z < 0) {
                    roll = CesiumMath.PI - roll;
                }
                this.setTransform(oldTransform);
                return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(roll);
            }
            return undefined;
        }
    }
});
Camera.prototype.update = function (mode) {
    if (!defined(mode)) {
        throw new DeveloperError('mode is required.');
    }
    var updateFrustum = false;
    if (mode !== this._mode) {
        this._mode = mode;
        this._modeChanged = mode !== SceneMode.MORPHING;
        updateFrustum = this._mode === SceneMode.SCENE2D;
    }
    if (updateFrustum) {
        var frustum = this._max2Dfrustum = this.frustum.clone();
        if (!defined(frustum.left) || !defined(frustum.right) || !defined(frustum.top) || !defined(frustum.bottom)) {
            throw new DeveloperError('The camera frustum is expected to be orthographic for 2D camera control.');
        }
        var maxZoomOut = 2;
        var ratio = frustum.top / frustum.right;
        frustum.right = this._maxCoord.x * maxZoomOut;
        frustum.left = -frustum.right;
        frustum.top = ratio * frustum.right;
        frustum.bottom = -frustum.top;
    }
};
var setTransformPosition = new Cartesian3();
var setTransformUp = new Cartesian3();
var setTransformDirection = new Cartesian3();
Camera.prototype.setTransform = function (transform) {
    var position = Cartesian3.clone(this.positionWC, setTransformPosition);
    var up = Cartesian3.clone(this.upWC, setTransformUp);
    var direction = Cartesian3.clone(this.directionWC, setTransformDirection);
    Matrix4.clone(transform, this.transform);
    updateMembers(this);
    var inverse = this._actualInvTransform;
    Matrix4.multiplyByPoint(inverse, position, this.position);
    Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);
    Matrix4.multiplyByPointAsVector(inverse, up, this.up);
    Cartesian3.cross(this.direction, this.up, this.right);
};
var scratchSetViewCartesian = new Cartesian3();
var scratchSetViewTransform1 = new Matrix4();
var scratchSetViewTransform2 = new Matrix4();
var scratchSetViewQuaternion = new Quaternion();
var scratchSetViewMatrix3 = new Matrix3();
var scratchSetViewCartographic = new Cartographic();
Camera.prototype.setView = function (options) {
    if (this._mode === SceneMode.MORPHING) {
        return;
    }
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var scene2D = this._mode === SceneMode.SCENE2D;
    var sceneCV = this._mode === SceneMode.COLUMBUS_VIEW;
    var heading = defaultValue(options.heading, this.heading);
    var pitch = scene2D ? -CesiumMath.PI_OVER_TWO : defaultValue(options.pitch, this.pitch);
    var roll = scene2D ? 0 : defaultValue(options.roll, this.roll);
    if (sceneCV) {
        roll = -roll;
    }
    var cartesian = options.position;
    var cartographic = options.positionCartographic;
    var projection = this._projection;
    var ellipsoid = projection.ellipsoid;
    if (!defined(cartesian)) {
        if (defined(cartographic)) {
            cartesian = ellipsoid.cartographicToCartesian(cartographic, scratchSetViewCartesian);
        } else {
            cartesian = Cartesian3.clone(this.positionWC, scratchSetViewCartesian);
        }
    }
    var currentTransform = Matrix4.clone(this.transform, scratchSetViewTransform1);
    var localTransform = Transforms.eastNorthUpToFixedFrame(cartesian, ellipsoid, scratchSetViewTransform2);
    this.setTransform(localTransform);
    if (scene2D) {
        Cartesian2.clone(Cartesian3.ZERO, this.position);
        var cartographic2D = ellipsoid.cartesianToCartographic(cartesian, scratchSetViewCartographic);
        var newLeft = -cartographic2D.height * 0.5;
        var newRight = -newLeft;
        var frustum = this.frustum;
        if (newRight > newLeft) {
            var ratio = frustum.top / frustum.right;
            frustum.right = newRight;
            frustum.left = newLeft;
            frustum.top = frustum.right * ratio;
            frustum.bottom = -frustum.top;
        }
    } else {
        Cartesian3.clone(Cartesian3.ZERO, this.position);
    }
    var rotQuat = Quaternion.fromHeadingPitchRoll(heading - CesiumMath.PI_OVER_TWO, pitch, roll, scratchSetViewQuaternion);
    var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);
    Matrix3.getColumn(rotMat, 0, this.direction);
    Matrix3.getColumn(rotMat, 2, this.up);
    Cartesian3.cross(this.direction, this.up, this.right);
    this.setTransform(currentTransform);
};
Camera.prototype.worldToCameraCoordinates = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        result = new Cartesian4();
    }
    updateMembers(this);
    return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);
};
Camera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    updateMembers(this);
    return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);
};
Camera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    updateMembers(this);
    return Matrix4.multiplyByPointAsVector(this._actualInvTransform, cartesian, result);
};
Camera.prototype.cameraToWorldCoordinates = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        result = new Cartesian4();
    }
    updateMembers(this);
    return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);
};
Camera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    updateMembers(this);
    return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);
};
Camera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {
    if (!defined(cartesian)) {
        throw new DeveloperError('cartesian is required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    updateMembers(this);
    return Matrix4.multiplyByPointAsVector(this._actualTransform, cartesian, result);
};
function clampMove2D(camera, position) {
    var maxX = camera._maxCoord.x * camera.maximumTranslateFactor;
    if (position.x > maxX) {
        position.x = maxX;
    }
    if (position.x < -maxX) {
        position.x = -maxX;
    }
    var maxY = camera._maxCoord.y * camera.maximumTranslateFactor;
    if (position.y > maxY) {
        position.y = maxY;
    }
    if (position.y < -maxY) {
        position.y = -maxY;
    }
}
var moveScratch = new Cartesian3();
Camera.prototype.move = function (direction, amount) {
    if (!defined(direction)) {
        throw new DeveloperError('direction is required.');
    }
    var cameraPosition = this.position;
    Cartesian3.multiplyByScalar(direction, amount, moveScratch);
    Cartesian3.add(cameraPosition, moveScratch, cameraPosition);
    if (this._mode === SceneMode.SCENE2D) {
        clampMove2D(this, cameraPosition);
    }
};
Camera.prototype.moveForward = function (amount) {
    amount = defaultValue(amount, this.defaultMoveAmount);
    this.move(this.direction, amount);
};
Camera.prototype.moveBackward = function (amount) {
    amount = defaultValue(amount, this.defaultMoveAmount);
    this.move(this.direction, -amount);
};
Camera.prototype.moveUp = function (amount) {
    amount = defaultValue(amount, this.defaultMoveAmount);
    this.move(this.up, amount);
};
Camera.prototype.moveDown = function (amount) {
    amount = defaultValue(amount, this.defaultMoveAmount);
    this.move(this.up, -amount);
};
Camera.prototype.moveRight = function (amount) {
    amount = defaultValue(amount, this.defaultMoveAmount);
    this.move(this.right, amount);
};
Camera.prototype.moveLeft = function (amount) {
    amount = defaultValue(amount, this.defaultMoveAmount);
    this.move(this.right, -amount);
};
Camera.prototype.lookLeft = function (amount) {
    amount = defaultValue(amount, this.defaultLookAmount);
    this.look(this.up, -amount);
};
Camera.prototype.lookRight = function (amount) {
    amount = defaultValue(amount, this.defaultLookAmount);
    this.look(this.up, amount);
};
Camera.prototype.lookUp = function (amount) {
    amount = defaultValue(amount, this.defaultLookAmount);
    this.look(this.right, -amount);
};
Camera.prototype.lookDown = function (amount) {
    amount = defaultValue(amount, this.defaultLookAmount);
    this.look(this.right, amount);
};
var lookScratchQuaternion = new Quaternion();
var lookScratchMatrix = new Matrix3();
Camera.prototype.look = function (axis, angle) {
    if (!defined(axis)) {
        throw new DeveloperError('axis is required.');
    }
    var turnAngle = defaultValue(angle, this.defaultLookAmount);
    var quaternion = Quaternion.fromAxisAngle(axis, -turnAngle, lookScratchQuaternion);
    var rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);
    var direction = this.direction;
    var up = this.up;
    var right = this.right;
    Matrix3.multiplyByVector(rotation, direction, direction);
    Matrix3.multiplyByVector(rotation, up, up);
    Matrix3.multiplyByVector(rotation, right, right);
};
Camera.prototype.twistLeft = function (amount) {
    amount = defaultValue(amount, this.defaultLookAmount);
    this.look(this.direction, amount);
};
Camera.prototype.twistRight = function (amount) {
    amount = defaultValue(amount, this.defaultLookAmount);
    this.look(this.direction, -amount);
};
var rotateScratchQuaternion = new Quaternion();
var rotateScratchMatrix = new Matrix3();
Camera.prototype.rotate = function (axis, angle) {
    if (!defined(axis)) {
        throw new DeveloperError('axis is required.');
    }
    var turnAngle = defaultValue(angle, this.defaultRotateAmount);
    var quaternion = Quaternion.fromAxisAngle(axis, -turnAngle, rotateScratchQuaternion);
    var rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);
    Matrix3.multiplyByVector(rotation, this.position, this.position);
    Matrix3.multiplyByVector(rotation, this.direction, this.direction);
    Matrix3.multiplyByVector(rotation, this.up, this.up);
    Cartesian3.cross(this.direction, this.up, this.right);
    Cartesian3.cross(this.right, this.direction, this.up);
};
Camera.prototype.rotateDown = function (angle) {
    angle = defaultValue(angle, this.defaultRotateAmount);
    rotateVertical(this, angle);
};
Camera.prototype.rotateUp = function (angle) {
    angle = defaultValue(angle, this.defaultRotateAmount);
    rotateVertical(this, -angle);
};
var rotateVertScratchP = new Cartesian3();
var rotateVertScratchA = new Cartesian3();
var rotateVertScratchTan = new Cartesian3();
var rotateVertScratchNegate = new Cartesian3();
function rotateVertical(camera, angle) {
    var position = camera.position;
    var p = Cartesian3.normalize(position, rotateVertScratchP);
    if (defined(camera.constrainedAxis)) {
        var northParallel = Cartesian3.equalsEpsilon(p, camera.constrainedAxis, CesiumMath.EPSILON2);
        var southParallel = Cartesian3.equalsEpsilon(p, Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate), CesiumMath.EPSILON2);
        if (!northParallel && !southParallel) {
            var constrainedAxis = Cartesian3.normalize(camera.constrainedAxis, rotateVertScratchA);
            var dot = Cartesian3.dot(p, constrainedAxis);
            var angleToAxis = CesiumMath.acosClamped(dot);
            if (angle > 0 && angle > angleToAxis) {
                angle = angleToAxis - CesiumMath.EPSILON4;
            }
            dot = Cartesian3.dot(p, Cartesian3.negate(constrainedAxis, rotateVertScratchNegate));
            angleToAxis = CesiumMath.acosClamped(dot);
            if (angle < 0 && -angle > angleToAxis) {
                angle = -angleToAxis + CesiumMath.EPSILON4;
            }
            var tangent = Cartesian3.cross(constrainedAxis, p, rotateVertScratchTan);
            camera.rotate(tangent, angle);
        } else if (northParallel && angle < 0 || southParallel && angle > 0) {
            camera.rotate(camera.right, angle);
        }
    } else {
        camera.rotate(camera.right, angle);
    }
}
Camera.prototype.rotateRight = function (angle) {
    angle = defaultValue(angle, this.defaultRotateAmount);
    rotateHorizontal(this, -angle);
};
Camera.prototype.rotateLeft = function (angle) {
    angle = defaultValue(angle, this.defaultRotateAmount);
    rotateHorizontal(this, angle);
};
function rotateHorizontal(camera, angle) {
    if (defined(camera.constrainedAxis)) {
        camera.rotate(camera.constrainedAxis, angle);
    } else {
        camera.rotate(camera.up, angle);
    }
}
function zoom2D(camera, amount) {
    var frustum = camera.frustum;
    if (!defined(frustum.left) || !defined(frustum.right) || !defined(frustum.top) || !defined(frustum.bottom)) {
        throw new DeveloperError('The camera frustum is expected to be orthographic for 2D camera control.');
    }
    amount = amount * 0.5;
    var newRight = frustum.right - amount;
    var newLeft = frustum.left + amount;
    var maxRight = camera._maxCoord.x * camera.maximumZoomFactor;
    if (newRight > maxRight) {
        newRight = maxRight;
        newLeft = -maxRight;
    }
    if (newRight <= newLeft) {
        newRight = 1;
        newLeft = -1;
    }
    var ratio = frustum.top / frustum.right;
    frustum.right = newRight;
    frustum.left = newLeft;
    frustum.top = frustum.right * ratio;
    frustum.bottom = -frustum.top;
}
function zoom3D(camera, amount) {
    camera.move(camera.direction, amount);
}
Camera.prototype.zoomIn = function (amount) {
    amount = defaultValue(amount, this.defaultZoomAmount);
    if (this._mode === SceneMode.SCENE2D) {
        zoom2D(this, amount);
    } else {
        zoom3D(this, amount);
    }
};
Camera.prototype.zoomOut = function (amount) {
    amount = defaultValue(amount, this.defaultZoomAmount);
    if (this._mode === SceneMode.SCENE2D) {
        zoom2D(this, -amount);
    } else {
        zoom3D(this, -amount);
    }
};
Camera.prototype.getMagnitude = function () {
    if (this._mode === SceneMode.SCENE3D) {
        return Cartesian3.magnitude(this.position);
    } else if (this._mode === SceneMode.COLUMBUS_VIEW) {
        return Math.abs(this.position.z);
    } else if (this._mode === SceneMode.SCENE2D) {
        return Math.max(this.frustum.right - this.frustum.left, this.frustum.top - this.frustum.bottom);
    }
};
Camera.prototype.setPositionCartographic = function (cartographic) {
    deprecationWarning('Camera.setPositionCartographic', 'Camera.setPositionCartographic was deprecated in Cesium 1.6. It will be removed in Cesium 1.7. Use Camera.setView.');
    if (!defined(cartographic)) {
        throw new DeveloperError('cartographic is required.');
    }
    this.setView({
        cartographic: cartographic,
        heading: 0,
        pitch: -CesiumMath.PI_OVER_TWO,
        roll: 0
    });
};
Camera.prototype.lookAt = function (eye, target, up) {
    if (!defined(eye)) {
        throw new DeveloperError('eye is required');
    }
    if (!defined(target)) {
        throw new DeveloperError('target is required');
    }
    if (!defined(up)) {
        throw new DeveloperError('up is required');
    }
    if (this._mode === SceneMode.MORPHING) {
        throw new DeveloperError('lookAt is not supported while morphing.');
    }
    if (this._mode === SceneMode.SCENE2D) {
        Cartesian2.clone(target, this.position);
        Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);
        Cartesian3.clone(up, this.up);
        this.up.z = 0;
        if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {
            Cartesian3.clone(Cartesian3.UNIT_Y, this.up);
        }
        Cartesian3.cross(this.direction, this.up, this.right);
        var frustum = this.frustum;
        var ratio = frustum.top / frustum.right;
        frustum.right = eye.z;
        frustum.left = -frustum.right;
        frustum.top = ratio * frustum.right;
        frustum.bottom = -frustum.top;
        return;
    }
    this.position = Cartesian3.clone(eye, this.position);
    this.direction = Cartesian3.normalize(Cartesian3.subtract(target, eye, this.direction), this.direction);
    this.right = Cartesian3.normalize(Cartesian3.cross(this.direction, up, this.right), this.right);
    this.up = Cartesian3.cross(this.right, this.direction, this.up);
};
var viewRectangle3DCartographic = new Cartographic();
var viewRectangle3DNorthEast = new Cartesian3();
var viewRectangle3DSouthWest = new Cartesian3();
var viewRectangle3DNorthWest = new Cartesian3();
var viewRectangle3DSouthEast = new Cartesian3();
var viewRectangle3DCenter = new Cartesian3();
var defaultRF = {
        direction: new Cartesian3(),
        right: new Cartesian3(),
        up: new Cartesian3()
    };
function rectangleCameraPosition3D(camera, rectangle, ellipsoid, result, positionOnly) {
    if (!defined(result)) {
        result = new Cartesian3();
    }
    var cameraRF = camera;
    if (positionOnly) {
        cameraRF = defaultRF;
    }
    var north = rectangle.north;
    var south = rectangle.south;
    var east = rectangle.east;
    var west = rectangle.west;
    if (west > east) {
        east += CesiumMath.TWO_PI;
    }
    var cart = viewRectangle3DCartographic;
    cart.longitude = east;
    cart.latitude = north;
    var northEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthEast);
    cart.latitude = south;
    var southEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthEast);
    cart.longitude = west;
    var southWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthWest);
    cart.latitude = north;
    var northWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthWest);
    var center = Cartesian3.subtract(northEast, southWest, viewRectangle3DCenter);
    Cartesian3.multiplyByScalar(center, 0.5, center);
    Cartesian3.add(southWest, center, center);
    var mag = Cartesian3.magnitude(center);
    if (mag < CesiumMath.EPSILON6) {
        cart.longitude = (east + west) * 0.5;
        cart.latitude = (north + south) * 0.5;
        ellipsoid.cartographicToCartesian(cart, center);
    }
    Cartesian3.subtract(northWest, center, northWest);
    Cartesian3.subtract(southEast, center, southEast);
    Cartesian3.subtract(northEast, center, northEast);
    Cartesian3.subtract(southWest, center, southWest);
    var direction = Cartesian3.negate(center, cameraRF.direction);
    Cartesian3.normalize(direction, direction);
    var right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);
    Cartesian3.normalize(right, right);
    var up = Cartesian3.cross(right, direction, cameraRF.up);
    var height = Math.max(Math.abs(Cartesian3.dot(up, northWest)), Math.abs(Cartesian3.dot(up, southEast)), Math.abs(Cartesian3.dot(up, northEast)), Math.abs(Cartesian3.dot(up, southWest)));
    var width = Math.max(Math.abs(Cartesian3.dot(right, northWest)), Math.abs(Cartesian3.dot(right, southEast)), Math.abs(Cartesian3.dot(right, northEast)), Math.abs(Cartesian3.dot(right, southWest)));
    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);
    var tanTheta = camera.frustum.aspectRatio * tanPhi;
    var d = Math.max(width / tanTheta, height / tanPhi);
    var scalar = mag + d;
    Cartesian3.normalize(center, center);
    return Cartesian3.multiplyByScalar(center, scalar, result);
}
var viewRectangleCVCartographic = new Cartographic();
var viewRectangleCVNorthEast = new Cartesian3();
var viewRectangleCVSouthWest = new Cartesian3();
function rectangleCameraPositionColumbusView(camera, rectangle, projection, result, positionOnly) {
    var north = rectangle.north;
    var south = rectangle.south;
    var east = rectangle.east;
    var west = rectangle.west;
    var transform = camera._actualTransform;
    var invTransform = camera._actualInvTransform;
    var cart = viewRectangleCVCartographic;
    cart.longitude = east;
    cart.latitude = north;
    var northEast = projection.project(cart, viewRectangleCVNorthEast);
    Matrix4.multiplyByPoint(transform, northEast, northEast);
    Matrix4.multiplyByPoint(invTransform, northEast, northEast);
    cart.longitude = west;
    cart.latitude = south;
    var southWest = projection.project(cart, viewRectangleCVSouthWest);
    Matrix4.multiplyByPoint(transform, southWest, southWest);
    Matrix4.multiplyByPoint(invTransform, southWest, southWest);
    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);
    var tanTheta = camera.frustum.aspectRatio * tanPhi;
    if (!defined(result)) {
        result = new Cartesian3();
    }
    result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;
    result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;
    result.z = Math.max((northEast.x - southWest.x) / tanTheta, (northEast.y - southWest.y) / tanPhi) * 0.5;
    if (!positionOnly) {
        var direction = Cartesian3.clone(Cartesian3.UNIT_Z, camera.direction);
        Cartesian3.negate(direction, direction);
        Cartesian3.clone(Cartesian3.UNIT_X, camera.right);
        Cartesian3.clone(Cartesian3.UNIT_Y, camera.up);
    }
    return result;
}
var viewRectangle2DCartographic = new Cartographic();
var viewRectangle2DNorthEast = new Cartesian3();
var viewRectangle2DSouthWest = new Cartesian3();
function rectangleCameraPosition2D(camera, rectangle, projection, result, positionOnly) {
    var north = rectangle.north;
    var south = rectangle.south;
    var east = rectangle.east;
    var west = rectangle.west;
    var cart = viewRectangle2DCartographic;
    cart.longitude = east;
    cart.latitude = north;
    var northEast = projection.project(cart, viewRectangle2DNorthEast);
    cart.longitude = west;
    cart.latitude = south;
    var southWest = projection.project(cart, viewRectangle2DSouthWest);
    var width = Math.abs(northEast.x - southWest.x) * 0.5;
    var height = Math.abs(northEast.y - southWest.y) * 0.5;
    var right, top;
    var ratio = camera.frustum.right / camera.frustum.top;
    var heightRatio = height * ratio;
    if (width > heightRatio) {
        right = width;
        top = right / ratio;
    } else {
        top = height;
        right = heightRatio;
    }
    height = Math.max(2 * right, 2 * top);
    if (!defined(result)) {
        result = new Cartesian3();
    }
    result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;
    result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;
    if (positionOnly) {
        cart = projection.unproject(result, cart);
        cart.height = height;
        result = projection.project(cart, result);
    } else {
        var frustum = camera.frustum;
        frustum.right = right;
        frustum.left = -right;
        frustum.top = top;
        frustum.bottom = -top;
        var direction = Cartesian3.clone(Cartesian3.UNIT_Z, camera.direction);
        Cartesian3.negate(direction, direction);
        Cartesian3.clone(Cartesian3.UNIT_X, camera.right);
        Cartesian3.clone(Cartesian3.UNIT_Y, camera.up);
    }
    return result;
}
Camera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required');
    }
    if (this._mode === SceneMode.SCENE3D) {
        return rectangleCameraPosition3D(this, rectangle, this._projection.ellipsoid, result, true);
    } else if (this._mode === SceneMode.COLUMBUS_VIEW) {
        return rectangleCameraPositionColumbusView(this, rectangle, this._projection, result, true);
    } else if (this._mode === SceneMode.SCENE2D) {
        return rectangleCameraPosition2D(this, rectangle, this._projection, result, true);
    }
    return undefined;
};
Camera.prototype.viewRectangle = function (rectangle, ellipsoid) {
    if (!defined(rectangle)) {
        throw new DeveloperError('rectangle is required.');
    }
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    if (this._mode === SceneMode.SCENE3D) {
        rectangleCameraPosition3D(this, rectangle, ellipsoid, this.position);
    } else if (this._mode === SceneMode.COLUMBUS_VIEW) {
        rectangleCameraPositionColumbusView(this, rectangle, this._projection, this.position);
    } else if (this._mode === SceneMode.SCENE2D) {
        rectangleCameraPosition2D(this, rectangle, this._projection, this.position);
    }
};
var pickEllipsoid3DRay = new Ray();
function pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    var ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);
    var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);
    if (!intersection) {
        return undefined;
    }
    var t = intersection.start > 0 ? intersection.start : intersection.stop;
    return Ray.getPoint(ray, t, result);
}
var pickEllipsoid2DRay = new Ray();
function pickMap2D(camera, windowPosition, projection, result) {
    var ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);
    var position = ray.origin;
    position.z = 0;
    var cart = projection.unproject(position);
    if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO || cart.longitude < -Math.PI || cart.longitude > Math.PI) {
        return undefined;
    }
    return projection.ellipsoid.cartographicToCartesian(cart, result);
}
var pickEllipsoidCVRay = new Ray();
function pickMapColumbusView(camera, windowPosition, projection, result) {
    var ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);
    var scalar = -ray.origin.x / ray.direction.x;
    Ray.getPoint(ray, scalar, result);
    var cart = projection.unproject(new Cartesian3(result.y, result.z, 0));
    if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO || cart.longitude < -Math.PI || cart.longitude > Math.PI) {
        return undefined;
    }
    return projection.ellipsoid.cartographicToCartesian(cart, result);
}
Camera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {
    if (!defined(windowPosition)) {
        throw new DeveloperError('windowPosition is required.');
    }
    if (!defined(result)) {
        result = new Cartesian3();
    }
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    if (this._mode === SceneMode.SCENE3D) {
        result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);
    } else if (this._mode === SceneMode.SCENE2D) {
        result = pickMap2D(this, windowPosition, this._projection, result);
    } else if (this._mode === SceneMode.COLUMBUS_VIEW) {
        result = pickMapColumbusView(this, windowPosition, this._projection, result);
    } else {
        return undefined;
    }
    return result;
};
var pickPerspCenter = new Cartesian3();
var pickPerspXDir = new Cartesian3();
var pickPerspYDir = new Cartesian3();
function getPickRayPerspective(camera, windowPosition, result) {
    var canvas = camera._scene.canvas;
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;
    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);
    var tanTheta = camera.frustum.aspectRatio * tanPhi;
    var near = camera.frustum.near;
    var x = 2 / width * windowPosition.x - 1;
    var y = 2 / height * (height - windowPosition.y) - 1;
    var position = camera.positionWC;
    Cartesian3.clone(position, result.origin);
    var nearCenter = Cartesian3.multiplyByScalar(camera.directionWC, near, pickPerspCenter);
    Cartesian3.add(position, nearCenter, nearCenter);
    var xDir = Cartesian3.multiplyByScalar(camera.rightWC, x * near * tanTheta, pickPerspXDir);
    var yDir = Cartesian3.multiplyByScalar(camera.upWC, y * near * tanPhi, pickPerspYDir);
    var direction = Cartesian3.add(nearCenter, xDir, result.direction);
    Cartesian3.add(direction, yDir, direction);
    Cartesian3.subtract(direction, position, direction);
    Cartesian3.normalize(direction, direction);
    return result;
}
var scratchDirection = new Cartesian3();
function getPickRayOrthographic(camera, windowPosition, result) {
    var canvas = camera._scene.canvas;
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;
    var x = 2 / width * windowPosition.x - 1;
    x *= (camera.frustum.right - camera.frustum.left) * 0.5;
    var y = 2 / height * (height - windowPosition.y) - 1;
    y *= (camera.frustum.top - camera.frustum.bottom) * 0.5;
    var origin = result.origin;
    Cartesian3.clone(camera.position, origin);
    Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);
    Cartesian3.add(scratchDirection, origin, origin);
    Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);
    Cartesian3.add(scratchDirection, origin, origin);
    Cartesian3.clone(camera.directionWC, result.direction);
    return result;
}
Camera.prototype.getPickRay = function (windowPosition, result) {
    if (!defined(windowPosition)) {
        throw new DeveloperError('windowPosition is required.');
    }
    if (!defined(result)) {
        result = new Ray();
    }
    var frustum = this.frustum;
    if (defined(frustum.aspectRatio) && defined(frustum.fov) && defined(frustum.near)) {
        return getPickRayPerspective(this, windowPosition, result);
    }
    return getPickRayOrthographic(this, windowPosition, result);
};
function createAnimation2D(camera, duration) {
    var position = camera.position;
    var translateX = position.x < -camera._maxCoord.x || position.x > camera._maxCoord.x;
    var translateY = position.y < -camera._maxCoord.y || position.y > camera._maxCoord.y;
    var animatePosition = translateX || translateY;
    var frustum = camera.frustum;
    var top = frustum.top;
    var bottom = frustum.bottom;
    var right = frustum.right;
    var left = frustum.left;
    var startFrustum = camera._max2Dfrustum;
    var animateFrustum = right > camera._max2Dfrustum.right;
    if (animatePosition || animateFrustum) {
        var translatedPosition = Cartesian3.clone(position);
        if (translatedPosition.x > camera._maxCoord.x) {
            translatedPosition.x = camera._maxCoord.x;
        } else if (translatedPosition.x < -camera._maxCoord.x) {
            translatedPosition.x = -camera._maxCoord.x;
        }
        if (translatedPosition.y > camera._maxCoord.y) {
            translatedPosition.y = camera._maxCoord.y;
        } else if (translatedPosition.y < -camera._maxCoord.y) {
            translatedPosition.y = -camera._maxCoord.y;
        }
        var update2D = function (value) {
            if (animatePosition) {
                camera.position = Cartesian3.lerp(position, translatedPosition, value.time, camera.position);
            }
            if (animateFrustum) {
                camera.frustum.top = CesiumMath.lerp(top, startFrustum.top, value.time);
                camera.frustum.bottom = CesiumMath.lerp(bottom, startFrustum.bottom, value.time);
                camera.frustum.right = CesiumMath.lerp(right, startFrustum.right, value.time);
                camera.frustum.left = CesiumMath.lerp(left, startFrustum.left, value.time);
            }
        };
        return {
            easingFunction: EasingFunction.EXPONENTIAL_OUT,
            startObject: { time: 0 },
            stopObject: { time: 1 },
            duration: duration,
            update: update2D
        };
    }
    return undefined;
}
function createAnimationTemplateCV(camera, position, center, maxX, maxY, duration) {
    var newPosition = Cartesian3.clone(position);
    if (center.y > maxX) {
        newPosition.y -= center.y - maxX;
    } else if (center.y < -maxX) {
        newPosition.y += -maxX - center.y;
    }
    if (center.z > maxY) {
        newPosition.z -= center.z - maxY;
    } else if (center.z < -maxY) {
        newPosition.z += -maxY - center.z;
    }
    var updateCV = function (value) {
        var interp = Cartesian3.lerp(position, newPosition, value.time, new Cartesian3());
        camera.worldToCameraCoordinatesPoint(interp, camera.position);
    };
    return {
        easingFunction: EasingFunction.EXPONENTIAL_OUT,
        startObject: { time: 0 },
        stopObject: { time: 1 },
        duration: duration,
        update: updateCV
    };
}
var normalScratch = new Cartesian3();
var centerScratch = new Cartesian3();
var posScratch = new Cartesian3();
var scratchCartesian3Subtract = new Cartesian3();
function createAnimationCV(camera, duration) {
    var position = camera.position;
    var direction = camera.direction;
    var normal = camera.worldToCameraCoordinatesVector(Cartesian3.UNIT_X, normalScratch);
    var scalar = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);
    var center = Cartesian3.add(position, Cartesian3.multiplyByScalar(direction, scalar, centerScratch), centerScratch);
    camera.cameraToWorldCoordinatesPoint(center, center);
    position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);
    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);
    var tanTheta = camera.frustum.aspectRatio * tanPhi;
    var distToC = Cartesian3.magnitude(Cartesian3.subtract(position, center, scratchCartesian3Subtract));
    var dWidth = tanTheta * distToC;
    var dHeight = tanPhi * distToC;
    var mapWidth = camera._maxCoord.x;
    var mapHeight = camera._maxCoord.y;
    var maxX = Math.max(dWidth - mapWidth, mapWidth);
    var maxY = Math.max(dHeight - mapHeight, mapHeight);
    if (position.z < -maxX || position.z > maxX || position.y < -maxY || position.y > maxY) {
        var translateX = center.y < -maxX || center.y > maxX;
        var translateY = center.z < -maxY || center.z > maxY;
        if (translateX || translateY) {
            return createAnimationTemplateCV(camera, position, center, maxX, maxY, duration);
        }
    }
    return undefined;
}
Camera.prototype.createCorrectPositionTween = function (duration) {
    if (!defined(duration)) {
        throw new DeveloperError('duration is required.');
    }
    if (this._mode === SceneMode.SCENE2D) {
        return createAnimation2D(this, duration);
    } else if (this._mode === SceneMode.COLUMBUS_VIEW) {
        return createAnimationCV(this, duration);
    }
    return undefined;
};
Camera.prototype.flyTo = function (options) {
    var scene = this._scene;
    scene.tweens.add(CameraFlightPath.createTween(scene, options));
};
Camera.prototype.flyToRectangle = function (options) {
    var scene = this._scene;
    scene.tweens.add(CameraFlightPath.createTweenRectangle(scene, options));
};
Camera.prototype.clone = function () {
    var camera = new Camera(this._scene);
    camera.position = Cartesian3.clone(this.position);
    camera.direction = Cartesian3.clone(this.direction);
    camera.up = Cartesian3.clone(this.up);
    camera.right = Cartesian3.clone(this.right);
    camera.transform = Matrix4.clone(this.transform);
    camera.frustum = this.frustum.clone();
    return camera;
};
module.exports = Camera;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Cartographic":104,"../Core/DeveloperError":123,"../Core/EasingFunction":126,"../Core/Ellipsoid":130,"../Core/IntersectionTests":164,"../Core/Math":174,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/Quaternion":197,"../Core/Ray":200,"../Core/Rectangle":201,"../Core/Transforms":226,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/deprecationWarning":246,"./CameraFlightPath":378,"./PerspectiveFrustum":422,"./SceneMode":438}],376:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), KeyboardEventModifier = require('../Core/KeyboardEventModifier'), CesiumMath = require('../Core/Math'), ScreenSpaceEventHandler = require('../Core/ScreenSpaceEventHandler'), ScreenSpaceEventType = require('../Core/ScreenSpaceEventType'), CameraEventType = require('./CameraEventType');
'use strict';
function getKey(type, modifier) {
    var key = type;
    if (defined(modifier)) {
        key += '+' + modifier;
    }
    return key;
}
function clonePinchMovement(pinchMovement, result) {
    Cartesian2.clone(pinchMovement.distance.startPosition, result.distance.startPosition);
    Cartesian2.clone(pinchMovement.distance.endPosition, result.distance.endPosition);
    Cartesian2.clone(pinchMovement.angleAndHeight.startPosition, result.angleAndHeight.startPosition);
    Cartesian2.clone(pinchMovement.angleAndHeight.endPosition, result.angleAndHeight.endPosition);
}
function transformDocumentCoordinatesToCanvasCoordinates(coordinates, canvas) {
    var canvasRect = canvas.getBoundingClientRect();
    coordinates.x -= canvasRect.left;
    coordinates.y -= canvasRect.top;
}
function listenToPinch(aggregator, modifier, canvas) {
    var key = getKey(CameraEventType.PINCH, modifier);
    var update = aggregator._update;
    var isDown = aggregator._isDown;
    var eventStartPosition = aggregator._eventStartPosition;
    var pressTime = aggregator._pressTime;
    var releaseTime = aggregator._releaseTime;
    update[key] = true;
    isDown[key] = false;
    eventStartPosition[key] = new Cartesian2();
    var movement = aggregator._movement[key];
    if (!defined(movement)) {
        movement = aggregator._movement[key] = {};
    }
    movement.distance = {
        startPosition: new Cartesian2(),
        endPosition: new Cartesian2()
    };
    movement.angleAndHeight = {
        startPosition: new Cartesian2(),
        endPosition: new Cartesian2()
    };
    movement.prevAngle = 0;
    aggregator._eventHandler.setInputAction(function (event) {
        aggregator._buttonsDown++;
        isDown[key] = true;
        pressTime[key] = new Date();
        Cartesian2.clone(event.position, eventStartPosition[key]);
    }, ScreenSpaceEventType.PINCH_START, modifier);
    aggregator._documentEventHandler.setInputAction(function () {
        aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);
        isDown[key] = false;
        releaseTime[key] = new Date();
    }, ScreenSpaceEventType.PINCH_END, modifier);
    aggregator._documentEventHandler.setInputAction(function (mouseMovement) {
        transformDocumentCoordinatesToCanvasCoordinates(mouseMovement.distance.startPosition, canvas);
        transformDocumentCoordinatesToCanvasCoordinates(mouseMovement.distance.endPosition, canvas);
        transformDocumentCoordinatesToCanvasCoordinates(mouseMovement.angleAndHeight.startPosition, canvas);
        transformDocumentCoordinatesToCanvasCoordinates(mouseMovement.angleAndHeight.endPosition, canvas);
        if (isDown[key]) {
            if (!update[key]) {
                Cartesian2.clone(mouseMovement.distance.endPosition, movement.distance.endPosition);
                Cartesian2.clone(mouseMovement.angleAndHeight.endPosition, movement.angleAndHeight.endPosition);
            } else {
                clonePinchMovement(mouseMovement, movement);
                update[key] = false;
                movement.prevAngle = movement.angleAndHeight.startPosition.x;
            }
            var angle = movement.angleAndHeight.endPosition.x;
            var prevAngle = movement.prevAngle;
            var TwoPI = Math.PI * 2;
            while (angle >= prevAngle + Math.PI) {
                angle -= TwoPI;
            }
            while (angle < prevAngle - Math.PI) {
                angle += TwoPI;
            }
            movement.angleAndHeight.endPosition.x = -angle * canvas.clientWidth / 12;
            movement.angleAndHeight.startPosition.x = -prevAngle * canvas.clientWidth / 12;
        }
    }, ScreenSpaceEventType.PINCH_MOVE, modifier);
}
function listenToWheel(aggregator, modifier) {
    var key = getKey(CameraEventType.WHEEL, modifier);
    var update = aggregator._update;
    update[key] = true;
    var movement = aggregator._movement[key];
    if (!defined(movement)) {
        movement = aggregator._movement[key] = {};
    }
    movement.startPosition = new Cartesian2();
    movement.endPosition = new Cartesian2();
    aggregator._eventHandler.setInputAction(function (delta) {
        var arcLength = 15 * CesiumMath.toRadians(delta);
        if (!update[key]) {
            movement.endPosition.y = movement.endPosition.y + arcLength;
        } else {
            Cartesian2.clone(Cartesian2.ZERO, movement.startPosition);
            movement.endPosition.x = 0;
            movement.endPosition.y = arcLength;
            update[key] = false;
        }
    }, ScreenSpaceEventType.WHEEL, modifier);
}
function listenMouseButtonDownUp(aggregator, modifier, type) {
    var key = getKey(type, modifier);
    var isDown = aggregator._isDown;
    var eventStartPosition = aggregator._eventStartPosition;
    var pressTime = aggregator._pressTime;
    var releaseTime = aggregator._releaseTime;
    isDown[key] = false;
    eventStartPosition[key] = new Cartesian2();
    var lastMovement = aggregator._lastMovement[key];
    if (!defined(lastMovement)) {
        lastMovement = aggregator._lastMovement[key] = {
            startPosition: new Cartesian2(),
            endPosition: new Cartesian2(),
            valid: false
        };
    }
    var down;
    var up;
    if (type === CameraEventType.LEFT_DRAG) {
        down = ScreenSpaceEventType.LEFT_DOWN;
        up = ScreenSpaceEventType.LEFT_UP;
    } else if (type === CameraEventType.RIGHT_DRAG) {
        down = ScreenSpaceEventType.RIGHT_DOWN;
        up = ScreenSpaceEventType.RIGHT_UP;
    } else if (type === CameraEventType.MIDDLE_DRAG) {
        down = ScreenSpaceEventType.MIDDLE_DOWN;
        up = ScreenSpaceEventType.MIDDLE_UP;
    }
    aggregator._eventHandler.setInputAction(function (event) {
        aggregator._buttonsDown++;
        lastMovement.valid = false;
        isDown[key] = true;
        pressTime[key] = new Date();
        Cartesian2.clone(event.position, eventStartPosition[key]);
    }, down, modifier);
    aggregator._documentEventHandler.setInputAction(function () {
        aggregator._buttonsDown = Math.max(aggregator._buttonsDown - 1, 0);
        isDown[key] = false;
        releaseTime[key] = new Date();
    }, up, modifier);
}
function cloneMouseMovement(mouseMovement, result) {
    Cartesian2.clone(mouseMovement.startPosition, result.startPosition);
    Cartesian2.clone(mouseMovement.endPosition, result.endPosition);
}
function listenMouseMove(aggregator, modifier, canvas) {
    var update = aggregator._update;
    var movement = aggregator._movement;
    var lastMovement = aggregator._lastMovement;
    var isDown = aggregator._isDown;
    for (var typeName in CameraEventType) {
        if (CameraEventType.hasOwnProperty(typeName)) {
            var type = CameraEventType[typeName];
            if (defined(type)) {
                var key = getKey(type, modifier);
                update[key] = true;
                if (!defined(aggregator._lastMovement[key])) {
                    aggregator._lastMovement[key] = {
                        startPosition: new Cartesian2(),
                        endPosition: new Cartesian2(),
                        valid: false
                    };
                }
                if (!defined(aggregator._movement[key])) {
                    aggregator._movement[key] = {
                        startPosition: new Cartesian2(),
                        endPosition: new Cartesian2()
                    };
                }
            }
        }
    }
    var mouseMovementScratch = {
            startPosition: new Cartesian2(),
            endPosition: new Cartesian2()
        };
    aggregator._documentEventHandler.setInputAction(function (mouseMovement) {
        transformDocumentCoordinatesToCanvasCoordinates(mouseMovement.startPosition, canvas);
        transformDocumentCoordinatesToCanvasCoordinates(mouseMovement.endPosition, canvas);
        for (var typeName in CameraEventType) {
            if (CameraEventType.hasOwnProperty(typeName)) {
                var type = CameraEventType[typeName];
                if (defined(type)) {
                    var key = getKey(type, modifier);
                    if (isDown[key]) {
                        if (!update[key]) {
                            Cartesian2.clone(mouseMovement.endPosition, movement[key].endPosition);
                        } else {
                            cloneMouseMovement(movement[key], lastMovement[key]);
                            lastMovement[key].valid = true;
                            cloneMouseMovement(mouseMovement, movement[key]);
                            update[key] = false;
                        }
                    }
                }
            }
        }
        Cartesian2.clone(mouseMovement.endPosition, aggregator._currentMousePosition);
    }, ScreenSpaceEventType.MOUSE_MOVE, modifier);
}
var CameraEventAggregator = function (canvas) {
    if (!defined(canvas)) {
        throw new DeveloperError('canvas is required.');
    }
    this._eventHandler = new ScreenSpaceEventHandler(canvas, false);
    this._documentEventHandler = new ScreenSpaceEventHandler(document, false);
    this._update = {};
    this._movement = {};
    this._lastMovement = {};
    this._isDown = {};
    this._eventStartPosition = {};
    this._pressTime = {};
    this._releaseTime = {};
    this._buttonsDown = 0;
    this._currentMousePosition = new Cartesian2();
    listenToWheel(this, undefined);
    listenToPinch(this, undefined, canvas);
    listenMouseButtonDownUp(this, undefined, CameraEventType.LEFT_DRAG);
    listenMouseButtonDownUp(this, undefined, CameraEventType.RIGHT_DRAG);
    listenMouseButtonDownUp(this, undefined, CameraEventType.MIDDLE_DRAG);
    listenMouseMove(this, undefined, canvas);
    for (var modifierName in KeyboardEventModifier) {
        if (KeyboardEventModifier.hasOwnProperty(modifierName)) {
            var modifier = KeyboardEventModifier[modifierName];
            if (defined(modifier)) {
                listenToWheel(this, modifier);
                listenToPinch(this, modifier, canvas);
                listenMouseButtonDownUp(this, modifier, CameraEventType.LEFT_DRAG);
                listenMouseButtonDownUp(this, modifier, CameraEventType.RIGHT_DRAG);
                listenMouseButtonDownUp(this, modifier, CameraEventType.MIDDLE_DRAG);
                listenMouseMove(this, modifier, canvas);
            }
        }
    }
};
defineProperties(CameraEventAggregator.prototype, {
    currentMousePosition: {
        get: function () {
            return this._currentMousePosition;
        }
    },
    anyButtonDown: {
        get: function () {
            var wheelMoved = !this._update[getKey(CameraEventType.WHEEL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.SHIFT)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.CTRL)] || !this._update[getKey(CameraEventType.WHEEL, KeyboardEventModifier.ALT)];
            return this._buttonsDown > 0 || wheelMoved;
        }
    }
});
CameraEventAggregator.prototype.isMoving = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    return !this._update[key];
};
CameraEventAggregator.prototype.getMovement = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    var movement = this._movement[key];
    return movement;
};
CameraEventAggregator.prototype.getLastMovement = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    var lastMovement = this._lastMovement[key];
    if (lastMovement.valid) {
        return lastMovement;
    }
    return undefined;
};
CameraEventAggregator.prototype.isButtonDown = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    return this._isDown[key];
};
CameraEventAggregator.prototype.getStartMousePosition = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    if (type === CameraEventType.WHEEL) {
        return this._currentMousePosition;
    }
    var key = getKey(type, modifier);
    return this._eventStartPosition[key];
};
CameraEventAggregator.prototype.getButtonPressTime = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    return this._pressTime[key];
};
CameraEventAggregator.prototype.getButtonReleaseTime = function (type, modifier) {
    if (!defined(type)) {
        throw new DeveloperError('type is required.');
    }
    var key = getKey(type, modifier);
    return this._releaseTime[key];
};
CameraEventAggregator.prototype.reset = function () {
    for (var name in this._update) {
        if (this._update.hasOwnProperty(name)) {
            this._update[name] = true;
        }
    }
};
CameraEventAggregator.prototype.isDestroyed = function () {
    return false;
};
CameraEventAggregator.prototype.destroy = function () {
    this._eventHandler = this._eventHandler && this._eventHandler.destroy();
    return destroyObject(this);
};
module.exports = CameraEventAggregator;
},{"../Core/Cartesian2":101,"../Core/DeveloperError":123,"../Core/KeyboardEventModifier":169,"../Core/Math":174,"../Core/ScreenSpaceEventHandler":208,"../Core/ScreenSpaceEventType":209,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"./CameraEventType":377}],377:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var CameraEventType = {
        LEFT_DRAG: 0,
        RIGHT_DRAG: 1,
        MIDDLE_DRAG: 2,
        WHEEL: 3,
        PINCH: 4
    };
module.exports = freezeObject(CameraEventType);
},{"../Core/freezeObject":249}],378:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartographic = require('../Core/Cartographic'), clone = require('../Core/clone'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), EasingFunction = require('../Core/EasingFunction'), HermiteSpline = require('../Core/HermiteSpline'), LinearSpline = require('../Core/LinearSpline'), CesiumMath = require('../Core/Math'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), Quaternion = require('../Core/Quaternion'), QuaternionSpline = require('../Core/QuaternionSpline'), PerspectiveFrustum = require('./PerspectiveFrustum'), PerspectiveOffCenterFrustum = require('./PerspectiveOffCenterFrustum'), SceneMode = require('./SceneMode');
'use strict';
var CameraFlightPath = {};
var c3destination = new Cartesian3();
var rotMatrix = new Matrix3();
var viewMat = new Matrix3();
var cqRight = new Cartesian3();
var cqUp = new Cartesian3();
function createQuaternion(direction, up, result) {
    Cartesian3.cross(direction, up, cqRight);
    Cartesian3.cross(cqRight, direction, cqUp);
    viewMat[0] = cqRight.x;
    viewMat[1] = cqUp.x;
    viewMat[2] = -direction.x;
    viewMat[3] = cqRight.y;
    viewMat[4] = cqUp.y;
    viewMat[5] = -direction.y;
    viewMat[6] = cqRight.z;
    viewMat[7] = cqUp.z;
    viewMat[8] = -direction.z;
    return Quaternion.fromRotationMatrix(viewMat, result);
}
function getAltitude(frustum, dx, dy) {
    var near;
    var top;
    var right;
    if (frustum instanceof PerspectiveFrustum) {
        var tanTheta = Math.tan(0.5 * frustum.fovy);
        near = frustum.near;
        top = frustum.near * tanTheta;
        right = frustum.aspectRatio * top;
        return Math.max(dx * near / right, dy * near / top);
    } else if (frustum instanceof PerspectiveOffCenterFrustum) {
        near = frustum.near;
        top = frustum.top;
        right = frustum.right;
        return Math.max(dx * near / right, dy * near / top);
    }
    return Math.max(dx, dy);
}
var scratchCart = new Cartesian3();
var scratchCart2 = new Cartesian3();
var scratchCart3 = new Cartesian3();
var scratchCart4 = new Cartesian3();
var rotMatrixScratch = new Matrix3();
function createPath3D(camera, ellipsoid, start, up, right, end, duration) {
    var radius = ellipsoid.maximumRadius;
    var frustum = camera.frustum;
    var maxStartAlt = getAltitude(frustum, radius, radius);
    var dot = Cartesian3.dot(Cartesian3.normalize(start, scratchCart), Cartesian3.normalize(end, scratchCart2));
    var points;
    var altitude;
    var incrementPercentage;
    if (Cartesian3.magnitude(start) > maxStartAlt) {
        altitude = radius + 0.6 * (maxStartAlt - radius);
        incrementPercentage = 0.35;
    } else {
        var diff = Cartesian3.subtract(start, end, scratchCart);
        altitude = Cartesian3.magnitude(Cartesian3.add(Cartesian3.multiplyByScalar(diff, 0.5, scratchCart2), end, scratchCart2));
        var verticalDistance = Cartesian3.magnitude(Cartesian3.multiplyByScalar(up, Cartesian3.dot(diff, up), scratchCart2));
        var horizontalDistance = Cartesian3.magnitude(Cartesian3.multiplyByScalar(right, Cartesian3.dot(diff, right), scratchCart2));
        altitude += getAltitude(frustum, verticalDistance, horizontalDistance);
        incrementPercentage = CesiumMath.clamp(dot + 1, 0.25, 0.5);
    }
    var aboveEnd = Cartesian3.multiplyByScalar(Cartesian3.normalize(end, scratchCart2), altitude, scratchCart2);
    var afterStart = Cartesian3.multiplyByScalar(Cartesian3.normalize(start, scratchCart), altitude, scratchCart);
    var axis, angle, rotation;
    var middle = new Cartesian3();
    if (Cartesian3.magnitude(end) > maxStartAlt && dot > 0.75) {
        middle = Cartesian3.add(Cartesian3.multiplyByScalar(Cartesian3.subtract(start, end, middle), 0.5, middle), end, middle);
        points = [
            start,
            middle,
            end
        ];
    } else if (Cartesian3.magnitude(start) > maxStartAlt && dot > 0) {
        middle = Cartesian3.add(Cartesian3.multiplyByScalar(Cartesian3.subtract(start, aboveEnd, middle), 0.5, middle), aboveEnd, middle);
        points = [
            start,
            middle,
            end
        ];
    } else {
        points = [start];
        angle = CesiumMath.acosClamped(Cartesian3.dot(Cartesian3.normalize(afterStart, scratchCart3), Cartesian3.normalize(aboveEnd, scratchCart4)));
        axis = Cartesian3.cross(aboveEnd, afterStart, scratchCart3);
        if (Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
            axis = Cartesian3.UNIT_Z;
        }
        var increment = incrementPercentage * angle;
        var startCondition = angle - increment;
        for (var i = startCondition; i > 0; i = i - increment) {
            rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, i), rotMatrixScratch);
            points.push(Matrix3.multiplyByVector(rotation, aboveEnd, new Cartesian3()));
        }
        points.push(end);
    }
    var times = new Array(points.length);
    var scalar = duration / (points.length - 1);
    for (var k = 0; k < points.length; ++k) {
        times[k] = k * scalar;
    }
    return HermiteSpline.createNaturalCubic({
        points: points,
        times: times
    });
}
var direction3D = new Cartesian3();
var right3D = new Cartesian3();
var up3D = new Cartesian3();
var quat3D = new Quaternion();
function createOrientations3D(path, startDirection, startUp, endDirection, endUp) {
    var points = path.points;
    var orientations = new Array(points.length);
    orientations[0] = createQuaternion(startDirection, startUp);
    var point;
    var length = points.length - 1;
    for (var i = 1; i < length; ++i) {
        point = points[i];
        Cartesian3.normalize(Cartesian3.negate(point, direction3D), direction3D);
        Cartesian3.normalize(Cartesian3.cross(direction3D, Cartesian3.UNIT_Z, right3D), right3D);
        Cartesian3.cross(right3D, direction3D, up3D);
        orientations[i] = createQuaternion(direction3D, up3D, quat3D);
    }
    point = points[length];
    if (defined(endDirection) && defined(endUp)) {
        orientations[length] = createQuaternion(endDirection, endUp);
    } else {
        Cartesian3.normalize(Cartesian3.negate(point, direction3D), direction3D);
        Cartesian3.normalize(Cartesian3.cross(direction3D, Cartesian3.UNIT_Z, right3D), right3D);
        Cartesian3.cross(right3D, direction3D, up3D);
        orientations[length] = createQuaternion(direction3D, up3D, quat3D);
    }
    return new QuaternionSpline({
        points: orientations,
        times: path.times
    });
}
var scratchStartPosition = new Cartesian3();
var scratchStartDirection = new Cartesian3();
var scratchStartUp = new Cartesian3();
var scratchStartRight = new Cartesian3();
var currentFrame = new Matrix4();
function createUpdate3D(scene, destination, duration, direction, up) {
    var camera = scene.camera;
    var ellipsoid = scene.mapProjection.ellipsoid;
    var start = camera.cameraToWorldCoordinatesPoint(camera.position, scratchStartPosition);
    var startDirection = camera.cameraToWorldCoordinatesVector(camera.direction, scratchStartDirection);
    var startUp = camera.cameraToWorldCoordinatesVector(camera.up, scratchStartUp);
    var startRight = Cartesian3.cross(startDirection, startUp, scratchStartRight);
    var path = createPath3D(camera, ellipsoid, start, startUp, startRight, destination, duration);
    var orientations = createOrientations3D(path, startDirection, startUp, direction, up);
    var update = function (value) {
        var time = value.time;
        var orientation = orientations.evaluate(time);
        Matrix3.fromQuaternion(orientation, rotMatrix);
        Matrix4.clone(camera.transform, currentFrame);
        Matrix4.clone(Matrix4.IDENTITY, camera.transform);
        camera.position = path.evaluate(time, camera.position);
        camera.right = Matrix3.getRow(rotMatrix, 0, camera.right);
        camera.up = Matrix3.getRow(rotMatrix, 1, camera.up);
        camera.direction = Cartesian3.negate(Matrix3.getRow(rotMatrix, 2, camera.direction), camera.direction);
        camera.setTransform(currentFrame);
    };
    return update;
}
var cartScratch1 = new Cartesian3();
function createPath2D(camera, ellipsoid, start, end, duration) {
    if (CesiumMath.equalsEpsilon(Cartesian2.magnitude(start), Cartesian2.magnitude(end), 10000)) {
        return new LinearSpline({
            points: [
                start,
                end
            ],
            times: [
                0,
                duration
            ]
        });
    }
    var radius = ellipsoid.maximumRadius;
    var frustum = camera.frustum;
    var maxStartAlt = getAltitude(frustum, Math.PI * radius, CesiumMath.PI_OVER_TWO * radius);
    var points;
    var altitude;
    var incrementPercentage = 0.5;
    if (start.z > maxStartAlt) {
        altitude = 0.6 * maxStartAlt;
    } else {
        var diff = Cartesian3.subtract(start, end, cartScratch1);
        altitude = getAltitude(frustum, Math.abs(diff.y), Math.abs(diff.x));
    }
    var aboveEnd = Cartesian3.clone(end);
    aboveEnd.z = altitude;
    var afterStart = Cartesian3.clone(start);
    afterStart.z = altitude;
    var middle = new Cartesian3();
    if (end.z > maxStartAlt) {
        middle = Cartesian3.add(Cartesian3.multiplyByScalar(Cartesian3.subtract(start, end, middle), 0.5, middle), end, middle);
        points = [
            start,
            middle,
            end
        ];
    } else if (start.z > maxStartAlt) {
        middle = Cartesian3.add(Cartesian3.multiplyByScalar(Cartesian3.subtract(start, aboveEnd, middle), 0.5, middle), aboveEnd, middle);
        points = [
            start,
            middle,
            end
        ];
    } else {
        points = [start];
        var v = Cartesian3.subtract(afterStart, aboveEnd, cartScratch1);
        var distance = Cartesian3.magnitude(v);
        Cartesian3.normalize(v, v);
        var increment = incrementPercentage * distance;
        var startCondition = distance - increment;
        for (var i = startCondition; i > 0; i = i - increment) {
            var p = new Cartesian3();
            points.push(Cartesian3.add(Cartesian3.multiplyByScalar(v, i, p), aboveEnd, p));
        }
        points.push(end);
    }
    var times = new Array(points.length);
    var scalar = duration / (points.length - 1);
    for (var k = 0; k < points.length; ++k) {
        times[k] = k * scalar;
    }
    return HermiteSpline.createNaturalCubic({
        points: points,
        times: times
    });
}
var direction2D = Cartesian3.negate(Cartesian3.UNIT_Z, new Cartesian3());
var right2D = new Cartesian3();
right2D = Cartesian3.normalize(Cartesian3.cross(direction2D, Cartesian3.UNIT_Y, right2D), right2D);
var up2D = Cartesian3.cross(right2D, direction2D, new Cartesian3());
var quat = createQuaternion(direction2D, up2D);
function createOrientations2D(camera, path, endDirection, endUp) {
    var points = path.points;
    var orientations = new Array(points.length);
    orientations[0] = createQuaternion(camera.direction, camera.up);
    var length = points.length - 1;
    for (var i = 1; i < length; ++i) {
        orientations[i] = quat;
    }
    if (defined(endDirection) && defined(endUp)) {
        orientations[length] = createQuaternion(endDirection, endUp);
    } else {
        orientations[length] = quat;
    }
    return new QuaternionSpline({
        points: orientations,
        times: path.times
    });
}
function createUpdateCV(scene, destination, duration, direction, up) {
    var camera = scene.camera;
    var ellipsoid = scene.mapProjection.ellipsoid;
    var path = createPath2D(camera, ellipsoid, Cartesian3.clone(camera.position), destination, duration);
    var orientations = createOrientations2D(camera, path, direction, up);
    var update = function (value) {
        var time = value.time;
        var orientation = orientations.evaluate(time);
        Matrix3.fromQuaternion(orientation, rotMatrix);
        Matrix4.clone(camera.transform, currentFrame);
        Matrix4.clone(Matrix4.IDENTITY, camera.transform);
        camera.position = path.evaluate(time, camera.position);
        camera.right = Matrix3.getRow(rotMatrix, 0, camera.right);
        camera.up = Matrix3.getRow(rotMatrix, 1, camera.up);
        camera.direction = Cartesian3.negate(Matrix3.getRow(rotMatrix, 2, camera.direction), camera.direction);
        camera.setTransform(currentFrame);
    };
    return update;
}
function createUpdate2D(scene, destination, duration, direction, up) {
    var camera = scene.camera;
    var ellipsoid = scene.mapProjection.ellipsoid;
    var start = Cartesian3.clone(camera.position);
    start.z = camera.frustum.right - camera.frustum.left;
    var path = createPath2D(camera, ellipsoid, start, destination, duration);
    var orientations = createOrientations2D(camera, path, Cartesian3.negate(Cartesian3.UNIT_Z, new Cartesian3()), up);
    var height = camera.position.z;
    var update = function (value) {
        var time = value.time;
        var orientation = orientations.evaluate(time);
        Matrix3.fromQuaternion(orientation, rotMatrix);
        camera.position = path.evaluate(time);
        var zoom = camera.position.z;
        camera.position.z = height;
        camera.right = Matrix3.getRow(rotMatrix, 0, camera.right);
        camera.up = Matrix3.getRow(rotMatrix, 1, camera.up);
        camera.direction = Cartesian3.negate(Matrix3.getRow(rotMatrix, 2, camera.direction), camera.direction);
        var frustum = camera.frustum;
        var ratio = frustum.top / frustum.right;
        var incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;
        frustum.right += incrementAmount;
        frustum.left -= incrementAmount;
        frustum.top = ratio * frustum.right;
        frustum.bottom = -frustum.top;
    };
    return update;
}
var dirScratch = new Cartesian3();
var rightScratch = new Cartesian3();
var upScratch = new Cartesian3();
var scratchCartographic = new Cartographic();
var scratchDestination = new Cartesian3();
CameraFlightPath.createTween = function (scene, options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var destination = options.destination;
    var direction = options.direction;
    var up = options.up;
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(destination)) {
        throw new DeveloperError('destination is required.');
    }
    if (defined(direction) && !defined(up) || defined(up) && !defined(direction)) {
        throw new DeveloperError('If either direction or up is given, then both are required.');
    }
    if (scene.mode === SceneMode.MORPHING) {
        return {
            startObject: {},
            stopObject: {},
            duration: 0
        };
    }
    var convert = defaultValue(options.convert, true);
    if (convert && scene.mode !== SceneMode.SCENE3D) {
        var projection = scene.mapProjection;
        var ellipsoid = projection.ellipsoid;
        ellipsoid.cartesianToCartographic(destination, scratchCartographic);
        destination = projection.project(scratchCartographic, scratchDestination);
    }
    var duration = defaultValue(options.duration, 3);
    var controller = scene.screenSpaceCameraController;
    controller.enableInputs = false;
    var wrapCallback = function (cb) {
        var wrapped = function () {
            if (typeof cb === 'function') {
                cb();
            }
            controller.enableInputs = true;
        };
        return wrapped;
    };
    var complete = wrapCallback(options.complete);
    var cancel = wrapCallback(options.cancel);
    var camera = scene.camera;
    var transform = options.endTransform;
    if (defined(transform)) {
        camera.setTransform(transform);
    }
    var frustum = camera.frustum;
    if (scene.mode === SceneMode.SCENE2D) {
        if (Cartesian2.equalsEpsilon(camera.position, destination, CesiumMath.EPSILON6) && CesiumMath.equalsEpsilon(Math.max(frustum.right - frustum.left, frustum.top - frustum.bottom), destination.z, CesiumMath.EPSILON6)) {
            return {
                startObject: {},
                stopObject: {},
                duration: 0,
                complete: complete,
                cancel: cancel
            };
        }
    } else if (Cartesian3.equalsEpsilon(destination, camera.position, CesiumMath.EPSILON6)) {
        return {
            startObject: {},
            stopObject: {},
            duration: 0,
            complete: complete,
            cancel: cancel
        };
    }
    if (duration <= 0) {
        var newOnComplete = function () {
            var position = destination;
            if (scene.mode === SceneMode.SCENE3D) {
                if (!defined(options.direction) && !defined(options.up)) {
                    dirScratch = Cartesian3.normalize(Cartesian3.negate(position, dirScratch), dirScratch);
                    rightScratch = Cartesian3.normalize(Cartesian3.cross(dirScratch, Cartesian3.UNIT_Z, rightScratch), rightScratch);
                } else {
                    dirScratch = options.direction;
                    rightScratch = Cartesian3.normalize(Cartesian3.cross(dirScratch, options.up, rightScratch), rightScratch);
                }
                upScratch = defaultValue(options.up, Cartesian3.cross(rightScratch, dirScratch, upScratch));
            } else {
                if (!defined(options.direction) && !defined(options.up)) {
                    dirScratch = Cartesian3.negate(Cartesian3.UNIT_Z, dirScratch);
                    rightScratch = Cartesian3.normalize(Cartesian3.cross(dirScratch, Cartesian3.UNIT_Y, rightScratch), rightScratch);
                } else {
                    dirScratch = options.direction;
                    rightScratch = Cartesian3.normalize(Cartesian3.cross(dirScratch, options.up, rightScratch), rightScratch);
                }
                upScratch = defaultValue(options.up, Cartesian3.cross(rightScratch, dirScratch, upScratch));
            }
            Cartesian3.clone(position, camera.position);
            Cartesian3.clone(dirScratch, camera.direction);
            Cartesian3.clone(upScratch, camera.up);
            Cartesian3.clone(rightScratch, camera.right);
            if (scene.mode === SceneMode.SCENE2D) {
                var zoom = camera.position.z;
                var ratio = frustum.top / frustum.right;
                var incrementAmount = (zoom - (frustum.right - frustum.left)) * 0.5;
                frustum.right += incrementAmount;
                frustum.left -= incrementAmount;
                frustum.top = ratio * frustum.right;
                frustum.bottom = -frustum.top;
            }
            if (typeof complete === 'function') {
                complete();
            }
        };
        return {
            startObject: {},
            stopObject: {},
            duration: 0,
            complete: newOnComplete,
            cancel: cancel
        };
    }
    var update;
    if (scene.mode === SceneMode.SCENE3D) {
        update = createUpdate3D(scene, destination, duration, direction, up);
    } else if (scene.mode === SceneMode.SCENE2D) {
        update = createUpdate2D(scene, destination, duration, direction, up);
    } else {
        update = createUpdateCV(scene, destination, duration, direction, up);
    }
    return {
        duration: duration,
        easingFunction: EasingFunction.SINUSOIDAL_IN_OUT,
        startObject: { time: 0 },
        stopObject: { time: duration },
        update: update,
        complete: complete,
        cancel: cancel
    };
};
CameraFlightPath.createTweenRectangle = function (scene, options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var rectangle = options.destination;
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(rectangle)) {
        throw new DeveloperError('options.destination is required.');
    }
    var createAnimationoptions = clone(options);
    scene.camera.getRectangleCameraCoordinates(rectangle, c3destination);
    createAnimationoptions.destination = c3destination;
    createAnimationoptions.convert = false;
    return this.createTween(scene, createAnimationoptions);
};
module.exports = CameraFlightPath;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartographic":104,"../Core/DeveloperError":123,"../Core/EasingFunction":126,"../Core/HermiteSpline":156,"../Core/LinearSpline":173,"../Core/Math":174,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/Quaternion":197,"../Core/QuaternionSpline":198,"../Core/clone":240,"../Core/defaultValue":243,"../Core/defined":245,"./PerspectiveFrustum":422,"./PerspectiveOffCenterFrustum":423,"./SceneMode":438}],379:[function(require,module,exports){
var Credit = require('../Core/Credit'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError');
'use strict';
function displayTextCredit(credit, container, delimiter) {
    if (!defined(credit.element)) {
        var text = credit.text;
        var link = credit.link;
        var span = document.createElement('span');
        if (credit.hasLink()) {
            var a = document.createElement('a');
            a.textContent = text;
            a.href = link;
            a.target = '_blank';
            span.appendChild(a);
        } else {
            span.textContent = text;
        }
        span.className = 'cesium-credit-text';
        credit.element = span;
    }
    if (container.hasChildNodes()) {
        var del = document.createElement('span');
        del.textContent = delimiter;
        del.className = 'cesium-credit-delimiter';
        container.appendChild(del);
    }
    container.appendChild(credit.element);
}
function displayImageCredit(credit, container) {
    if (!defined(credit.element)) {
        var text = credit.text;
        var link = credit.link;
        var span = document.createElement('span');
        var content = document.createElement('img');
        content.src = credit.imageUrl;
        content.style['vertical-align'] = 'bottom';
        if (defined(text)) {
            content.alt = text;
            content.title = text;
        }
        if (credit.hasLink()) {
            var a = document.createElement('a');
            a.appendChild(content);
            a.href = link;
            a.target = '_blank';
            span.appendChild(a);
        } else {
            span.appendChild(content);
        }
        span.className = 'cesium-credit-image';
        credit.element = span;
    }
    container.appendChild(credit.element);
}
function contains(credits, credit) {
    var len = credits.length;
    for (var i = 0; i < len; i++) {
        var existingCredit = credits[i];
        if (Credit.equals(existingCredit, credit)) {
            return true;
        }
    }
    return false;
}
function removeCreditDomElement(credit) {
    var element = credit.element;
    if (defined(element)) {
        var container = element.parentNode;
        if (!credit.hasImage()) {
            var delimiter = element.previousSibling;
            if (delimiter === null) {
                delimiter = element.nextSibling;
            }
            if (delimiter !== null) {
                container.removeChild(delimiter);
            }
        }
        container.removeChild(element);
    }
}
function displayTextCredits(creditDisplay, textCredits) {
    var i;
    var index;
    var credit;
    var displayedTextCredits = creditDisplay._displayedCredits.textCredits;
    for (i = 0; i < textCredits.length; i++) {
        credit = textCredits[i];
        if (defined(credit)) {
            index = displayedTextCredits.indexOf(credit);
            if (index === -1) {
                displayTextCredit(credit, creditDisplay._textContainer, creditDisplay._delimiter);
            } else {
                displayedTextCredits.splice(index, 1);
            }
        }
    }
    for (i = 0; i < displayedTextCredits.length; i++) {
        credit = displayedTextCredits[i];
        if (defined(credit)) {
            removeCreditDomElement(credit);
        }
    }
}
function displayImageCredits(creditDisplay, imageCredits) {
    var i;
    var index;
    var credit;
    var displayedImageCredits = creditDisplay._displayedCredits.imageCredits;
    for (i = 0; i < imageCredits.length; i++) {
        credit = imageCredits[i];
        if (defined(credit)) {
            index = displayedImageCredits.indexOf(credit);
            if (index === -1) {
                displayImageCredit(credit, creditDisplay._imageContainer);
            } else {
                displayedImageCredits.splice(index, 1);
            }
        }
    }
    for (i = 0; i < displayedImageCredits.length; i++) {
        credit = displayedImageCredits[i];
        if (defined(credit)) {
            removeCreditDomElement(credit);
        }
    }
}
var CreditDisplay = function (container, delimiter) {
    if (!defined(container)) {
        throw new DeveloperError('credit container is required');
    }
    var imageContainer = document.createElement('span');
    imageContainer.className = 'cesium-credit-imageContainer';
    var textContainer = document.createElement('span');
    textContainer.className = 'cesium-credit-textContainer';
    container.appendChild(imageContainer);
    container.appendChild(textContainer);
    this._delimiter = defaultValue(delimiter, ' \u2022 ');
    this._container = container;
    this._textContainer = textContainer;
    this._imageContainer = imageContainer;
    this._defaultImageCredits = [];
    this._defaultTextCredits = [];
    this._displayedCredits = {
        imageCredits: [],
        textCredits: []
    };
    this._currentFrameCredits = {
        imageCredits: [],
        textCredits: []
    };
};
CreditDisplay.prototype.addCredit = function (credit) {
    if (!defined(credit)) {
        throw new DeveloperError('credit must be defined');
    }
    if (credit.hasImage()) {
        var imageCredits = this._currentFrameCredits.imageCredits;
        if (!contains(this._defaultImageCredits, credit)) {
            imageCredits[credit.id] = credit;
        }
    } else {
        var textCredits = this._currentFrameCredits.textCredits;
        if (!contains(this._defaultTextCredits, credit)) {
            textCredits[credit.id] = credit;
        }
    }
};
CreditDisplay.prototype.addDefaultCredit = function (credit) {
    if (!defined(credit)) {
        throw new DeveloperError('credit must be defined');
    }
    if (credit.hasImage()) {
        var imageCredits = this._defaultImageCredits;
        if (!contains(imageCredits, credit)) {
            imageCredits.push(credit);
        }
    } else {
        var textCredits = this._defaultTextCredits;
        if (!contains(textCredits, credit)) {
            textCredits.push(credit);
        }
    }
};
CreditDisplay.prototype.removeDefaultCredit = function (credit) {
    if (!defined(credit)) {
        throw new DeveloperError('credit must be defined');
    }
    var index;
    if (credit.hasImage()) {
        index = this._defaultImageCredits.indexOf(credit);
        if (index !== -1) {
            this._defaultImageCredits.splice(index, 1);
        }
    } else {
        index = this._defaultTextCredits.indexOf(credit);
        if (index !== -1) {
            this._defaultTextCredits.splice(index, 1);
        }
    }
};
CreditDisplay.prototype.beginFrame = function () {
    this._currentFrameCredits.imageCredits.length = 0;
    this._currentFrameCredits.textCredits.length = 0;
};
CreditDisplay.prototype.endFrame = function () {
    var textCredits = this._defaultTextCredits.concat(this._currentFrameCredits.textCredits);
    var imageCredits = this._defaultImageCredits.concat(this._currentFrameCredits.imageCredits);
    displayTextCredits(this, textCredits);
    displayImageCredits(this, imageCredits);
    this._displayedCredits.textCredits = textCredits;
    this._displayedCredits.imageCredits = imageCredits;
};
CreditDisplay.prototype.destroy = function () {
    this._container.removeChild(this._textContainer);
    this._container.removeChild(this._imageContainer);
    return destroyObject(this);
};
CreditDisplay.prototype.isDestroyed = function () {
    return false;
};
module.exports = CreditDisplay;
},{"../Core/Credit":118,"../Core/DeveloperError":123,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247}],380:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var CullFace = {
        FRONT: 1028,
        BACK: 1029,
        FRONT_AND_BACK: 1032
    };
module.exports = freezeObject(CullFace);
},{"../Core/freezeObject":249}],381:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), Intersect = require('../Core/Intersect');
'use strict';
var CullingVolume = function (planes) {
    this.planes = defaultValue(planes, []);
};
CullingVolume.prototype.computeVisibility = function (boundingVolume) {
    if (!defined(boundingVolume)) {
        throw new DeveloperError('boundingVolume is required.');
    }
    var planes = this.planes;
    var intersecting = false;
    for (var k = 0, len = planes.length; k < len; ++k) {
        var result = boundingVolume.intersect(planes[k]);
        if (result === Intersect.OUTSIDE) {
            return Intersect.OUTSIDE;
        } else if (result === Intersect.INTERSECTING) {
            intersecting = true;
        }
    }
    return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;
};
module.exports = CullingVolume;
},{"../Core/DeveloperError":123,"../Core/Intersect":163,"../Core/defaultValue":243,"../Core/defined":245}],382:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var DepthFunction = {
        NEVER: 512,
        LESS: 513,
        EQUAL: 514,
        LESS_OR_EQUAL: 515,
        GREATER: 516,
        NOT_EQUAL: 517,
        GREATER_OR_EQUAL: 518,
        ALWAYS: 519
    };
module.exports = freezeObject(DepthFunction);
},{"../Core/freezeObject":249}],383:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), getImagePixels = require('../Core/getImagePixels'), loadImageViaBlob = require('../Core/loadImageViaBlob'), when = require('../ThirdParty/when');
'use strict';
var DiscardMissingTileImagePolicy = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.missingImageUrl)) {
        throw new DeveloperError('options.missingImageUrl is required.');
    }
    if (!defined(options.pixelsToCheck)) {
        throw new DeveloperError('options.pixelsToCheck is required.');
    }
    this._pixelsToCheck = options.pixelsToCheck;
    this._missingImagePixels = undefined;
    this._missingImageByteLength = undefined;
    this._isReady = false;
    var that = this;
    function success(image) {
        if (defined(image.blob)) {
            that._missingImageByteLength = image.blob.size;
        }
        var pixels = getImagePixels(image);
        if (options.disableCheckIfAllPixelsAreTransparent) {
            var allAreTransparent = true;
            var width = image.width;
            var pixelsToCheck = options.pixelsToCheck;
            for (var i = 0, len = pixelsToCheck.length; allAreTransparent && i < len; ++i) {
                var pos = pixelsToCheck[i];
                var index = pos.x * 4 + pos.y * width;
                var alpha = pixels[index + 3];
                if (alpha > 0) {
                    allAreTransparent = false;
                }
            }
            if (allAreTransparent) {
                pixels = undefined;
            }
        }
        that._missingImagePixels = pixels;
        that._isReady = true;
    }
    function failure() {
        that._missingImagePixels = undefined;
        that._isReady = true;
    }
    when(loadImageViaBlob(options.missingImageUrl), success, failure);
};
DiscardMissingTileImagePolicy.prototype.isReady = function () {
    return this._isReady;
};
DiscardMissingTileImagePolicy.prototype.shouldDiscardImage = function (image) {
    if (!this._isReady) {
        throw new DeveloperError('shouldDiscardImage must not be called before the discard policy is ready.');
    }
    var pixelsToCheck = this._pixelsToCheck;
    var missingImagePixels = this._missingImagePixels;
    if (!defined(missingImagePixels)) {
        return false;
    }
    if (defined(image.blob) && image.blob.size !== this._missingImageByteLength) {
        return false;
    }
    var pixels = getImagePixels(image);
    var width = image.width;
    for (var i = 0, len = pixelsToCheck.length; i < len; ++i) {
        var pos = pixelsToCheck[i];
        var index = pos.x * 4 + pos.y * width;
        for (var offset = 0; offset < 4; ++offset) {
            var pixel = index + offset;
            if (pixels[pixel] !== missingImagePixels[pixel]) {
                return false;
            }
        }
    }
    return true;
};
module.exports = DiscardMissingTileImagePolicy;
},{"../Core/DeveloperError":123,"../Core/defaultValue":243,"../Core/defined":245,"../Core/getImagePixels":251,"../Core/loadImageViaBlob":260,"../ThirdParty/when":596}],384:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), BoxGeometry = require('../Core/BoxGeometry'), Cartesian3 = require('../Core/Cartesian3'), combine = require('../Core/combine'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Matrix4 = require('../Core/Matrix4'), VertexFormat = require('../Core/VertexFormat'), BufferUsage = require('../Renderer/BufferUsage'), DrawCommand = require('../Renderer/DrawCommand'), ShaderSource = require('../Renderer/ShaderSource'), EllipsoidFS = require('../Shaders/EllipsoidFS'), EllipsoidVS = require('../Shaders/EllipsoidVS'), BlendingState = require('./BlendingState'), CullFace = require('./CullFace'), Material = require('./Material'), Pass = require('./Pass'), SceneMode = require('./SceneMode');
'use strict';
var attributeLocations = { position: 0 };
var EllipsoidPrimitive = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.center = Cartesian3.clone(defaultValue(options.center, Cartesian3.ZERO));
    this._center = new Cartesian3();
    this.radii = Cartesian3.clone(options.radii);
    this._radii = new Cartesian3();
    this._oneOverEllipsoidRadiiSquared = new Cartesian3();
    this._boundingSphere = new BoundingSphere();
    this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));
    this._modelMatrix = new Matrix4();
    this._computedModelMatrix = new Matrix4();
    this.show = defaultValue(options.show, true);
    this.material = defaultValue(options.material, Material.fromType(Material.ColorType));
    this._material = undefined;
    this._translucent = undefined;
    this.id = options.id;
    this._id = undefined;
    this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);
    this.onlySunLighting = defaultValue(options.onlySunLighting, false);
    this._onlySunLighting = false;
    this._sp = undefined;
    this._rs = undefined;
    this._va = undefined;
    this._pickSP = undefined;
    this._pickId = undefined;
    this._colorCommand = new DrawCommand({ owner: defaultValue(options._owner, this) });
    this._pickCommand = new DrawCommand({ owner: defaultValue(options._owner, this) });
    var that = this;
    this._uniforms = {
        u_radii: function () {
            return that.radii;
        },
        u_oneOverEllipsoidRadiiSquared: function () {
            return that._oneOverEllipsoidRadiiSquared;
        }
    };
    this._pickUniforms = {
        czm_pickColor: function () {
            return that._pickId.color;
        }
    };
};
function getVertexArray(context) {
    var vertexArray = context.cache.ellipsoidPrimitive_vertexArray;
    if (defined(vertexArray)) {
        return vertexArray;
    }
    var geometry = BoxGeometry.createGeometry(BoxGeometry.fromDimensions({
            dimensions: new Cartesian3(2, 2, 2),
            vertexFormat: VertexFormat.POSITION_ONLY
        }));
    vertexArray = context.createVertexArrayFromGeometry({
        geometry: geometry,
        attributeLocations: attributeLocations,
        bufferUsage: BufferUsage.STATIC_DRAW,
        interleave: true
    });
    context.cache.ellipsoidPrimitive_vertexArray = vertexArray;
    return vertexArray;
}
EllipsoidPrimitive.prototype.update = function (context, frameState, commandList) {
    if (!this.show || frameState.mode !== SceneMode.SCENE3D || !defined(this.center) || !defined(this.radii)) {
        return;
    }
    if (!defined(this.material)) {
        throw new DeveloperError('this.material must be defined.');
    }
    var translucent = this.material.isTranslucent();
    var translucencyChanged = this._translucent !== translucent;
    if (!defined(this._rs) || translucencyChanged) {
        this._translucent = translucent;
        this._rs = context.createRenderState({
            cull: {
                enabled: true,
                face: CullFace.FRONT
            },
            depthTest: { enabled: true },
            depthMask: !translucent && context.fragmentDepth,
            blending: translucent ? BlendingState.ALPHA_BLEND : undefined
        });
    }
    if (!defined(this._va)) {
        this._va = getVertexArray(context);
    }
    var boundingSphereDirty = false;
    var radii = this.radii;
    if (!Cartesian3.equals(this._radii, radii)) {
        Cartesian3.clone(radii, this._radii);
        var r = this._oneOverEllipsoidRadiiSquared;
        r.x = 1 / (radii.x * radii.x);
        r.y = 1 / (radii.y * radii.y);
        r.z = 1 / (radii.z * radii.z);
        boundingSphereDirty = true;
    }
    if (!Matrix4.equals(this.modelMatrix, this._modelMatrix) || !Cartesian3.equals(this.center, this._center)) {
        Matrix4.clone(this.modelMatrix, this._modelMatrix);
        Cartesian3.clone(this.center, this._center);
        Matrix4.multiplyByTranslation(this.modelMatrix, this.center, this._computedModelMatrix);
        boundingSphereDirty = true;
    }
    if (boundingSphereDirty) {
        Cartesian3.clone(Cartesian3.ZERO, this._boundingSphere.center);
        this._boundingSphere.radius = Cartesian3.maximumComponent(radii);
        BoundingSphere.transform(this._boundingSphere, this._computedModelMatrix, this._boundingSphere);
    }
    var materialChanged = this._material !== this.material;
    this._material = this.material;
    this._material.update(context);
    var lightingChanged = this.onlySunLighting !== this._onlySunLighting;
    this._onlySunLighting = this.onlySunLighting;
    var colorCommand = this._colorCommand;
    var vs;
    var fs;
    if (materialChanged || lightingChanged || translucencyChanged) {
        fs = new ShaderSource({
            sources: [
                this.material.shaderSource,
                EllipsoidFS
            ]
        });
        if (this.onlySunLighting) {
            fs.defines.push('ONLY_SUN_LIGHTING');
        }
        if (!translucent && context.fragmentDepth) {
            fs.defines.push('WRITE_DEPTH');
        }
        this._sp = context.replaceShaderProgram(this._sp, EllipsoidVS, fs, attributeLocations);
        colorCommand.vertexArray = this._va;
        colorCommand.renderState = this._rs;
        colorCommand.shaderProgram = this._sp;
        colorCommand.uniformMap = combine(this._uniforms, this.material._uniforms);
        colorCommand.executeInClosestFrustum = translucent;
    }
    var passes = frameState.passes;
    if (passes.render) {
        colorCommand.boundingVolume = this._boundingSphere;
        colorCommand.debugShowBoundingVolume = this.debugShowBoundingVolume;
        colorCommand.modelMatrix = this._computedModelMatrix;
        colorCommand.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;
        commandList.push(colorCommand);
    }
    if (passes.pick) {
        var pickCommand = this._pickCommand;
        if (!defined(this._pickId) || this._id !== this.id) {
            this._id = this.id;
            this._pickId = this._pickId && this._pickId.destroy();
            this._pickId = context.createPickId({
                primitive: this,
                id: this.id
            });
        }
        if (materialChanged || lightingChanged || !defined(this._pickSP)) {
            fs = new ShaderSource({
                sources: [
                    this.material.shaderSource,
                    EllipsoidFS
                ],
                pickColorQualifier: 'uniform'
            });
            if (this.onlySunLighting) {
                fs.defines.push('ONLY_SUN_LIGHTING');
            }
            if (!translucent && context.fragmentDepth) {
                fs.defines.push('WRITE_DEPTH');
            }
            this._pickSP = context.replaceShaderProgram(this._pickSP, EllipsoidVS, fs, attributeLocations);
            pickCommand.vertexArray = this._va;
            pickCommand.renderState = this._rs;
            pickCommand.shaderProgram = this._pickSP;
            pickCommand.uniformMap = combine(combine(this._uniforms, this._pickUniforms), this.material._uniforms);
            pickCommand.executeInClosestFrustum = translucent;
        }
        pickCommand.boundingVolume = this._boundingSphere;
        pickCommand.modelMatrix = this._computedModelMatrix;
        pickCommand.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;
        commandList.push(pickCommand);
    }
};
EllipsoidPrimitive.prototype.isDestroyed = function () {
    return false;
};
EllipsoidPrimitive.prototype.destroy = function () {
    this._sp = this._sp && this._sp.destroy();
    this._pickSP = this._pickSP && this._pickSP.destroy();
    this._pickId = this._pickId && this._pickId.destroy();
    return destroyObject(this);
};
module.exports = EllipsoidPrimitive;
},{"../Core/BoundingSphere":98,"../Core/BoxGeometry":99,"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/Matrix4":177,"../Core/VertexFormat":228,"../Core/combine":241,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/BufferUsage":339,"../Renderer/DrawCommand":344,"../Renderer/ShaderSource":355,"../Shaders/EllipsoidFS":548,"../Shaders/EllipsoidVS":549,"./BlendingState":374,"./CullFace":380,"./Material":404,"./Pass":419,"./SceneMode":438}],385:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), VertexFormat = require('../Core/VertexFormat'), EllipsoidSurfaceAppearanceFS = require('../Shaders/Appearances/EllipsoidSurfaceAppearanceFS'), EllipsoidSurfaceAppearanceVS = require('../Shaders/Appearances/EllipsoidSurfaceAppearanceVS'), Appearance = require('./Appearance'), Material = require('./Material');
'use strict';
var EllipsoidSurfaceAppearance = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var translucent = defaultValue(options.translucent, true);
    var aboveGround = defaultValue(options.aboveGround, false);
    this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
    this.translucent = defaultValue(options.translucent, true);
    this._vertexShaderSource = defaultValue(options.vertexShaderSource, EllipsoidSurfaceAppearanceVS);
    this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, EllipsoidSurfaceAppearanceFS);
    this._renderState = Appearance.getDefaultRenderState(translucent, !aboveGround, options.renderState);
    this._closed = false;
    this._flat = defaultValue(options.flat, false);
    this._faceForward = defaultValue(options.faceForward, aboveGround);
    this._aboveGround = aboveGround;
};
defineProperties(EllipsoidSurfaceAppearance.prototype, {
    vertexShaderSource: {
        get: function () {
            return this._vertexShaderSource;
        }
    },
    fragmentShaderSource: {
        get: function () {
            return this._fragmentShaderSource;
        }
    },
    renderState: {
        get: function () {
            return this._renderState;
        }
    },
    closed: {
        get: function () {
            return this._closed;
        }
    },
    vertexFormat: {
        get: function () {
            return EllipsoidSurfaceAppearance.VERTEX_FORMAT;
        }
    },
    flat: {
        get: function () {
            return this._flat;
        }
    },
    faceForward: {
        get: function () {
            return this._faceForward;
        }
    },
    aboveGround: {
        get: function () {
            return this._aboveGround;
        }
    }
});
EllipsoidSurfaceAppearance.VERTEX_FORMAT = VertexFormat.POSITION_AND_ST;
EllipsoidSurfaceAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;
EllipsoidSurfaceAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;
EllipsoidSurfaceAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;
module.exports = EllipsoidSurfaceAppearance;
},{"../Core/VertexFormat":228,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Shaders/Appearances/EllipsoidSurfaceAppearanceFS":463,"../Shaders/Appearances/EllipsoidSurfaceAppearanceVS":464,"./Appearance":366,"./Material":404}],386:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Color = require('../Core/Color'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), PixelFormat = require('../Core/PixelFormat'), ClearCommand = require('../Renderer/ClearCommand'), PixelDatatype = require('../Renderer/PixelDatatype'), RenderbufferFormat = require('../Renderer/RenderbufferFormat'), FXAAFS = require('../Shaders/PostProcessFilters/FXAA');
'use strict';
var FXAA = function (context) {
    this._texture = undefined;
    this._depthTexture = undefined;
    this._depthRenderbuffer = undefined;
    this._fbo = undefined;
    this._command = undefined;
    var clearCommand = new ClearCommand({
            color: new Color(0, 0, 0, 0),
            depth: 1,
            owner: this
        });
    this._clearCommand = clearCommand;
};
function destroyResources(fxaa) {
    fxaa._fbo = fxaa._fbo && fxaa._fbo.destroy();
    fxaa._texture = fxaa._texture && fxaa._texture.destroy();
    fxaa._depthTexture = fxaa._depthTexture && fxaa._depthTexture.destroy();
    fxaa._depthRenderbuffer = fxaa._depthRenderbuffer && fxaa._depthRenderbuffer.destroy();
    fxaa._fbo = undefined;
    fxaa._texture = undefined;
    fxaa._depthTexture = undefined;
    fxaa._depthRenderbuffer = undefined;
    if (defined(fxaa._command)) {
        fxaa._command.shaderProgram = fxaa._command.shaderProgram && fxaa._command.shaderProgram.destroy();
        fxaa._command = undefined;
    }
}
FXAA.prototype.update = function (context) {
    var width = context.drawingBufferWidth;
    var height = context.drawingBufferHeight;
    var fxaaTexture = this._texture;
    var textureChanged = !defined(fxaaTexture) || fxaaTexture.width !== width || fxaaTexture.height !== height;
    if (textureChanged) {
        this._texture = this._texture && this._texture.destroy();
        this._depthTexture = this._depthTexture && this._depthTexture.destroy();
        this._depthRenderbuffer = this._depthRenderbuffer && this._depthRenderbuffer.destroy();
        this._texture = context.createTexture2D({
            width: width,
            height: height,
            pixelFormat: PixelFormat.RGBA,
            pixelDatatype: PixelDatatype.UNSIGNED_BYTE
        });
        if (context.depthTexture) {
            this._depthTexture = context.createTexture2D({
                width: width,
                height: height,
                pixelFormat: PixelFormat.DEPTH_COMPONENT,
                pixelDatatype: PixelDatatype.UNSIGNED_SHORT
            });
        } else {
            this._depthRenderbuffer = context.createRenderbuffer({
                width: width,
                height: height,
                format: RenderbufferFormat.DEPTH_COMPONENT16
            });
        }
    }
    if (!defined(this._fbo) || textureChanged) {
        this._fbo = this._fbo && this._fbo.destroy();
        this._fbo = context.createFramebuffer({
            colorTextures: [this._texture],
            depthTexture: this._depthTexture,
            depthRenderbuffer: this._depthRenderbuffer,
            destroyAttachments: false
        });
    }
    if (!defined(this._command)) {
        this._command = context.createViewportQuadCommand(FXAAFS, {
            renderState: context.createRenderState(),
            owner: this
        });
    }
    if (textureChanged) {
        var that = this;
        var step = new Cartesian2(1 / this._texture.width, 1 / this._texture.height);
        this._command.uniformMap = {
            u_texture: function () {
                return that._texture;
            },
            u_step: function () {
                return step;
            }
        };
    }
};
FXAA.prototype.execute = function (context, passState) {
    this._command.execute(context, passState);
};
FXAA.prototype.clear = function (context, passState, clearColor) {
    var framebuffer = passState.framebuffer;
    passState.framebuffer = this._fbo;
    Color.clone(clearColor, this._clearCommand.color);
    this._clearCommand.execute(context, passState);
    passState.framebuffer = framebuffer;
};
FXAA.prototype.getColorFramebuffer = function () {
    return this._fbo;
};
FXAA.prototype.isDestroyed = function () {
    return false;
};
FXAA.prototype.destroy = function () {
    destroyResources(this);
    return destroyObject(this);
};
module.exports = FXAA;
},{"../Core/Cartesian2":101,"../Core/Color":111,"../Core/PixelFormat":181,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/ClearCommand":340,"../Renderer/PixelDatatype":349,"../Renderer/RenderbufferFormat":352,"../Shaders/PostProcessFilters/FXAA":573}],387:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), getTimestamp = require('../Core/getTimestamp'), TimeConstants = require('../Core/TimeConstants');
'use strict';
var FrameRateMonitor = function (options) {
    if (!defined(options) || !defined(options.scene)) {
        throw new DeveloperError('options.scene is required.');
    }
    this._scene = options.scene;
    this.samplingWindow = defaultValue(options.samplingWindow, FrameRateMonitor.defaultSettings.samplingWindow);
    this.quietPeriod = defaultValue(options.quietPeriod, FrameRateMonitor.defaultSettings.quietPeriod);
    this.warmupPeriod = defaultValue(options.warmupPeriod, FrameRateMonitor.defaultSettings.warmupPeriod);
    this.minimumFrameRateDuringWarmup = defaultValue(options.minimumFrameRateDuringWarmup, FrameRateMonitor.defaultSettings.minimumFrameRateDuringWarmup);
    this.minimumFrameRateAfterWarmup = defaultValue(options.minimumFrameRateAfterWarmup, FrameRateMonitor.defaultSettings.minimumFrameRateAfterWarmup);
    this._lowFrameRate = new Event();
    this._nominalFrameRate = new Event();
    this._frameTimes = [];
    this._needsQuietPeriod = true;
    this._quietPeriodEndTime = 0;
    this._warmupPeriodEndTime = 0;
    this._frameRateIsLow = false;
    this._lastFramesPerSecond = undefined;
    this._pauseCount = 0;
    var that = this;
    this._preRenderRemoveListener = this._scene.preRender.addEventListener(function (scene, time) {
        update(that, time);
    });
    this._hiddenPropertyName = defined(document.hidden) ? 'hidden' : defined(document.mozHidden) ? 'mozHidden' : defined(document.msHidden) ? 'msHidden' : defined(document.webkitHidden) ? 'webkitHidden' : undefined;
    var visibilityChangeEventName = defined(document.hidden) ? 'visibilitychange' : defined(document.mozHidden) ? 'mozvisibilitychange' : defined(document.msHidden) ? 'msvisibilitychange' : defined(document.webkitHidden) ? 'webkitvisibilitychange' : undefined;
    function visibilityChangeListener() {
        visibilityChanged(that);
    }
    this._visibilityChangeRemoveListener = undefined;
    if (defined(visibilityChangeEventName)) {
        document.addEventListener(visibilityChangeEventName, visibilityChangeListener, false);
        this._visibilityChangeRemoveListener = function () {
            document.removeEventListener(visibilityChangeEventName, visibilityChangeListener, false);
        };
    }
};
FrameRateMonitor.defaultSettings = {
    samplingWindow: 5,
    quietPeriod: 2,
    warmupPeriod: 5,
    minimumFrameRateDuringWarmup: 4,
    minimumFrameRateAfterWarmup: 8
};
FrameRateMonitor.fromScene = function (scene) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(scene._frameRateMonitor) || scene._frameRateMonitor.isDestroyed()) {
        scene._frameRateMonitor = new FrameRateMonitor({ scene: scene });
    }
    return scene._frameRateMonitor;
};
defineProperties(FrameRateMonitor.prototype, {
    scene: {
        get: function () {
            return this._scene;
        }
    },
    lowFrameRate: {
        get: function () {
            return this._lowFrameRate;
        }
    },
    nominalFrameRate: {
        get: function () {
            return this._nominalFrameRate;
        }
    },
    lastFramesPerSecond: {
        get: function () {
            return this._lastFramesPerSecond;
        }
    }
});
FrameRateMonitor.prototype.pause = function () {
    ++this._pauseCount;
    if (this._pauseCount === 1) {
        this._frameTimes.length = 0;
        this._lastFramesPerSecond = undefined;
    }
};
FrameRateMonitor.prototype.unpause = function () {
    --this._pauseCount;
    if (this._pauseCount <= 0) {
        this._pauseCount = 0;
        this._needsQuietPeriod = true;
    }
};
FrameRateMonitor.prototype.isDestroyed = function () {
    return false;
};
FrameRateMonitor.prototype.destroy = function () {
    this._preRenderRemoveListener();
    if (defined(this._visibilityChangeRemoveListener)) {
        this._visibilityChangeRemoveListener();
    }
    return destroyObject(this);
};
function update(monitor, time) {
    if (monitor._pauseCount > 0) {
        return;
    }
    var timeStamp = getTimestamp();
    if (monitor._needsQuietPeriod) {
        monitor._needsQuietPeriod = false;
        monitor._frameTimes.length = 0;
        monitor._quietPeriodEndTime = timeStamp + monitor.quietPeriod / TimeConstants.SECONDS_PER_MILLISECOND;
        monitor._warmupPeriodEndTime = monitor._quietPeriodEndTime + (monitor.warmupPeriod + monitor.samplingWindow) / TimeConstants.SECONDS_PER_MILLISECOND;
    } else if (timeStamp >= monitor._quietPeriodEndTime) {
        monitor._frameTimes.push(timeStamp);
        var beginningOfWindow = timeStamp - monitor.samplingWindow / TimeConstants.SECONDS_PER_MILLISECOND;
        if (monitor._frameTimes.length >= 2 && monitor._frameTimes[0] <= beginningOfWindow) {
            while (monitor._frameTimes.length >= 2 && monitor._frameTimes[1] < beginningOfWindow) {
                monitor._frameTimes.shift();
            }
            var averageTimeBetweenFrames = (timeStamp - monitor._frameTimes[0]) / (monitor._frameTimes.length - 1);
            monitor._lastFramesPerSecond = 1000 / averageTimeBetweenFrames;
            var maximumFrameTime = 1000 / (timeStamp > monitor._warmupPeriodEndTime ? monitor.minimumFrameRateAfterWarmup : monitor.minimumFrameRateDuringWarmup);
            if (averageTimeBetweenFrames > maximumFrameTime) {
                if (!monitor._frameRateIsLow) {
                    monitor._frameRateIsLow = true;
                    monitor._needsQuietPeriod = true;
                    monitor.lowFrameRate.raiseEvent(monitor.scene, monitor._lastFramesPerSecond);
                }
            } else if (monitor._frameRateIsLow) {
                monitor._frameRateIsLow = false;
                monitor._needsQuietPeriod = true;
                monitor.nominalFrameRate.raiseEvent(monitor.scene, monitor._lastFramesPerSecond);
            }
        }
    }
}
function visibilityChanged(monitor) {
    if (document[monitor._hiddenPropertyName]) {
        monitor.pause();
    } else {
        monitor.unpause();
    }
}
module.exports = FrameRateMonitor;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/TimeConstants":221,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Core/getTimestamp":252}],388:[function(require,module,exports){
var SceneMode = require('./SceneMode');
'use strict';
var FrameState = function (creditDisplay) {
    this.mode = SceneMode.SCENE3D;
    this.morphTime = SceneMode.getMorphTime(SceneMode.SCENE3D);
    this.frameNumber = 0;
    this.time = undefined;
    this.mapProjection = undefined;
    this.camera = undefined;
    this.cullingVolume = undefined;
    this.occluder = undefined;
    this.passes = {
        render: false,
        pick: false
    };
    this.creditDisplay = creditDisplay;
    this.afterRender = [];
    this.scene3DOnly = false;
};
module.exports = FrameState;
},{"./SceneMode":438}],389:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue');
'use strict';
var FrustumCommands = function (near, far) {
    this.near = defaultValue(near, 0);
    this.far = defaultValue(far, 0);
    this.opaqueCommands = [];
    this.translucentCommands = [];
};
module.exports = FrustumCommands;
},{"../Core/defaultValue":243}],390:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), BoundingSphere = require('../Core/BoundingSphere'), buildModuleUrl = require('../Core/buildModuleUrl'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartographic = require('../Core/Cartographic'), combine = require('../Core/combine'), ComponentDatatype = require('../Core/ComponentDatatype'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Ellipsoid = require('../Core/Ellipsoid'), EllipsoidTerrainProvider = require('../Core/EllipsoidTerrainProvider'), FeatureDetection = require('../Core/FeatureDetection'), GeographicProjection = require('../Core/GeographicProjection'), Geometry = require('../Core/Geometry'), GeometryAttribute = require('../Core/GeometryAttribute'), Intersect = require('../Core/Intersect'), IntersectionTests = require('../Core/IntersectionTests'), loadImage = require('../Core/loadImage'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), Occluder = require('../Core/Occluder'), PrimitiveType = require('../Core/PrimitiveType'), Ray = require('../Core/Ray'), Rectangle = require('../Core/Rectangle'), Transforms = require('../Core/Transforms'), BufferUsage = require('../Renderer/BufferUsage'), ClearCommand = require('../Renderer/ClearCommand'), DrawCommand = require('../Renderer/DrawCommand'), ShaderSource = require('../Renderer/ShaderSource'), GlobeFS = require('../Shaders/GlobeFS'), GlobeFSDepth = require('../Shaders/GlobeFSDepth'), GlobeFSPole = require('../Shaders/GlobeFSPole'), GlobeVS = require('../Shaders/GlobeVS'), GlobeVSDepth = require('../Shaders/GlobeVSDepth'), GlobeVSPole = require('../Shaders/GlobeVSPole'), when = require('../ThirdParty/when'), DepthFunction = require('./DepthFunction'), GlobeSurfaceShaderSet = require('./GlobeSurfaceShaderSet'), GlobeSurfaceTileProvider = require('./GlobeSurfaceTileProvider'), ImageryLayerCollection = require('./ImageryLayerCollection'), Pass = require('./Pass'), QuadtreePrimitive = require('./QuadtreePrimitive'), SceneMode = require('./SceneMode'), terrainAttributeLocations = require('./terrainAttributeLocations');
'use strict';
var Globe = function (ellipsoid) {
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    var terrainProvider = new EllipsoidTerrainProvider({ ellipsoid: ellipsoid });
    var imageryLayerCollection = new ImageryLayerCollection();
    this._ellipsoid = ellipsoid;
    this._imageryLayerCollection = imageryLayerCollection;
    this._surfaceShaderSet = new GlobeSurfaceShaderSet();
    this._surfaceShaderSet.baseVertexShaderSource = new ShaderSource({ sources: [GlobeVS] });
    this._surfaceShaderSet.baseFragmentShaderSource = new ShaderSource({ sources: [GlobeFS] });
    this._surface = new QuadtreePrimitive({
        tileProvider: new GlobeSurfaceTileProvider({
            terrainProvider: terrainProvider,
            imageryLayers: imageryLayerCollection,
            surfaceShaderSet: this._surfaceShaderSet
        })
    });
    this._occluder = new Occluder(new BoundingSphere(Cartesian3.ZERO, ellipsoid.minimumRadius), Cartesian3.ZERO);
    this._rsColor = undefined;
    this._rsColorWithoutDepthTest = undefined;
    this._clearDepthCommand = new ClearCommand({
        depth: 1,
        stencil: 0,
        owner: this
    });
    this._depthCommand = new DrawCommand({
        boundingVolume: new BoundingSphere(Cartesian3.ZERO, ellipsoid.maximumRadius),
        pass: Pass.OPAQUE,
        owner: this
    });
    this._northPoleCommand = new DrawCommand({
        pass: Pass.OPAQUE,
        owner: this
    });
    this._southPoleCommand = new DrawCommand({
        pass: Pass.OPAQUE,
        owner: this
    });
    this._drawNorthPole = false;
    this._drawSouthPole = false;
    this._mode = SceneMode.SCENE3D;
    this.terrainProvider = terrainProvider;
    this.northPoleColor = new Cartesian3(2 / 255, 6 / 255, 18 / 255);
    this.southPoleColor = new Cartesian3(1, 1, 1);
    this.show = true;
    this.oceanNormalMapUrl = buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg');
    this._oceanNormalMapUrl = undefined;
    this.depthTestAgainstTerrain = false;
    this.maximumScreenSpaceError = 2;
    this.tileCacheSize = 100;
    this.enableLighting = false;
    this.lightingFadeOutDistance = 6500000;
    this.lightingFadeInDistance = 9000000;
    this.showWaterEffect = true;
    this._oceanNormalMap = undefined;
    this._zoomedOutOceanSpecularIntensity = 0.5;
    this._lightingFadeDistance = new Cartesian2(this.lightingFadeOutDistance, this.lightingFadeInDistance);
    var that = this;
    this._drawUniforms = {
        u_zoomedOutOceanSpecularIntensity: function () {
            return that._zoomedOutOceanSpecularIntensity;
        },
        u_oceanNormalMap: function () {
            return that._oceanNormalMap;
        },
        u_lightingFadeDistance: function () {
            return that._lightingFadeDistance;
        }
    };
};
defineProperties(Globe.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    },
    imageryLayers: {
        get: function () {
            return this._imageryLayerCollection;
        }
    },
    baseColor: {
        get: function () {
            return this._surface.tileProvider.baseColor;
        },
        set: function (value) {
            this._surface.tileProvider.baseColor = value;
        }
    }
});
function createComparePickTileFunction(rayOrigin) {
    return function (a, b) {
        var aDist = BoundingSphere.distanceSquaredTo(a.data.pickBoundingSphere, rayOrigin);
        var bDist = BoundingSphere.distanceSquaredTo(b.data.pickBoundingSphere, rayOrigin);
        return aDist - bDist;
    };
}
var scratchArray = [];
var scratchSphereIntersectionResult = {
        start: 0,
        stop: 0
    };
Globe.prototype.pick = function (ray, scene, result) {
    if (!defined(ray)) {
        throw new DeveloperError('ray is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    var mode = scene.mode;
    var projection = scene.mapProjection;
    var sphereIntersections = scratchArray;
    sphereIntersections.length = 0;
    var tilesToRender = this._surface._tilesToRender;
    var length = tilesToRender.length;
    var tile;
    var i;
    for (i = 0; i < length; ++i) {
        tile = tilesToRender[i];
        var tileData = tile.data;
        if (!defined(tileData)) {
            continue;
        }
        var boundingVolume = tileData.pickBoundingSphere;
        if (mode !== SceneMode.SCENE3D) {
            BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, projection, tileData.minimumHeight, tileData.maximumHeight, boundingVolume);
            Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);
        } else {
            BoundingSphere.clone(tileData.boundingSphere3D, boundingVolume);
        }
        var boundingSphereIntersection = IntersectionTests.raySphere(ray, boundingVolume, scratchSphereIntersectionResult);
        if (defined(boundingSphereIntersection)) {
            sphereIntersections.push(tile);
        }
    }
    sphereIntersections.sort(createComparePickTileFunction(ray.origin));
    var intersection;
    length = sphereIntersections.length;
    for (i = 0; i < length; ++i) {
        intersection = sphereIntersections[i].data.pick(ray, scene, true, result);
        if (defined(intersection)) {
            break;
        }
    }
    return intersection;
};
Globe.prototype.pickTriangle = function (ray, scene, result) {
    if (!defined(ray)) {
        throw new DeveloperError('ray is required');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required');
    }
    var mode = scene.mode;
    var projection = scene.mapProjection;
    var sphereIntersections = scratchArray;
    sphereIntersections.length = 0;
    var tilesToRender = this._surface._tilesToRender;
    var length = tilesToRender.length;
    var tile;
    var i;
    for (i = 0; i < length; ++i) {
        tile = tilesToRender[i];
        var tileData = tile.data;
        if (!defined(tileData)) {
            continue;
        }
        var boundingVolume = tileData.pickBoundingSphere;
        if (mode !== SceneMode.SCENE3D) {
            BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, projection, tileData.minimumHeight, tileData.maximumHeight, boundingVolume);
            Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);
        } else {
            BoundingSphere.clone(tileData.boundingSphere3D, boundingVolume);
        }
        var boundingSphereIntersection = IntersectionTests.raySphere(ray, boundingVolume, scratchSphereIntersectionResult);
        if (defined(boundingSphereIntersection)) {
            sphereIntersections.push(tile);
        }
    }
    sphereIntersections.sort(createComparePickTileFunction(ray.origin));
    var intersection;
    length = sphereIntersections.length;
    for (i = 0; i < length; ++i) {
        intersection = sphereIntersections[i].data.pickTriangle(ray, scene, true, result);
        if (defined(intersection)) {
            intersection.tile = sphereIntersections[i];
            break;
        }
    }
    return intersection;
};
var scratchGetHeightCartesian = new Cartesian3();
var scratchGetHeightIntersection = new Cartesian3();
var scratchGetHeightCartographic = new Cartographic();
var scratchGetHeightRay = new Ray();
Globe.prototype.getHeight = function (cartographic) {
    if (!defined(cartographic)) {
        throw new DeveloperError('cartographic is required');
    }
    var levelZeroTiles = this._surface._levelZeroTiles;
    if (!defined(levelZeroTiles)) {
        return;
    }
    var tile;
    var i;
    var length = levelZeroTiles.length;
    for (i = 0; i < length; ++i) {
        tile = levelZeroTiles[i];
        if (Rectangle.contains(tile.rectangle, cartographic)) {
            break;
        }
    }
    if (!defined(tile) || !Rectangle.contains(tile.rectangle, cartographic)) {
        return undefined;
    }
    while (tile.renderable) {
        var children = tile.children;
        length = children.length;
        for (i = 0; i < length; ++i) {
            tile = children[i];
            if (Rectangle.contains(tile.rectangle, cartographic)) {
                break;
            }
        }
    }
    while (defined(tile) && (!defined(tile.data) || !defined(tile.data.pickTerrain))) {
        tile = tile.parent;
    }
    if (!defined(tile)) {
        return undefined;
    }
    var ellipsoid = this._surface._tileProvider.tilingScheme.ellipsoid;
    var cartesian = ellipsoid.cartographicToCartesian(cartographic, scratchGetHeightCartesian);
    var ray = scratchGetHeightRay;
    Cartesian3.normalize(cartesian, ray.direction);
    var intersection = tile.data.pick(ray, undefined, false, scratchGetHeightIntersection);
    if (!defined(intersection)) {
        return undefined;
    }
    return ellipsoid.cartesianToCartographic(intersection, scratchGetHeightCartographic).height;
};
var depthQuadScratch = FeatureDetection.supportsTypedArrays() ? new Float32Array(12) : [];
var scratchCartesian1 = new Cartesian3();
var scratchCartesian2 = new Cartesian3();
var scratchCartesian3 = new Cartesian3();
var scratchCartesian4 = new Cartesian3();
function computeDepthQuad(globe, frameState) {
    var radii = globe._ellipsoid.radii;
    var p = frameState.camera.positionWC;
    var q = Cartesian3.multiplyComponents(globe._ellipsoid.oneOverRadii, p, scratchCartesian1);
    var qMagnitude = Cartesian3.magnitude(q);
    var qUnit = Cartesian3.normalize(q, scratchCartesian2);
    var eUnit = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, q, scratchCartesian3), scratchCartesian3);
    var nUnit = Cartesian3.normalize(Cartesian3.cross(qUnit, eUnit, scratchCartesian4), scratchCartesian4);
    var wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1);
    var center = Cartesian3.multiplyByScalar(qUnit, 1 / qMagnitude, scratchCartesian1);
    var scalar = wMagnitude / qMagnitude;
    var eastOffset = Cartesian3.multiplyByScalar(eUnit, scalar, scratchCartesian2);
    var northOffset = Cartesian3.multiplyByScalar(nUnit, scalar, scratchCartesian3);
    var upperLeft = Cartesian3.add(center, northOffset, scratchCartesian4);
    Cartesian3.subtract(upperLeft, eastOffset, upperLeft);
    Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);
    Cartesian3.pack(upperLeft, depthQuadScratch, 0);
    var lowerLeft = Cartesian3.subtract(center, northOffset, scratchCartesian4);
    Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);
    Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);
    Cartesian3.pack(lowerLeft, depthQuadScratch, 3);
    var upperRight = Cartesian3.add(center, northOffset, scratchCartesian4);
    Cartesian3.add(upperRight, eastOffset, upperRight);
    Cartesian3.multiplyComponents(radii, upperRight, upperRight);
    Cartesian3.pack(upperRight, depthQuadScratch, 6);
    var lowerRight = Cartesian3.subtract(center, northOffset, scratchCartesian4);
    Cartesian3.add(lowerRight, eastOffset, lowerRight);
    Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);
    Cartesian3.pack(lowerRight, depthQuadScratch, 9);
    return depthQuadScratch;
}
var rightScratch = new Cartesian3();
var upScratch = new Cartesian3();
var negativeZ = Cartesian3.negate(Cartesian3.UNIT_Z, new Cartesian3());
var cartographicScratch = new Cartographic(0, 0);
var pt1Scratch = new Cartesian3();
var pt2Scratch = new Cartesian3();
function computePoleQuad(globe, frameState, maxLat, maxGivenLat, viewProjMatrix, viewportTransformation) {
    cartographicScratch.longitude = 0;
    cartographicScratch.latitude = maxGivenLat;
    var pt1 = globe._ellipsoid.cartographicToCartesian(cartographicScratch, pt1Scratch);
    cartographicScratch.longitude = Math.PI;
    var pt2 = globe._ellipsoid.cartographicToCartesian(cartographicScratch, pt2Scratch);
    var radius = Cartesian3.magnitude(Cartesian3.subtract(pt1, pt2, rightScratch), rightScratch) * 0.5;
    cartographicScratch.longitude = 0;
    cartographicScratch.latitude = maxLat;
    var center = globe._ellipsoid.cartographicToCartesian(cartographicScratch, pt1Scratch);
    var right;
    var dir = frameState.camera.direction;
    if (1 - Cartesian3.dot(negativeZ, dir) < CesiumMath.EPSILON6) {
        right = Cartesian3.UNIT_X;
    } else {
        right = Cartesian3.normalize(Cartesian3.cross(dir, Cartesian3.UNIT_Z, rightScratch), rightScratch);
    }
    var screenRight = Cartesian3.add(center, Cartesian3.multiplyByScalar(right, radius, rightScratch), rightScratch);
    var screenUp = Cartesian3.add(center, Cartesian3.multiplyByScalar(Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, right, upScratch), upScratch), radius, upScratch), upScratch);
    Transforms.pointToGLWindowCoordinates(viewProjMatrix, viewportTransformation, center, center);
    Transforms.pointToGLWindowCoordinates(viewProjMatrix, viewportTransformation, screenRight, screenRight);
    Transforms.pointToGLWindowCoordinates(viewProjMatrix, viewportTransformation, screenUp, screenUp);
    var halfWidth = Math.floor(Math.max(Cartesian3.distance(screenUp, center), Cartesian3.distance(screenRight, center)));
    var halfHeight = halfWidth;
    return new BoundingRectangle(Math.floor(center.x) - halfWidth, Math.floor(center.y) - halfHeight, halfWidth * 2, halfHeight * 2);
}
var viewportScratch = new BoundingRectangle();
var vpTransformScratch = new Matrix4();
var polePositionsScratch = FeatureDetection.supportsTypedArrays() ? new Float32Array(8) : [];
function fillPoles(globe, context, frameState) {
    var terrainProvider = globe.terrainProvider;
    if (frameState.mode !== SceneMode.SCENE3D) {
        return;
    }
    if (!terrainProvider.ready) {
        return;
    }
    var terrainMaxRectangle = terrainProvider.tilingScheme.rectangle;
    var viewProjMatrix = context.uniformState.viewProjection;
    var viewport = viewportScratch;
    viewport.width = context.drawingBufferWidth;
    viewport.height = context.drawingBufferHeight;
    var viewportTransformation = Matrix4.computeViewportTransformation(viewport, 0, 1, vpTransformScratch);
    var latitudeExtension = 0.05;
    var rectangle;
    var boundingVolume;
    var frustumCull;
    var occludeePoint;
    var occluded;
    var geometry;
    var rect;
    var occluder = globe._occluder;
    if (terrainMaxRectangle.north < CesiumMath.PI_OVER_TWO) {
        rectangle = new Rectangle(-Math.PI, terrainMaxRectangle.north, Math.PI, CesiumMath.PI_OVER_TWO);
        boundingVolume = BoundingSphere.fromRectangle3D(rectangle, globe._ellipsoid);
        frustumCull = frameState.cullingVolume.computeVisibility(boundingVolume) === Intersect.OUTSIDE;
        occludeePoint = Occluder.computeOccludeePointFromRectangle(rectangle, globe._ellipsoid);
        occluded = occludeePoint && !occluder.isPointVisible(occludeePoint, 0) || !occluder.isBoundingSphereVisible(boundingVolume);
        globe._drawNorthPole = !frustumCull && !occluded;
        if (globe._drawNorthPole) {
            rect = computePoleQuad(globe, frameState, rectangle.north, rectangle.south - latitudeExtension, viewProjMatrix, viewportTransformation);
            polePositionsScratch[0] = rect.x;
            polePositionsScratch[1] = rect.y;
            polePositionsScratch[2] = rect.x + rect.width;
            polePositionsScratch[3] = rect.y;
            polePositionsScratch[4] = rect.x + rect.width;
            polePositionsScratch[5] = rect.y + rect.height;
            polePositionsScratch[6] = rect.x;
            polePositionsScratch[7] = rect.y + rect.height;
            if (!defined(globe._northPoleCommand.vertexArray)) {
                globe._northPoleCommand.boundingVolume = BoundingSphere.fromRectangle3D(rectangle, globe._ellipsoid);
                geometry = new Geometry({
                    attributes: {
                        position: new GeometryAttribute({
                            componentDatatype: ComponentDatatype.FLOAT,
                            componentsPerAttribute: 2,
                            values: polePositionsScratch
                        })
                    }
                });
                globe._northPoleCommand.vertexArray = context.createVertexArrayFromGeometry({
                    geometry: geometry,
                    attributeLocations: { position: 0 },
                    bufferUsage: BufferUsage.STREAM_DRAW
                });
            } else {
                globe._northPoleCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(polePositionsScratch);
            }
        }
    }
    if (terrainMaxRectangle.south > -CesiumMath.PI_OVER_TWO) {
        rectangle = new Rectangle(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, terrainMaxRectangle.south);
        boundingVolume = BoundingSphere.fromRectangle3D(rectangle, globe._ellipsoid);
        frustumCull = frameState.cullingVolume.computeVisibility(boundingVolume) === Intersect.OUTSIDE;
        occludeePoint = Occluder.computeOccludeePointFromRectangle(rectangle, globe._ellipsoid);
        occluded = occludeePoint && !occluder.isPointVisible(occludeePoint) || !occluder.isBoundingSphereVisible(boundingVolume);
        globe._drawSouthPole = !frustumCull && !occluded;
        if (globe._drawSouthPole) {
            rect = computePoleQuad(globe, frameState, rectangle.south, rectangle.north + latitudeExtension, viewProjMatrix, viewportTransformation);
            polePositionsScratch[0] = rect.x;
            polePositionsScratch[1] = rect.y;
            polePositionsScratch[2] = rect.x + rect.width;
            polePositionsScratch[3] = rect.y;
            polePositionsScratch[4] = rect.x + rect.width;
            polePositionsScratch[5] = rect.y + rect.height;
            polePositionsScratch[6] = rect.x;
            polePositionsScratch[7] = rect.y + rect.height;
            if (!defined(globe._southPoleCommand.vertexArray)) {
                globe._southPoleCommand.boundingVolume = BoundingSphere.fromRectangle3D(rectangle, globe._ellipsoid);
                geometry = new Geometry({
                    attributes: {
                        position: new GeometryAttribute({
                            componentDatatype: ComponentDatatype.FLOAT,
                            componentsPerAttribute: 2,
                            values: polePositionsScratch
                        })
                    }
                });
                globe._southPoleCommand.vertexArray = context.createVertexArrayFromGeometry({
                    geometry: geometry,
                    attributeLocations: { position: 0 },
                    bufferUsage: BufferUsage.STREAM_DRAW
                });
            } else {
                globe._southPoleCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(polePositionsScratch);
            }
        }
    }
    var poleIntensity = 0;
    var baseLayer = globe._imageryLayerCollection.length > 0 ? globe._imageryLayerCollection.get(0) : undefined;
    if (defined(baseLayer) && defined(baseLayer.imageryProvider) && defined(baseLayer.imageryProvider.getPoleIntensity)) {
        poleIntensity = baseLayer.imageryProvider.getPoleIntensity();
    }
    var drawUniforms = {
            u_dayIntensity: function () {
                return poleIntensity;
            }
        };
    if (!defined(globe._northPoleCommand.uniformMap)) {
        var northPoleUniforms = combine(drawUniforms, {
                u_color: function () {
                    return globe.northPoleColor;
                }
            });
        globe._northPoleCommand.uniformMap = combine(northPoleUniforms, globe._drawUniforms);
    }
    if (!defined(globe._southPoleCommand.uniformMap)) {
        var southPoleUniforms = combine(drawUniforms, {
                u_color: function () {
                    return globe.southPoleColor;
                }
            });
        globe._southPoleCommand.uniformMap = combine(southPoleUniforms, globe._drawUniforms);
    }
}
Globe.prototype.update = function (context, frameState, commandList) {
    if (!this.show) {
        return;
    }
    var width = context.drawingBufferWidth;
    var height = context.drawingBufferHeight;
    if (width === 0 || height === 0) {
        return;
    }
    var mode = frameState.mode;
    var projection = frameState.mapProjection;
    var modeChanged = false;
    if (this._mode !== mode || !defined(this._rsColor)) {
        modeChanged = true;
        if (mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) {
            this._rsColor = context.createRenderState({
                cull: { enabled: true },
                depthTest: { enabled: true }
            });
            this._rsColorWithoutDepthTest = context.createRenderState({ cull: { enabled: true } });
            this._depthCommand.renderState = context.createRenderState({
                cull: { enabled: true },
                depthTest: {
                    enabled: true,
                    func: DepthFunction.ALWAYS
                },
                colorMask: {
                    red: false,
                    green: false,
                    blue: false,
                    alpha: false
                }
            });
        } else {
            this._rsColor = context.createRenderState({ cull: { enabled: true } });
            this._rsColorWithoutDepthTest = context.createRenderState({ cull: { enabled: true } });
            this._depthCommand.renderState = context.createRenderState({ cull: { enabled: true } });
        }
    }
    this._mode = mode;
    var northPoleCommand = this._northPoleCommand;
    var southPoleCommand = this._southPoleCommand;
    northPoleCommand.renderState = this._rsColorWithoutDepthTest;
    southPoleCommand.renderState = this._rsColorWithoutDepthTest;
    var depthQuad = computeDepthQuad(this, frameState);
    if (!this._depthCommand.vertexArray) {
        var geometry = new Geometry({
                attributes: {
                    position: new GeometryAttribute({
                        componentDatatype: ComponentDatatype.FLOAT,
                        componentsPerAttribute: 3,
                        values: depthQuad
                    })
                },
                indices: [
                    0,
                    1,
                    2,
                    2,
                    1,
                    3
                ],
                primitiveType: PrimitiveType.TRIANGLES
            });
        this._depthCommand.vertexArray = context.createVertexArrayFromGeometry({
            geometry: geometry,
            attributeLocations: { position: 0 },
            bufferUsage: BufferUsage.DYNAMIC_DRAW
        });
    } else {
        this._depthCommand.vertexArray.getAttribute(0).vertexBuffer.copyFromArrayView(depthQuad);
    }
    if (!defined(this._depthCommand.shaderProgram)) {
        this._depthCommand.shaderProgram = context.createShaderProgram(GlobeVSDepth, GlobeFSDepth, { position: 0 });
    }
    var surface = this._surface;
    var tileProvider = surface.tileProvider;
    var terrainProvider = this.terrainProvider;
    var hasWaterMask = this.showWaterEffect && terrainProvider.ready && terrainProvider.hasWaterMask;
    if (hasWaterMask && this.oceanNormalMapUrl !== this._oceanNormalMapUrl) {
        var oceanNormalMapUrl = this.oceanNormalMapUrl;
        this._oceanNormalMapUrl = oceanNormalMapUrl;
        if (defined(oceanNormalMapUrl)) {
            var that = this;
            when(loadImage(oceanNormalMapUrl), function (image) {
                if (oceanNormalMapUrl !== that.oceanNormalMapUrl) {
                    return;
                }
                that._oceanNormalMap = that._oceanNormalMap && that._oceanNormalMap.destroy();
                that._oceanNormalMap = context.createTexture2D({ source: image });
            });
        } else {
            this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();
        }
    }
    if (!defined(northPoleCommand.shaderProgram) || !defined(southPoleCommand.shaderProgram)) {
        var poleShaderProgram = context.replaceShaderProgram(northPoleCommand.shaderProgram, GlobeVSPole, GlobeFSPole, terrainAttributeLocations);
        northPoleCommand.shaderProgram = poleShaderProgram;
        southPoleCommand.shaderProgram = poleShaderProgram;
    }
    this._occluder.cameraPosition = frameState.camera.positionWC;
    fillPoles(this, context, frameState);
    var pass = frameState.passes;
    if (pass.render) {
        if (mode === SceneMode.SCENE3D) {
            if (this._drawNorthPole) {
                commandList.push(northPoleCommand);
            }
            if (this._drawSouthPole) {
                commandList.push(southPoleCommand);
            }
        }
        if (mode === SceneMode.SCENE3D) {
            this._zoomedOutOceanSpecularIntensity = 0.5;
        } else {
            this._zoomedOutOceanSpecularIntensity = 0;
        }
        surface.maximumScreenSpaceError = this.maximumScreenSpaceError;
        surface.tileCacheSize = this.tileCacheSize;
        tileProvider.terrainProvider = this.terrainProvider;
        tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;
        tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;
        tileProvider.zoomedOutOceanSpecularIntensity = this._zoomedOutOceanSpecularIntensity;
        tileProvider.hasWaterMask = hasWaterMask;
        tileProvider.oceanNormalMap = this._oceanNormalMap;
        tileProvider.enableLighting = this.enableLighting;
        surface.update(context, frameState, commandList);
        if (mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) {
            if (!this.depthTestAgainstTerrain) {
                commandList.push(this._clearDepthCommand);
                if (mode === SceneMode.SCENE3D) {
                    commandList.push(this._depthCommand);
                }
            }
        }
    }
    if (pass.pick) {
        commandList.push(this._depthCommand);
    }
};
Globe.prototype.isDestroyed = function () {
    return false;
};
Globe.prototype.destroy = function () {
    this._northPoleCommand.vertexArray = this._northPoleCommand.vertexArray && this._northPoleCommand.vertexArray.destroy();
    this._southPoleCommand.vertexArray = this._southPoleCommand.vertexArray && this._southPoleCommand.vertexArray.destroy();
    this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy();
    this._northPoleCommand.shaderProgram = this._northPoleCommand.shaderProgram && this._northPoleCommand.shaderProgram.destroy();
    this._southPoleCommand.shaderProgram = this._northPoleCommand.shaderProgram;
    this._depthCommand.shaderProgram = this._depthCommand.shaderProgram && this._depthCommand.shaderProgram.destroy();
    this._depthCommand.vertexArray = this._depthCommand.vertexArray && this._depthCommand.vertexArray.destroy();
    this._surface = this._surface && this._surface.destroy();
    this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();
    return destroyObject(this);
};
module.exports = Globe;
},{"../Core/BoundingRectangle":97,"../Core/BoundingSphere":98,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartographic":104,"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/Ellipsoid":130,"../Core/EllipsoidTerrainProvider":135,"../Core/FeatureDetection":141,"../Core/GeographicProjection":143,"../Core/Geometry":145,"../Core/GeometryAttribute":146,"../Core/Intersect":163,"../Core/IntersectionTests":164,"../Core/Math":174,"../Core/Matrix4":177,"../Core/Occluder":179,"../Core/PrimitiveType":193,"../Core/Ray":200,"../Core/Rectangle":201,"../Core/Transforms":226,"../Core/buildModuleUrl":239,"../Core/combine":241,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Core/loadImage":259,"../Renderer/BufferUsage":339,"../Renderer/ClearCommand":340,"../Renderer/DrawCommand":344,"../Renderer/ShaderSource":355,"../Shaders/GlobeFS":550,"../Shaders/GlobeFSDepth":551,"../Shaders/GlobeFSPole":552,"../Shaders/GlobeVS":553,"../Shaders/GlobeVSDepth":554,"../Shaders/GlobeVSPole":555,"../ThirdParty/when":596,"./DepthFunction":382,"./GlobeSurfaceShaderSet":391,"./GlobeSurfaceTileProvider":393,"./ImageryLayerCollection":397,"./Pass":419,"./QuadtreePrimitive":433,"./SceneMode":438,"./terrainAttributeLocations":457}],391:[function(require,module,exports){
var defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), SceneMode = require('../Scene/SceneMode'), terrainAttributeLocations = require('../Scene/terrainAttributeLocations');
'use strict';
function GlobeSurfaceShader(numberOfDayTextures, flags, shaderProgram) {
    this.numberOfDayTextures = numberOfDayTextures;
    this.flags = flags;
    this.shaderProgram = shaderProgram;
}
function GlobeSurfaceShaderSet() {
    this.baseVertexShaderSource = undefined;
    this.baseFragmentShaderSource = undefined;
    this._attributeLocations = terrainAttributeLocations;
    this._shadersByTexturesFlags = [];
}
GlobeSurfaceShaderSet.prototype.getShaderProgram = function (context, sceneMode, surfaceTile, numberOfDayTextures, applyBrightness, applyContrast, applyHue, applySaturation, applyGamma, applyAlpha, showReflectiveOcean, showOceanWaves, enableLighting, hasVertexNormals, useWebMercatorProjection) {
    var flags = sceneMode | applyBrightness << 2 | applyContrast << 3 | applyHue << 4 | applySaturation << 5 | applyGamma << 6 | applyAlpha << 7 | showReflectiveOcean << 8 | showOceanWaves << 9 | enableLighting << 10 | hasVertexNormals << 11 | useWebMercatorProjection << 12;
    var surfaceShader = surfaceTile.surfaceShader;
    if (defined(surfaceShader) && surfaceShader.numberOfDayTextures === numberOfDayTextures && surfaceShader.flags === flags) {
        return surfaceShader.shaderProgram;
    }
    var shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures];
    if (!defined(shadersByFlags)) {
        shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures] = [];
    }
    surfaceShader = shadersByFlags[flags];
    if (!defined(surfaceShader)) {
        var vs = this.baseVertexShaderSource.clone();
        var fs = this.baseFragmentShaderSource.clone();
        fs.defines.push('TEXTURE_UNITS ' + numberOfDayTextures);
        if (applyBrightness) {
            fs.defines.push('APPLY_BRIGHTNESS');
        }
        if (applyContrast) {
            fs.defines.push('APPLY_CONTRAST');
        }
        if (applyHue) {
            fs.defines.push('APPLY_HUE');
        }
        if (applySaturation) {
            fs.defines.push('APPLY_SATURATION');
        }
        if (applyGamma) {
            fs.defines.push('APPLY_GAMMA');
        }
        if (applyAlpha) {
            fs.defines.push('APPLY_ALPHA');
        }
        if (showReflectiveOcean) {
            fs.defines.push('SHOW_REFLECTIVE_OCEAN');
            vs.defines.push('SHOW_REFLECTIVE_OCEAN');
        }
        if (showOceanWaves) {
            fs.defines.push('SHOW_OCEAN_WAVES');
        }
        if (enableLighting) {
            if (hasVertexNormals) {
                vs.defines.push('ENABLE_VERTEX_LIGHTING');
                fs.defines.push('ENABLE_VERTEX_LIGHTING');
            } else {
                vs.defines.push('ENABLE_DAYNIGHT_SHADING');
                fs.defines.push('ENABLE_DAYNIGHT_SHADING');
            }
        }
        var computeDayColor = '    vec4 computeDayColor(vec4 initialColor, vec2 textureCoordinates)\n    {\n        vec4 color = initialColor;\n';
        for (var i = 0; i < numberOfDayTextures; ++i) {
            computeDayColor += '    color = sampleAndBlend(\n        color,\n        u_dayTextures[' + i + '],\n        textureCoordinates,\n        u_dayTextureTexCoordsRectangle[' + i + '],\n        u_dayTextureTranslationAndScale[' + i + '],\n        ' + (applyAlpha ? 'u_dayTextureAlpha[' + i + ']' : '1.0') + ',\n        ' + (applyBrightness ? 'u_dayTextureBrightness[' + i + ']' : '0.0') + ',\n        ' + (applyContrast ? 'u_dayTextureContrast[' + i + ']' : '0.0') + ',\n        ' + (applyHue ? 'u_dayTextureHue[' + i + ']' : '0.0') + ',\n        ' + (applySaturation ? 'u_dayTextureSaturation[' + i + ']' : '0.0') + ',\n        ' + (applyGamma ? 'u_dayTextureOneOverGamma[' + i + ']' : '0.0') + '\n    );\n';
        }
        computeDayColor += '        return color;\n    }';
        fs.sources.push(computeDayColor);
        var getPosition3DMode = 'vec4 getPosition(vec3 position3DWC) { return getPosition3DMode(position3DWC); }';
        var getPosition2DMode = 'vec4 getPosition(vec3 position3DWC) { return getPosition2DMode(position3DWC); }';
        var getPositionColumbusViewMode = 'vec4 getPosition(vec3 position3DWC) { return getPositionColumbusViewMode(position3DWC); }';
        var getPositionMorphingMode = 'vec4 getPosition(vec3 position3DWC) { return getPositionMorphingMode(position3DWC); }';
        var getPositionMode;
        switch (sceneMode) {
        case SceneMode.SCENE3D:
            getPositionMode = getPosition3DMode;
            break;
        case SceneMode.SCENE2D:
            getPositionMode = getPosition2DMode;
            break;
        case SceneMode.COLUMBUS_VIEW:
            getPositionMode = getPositionColumbusViewMode;
            break;
        case SceneMode.MORPHING:
            getPositionMode = getPositionMorphingMode;
            break;
        }
        vs.sources.push(getPositionMode);
        var get2DYPositionFractionGeographicProjection = 'float get2DYPositionFraction() { return get2DGeographicYPositionFraction(); }';
        var get2DYPositionFractionMercatorProjection = 'float get2DYPositionFraction() { return get2DMercatorYPositionFraction(); }';
        var get2DYPositionFraction;
        if (useWebMercatorProjection) {
            get2DYPositionFraction = get2DYPositionFractionMercatorProjection;
        } else {
            get2DYPositionFraction = get2DYPositionFractionGeographicProjection;
        }
        vs.sources.push(get2DYPositionFraction);
        var shader = context.createShaderProgram(vs, fs, this._attributeLocations);
        surfaceShader = shadersByFlags[flags] = new GlobeSurfaceShader(numberOfDayTextures, flags, shader);
    }
    surfaceTile.surfaceShader = surfaceShader;
    return surfaceShader.shaderProgram;
};
GlobeSurfaceShaderSet.prototype.destroy = function () {
    var shadersByTexturesFlags = this._shadersByTexturesFlags;
    for (var textureCount in shadersByTexturesFlags) {
        if (shadersByTexturesFlags.hasOwnProperty(textureCount)) {
            var shadersByFlags = shadersByTexturesFlags[textureCount];
            if (!defined(shadersByFlags)) {
                continue;
            }
            for (var flags in shadersByFlags) {
                if (shadersByFlags.hasOwnProperty(flags)) {
                    var shader = shadersByFlags[flags];
                    if (defined(shader)) {
                        shader.shaderProgram.destroy();
                    }
                }
            }
        }
    }
    return destroyObject(this);
};
module.exports = GlobeSurfaceShaderSet;
},{"../Core/defined":245,"../Core/destroyObject":247,"../Scene/SceneMode":438,"../Scene/terrainAttributeLocations":457}],392:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Cartographic = require('../Core/Cartographic'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), IntersectionTests = require('../Core/IntersectionTests'), PixelFormat = require('../Core/PixelFormat'), Rectangle = require('../Core/Rectangle'), PixelDatatype = require('../Renderer/PixelDatatype'), TextureMagnificationFilter = require('../Renderer/TextureMagnificationFilter'), TextureMinificationFilter = require('../Renderer/TextureMinificationFilter'), TextureWrap = require('../Renderer/TextureWrap'), ImageryState = require('./ImageryState'), QuadtreeTileLoadState = require('./QuadtreeTileLoadState'), SceneMode = require('./SceneMode'), TerrainState = require('./TerrainState'), TileTerrain = require('./TileTerrain');
'use strict';
var GlobeSurfaceTile = function () {
    this.imagery = [];
    this.southwestCornerCartesian = new Cartesian3();
    this.northeastCornerCartesian = new Cartesian3();
    this.westNormal = new Cartesian3();
    this.southNormal = new Cartesian3();
    this.eastNormal = new Cartesian3();
    this.northNormal = new Cartesian3();
    this.waterMaskTexture = undefined;
    this.waterMaskTranslationAndScale = new Cartesian4(0, 0, 1, 1);
    this.terrainData = undefined;
    this.center = new Cartesian3();
    this.vertexArray = undefined;
    this.minimumHeight = 0;
    this.maximumHeight = 0;
    this.boundingSphere3D = new BoundingSphere();
    this.boundingSphere2D = new BoundingSphere();
    this.occludeePointInScaledSpace = new Cartesian3();
    this.loadedTerrain = undefined;
    this.upsampledTerrain = undefined;
    this.pickBoundingSphere = new BoundingSphere();
    this.pickTerrain = undefined;
    this.surfaceShader = undefined;
};
defineProperties(GlobeSurfaceTile.prototype, {
    eligibleForUnloading: {
        get: function () {
            var loadedTerrain = this.loadedTerrain;
            var loadingIsTransitioning = defined(loadedTerrain) && (loadedTerrain.state === TerrainState.RECEIVING || loadedTerrain.state === TerrainState.TRANSFORMING);
            var upsampledTerrain = this.upsampledTerrain;
            var upsamplingIsTransitioning = defined(upsampledTerrain) && (upsampledTerrain.state === TerrainState.RECEIVING || upsampledTerrain.state === TerrainState.TRANSFORMING);
            var shouldRemoveTile = !loadingIsTransitioning && !upsamplingIsTransitioning;
            var imagery = this.imagery;
            for (var i = 0, len = imagery.length; shouldRemoveTile && i < len; ++i) {
                var tileImagery = imagery[i];
                shouldRemoveTile = !defined(tileImagery.loadingImagery) || tileImagery.loadingImagery.state !== ImageryState.TRANSITIONING;
            }
            return shouldRemoveTile;
        }
    }
});
function getPosition(tile, scene, vertices, stride, index, result) {
    Cartesian3.unpack(vertices, index * stride, result);
    Cartesian3.add(tile.center, result, result);
    if (defined(scene) && scene.mode !== SceneMode.SCENE3D) {
        var projection = scene.mapProjection;
        var ellipsoid = projection.ellipsoid;
        var positionCart = ellipsoid.cartesianToCartographic(result);
        projection.project(positionCart, result);
        Cartesian3.fromElements(result.z, result.x, result.y, result);
    }
    return result;
}
var scratchV0 = new Cartesian3();
var scratchV1 = new Cartesian3();
var scratchV2 = new Cartesian3();
var scratchResult = new Cartesian3();
GlobeSurfaceTile.prototype.pick = function (ray, scene, cullBackFaces, result) {
    var terrain = this.pickTerrain;
    if (!defined(terrain)) {
        return undefined;
    }
    var mesh = terrain.mesh;
    if (!defined(mesh)) {
        return undefined;
    }
    var vertices = mesh.vertices;
    var stride = mesh.stride;
    var indices = mesh.indices;
    var length = indices.length;
    for (var i = 0; i < length; i += 3) {
        var i0 = indices[i];
        var i1 = indices[i + 1];
        var i2 = indices[i + 2];
        var v0 = getPosition(this, scene, vertices, stride, i0, scratchV0);
        var v1 = getPosition(this, scene, vertices, stride, i1, scratchV1);
        var v2 = getPosition(this, scene, vertices, stride, i2, scratchV2);
        var intersection = IntersectionTests.rayTriangle(ray, v0, v1, v2, cullBackFaces, scratchResult);
        if (defined(intersection)) {
            return Cartesian3.clone(intersection, result);
        }
    }
    return undefined;
};
GlobeSurfaceTile.prototype.pickTriangle = function (ray, scene, cullBackFaces) {
    var terrain = this.pickTerrain;
    if (!defined(terrain)) {
        return undefined;
    }
    var mesh = terrain.mesh;
    if (!defined(mesh)) {
        return undefined;
    }
    var vertices = mesh.vertices;
    var stride = mesh.stride;
    var indices = mesh.indices;
    var length = indices.length;
    for (var i = 0; i < length; i += 3) {
        var i0 = indices[i];
        var i1 = indices[i + 1];
        var i2 = indices[i + 2];
        var v0 = getPosition(this, scene, vertices, stride, i0, scratchV0);
        var v1 = getPosition(this, scene, vertices, stride, i1, scratchV1);
        var v2 = getPosition(this, scene, vertices, stride, i2, scratchV2);
        var intersection = IntersectionTests.rayTriangle(ray, v0, v1, v2, cullBackFaces, scratchResult);
        if (defined(intersection)) {
            return {
                intersection: intersection,
                v0: v0,
                v1: v1,
                v2: v2
            };
        }
    }
    return undefined;
};
GlobeSurfaceTile.prototype.freeResources = function () {
    if (defined(this.waterMaskTexture)) {
        --this.waterMaskTexture.referenceCount;
        if (this.waterMaskTexture.referenceCount === 0) {
            this.waterMaskTexture.destroy();
        }
        this.waterMaskTexture = undefined;
    }
    this.terrainData = undefined;
    if (defined(this.loadedTerrain)) {
        this.loadedTerrain.freeResources();
        this.loadedTerrain = undefined;
    }
    if (defined(this.upsampledTerrain)) {
        this.upsampledTerrain.freeResources();
        this.upsampledTerrain = undefined;
    }
    if (defined(this.pickTerrain)) {
        this.pickTerrain.freeResources();
        this.pickTerrain = undefined;
    }
    var i, len;
    var imageryList = this.imagery;
    for (i = 0, len = imageryList.length; i < len; ++i) {
        imageryList[i].freeResources();
    }
    this.imagery.length = 0;
    this.freeVertexArray();
};
GlobeSurfaceTile.prototype.freeVertexArray = function () {
    var indexBuffer;
    if (defined(this.vertexArray)) {
        indexBuffer = this.vertexArray.indexBuffer;
        this.vertexArray = this.vertexArray.destroy();
        if (!indexBuffer.isDestroyed() && defined(indexBuffer.referenceCount)) {
            --indexBuffer.referenceCount;
            if (indexBuffer.referenceCount === 0) {
                indexBuffer.destroy();
            }
        }
    }
    if (defined(this.wireframeVertexArray)) {
        indexBuffer = this.wireframeVertexArray.indexBuffer;
        this.wireframeVertexArray = this.wireframeVertexArray.destroy();
        if (!indexBuffer.isDestroyed() && defined(indexBuffer.referenceCount)) {
            --indexBuffer.referenceCount;
            if (indexBuffer.referenceCount === 0) {
                indexBuffer.destroy();
            }
        }
    }
};
GlobeSurfaceTile.processStateMachine = function (tile, context, terrainProvider, imageryLayerCollection) {
    var surfaceTile = tile.data;
    if (!defined(surfaceTile)) {
        surfaceTile = tile.data = new GlobeSurfaceTile();
    }
    if (tile.state === QuadtreeTileLoadState.START) {
        prepareNewTile(tile, terrainProvider, imageryLayerCollection);
        tile.state = QuadtreeTileLoadState.LOADING;
    }
    if (tile.state === QuadtreeTileLoadState.LOADING) {
        processTerrainStateMachine(tile, context, terrainProvider);
    }
    var isRenderable = defined(surfaceTile.vertexArray);
    var isDoneLoading = !defined(surfaceTile.loadedTerrain) && !defined(surfaceTile.upsampledTerrain);
    var isUpsampledOnly = defined(surfaceTile.terrainData) && surfaceTile.terrainData.wasCreatedByUpsampling();
    var tileImageryCollection = surfaceTile.imagery;
    for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {
        var tileImagery = tileImageryCollection[i];
        if (!defined(tileImagery.loadingImagery)) {
            isUpsampledOnly = false;
            continue;
        }
        if (tileImagery.loadingImagery.state === ImageryState.PLACEHOLDER) {
            var imageryLayer = tileImagery.loadingImagery.imageryLayer;
            if (imageryLayer.imageryProvider.ready) {
                tileImagery.freeResources();
                tileImageryCollection.splice(i, 1);
                imageryLayer._createTileImagerySkeletons(tile, terrainProvider, i);
                --i;
                len = tileImageryCollection.length;
                continue;
            } else {
                isUpsampledOnly = false;
            }
        }
        var thisTileDoneLoading = tileImagery.processStateMachine(tile, context);
        isDoneLoading = isDoneLoading && thisTileDoneLoading;
        isRenderable = isRenderable && (thisTileDoneLoading || defined(tileImagery.readyImagery));
        isUpsampledOnly = isUpsampledOnly && defined(tileImagery.loadingImagery) && (tileImagery.loadingImagery.state === ImageryState.FAILED || tileImagery.loadingImagery.state === ImageryState.INVALID);
    }
    tile.upsampledFromParent = isUpsampledOnly;
    if (i === len) {
        if (isRenderable) {
            tile.renderable = true;
        }
        if (isDoneLoading) {
            tile.state = QuadtreeTileLoadState.DONE;
        }
    }
};
var cartesian3Scratch = new Cartesian3();
var cartesian3Scratch2 = new Cartesian3();
var westernMidpointScratch = new Cartesian3();
var easternMidpointScratch = new Cartesian3();
var cartographicScratch = new Cartographic();
function prepareNewTile(tile, terrainProvider, imageryLayerCollection) {
    var surfaceTile = tile.data;
    var upsampleTileDetails = getUpsampleTileDetails(tile);
    if (defined(upsampleTileDetails)) {
        surfaceTile.upsampledTerrain = new TileTerrain(upsampleTileDetails);
    }
    if (isDataAvailable(tile, terrainProvider)) {
        surfaceTile.loadedTerrain = new TileTerrain();
    }
    for (var i = 0, len = imageryLayerCollection.length; i < len; ++i) {
        var layer = imageryLayerCollection.get(i);
        if (layer.show) {
            layer._createTileImagerySkeletons(tile, terrainProvider);
        }
    }
    var ellipsoid = tile.tilingScheme.ellipsoid;
    var rectangle = tile.rectangle;
    ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle), surfaceTile.southwestCornerCartesian);
    ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle), surfaceTile.northeastCornerCartesian);
    cartographicScratch.longitude = rectangle.west;
    cartographicScratch.latitude = (rectangle.south + rectangle.north) * 0.5;
    cartographicScratch.height = 0;
    var westernMidpointCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, westernMidpointScratch);
    var westNormal = Cartesian3.cross(westernMidpointCartesian, Cartesian3.UNIT_Z, cartesian3Scratch);
    Cartesian3.normalize(westNormal, surfaceTile.westNormal);
    cartographicScratch.longitude = rectangle.east;
    var easternMidpointCartesian = ellipsoid.cartographicToCartesian(cartographicScratch, easternMidpointScratch);
    var eastNormal = Cartesian3.cross(Cartesian3.UNIT_Z, easternMidpointCartesian, cartesian3Scratch);
    Cartesian3.normalize(eastNormal, surfaceTile.eastNormal);
    var southeastCornerNormal = ellipsoid.geodeticSurfaceNormalCartographic(Rectangle.southeast(rectangle), cartesian3Scratch2);
    var westVector = Cartesian3.subtract(westernMidpointCartesian, easternMidpointCartesian, cartesian3Scratch);
    var southNormal = Cartesian3.cross(southeastCornerNormal, westVector, cartesian3Scratch2);
    Cartesian3.normalize(southNormal, surfaceTile.southNormal);
    var northwestCornerNormal = ellipsoid.geodeticSurfaceNormalCartographic(Rectangle.northwest(rectangle), cartesian3Scratch2);
    var northNormal = Cartesian3.cross(westVector, northwestCornerNormal, cartesian3Scratch2);
    Cartesian3.normalize(northNormal, surfaceTile.northNormal);
}
function processTerrainStateMachine(tile, context, terrainProvider) {
    var surfaceTile = tile.data;
    var loaded = surfaceTile.loadedTerrain;
    var upsampled = surfaceTile.upsampledTerrain;
    var suspendUpsampling = false;
    if (defined(loaded)) {
        loaded.processLoadStateMachine(context, terrainProvider, tile.x, tile.y, tile.level);
        if (loaded.state >= TerrainState.RECEIVED) {
            if (surfaceTile.terrainData !== loaded.data) {
                surfaceTile.terrainData = loaded.data;
                createWaterMaskTextureIfNeeded(context, surfaceTile);
                propagateNewLoadedDataToChildren(tile);
            }
            suspendUpsampling = true;
        }
        if (loaded.state === TerrainState.READY) {
            loaded.publishToTile(tile);
            surfaceTile.pickTerrain = defaultValue(surfaceTile.loadedTerrain, surfaceTile.upsampledTerrain);
            surfaceTile.loadedTerrain = undefined;
            surfaceTile.upsampledTerrain = undefined;
        } else if (loaded.state === TerrainState.FAILED) {
            surfaceTile.loadedTerrain = undefined;
        }
    }
    if (!suspendUpsampling && defined(upsampled)) {
        upsampled.processUpsampleStateMachine(context, terrainProvider, tile.x, tile.y, tile.level);
        if (upsampled.state >= TerrainState.RECEIVED) {
            if (surfaceTile.terrainData !== upsampled.data) {
                surfaceTile.terrainData = upsampled.data;
                if (terrainProvider.hasWaterMask) {
                    upsampleWaterMask(tile);
                }
                propagateNewUpsampledDataToChildren(tile);
            }
        }
        if (upsampled.state === TerrainState.READY) {
            upsampled.publishToTile(tile);
            surfaceTile.pickTerrain = surfaceTile.upsampledTerrain;
            surfaceTile.upsampledTerrain = undefined;
        } else if (upsampled.state === TerrainState.FAILED) {
            surfaceTile.upsampledTerrain = undefined;
        }
    }
}
function getUpsampleTileDetails(tile) {
    var sourceTile = tile.parent;
    while (defined(sourceTile) && defined(sourceTile.data) && !defined(sourceTile.data.terrainData)) {
        sourceTile = sourceTile.parent;
    }
    if (!defined(sourceTile) || !defined(sourceTile.data)) {
        return undefined;
    }
    return {
        data: sourceTile.data.terrainData,
        x: sourceTile.x,
        y: sourceTile.y,
        level: sourceTile.level
    };
}
function propagateNewUpsampledDataToChildren(tile) {
    var surfaceTile = tile.data;
    if (defined(tile._children)) {
        for (var childIndex = 0; childIndex < 4; ++childIndex) {
            var childTile = tile._children[childIndex];
            if (childTile.state !== QuadtreeTileLoadState.START) {
                var childSurfaceTile = childTile.data;
                if (defined(childSurfaceTile.terrainData) && !childSurfaceTile.terrainData.wasCreatedByUpsampling()) {
                    continue;
                }
                if (defined(childSurfaceTile.upsampledTerrain)) {
                    childSurfaceTile.upsampledTerrain.freeResources();
                }
                childSurfaceTile.upsampledTerrain = new TileTerrain({
                    data: surfaceTile.terrainData,
                    x: tile.x,
                    y: tile.y,
                    level: tile.level
                });
                childTile.state = QuadtreeTileLoadState.LOADING;
            }
        }
    }
}
function propagateNewLoadedDataToChildren(tile) {
    var surfaceTile = tile.data;
    if (defined(tile.children)) {
        for (var childIndex = 0; childIndex < 4; ++childIndex) {
            var childTile = tile.children[childIndex];
            if (childTile.state !== QuadtreeTileLoadState.START) {
                var childSurfaceTile = childTile.data;
                if (defined(childSurfaceTile.terrainData) && !childSurfaceTile.terrainData.wasCreatedByUpsampling()) {
                    continue;
                }
                if (defined(childSurfaceTile.upsampledTerrain)) {
                    childSurfaceTile.upsampledTerrain.freeResources();
                }
                childSurfaceTile.upsampledTerrain = new TileTerrain({
                    data: surfaceTile.terrainData,
                    x: tile.x,
                    y: tile.y,
                    level: tile.level
                });
                if (surfaceTile.terrainData.isChildAvailable(tile.x, tile.y, childTile.x, childTile.y)) {
                    if (!defined(childSurfaceTile.loadedTerrain)) {
                        childSurfaceTile.loadedTerrain = new TileTerrain();
                    }
                }
                childTile.state = QuadtreeTileLoadState.LOADING;
            }
        }
    }
}
function isDataAvailable(tile, terrainProvider) {
    var tileDataAvailable = terrainProvider.getTileDataAvailable(tile.x, tile.y, tile.level);
    if (defined(tileDataAvailable)) {
        return tileDataAvailable;
    }
    var parent = tile.parent;
    if (!defined(parent)) {
        return true;
    }
    if (!defined(parent.data) || !defined(parent.data.terrainData)) {
        return false;
    }
    return parent.data.terrainData.isChildAvailable(parent.x, parent.y, tile.x, tile.y);
}
function getContextWaterMaskData(context) {
    var data = context.cache.tile_waterMaskData;
    if (!defined(data)) {
        var allWaterTexture = context.createTexture2D({
                pixelFormat: PixelFormat.LUMINANCE,
                pixelDatatype: PixelDatatype.UNSIGNED_BYTE,
                source: {
                    arrayBufferView: new Uint8Array([255]),
                    width: 1,
                    height: 1
                }
            });
        allWaterTexture.referenceCount = 1;
        var sampler = context.createSampler({
                wrapS: TextureWrap.CLAMP_TO_EDGE,
                wrapT: TextureWrap.CLAMP_TO_EDGE,
                minificationFilter: TextureMinificationFilter.LINEAR,
                magnificationFilter: TextureMagnificationFilter.LINEAR
            });
        data = {
            allWaterTexture: allWaterTexture,
            sampler: sampler,
            destroy: function () {
                this.allWaterTexture.destroy();
            }
        };
        context.cache.tile_waterMaskData = data;
    }
    return data;
}
function createWaterMaskTextureIfNeeded(context, surfaceTile) {
    var previousTexture = surfaceTile.waterMaskTexture;
    if (defined(previousTexture)) {
        --previousTexture.referenceCount;
        if (previousTexture.referenceCount === 0) {
            previousTexture.destroy();
        }
        surfaceTile.waterMaskTexture = undefined;
    }
    var waterMask = surfaceTile.terrainData.waterMask;
    if (!defined(waterMask)) {
        return;
    }
    var waterMaskData = getContextWaterMaskData(context);
    var texture;
    var waterMaskLength = waterMask.length;
    if (waterMaskLength === 1) {
        if (waterMask[0] !== 0) {
            texture = waterMaskData.allWaterTexture;
        } else {
            return;
        }
    } else {
        var textureSize = Math.sqrt(waterMaskLength);
        texture = context.createTexture2D({
            pixelFormat: PixelFormat.LUMINANCE,
            pixelDatatype: PixelDatatype.UNSIGNED_BYTE,
            source: {
                width: textureSize,
                height: textureSize,
                arrayBufferView: waterMask
            }
        });
        texture.referenceCount = 0;
        texture.sampler = waterMaskData.sampler;
    }
    ++texture.referenceCount;
    surfaceTile.waterMaskTexture = texture;
    Cartesian4.fromElements(0, 0, 1, 1, surfaceTile.waterMaskTranslationAndScale);
}
function upsampleWaterMask(tile) {
    var surfaceTile = tile.data;
    var sourceTile = tile.parent;
    while (defined(sourceTile) && !defined(sourceTile.data.terrainData) || sourceTile.data.terrainData.wasCreatedByUpsampling()) {
        sourceTile = sourceTile.parent;
    }
    if (!defined(sourceTile) || !defined(sourceTile.data.waterMaskTexture)) {
        return;
    }
    surfaceTile.waterMaskTexture = sourceTile.data.waterMaskTexture;
    ++surfaceTile.waterMaskTexture.referenceCount;
    var sourceTileRectangle = sourceTile.rectangle;
    var tileRectangle = tile.rectangle;
    var tileWidth = tileRectangle.width;
    var tileHeight = tileRectangle.height;
    var scaleX = tileWidth / sourceTileRectangle.width;
    var scaleY = tileHeight / sourceTileRectangle.height;
    surfaceTile.waterMaskTranslationAndScale.x = scaleX * (tileRectangle.west - sourceTileRectangle.west) / tileWidth;
    surfaceTile.waterMaskTranslationAndScale.y = scaleY * (tileRectangle.south - sourceTileRectangle.south) / tileHeight;
    surfaceTile.waterMaskTranslationAndScale.z = scaleX;
    surfaceTile.waterMaskTranslationAndScale.w = scaleY;
}
module.exports = GlobeSurfaceTile;
},{"../Core/BoundingSphere":98,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Cartographic":104,"../Core/IntersectionTests":164,"../Core/PixelFormat":181,"../Core/Rectangle":201,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Renderer/PixelDatatype":349,"../Renderer/TextureMagnificationFilter":357,"../Renderer/TextureMinificationFilter":358,"../Renderer/TextureWrap":359,"./ImageryState":400,"./QuadtreeTileLoadState":435,"./SceneMode":438,"./TerrainState":447,"./TileTerrain":452}],393:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Color = require('../Core/Color'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), FeatureDetection = require('../Core/FeatureDetection'), GeometryPipeline = require('../Core/GeometryPipeline'), IndexDatatype = require('../Core/IndexDatatype'), Intersect = require('../Core/Intersect'), Matrix4 = require('../Core/Matrix4'), PrimitiveType = require('../Core/PrimitiveType'), Rectangle = require('../Core/Rectangle'), Visibility = require('../Core/Visibility'), WebMercatorProjection = require('../Core/WebMercatorProjection'), BufferUsage = require('../Renderer/BufferUsage'), DrawCommand = require('../Renderer/DrawCommand'), BlendingState = require('../Scene/BlendingState'), DepthFunction = require('../Scene/DepthFunction'), Pass = require('../Scene/Pass'), when = require('../ThirdParty/when'), GlobeSurfaceTile = require('./GlobeSurfaceTile'), ImageryLayer = require('./ImageryLayer'), ImageryState = require('./ImageryState'), QuadtreeTileLoadState = require('./QuadtreeTileLoadState'), SceneMode = require('./SceneMode');
'use strict';
var GlobeSurfaceTileProvider = function GlobeSurfaceTileProvider(options) {
    if (!defined(options)) {
        throw new DeveloperError('options is required.');
    }
    if (!defined(options.terrainProvider)) {
        throw new DeveloperError('options.terrainProvider is required.');
    } else if (!defined(options.imageryLayers)) {
        throw new DeveloperError('options.imageryLayers is required.');
    } else if (!defined(options.surfaceShaderSet)) {
        throw new DeveloperError('options.surfaceShaderSet is required.');
    }
    this.lightingFadeOutDistance = 6500000;
    this.lightingFadeInDistance = 9000000;
    this.hasWaterMask = false;
    this.oceanNormalMap = undefined;
    this.zoomedOutOceanSpecularIntensity = 0.5;
    this.enableLighting = false;
    this._quadtree = undefined;
    this._terrainProvider = options.terrainProvider;
    this._imageryLayers = options.imageryLayers;
    this._surfaceShaderSet = options.surfaceShaderSet;
    this._renderState = undefined;
    this._blendRenderState = undefined;
    this._errorEvent = new Event();
    this._imageryLayers.layerAdded.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerAdded, this);
    this._imageryLayers.layerRemoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerRemoved, this);
    this._imageryLayers.layerMoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerMoved, this);
    this._imageryLayers.layerShownOrHidden.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden, this);
    this._layerOrderChanged = false;
    this._tilesToRenderByTextureCount = [];
    this._drawCommands = [];
    this._uniformMaps = [];
    this._usedDrawCommands = 0;
    this._debug = {
        wireframe: false,
        boundingSphereTile: undefined
    };
    this._baseColor = undefined;
    this._firstPassInitialColor = undefined;
    this.baseColor = new Color(0, 0, 0.5, 1);
};
defineProperties(GlobeSurfaceTileProvider.prototype, {
    baseColor: {
        get: function () {
            return this._baseColor;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            this._baseColor = value;
            this._firstPassInitialColor = Cartesian4.fromColor(value, this._firstPassInitialColor);
        }
    },
    quadtree: {
        get: function () {
            return this._quadtree;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            this._quadtree = value;
        }
    },
    ready: {
        get: function () {
            return this._terrainProvider.ready && (this._imageryLayers.length === 0 || this._imageryLayers.get(0).imageryProvider.ready);
        }
    },
    tilingScheme: {
        get: function () {
            return this._terrainProvider.tilingScheme;
        }
    },
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    terrainProvider: {
        get: function () {
            return this._terrainProvider;
        },
        set: function (terrainProvider) {
            if (this._terrainProvider === terrainProvider) {
                return;
            }
            if (!defined(terrainProvider)) {
                throw new DeveloperError('terrainProvider is required.');
            }
            this._terrainProvider = terrainProvider;
            if (defined(this._quadtree)) {
                this._quadtree.invalidateAllTiles();
            }
        }
    }
});
function sortTileImageryByLayerIndex(a, b) {
    var aImagery = a.loadingImagery;
    if (!defined(aImagery)) {
        aImagery = a.readyImagery;
    }
    var bImagery = b.loadingImagery;
    if (!defined(bImagery)) {
        bImagery = b.readyImagery;
    }
    return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;
}
GlobeSurfaceTileProvider.prototype.beginUpdate = function (context, frameState, commandList) {
    this._imageryLayers._update();
    if (this._layerOrderChanged) {
        this._layerOrderChanged = false;
        this._quadtree.forEachLoadedTile(function (tile) {
            tile.data.imagery.sort(sortTileImageryByLayerIndex);
        });
    }
    var i;
    var len;
    var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;
    for (i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {
        var tiles = tilesToRenderByTextureCount[i];
        if (defined(tiles)) {
            tiles.length = 0;
        }
    }
    this._usedDrawCommands = 0;
    var creditDisplay = frameState.creditDisplay;
    if (this._terrainProvider.ready && defined(this._terrainProvider.credit)) {
        creditDisplay.addCredit(this._terrainProvider.credit);
    }
    var imageryLayers = this._imageryLayers;
    for (i = 0, len = imageryLayers.length; i < len; ++i) {
        var imageryProvider = imageryLayers.get(i).imageryProvider;
        if (imageryProvider.ready && defined(imageryProvider.credit)) {
            creditDisplay.addCredit(imageryProvider.credit);
        }
    }
};
GlobeSurfaceTileProvider.prototype.endUpdate = function (context, frameState, commandList) {
    if (!defined(this._renderState)) {
        this._renderState = context.createRenderState({
            cull: { enabled: true },
            depthTest: { enabled: true }
        });
    }
    if (!defined(this._blendRenderState)) {
        this._blendRenderState = context.createRenderState({
            cull: { enabled: true },
            depthTest: {
                enabled: true,
                func: DepthFunction.LESS_OR_EQUAL
            },
            blending: BlendingState.ALPHA_BLEND
        });
    }
    this._renderState.depthTest.enabled = frameState.mode === SceneMode.SCENE3D || frameState.mode === SceneMode.COLUMBUS_VIEW;
    this._blendRenderState.depthTest.enabled = this._renderState.depthTest.enabled;
    var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;
    for (var textureCountIndex = 0, textureCountLength = tilesToRenderByTextureCount.length; textureCountIndex < textureCountLength; ++textureCountIndex) {
        var tilesToRender = tilesToRenderByTextureCount[textureCountIndex];
        if (!defined(tilesToRender)) {
            continue;
        }
        for (var tileIndex = 0, tileLength = tilesToRender.length; tileIndex < tileLength; ++tileIndex) {
            addDrawCommandsForTile(this, tilesToRender[tileIndex], context, frameState, commandList);
        }
    }
};
GlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (level) {
    return this._terrainProvider.getLevelMaximumGeometricError(level);
};
GlobeSurfaceTileProvider.prototype.loadTile = function (context, frameState, tile) {
    GlobeSurfaceTile.processStateMachine(tile, context, this._terrainProvider, this._imageryLayers);
};
var boundingSphereScratch = new BoundingSphere();
GlobeSurfaceTileProvider.prototype.computeTileVisibility = function (tile, frameState, occluders) {
    var surfaceTile = tile.data;
    var cullingVolume = frameState.cullingVolume;
    var boundingVolume = surfaceTile.boundingSphere3D;
    if (frameState.mode !== SceneMode.SCENE3D) {
        boundingVolume = boundingSphereScratch;
        BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, frameState.mapProjection, surfaceTile.minimumHeight, surfaceTile.maximumHeight, boundingVolume);
        Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);
        if (frameState.mode === SceneMode.MORPHING) {
            boundingVolume = BoundingSphere.union(surfaceTile.boundingSphere3D, boundingVolume, boundingVolume);
        }
    }
    var intersection = cullingVolume.computeVisibility(boundingVolume);
    if (intersection === Intersect.OUTSIDE) {
        return Visibility.NONE;
    }
    if (frameState.mode === SceneMode.SCENE3D) {
        var occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;
        if (!defined(occludeePointInScaledSpace)) {
            return intersection;
        }
        if (occluders.ellipsoid.isScaledSpacePointVisible(occludeePointInScaledSpace)) {
            return intersection;
        }
        return Visibility.NONE;
    }
    return intersection;
};
var float32ArrayScratch = FeatureDetection.supportsTypedArrays() ? new Float32Array(1) : undefined;
var modifiedModelViewScratch = new Matrix4();
var tileRectangleScratch = new Cartesian4();
var rtcScratch = new Cartesian3();
var centerEyeScratch = new Cartesian4();
var southwestScratch = new Cartesian3();
var northeastScratch = new Cartesian3();
GlobeSurfaceTileProvider.prototype.showTileThisFrame = function (tile, context, frameState, commandList) {
    var readyTextureCount = 0;
    var tileImageryCollection = tile.data.imagery;
    for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {
        var tileImagery = tileImageryCollection[i];
        if (defined(tileImagery.readyImagery) && tileImagery.readyImagery.imageryLayer.alpha !== 0) {
            ++readyTextureCount;
        }
    }
    var tileSet = this._tilesToRenderByTextureCount[readyTextureCount];
    if (!defined(tileSet)) {
        tileSet = [];
        this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;
    }
    tileSet.push(tile);
    var debug = this._debug;
    ++debug.tilesRendered;
    debug.texturesRendered += readyTextureCount;
};
var southwestCornerScratch = new Cartesian3();
var northeastCornerScratch = new Cartesian3();
var negativeUnitY = new Cartesian3(0, -1, 0);
var negativeUnitZ = new Cartesian3(0, 0, -1);
var vectorScratch = new Cartesian3();
GlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (tile, frameState) {
    var surfaceTile = tile.data;
    var southwestCornerCartesian = surfaceTile.southwestCornerCartesian;
    var northeastCornerCartesian = surfaceTile.northeastCornerCartesian;
    var westNormal = surfaceTile.westNormal;
    var southNormal = surfaceTile.southNormal;
    var eastNormal = surfaceTile.eastNormal;
    var northNormal = surfaceTile.northNormal;
    var maximumHeight = surfaceTile.maximumHeight;
    if (frameState.mode !== SceneMode.SCENE3D) {
        southwestCornerCartesian = frameState.mapProjection.project(Rectangle.southwest(tile.rectangle), southwestCornerScratch);
        southwestCornerCartesian.z = southwestCornerCartesian.y;
        southwestCornerCartesian.y = southwestCornerCartesian.x;
        southwestCornerCartesian.x = 0;
        northeastCornerCartesian = frameState.mapProjection.project(Rectangle.northeast(tile.rectangle), northeastCornerScratch);
        northeastCornerCartesian.z = northeastCornerCartesian.y;
        northeastCornerCartesian.y = northeastCornerCartesian.x;
        northeastCornerCartesian.x = 0;
        westNormal = negativeUnitY;
        eastNormal = Cartesian3.UNIT_Y;
        southNormal = negativeUnitZ;
        northNormal = Cartesian3.UNIT_Z;
        maximumHeight = 0;
    }
    var cameraCartesianPosition = frameState.camera.positionWC;
    var cameraCartographicPosition = frameState.camera.positionCartographic;
    var vectorFromSouthwestCorner = Cartesian3.subtract(cameraCartesianPosition, southwestCornerCartesian, vectorScratch);
    var distanceToWestPlane = Cartesian3.dot(vectorFromSouthwestCorner, westNormal);
    var distanceToSouthPlane = Cartesian3.dot(vectorFromSouthwestCorner, southNormal);
    var vectorFromNortheastCorner = Cartesian3.subtract(cameraCartesianPosition, northeastCornerCartesian, vectorScratch);
    var distanceToEastPlane = Cartesian3.dot(vectorFromNortheastCorner, eastNormal);
    var distanceToNorthPlane = Cartesian3.dot(vectorFromNortheastCorner, northNormal);
    var cameraHeight;
    if (frameState.mode === SceneMode.SCENE3D) {
        cameraHeight = cameraCartographicPosition.height;
    } else {
        cameraHeight = cameraCartesianPosition.x;
    }
    var distanceFromTop = cameraHeight - maximumHeight;
    var result = 0;
    if (distanceToWestPlane > 0) {
        result += distanceToWestPlane * distanceToWestPlane;
    } else if (distanceToEastPlane > 0) {
        result += distanceToEastPlane * distanceToEastPlane;
    }
    if (distanceToSouthPlane > 0) {
        result += distanceToSouthPlane * distanceToSouthPlane;
    } else if (distanceToNorthPlane > 0) {
        result += distanceToNorthPlane * distanceToNorthPlane;
    }
    if (distanceFromTop > 0) {
        result += distanceFromTop * distanceFromTop;
    }
    return Math.sqrt(result);
};
GlobeSurfaceTileProvider.prototype.isDestroyed = function () {
    return false;
};
GlobeSurfaceTileProvider.prototype.destroy = function () {
    this._tileProvider = this._tileProvider && this._tileProvider.destroy();
    return destroyObject(this);
};
GlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {
    if (layer.show) {
        var terrainProvider = this._terrainProvider;
        this._quadtree.forEachLoadedTile(function (tile) {
            if (layer._createTileImagerySkeletons(tile, terrainProvider)) {
                tile.state = QuadtreeTileLoadState.LOADING;
            }
        });
        this._layerOrderChanged = true;
    }
};
GlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {
    this._quadtree.forEachLoadedTile(function (tile) {
        var tileImageryCollection = tile.data.imagery;
        var startIndex = -1;
        var numDestroyed = 0;
        for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {
            var tileImagery = tileImageryCollection[i];
            var imagery = tileImagery.loadingImagery;
            if (!defined(imagery)) {
                imagery = tileImagery.readyImagery;
            }
            if (imagery.imageryLayer === layer) {
                if (startIndex === -1) {
                    startIndex = i;
                }
                tileImagery.freeResources();
                ++numDestroyed;
            } else if (startIndex !== -1) {
                break;
            }
        }
        if (startIndex !== -1) {
            tileImageryCollection.splice(startIndex, numDestroyed);
        }
    });
};
GlobeSurfaceTileProvider.prototype._onLayerMoved = function (layer, newIndex, oldIndex) {
    this._layerOrderChanged = true;
};
GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (layer, index, show) {
    if (show) {
        this._onLayerAdded(layer, index);
    } else {
        this._onLayerRemoved(layer, index);
    }
};
function createTileUniformMap() {
    var uniformMap = {
            u_initialColor: function () {
                return this.initialColor;
            },
            u_zoomedOutOceanSpecularIntensity: function () {
                return this.zoomedOutOceanSpecularIntensity;
            },
            u_oceanNormalMap: function () {
                return this.oceanNormalMap;
            },
            u_lightingFadeDistance: function () {
                return this.lightingFadeDistance;
            },
            u_center3D: function () {
                return this.center3D;
            },
            u_tileRectangle: function () {
                return this.tileRectangle;
            },
            u_modifiedModelView: function () {
                return this.modifiedModelView;
            },
            u_dayTextures: function () {
                return this.dayTextures;
            },
            u_dayTextureTranslationAndScale: function () {
                return this.dayTextureTranslationAndScale;
            },
            u_dayTextureTexCoordsRectangle: function () {
                return this.dayTextureTexCoordsRectangle;
            },
            u_dayTextureAlpha: function () {
                return this.dayTextureAlpha;
            },
            u_dayTextureBrightness: function () {
                return this.dayTextureBrightness;
            },
            u_dayTextureContrast: function () {
                return this.dayTextureContrast;
            },
            u_dayTextureHue: function () {
                return this.dayTextureHue;
            },
            u_dayTextureSaturation: function () {
                return this.dayTextureSaturation;
            },
            u_dayTextureOneOverGamma: function () {
                return this.dayTextureOneOverGamma;
            },
            u_dayIntensity: function () {
                return this.dayIntensity;
            },
            u_southAndNorthLatitude: function () {
                return this.southAndNorthLatitude;
            },
            u_southMercatorYLowAndHighAndOneOverHeight: function () {
                return this.southMercatorYLowAndHighAndOneOverHeight;
            },
            u_waterMask: function () {
                return this.waterMask;
            },
            u_waterMaskTranslationAndScale: function () {
                return this.waterMaskTranslationAndScale;
            },
            initialColor: new Cartesian4(0, 0, 0.5, 1),
            zoomedOutOceanSpecularIntensity: 0.5,
            oceanNormalMap: undefined,
            lightingFadeDistance: new Cartesian2(6500000, 9000000),
            center3D: undefined,
            modifiedModelView: new Matrix4(),
            tileRectangle: new Cartesian4(),
            dayTextures: [],
            dayTextureTranslationAndScale: [],
            dayTextureTexCoordsRectangle: [],
            dayTextureAlpha: [],
            dayTextureBrightness: [],
            dayTextureContrast: [],
            dayTextureHue: [],
            dayTextureSaturation: [],
            dayTextureOneOverGamma: [],
            dayIntensity: 0,
            southAndNorthLatitude: new Cartesian2(),
            southMercatorYLowAndHighAndOneOverHeight: new Cartesian3(),
            waterMask: undefined,
            waterMaskTranslationAndScale: new Cartesian4()
        };
    return uniformMap;
}
function createWireframeVertexArrayIfNecessary(context, provider, tile) {
    var surfaceTile = tile.data;
    if (defined(surfaceTile.wireframeVertexArray)) {
        return;
    }
    if (defined(surfaceTile.meshForWireframePromise)) {
        return;
    }
    surfaceTile.meshForWireframePromise = surfaceTile.terrainData.createMesh(provider._terrainProvider.tilingScheme, tile.x, tile.y, tile.level);
    if (!defined(surfaceTile.meshForWireframePromise)) {
        return;
    }
    var vertexArray = surfaceTile.vertexArray;
    when(surfaceTile.meshForWireframePromise, function (mesh) {
        if (surfaceTile.vertexArray === vertexArray) {
            surfaceTile.wireframeVertexArray = createWireframeVertexArray(context, surfaceTile.vertexArray, mesh);
        }
        surfaceTile.meshForWireframePromise = undefined;
    });
}
function createWireframeVertexArray(context, vertexArray, terrainMesh) {
    var geometry = {
            indices: terrainMesh.indices,
            primitiveType: PrimitiveType.TRIANGLES
        };
    GeometryPipeline.toWireframe(geometry);
    var wireframeIndices = geometry.indices;
    var wireframeIndexBuffer = context.createIndexBuffer(wireframeIndices, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
    return context.createVertexArray(vertexArray._attributes, wireframeIndexBuffer);
}
var otherPassesInitialColor = new Cartesian4(0, 0, 0, 0);
function addDrawCommandsForTile(tileProvider, tile, context, frameState, commandList) {
    var surfaceTile = tile.data;
    var viewMatrix = frameState.camera.viewMatrix;
    var maxTextures = context.maximumTextureImageUnits;
    var waterMaskTexture = surfaceTile.waterMaskTexture;
    var showReflectiveOcean = tileProvider.hasWaterMask && defined(waterMaskTexture);
    var oceanNormalMap = tileProvider.oceanNormalMap;
    var showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);
    var hasVertexNormals = tileProvider.terrainProvider.ready && tileProvider.terrainProvider.hasVertexNormals;
    if (showReflectiveOcean) {
        --maxTextures;
    }
    if (showOceanWaves) {
        --maxTextures;
    }
    var rtc = surfaceTile.center;
    var tileRectangle = tileRectangleScratch;
    var southLatitude = 0;
    var northLatitude = 0;
    var southMercatorYHigh = 0;
    var southMercatorYLow = 0;
    var oneOverMercatorHeight = 0;
    var useWebMercatorProjection = false;
    if (frameState.mode !== SceneMode.SCENE3D) {
        var projection = frameState.mapProjection;
        var southwest = projection.project(Rectangle.southwest(tile.rectangle), southwestScratch);
        var northeast = projection.project(Rectangle.northeast(tile.rectangle), northeastScratch);
        tileRectangle.x = southwest.x;
        tileRectangle.y = southwest.y;
        tileRectangle.z = northeast.x;
        tileRectangle.w = northeast.y;
        if (frameState.mode !== SceneMode.MORPHING) {
            rtc = rtcScratch;
            rtc.x = 0;
            rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;
            rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;
            tileRectangle.x -= rtc.y;
            tileRectangle.y -= rtc.z;
            tileRectangle.z -= rtc.y;
            tileRectangle.w -= rtc.z;
        }
        if (projection instanceof WebMercatorProjection) {
            southLatitude = tile.rectangle.south;
            northLatitude = tile.rectangle.north;
            var southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(southLatitude);
            var northMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude);
            float32ArrayScratch[0] = southMercatorY;
            southMercatorYHigh = float32ArrayScratch[0];
            southMercatorYLow = southMercatorY - float32ArrayScratch[0];
            oneOverMercatorHeight = 1 / (northMercatorY - southMercatorY);
            useWebMercatorProjection = true;
        }
    }
    var centerEye = centerEyeScratch;
    centerEye.x = rtc.x;
    centerEye.y = rtc.y;
    centerEye.z = rtc.z;
    centerEye.w = 1;
    Matrix4.multiplyByVector(viewMatrix, centerEye, centerEye);
    Matrix4.setColumn(viewMatrix, 3, centerEye, modifiedModelViewScratch);
    var tileImageryCollection = surfaceTile.imagery;
    var imageryIndex = 0;
    var imageryLen = tileImageryCollection.length;
    var firstPassRenderState = tileProvider._renderState;
    var otherPassesRenderState = tileProvider._blendRenderState;
    var renderState = firstPassRenderState;
    var initialColor = tileProvider._firstPassInitialColor;
    do {
        var numberOfDayTextures = 0;
        var command;
        var uniformMap;
        if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {
            command = new DrawCommand();
            command.owner = tile;
            command.cull = false;
            command.boundingVolume = new BoundingSphere();
            uniformMap = createTileUniformMap();
            tileProvider._drawCommands.push(command);
            tileProvider._uniformMaps.push(uniformMap);
        } else {
            command = tileProvider._drawCommands[tileProvider._usedDrawCommands];
            uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];
        }
        command.owner = tile;
        ++tileProvider._usedDrawCommands;
        command.debugShowBoundingVolume = tile === tileProvider._debug.boundingSphereTile;
        Cartesian4.clone(initialColor, uniformMap.initialColor);
        uniformMap.oceanNormalMap = oceanNormalMap;
        uniformMap.lightingFadeDistance.x = tileProvider.lightingFadeOutDistance;
        uniformMap.lightingFadeDistance.y = tileProvider.lightingFadeInDistance;
        uniformMap.zoomedOutOceanSpecularIntensity = tileProvider.zoomedOutOceanSpecularIntensity;
        uniformMap.center3D = surfaceTile.center;
        Cartesian4.clone(tileRectangle, uniformMap.tileRectangle);
        uniformMap.southAndNorthLatitude.x = southLatitude;
        uniformMap.southAndNorthLatitude.y = northLatitude;
        uniformMap.southMercatorYLowAndHighAndOneOverHeight.x = southMercatorYLow;
        uniformMap.southMercatorYLowAndHighAndOneOverHeight.y = southMercatorYHigh;
        uniformMap.southMercatorYLowAndHighAndOneOverHeight.z = oneOverMercatorHeight;
        Matrix4.clone(modifiedModelViewScratch, uniformMap.modifiedModelView);
        var applyBrightness = false;
        var applyContrast = false;
        var applyHue = false;
        var applySaturation = false;
        var applyGamma = false;
        var applyAlpha = false;
        while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {
            var tileImagery = tileImageryCollection[imageryIndex];
            var imagery = tileImagery.readyImagery;
            ++imageryIndex;
            if (!defined(imagery) || imagery.state !== ImageryState.READY || imagery.imageryLayer.alpha === 0) {
                continue;
            }
            var imageryLayer = imagery.imageryLayer;
            if (!defined(tileImagery.textureTranslationAndScale)) {
                tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, tileImagery);
            }
            uniformMap.dayTextures[numberOfDayTextures] = imagery.texture;
            uniformMap.dayTextureTranslationAndScale[numberOfDayTextures] = tileImagery.textureTranslationAndScale;
            uniformMap.dayTextureTexCoordsRectangle[numberOfDayTextures] = tileImagery.textureCoordinateRectangle;
            uniformMap.dayTextureAlpha[numberOfDayTextures] = imageryLayer.alpha;
            applyAlpha = applyAlpha || uniformMap.dayTextureAlpha[numberOfDayTextures] !== 1;
            uniformMap.dayTextureBrightness[numberOfDayTextures] = imageryLayer.brightness;
            applyBrightness = applyBrightness || uniformMap.dayTextureBrightness[numberOfDayTextures] !== ImageryLayer.DEFAULT_BRIGHTNESS;
            uniformMap.dayTextureContrast[numberOfDayTextures] = imageryLayer.contrast;
            applyContrast = applyContrast || uniformMap.dayTextureContrast[numberOfDayTextures] !== ImageryLayer.DEFAULT_CONTRAST;
            uniformMap.dayTextureHue[numberOfDayTextures] = imageryLayer.hue;
            applyHue = applyHue || uniformMap.dayTextureHue[numberOfDayTextures] !== ImageryLayer.DEFAULT_HUE;
            uniformMap.dayTextureSaturation[numberOfDayTextures] = imageryLayer.saturation;
            applySaturation = applySaturation || uniformMap.dayTextureSaturation[numberOfDayTextures] !== ImageryLayer.DEFAULT_SATURATION;
            uniformMap.dayTextureOneOverGamma[numberOfDayTextures] = 1 / imageryLayer.gamma;
            applyGamma = applyGamma || uniformMap.dayTextureOneOverGamma[numberOfDayTextures] !== 1 / ImageryLayer.DEFAULT_GAMMA;
            if (defined(imagery.credits)) {
                var creditDisplay = frameState.creditDisplay;
                var credits = imagery.credits;
                for (var creditIndex = 0, creditLength = credits.length; creditIndex < creditLength; ++creditIndex) {
                    creditDisplay.addCredit(credits[creditIndex]);
                }
            }
            ++numberOfDayTextures;
        }
        uniformMap.dayTextures.length = numberOfDayTextures;
        uniformMap.waterMask = waterMaskTexture;
        Cartesian4.clone(surfaceTile.waterMaskTranslationAndScale, uniformMap.waterMaskTranslationAndScale);
        command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(context, frameState.mode, surfaceTile, numberOfDayTextures, applyBrightness, applyContrast, applyHue, applySaturation, applyGamma, applyAlpha, showReflectiveOcean, showOceanWaves, tileProvider.enableLighting, hasVertexNormals, useWebMercatorProjection);
        command.renderState = renderState;
        command.primitiveType = PrimitiveType.TRIANGLES;
        command.vertexArray = surfaceTile.vertexArray;
        command.uniformMap = uniformMap;
        command.pass = Pass.OPAQUE;
        if (tileProvider._debug.wireframe) {
            createWireframeVertexArrayIfNecessary(context, tileProvider, tile);
            if (defined(surfaceTile.wireframeVertexArray)) {
                command.vertexArray = surfaceTile.wireframeVertexArray;
                command.primitiveType = PrimitiveType.LINES;
            }
        }
        var boundingVolume = command.boundingVolume;
        if (frameState.mode !== SceneMode.SCENE3D) {
            BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, frameState.mapProjection, surfaceTile.minimumHeight, surfaceTile.maximumHeight, boundingVolume);
            Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);
            if (frameState.mode === SceneMode.MORPHING) {
                boundingVolume = BoundingSphere.union(surfaceTile.boundingSphere3D, boundingVolume, boundingVolume);
            }
        } else {
            BoundingSphere.clone(surfaceTile.boundingSphere3D, boundingVolume);
        }
        commandList.push(command);
        renderState = otherPassesRenderState;
        initialColor = otherPassesInitialColor;
    } while (imageryIndex < imageryLen);
}
module.exports = GlobeSurfaceTileProvider;
},{"../Core/BoundingSphere":98,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/FeatureDetection":141,"../Core/GeometryPipeline":150,"../Core/IndexDatatype":162,"../Core/Intersect":163,"../Core/Matrix4":177,"../Core/PrimitiveType":193,"../Core/Rectangle":201,"../Core/Visibility":229,"../Core/WebMercatorProjection":233,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/BufferUsage":339,"../Renderer/DrawCommand":344,"../Scene/BlendingState":374,"../Scene/DepthFunction":382,"../Scene/Pass":419,"../ThirdParty/when":596,"./GlobeSurfaceTile":392,"./ImageryLayer":396,"./ImageryState":400,"./QuadtreeTileLoadState":435,"./SceneMode":438}],394:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var HorizontalOrigin = {
        CENTER: 0,
        LEFT: 1,
        RIGHT: -1
    };
module.exports = freezeObject(HorizontalOrigin);
},{"../Core/freezeObject":249}],395:[function(require,module,exports){
var defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), ImageryState = require('./ImageryState');
'use strict';
var Imagery = function (imageryLayer, x, y, level, rectangle) {
    this.imageryLayer = imageryLayer;
    this.x = x;
    this.y = y;
    this.level = level;
    if (level !== 0) {
        var parentX = x / 2 | 0;
        var parentY = y / 2 | 0;
        var parentLevel = level - 1;
        this.parent = imageryLayer.getImageryFromCache(parentX, parentY, parentLevel);
    }
    this.state = ImageryState.UNLOADED;
    this.imageUrl = undefined;
    this.image = undefined;
    this.texture = undefined;
    this.credits = undefined;
    this.referenceCount = 0;
    if (!defined(rectangle) && imageryLayer.imageryProvider.ready) {
        var tilingScheme = imageryLayer.imageryProvider.tilingScheme;
        rectangle = tilingScheme.tileXYToRectangle(x, y, level);
    }
    this.rectangle = rectangle;
};
Imagery.createPlaceholder = function (imageryLayer) {
    var result = new Imagery(imageryLayer, 0, 0, 0);
    result.addReference();
    result.state = ImageryState.PLACEHOLDER;
    return result;
};
Imagery.prototype.addReference = function () {
    ++this.referenceCount;
};
Imagery.prototype.releaseReference = function () {
    --this.referenceCount;
    if (this.referenceCount === 0) {
        this.imageryLayer.removeImageryFromCache(this);
        if (defined(this.parent)) {
            this.parent.releaseReference();
        }
        if (defined(this.image) && defined(this.image.destroy)) {
            this.image.destroy();
        }
        if (defined(this.texture)) {
            this.texture.destroy();
        }
        destroyObject(this);
        return 0;
    }
    return this.referenceCount;
};
module.exports = Imagery;
},{"../Core/defined":245,"../Core/destroyObject":247,"./ImageryState":400}],396:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), Cartesian2 = require('../Core/Cartesian2'), Cartesian4 = require('../Core/Cartesian4'), Color = require('../Core/Color'), ComponentDatatype = require('../Core/ComponentDatatype'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), FeatureDetection = require('../Core/FeatureDetection'), GeographicTilingScheme = require('../Core/GeographicTilingScheme'), IndexDatatype = require('../Core/IndexDatatype'), CesiumMath = require('../Core/Math'), PixelFormat = require('../Core/PixelFormat'), PrimitiveType = require('../Core/PrimitiveType'), Rectangle = require('../Core/Rectangle'), TerrainProvider = require('../Core/TerrainProvider'), TileProviderError = require('../Core/TileProviderError'), BufferUsage = require('../Renderer/BufferUsage'), ClearCommand = require('../Renderer/ClearCommand'), DrawCommand = require('../Renderer/DrawCommand'), MipmapHint = require('../Renderer/MipmapHint'), ShaderSource = require('../Renderer/ShaderSource'), TextureMagnificationFilter = require('../Renderer/TextureMagnificationFilter'), TextureMinificationFilter = require('../Renderer/TextureMinificationFilter'), TextureWrap = require('../Renderer/TextureWrap'), ReprojectWebMercatorFS = require('../Shaders/ReprojectWebMercatorFS'), ReprojectWebMercatorVS = require('../Shaders/ReprojectWebMercatorVS'), when = require('../ThirdParty/when'), Imagery = require('./Imagery'), ImageryState = require('./ImageryState'), TileImagery = require('./TileImagery');
'use strict';
var ImageryLayer = function ImageryLayer(imageryProvider, options) {
    this._imageryProvider = imageryProvider;
    options = defaultValue(options, {});
    this.alpha = defaultValue(options.alpha, defaultValue(imageryProvider.defaultAlpha, 1));
    this.brightness = defaultValue(options.brightness, defaultValue(imageryProvider.defaultBrightness, ImageryLayer.DEFAULT_BRIGHTNESS));
    this.contrast = defaultValue(options.contrast, defaultValue(imageryProvider.defaultContrast, ImageryLayer.DEFAULT_CONTRAST));
    this.hue = defaultValue(options.hue, defaultValue(imageryProvider.defaultHue, ImageryLayer.DEFAULT_HUE));
    this.saturation = defaultValue(options.saturation, defaultValue(imageryProvider.defaultSaturation, ImageryLayer.DEFAULT_SATURATION));
    this.gamma = defaultValue(options.gamma, defaultValue(imageryProvider.defaultGamma, ImageryLayer.DEFAULT_GAMMA));
    this.show = defaultValue(options.show, true);
    this._minimumTerrainLevel = options.minimumTerrainLevel;
    this._maximumTerrainLevel = options.maximumTerrainLevel;
    this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);
    this._maximumAnisotropy = options.maximumAnisotropy;
    this._imageryCache = {};
    this._skeletonPlaceholder = new TileImagery(Imagery.createPlaceholder(this));
    this._show = true;
    this._layerIndex = -1;
    this._isBaseLayer = false;
    this._requestImageError = undefined;
};
defineProperties(ImageryLayer.prototype, {
    imageryProvider: {
        get: function () {
            return this._imageryProvider;
        }
    },
    rectangle: {
        get: function () {
            return this._rectangle;
        }
    }
});
ImageryLayer.DEFAULT_BRIGHTNESS = 1;
ImageryLayer.DEFAULT_CONTRAST = 1;
ImageryLayer.DEFAULT_HUE = 0;
ImageryLayer.DEFAULT_SATURATION = 1;
ImageryLayer.DEFAULT_GAMMA = 1;
ImageryLayer.prototype.isBaseLayer = function () {
    return this._isBaseLayer;
};
ImageryLayer.prototype.isDestroyed = function () {
    return false;
};
ImageryLayer.prototype.destroy = function () {
    return destroyObject(this);
};
var imageryBoundsScratch = new Rectangle();
var tileImageryBoundsScratch = new Rectangle();
var clippedRectangleScratch = new Rectangle();
ImageryLayer.prototype._createTileImagerySkeletons = function (tile, terrainProvider, insertionPoint) {
    var surfaceTile = tile.data;
    if (defined(this._minimumTerrainLevel) && tile.level < this._minimumTerrainLevel) {
        return false;
    }
    if (defined(this._maximumTerrainLevel) && tile.level > this._maximumTerrainLevel) {
        return false;
    }
    var imageryProvider = this._imageryProvider;
    if (!defined(insertionPoint)) {
        insertionPoint = surfaceTile.imagery.length;
    }
    if (!imageryProvider.ready) {
        this._skeletonPlaceholder.loadingImagery.addReference();
        surfaceTile.imagery.splice(insertionPoint, 0, this._skeletonPlaceholder);
        return true;
    }
    var imageryBounds = Rectangle.intersection(imageryProvider.rectangle, this._rectangle, imageryBoundsScratch);
    var rectangle = Rectangle.intersection(tile.rectangle, imageryBounds, tileImageryBoundsScratch);
    if (!defined(rectangle)) {
        if (!this.isBaseLayer()) {
            return false;
        }
        var baseImageryRectangle = imageryBounds;
        var baseTerrainRectangle = tile.rectangle;
        rectangle = tileImageryBoundsScratch;
        if (baseTerrainRectangle.south >= baseImageryRectangle.north) {
            rectangle.north = rectangle.south = baseImageryRectangle.north;
        } else if (baseTerrainRectangle.north <= baseImageryRectangle.south) {
            rectangle.north = rectangle.south = baseImageryRectangle.south;
        }
        if (baseTerrainRectangle.west >= baseImageryRectangle.east) {
            rectangle.west = rectangle.east = baseImageryRectangle.east;
        } else if (baseTerrainRectangle.east <= baseImageryRectangle.west) {
            rectangle.west = rectangle.east = baseImageryRectangle.west;
        }
    }
    var latitudeClosestToEquator = 0;
    if (rectangle.south > 0) {
        latitudeClosestToEquator = rectangle.south;
    } else if (rectangle.north < 0) {
        latitudeClosestToEquator = rectangle.north;
    }
    var errorRatio = 1;
    var targetGeometricError = errorRatio * terrainProvider.getLevelMaximumGeometricError(tile.level);
    var imageryLevel = getLevelWithMaximumTexelSpacing(this, targetGeometricError, latitudeClosestToEquator);
    imageryLevel = Math.max(0, imageryLevel);
    var maximumLevel = imageryProvider.maximumLevel;
    if (imageryLevel > maximumLevel) {
        imageryLevel = maximumLevel;
    }
    if (defined(imageryProvider.minimumLevel)) {
        var minimumLevel = imageryProvider.minimumLevel;
        if (imageryLevel < minimumLevel) {
            imageryLevel = minimumLevel;
        }
    }
    var imageryTilingScheme = imageryProvider.tilingScheme;
    var northwestTileCoordinates = imageryTilingScheme.positionToTileXY(Rectangle.northwest(rectangle), imageryLevel);
    var southeastTileCoordinates = imageryTilingScheme.positionToTileXY(Rectangle.southeast(rectangle), imageryLevel);
    var veryCloseX = tile.rectangle.height / 512;
    var veryCloseY = tile.rectangle.width / 512;
    var northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(northwestTileCoordinates.x, northwestTileCoordinates.y, imageryLevel);
    if (Math.abs(northwestTileRectangle.south - tile.rectangle.north) < veryCloseY && northwestTileCoordinates.y < southeastTileCoordinates.y) {
        ++northwestTileCoordinates.y;
    }
    if (Math.abs(northwestTileRectangle.east - tile.rectangle.west) < veryCloseX && northwestTileCoordinates.x < southeastTileCoordinates.x) {
        ++northwestTileCoordinates.x;
    }
    var southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(southeastTileCoordinates.x, southeastTileCoordinates.y, imageryLevel);
    if (Math.abs(southeastTileRectangle.north - tile.rectangle.south) < veryCloseY && southeastTileCoordinates.y > northwestTileCoordinates.y) {
        --southeastTileCoordinates.y;
    }
    if (Math.abs(southeastTileRectangle.west - tile.rectangle.east) < veryCloseX && southeastTileCoordinates.x > northwestTileCoordinates.x) {
        --southeastTileCoordinates.x;
    }
    var terrainRectangle = tile.rectangle;
    var imageryRectangle = imageryTilingScheme.tileXYToRectangle(northwestTileCoordinates.x, northwestTileCoordinates.y, imageryLevel);
    var clippedImageryRectangle = Rectangle.intersection(imageryRectangle, imageryBounds, clippedRectangleScratch);
    var minU;
    var maxU = 0;
    var minV = 1;
    var maxV;
    if (!this.isBaseLayer() && Math.abs(clippedImageryRectangle.west - tile.rectangle.west) >= veryCloseX) {
        maxU = Math.min(1, (clippedImageryRectangle.west - terrainRectangle.west) / terrainRectangle.width);
    }
    if (!this.isBaseLayer() && Math.abs(clippedImageryRectangle.north - tile.rectangle.north) >= veryCloseY) {
        minV = Math.max(0, (clippedImageryRectangle.north - terrainRectangle.south) / terrainRectangle.height);
    }
    var initialMinV = minV;
    for (var i = northwestTileCoordinates.x; i <= southeastTileCoordinates.x; i++) {
        minU = maxU;
        imageryRectangle = imageryTilingScheme.tileXYToRectangle(i, northwestTileCoordinates.y, imageryLevel);
        clippedImageryRectangle = Rectangle.intersection(imageryRectangle, imageryBounds, clippedRectangleScratch);
        maxU = Math.min(1, (clippedImageryRectangle.east - terrainRectangle.west) / terrainRectangle.width);
        if (i === southeastTileCoordinates.x && (this.isBaseLayer() || Math.abs(clippedImageryRectangle.east - tile.rectangle.east) < veryCloseX)) {
            maxU = 1;
        }
        minV = initialMinV;
        for (var j = northwestTileCoordinates.y; j <= southeastTileCoordinates.y; j++) {
            maxV = minV;
            imageryRectangle = imageryTilingScheme.tileXYToRectangle(i, j, imageryLevel);
            clippedImageryRectangle = Rectangle.intersection(imageryRectangle, imageryBounds, clippedRectangleScratch);
            minV = Math.max(0, (clippedImageryRectangle.south - terrainRectangle.south) / terrainRectangle.height);
            if (j === southeastTileCoordinates.y && (this.isBaseLayer() || Math.abs(clippedImageryRectangle.south - tile.rectangle.south) < veryCloseY)) {
                minV = 0;
            }
            var texCoordsRectangle = new Cartesian4(minU, minV, maxU, maxV);
            var imagery = this.getImageryFromCache(i, j, imageryLevel, imageryRectangle);
            surfaceTile.imagery.splice(insertionPoint, 0, new TileImagery(imagery, texCoordsRectangle));
            ++insertionPoint;
        }
    }
    return true;
};
ImageryLayer.prototype._calculateTextureTranslationAndScale = function (tile, tileImagery) {
    var imageryRectangle = tileImagery.readyImagery.rectangle;
    var terrainRectangle = tile.rectangle;
    var terrainWidth = terrainRectangle.width;
    var terrainHeight = terrainRectangle.height;
    var scaleX = terrainWidth / imageryRectangle.width;
    var scaleY = terrainHeight / imageryRectangle.height;
    return new Cartesian4(scaleX * (terrainRectangle.west - imageryRectangle.west) / terrainWidth, scaleY * (terrainRectangle.south - imageryRectangle.south) / terrainHeight, scaleX, scaleY);
};
ImageryLayer.prototype._requestImagery = function (imagery) {
    var imageryProvider = this._imageryProvider;
    var that = this;
    function success(image) {
        if (!defined(image)) {
            return failure();
        }
        imagery.image = image;
        imagery.state = ImageryState.RECEIVED;
        TileProviderError.handleSuccess(that._requestImageError);
    }
    function failure(e) {
        imagery.state = ImageryState.FAILED;
        var message = 'Failed to obtain image tile X: ' + imagery.x + ' Y: ' + imagery.y + ' Level: ' + imagery.level + '.';
        that._requestImageError = TileProviderError.handleError(that._requestImageError, imageryProvider, imageryProvider.errorEvent, message, imagery.x, imagery.y, imagery.level, doRequest);
    }
    function doRequest() {
        imagery.state = ImageryState.TRANSITIONING;
        var imagePromise = imageryProvider.requestImage(imagery.x, imagery.y, imagery.level);
        if (!defined(imagePromise)) {
            imagery.state = ImageryState.UNLOADED;
            return;
        }
        if (defined(imageryProvider.getTileCredits)) {
            imagery.credits = imageryProvider.getTileCredits(imagery.x, imagery.y, imagery.level);
        }
        when(imagePromise, success, failure);
    }
    doRequest();
};
ImageryLayer.prototype._createTexture = function (context, imagery) {
    var imageryProvider = this._imageryProvider;
    if (defined(imageryProvider.tileDiscardPolicy)) {
        var discardPolicy = imageryProvider.tileDiscardPolicy;
        if (defined(discardPolicy)) {
            if (!discardPolicy.isReady()) {
                imagery.state = ImageryState.RECEIVED;
                return;
            }
            if (discardPolicy.shouldDiscardImage(imagery.image)) {
                imagery.state = ImageryState.INVALID;
                return;
            }
        }
    }
    var texture = context.createTexture2D({
            source: imagery.image,
            pixelFormat: imageryProvider.hasAlphaChannel ? PixelFormat.RGBA : PixelFormat.RGB
        });
    imagery.texture = texture;
    imagery.image = undefined;
    imagery.state = ImageryState.TEXTURE_LOADED;
};
ImageryLayer.prototype._reprojectTexture = function (context, imagery) {
    var texture = imagery.texture;
    var rectangle = imagery.rectangle;
    if (!(this._imageryProvider.tilingScheme instanceof GeographicTilingScheme) && rectangle.width / texture.width > 0.00001) {
        var reprojectedTexture = reprojectToGeographic(this, context, texture, imagery.rectangle);
        texture.destroy();
        imagery.texture = texture = reprojectedTexture;
    }
    if (CesiumMath.isPowerOfTwo(texture.width) && CesiumMath.isPowerOfTwo(texture.height)) {
        var mipmapSampler = context.cache.imageryLayer_mipmapSampler;
        if (!defined(mipmapSampler)) {
            var maximumSupportedAnisotropy = context.maximumTextureFilterAnisotropy;
            mipmapSampler = context.cache.imageryLayer_mipmapSampler = context.createSampler({
                wrapS: TextureWrap.CLAMP_TO_EDGE,
                wrapT: TextureWrap.CLAMP_TO_EDGE,
                minificationFilter: TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,
                magnificationFilter: TextureMagnificationFilter.LINEAR,
                maximumAnisotropy: Math.min(maximumSupportedAnisotropy, defaultValue(this._maximumAnisotropy, maximumSupportedAnisotropy))
            });
        }
        texture.generateMipmap(MipmapHint.NICEST);
        texture.sampler = mipmapSampler;
    } else {
        var nonMipmapSampler = context.cache.imageryLayer_nonMipmapSampler;
        if (!defined(nonMipmapSampler)) {
            nonMipmapSampler = context.cache.imageryLayer_nonMipmapSampler = context.createSampler({
                wrapS: TextureWrap.CLAMP_TO_EDGE,
                wrapT: TextureWrap.CLAMP_TO_EDGE,
                minificationFilter: TextureMinificationFilter.LINEAR,
                magnificationFilter: TextureMagnificationFilter.LINEAR
            });
        }
        texture.sampler = nonMipmapSampler;
    }
    imagery.state = ImageryState.READY;
};
ImageryLayer.prototype.getImageryFromCache = function (x, y, level, imageryRectangle) {
    var cacheKey = getImageryCacheKey(x, y, level);
    var imagery = this._imageryCache[cacheKey];
    if (!defined(imagery)) {
        imagery = new Imagery(this, x, y, level, imageryRectangle);
        this._imageryCache[cacheKey] = imagery;
    }
    imagery.addReference();
    return imagery;
};
ImageryLayer.prototype.removeImageryFromCache = function (imagery) {
    var cacheKey = getImageryCacheKey(imagery.x, imagery.y, imagery.level);
    delete this._imageryCache[cacheKey];
};
function getImageryCacheKey(x, y, level) {
    return JSON.stringify([
        x,
        y,
        level
    ]);
}
var uniformMap = {
        u_textureDimensions: function () {
            return this.textureDimensions;
        },
        u_texture: function () {
            return this.texture;
        },
        textureDimensions: new Cartesian2(),
        texture: undefined
    };
var float32ArrayScratch = FeatureDetection.supportsTypedArrays() ? new Float32Array(2 * 64) : undefined;
function reprojectToGeographic(imageryLayer, context, texture, rectangle) {
    var reproject = context.cache.imageryLayer_reproject;
    if (!defined(reproject)) {
        reproject = context.cache.imageryLayer_reproject = {
            framebuffer: undefined,
            vertexArray: undefined,
            shaderProgram: undefined,
            renderState: undefined,
            sampler: undefined,
            destroy: function () {
                if (defined(this.framebuffer)) {
                    this.framebuffer.destroy();
                }
                if (defined(this.vertexArray)) {
                    this.vertexArray.destroy();
                }
                if (defined(this.shaderProgram)) {
                    this.shaderProgram.destroy();
                }
            }
        };
        var positions = new Float32Array(2 * 64 * 2);
        var index = 0;
        for (var j = 0; j < 64; ++j) {
            var y = j / 63;
            positions[index++] = 0;
            positions[index++] = y;
            positions[index++] = 1;
            positions[index++] = y;
        }
        var reprojectAttributeIndices = {
                position: 0,
                webMercatorT: 1
            };
        var indices = TerrainProvider.getRegularGridIndices(2, 64);
        var indexBuffer = context.createIndexBuffer(indices, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
        reproject.vertexArray = context.createVertexArray([
            {
                index: reprojectAttributeIndices.position,
                vertexBuffer: context.createVertexBuffer(positions, BufferUsage.STATIC_DRAW),
                componentsPerAttribute: 2
            },
            {
                index: reprojectAttributeIndices.webMercatorT,
                vertexBuffer: context.createVertexBuffer(64 * 2 * 4, BufferUsage.STREAM_DRAW),
                componentsPerAttribute: 1
            }
        ], indexBuffer);
        var vs = new ShaderSource({ sources: [ReprojectWebMercatorVS] });
        reproject.shaderProgram = context.createShaderProgram(vs, ReprojectWebMercatorFS, reprojectAttributeIndices);
        reproject.sampler = context.createSampler({
            wrapS: TextureWrap.CLAMP_TO_EDGE,
            wrapT: TextureWrap.CLAMP_TO_EDGE,
            minificationFilter: TextureMinificationFilter.LINEAR,
            magnificationFilter: TextureMagnificationFilter.LINEAR
        });
    }
    texture.sampler = reproject.sampler;
    var width = texture.width;
    var height = texture.height;
    uniformMap.textureDimensions.x = width;
    uniformMap.textureDimensions.y = height;
    uniformMap.texture = texture;
    var sinLatitude = Math.sin(rectangle.south);
    var southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));
    sinLatitude = Math.sin(rectangle.north);
    var northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));
    var oneOverMercatorHeight = 1 / (northMercatorY - southMercatorY);
    var outputTexture = context.createTexture2D({
            width: width,
            height: height,
            pixelFormat: texture.pixelFormat,
            pixelDatatype: texture.pixelDatatype,
            preMultiplyAlpha: texture.preMultiplyAlpha
        });
    outputTexture.generateMipmap(MipmapHint.NICEST);
    if (defined(reproject.framebuffer)) {
        reproject.framebuffer.destroy();
    }
    reproject.framebuffer = context.createFramebuffer({ colorTextures: [outputTexture] });
    reproject.framebuffer.destroyAttachments = false;
    var south = rectangle.south;
    var north = rectangle.north;
    var webMercatorT = float32ArrayScratch;
    var outputIndex = 0;
    for (var webMercatorTIndex = 0; webMercatorTIndex < 64; ++webMercatorTIndex) {
        var fraction = webMercatorTIndex / 63;
        var latitude = CesiumMath.lerp(south, north, fraction);
        sinLatitude = Math.sin(latitude);
        var mercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));
        var mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;
        webMercatorT[outputIndex++] = mercatorFraction;
        webMercatorT[outputIndex++] = mercatorFraction;
    }
    reproject.vertexArray.getAttribute(1).vertexBuffer.copyFromArrayView(webMercatorT);
    var command = new ClearCommand({
            color: Color.BLACK,
            framebuffer: reproject.framebuffer
        });
    command.execute(context);
    if (!defined(reproject.renderState) || reproject.renderState.viewport.width !== width || reproject.renderState.viewport.height !== height) {
        reproject.renderState = context.createRenderState({ viewport: new BoundingRectangle(0, 0, width, height) });
    }
    var drawCommand = new DrawCommand({
            framebuffer: reproject.framebuffer,
            shaderProgram: reproject.shaderProgram,
            renderState: reproject.renderState,
            primitiveType: PrimitiveType.TRIANGLES,
            vertexArray: reproject.vertexArray,
            uniformMap: uniformMap
        });
    drawCommand.execute(context);
    return outputTexture;
}
function getLevelWithMaximumTexelSpacing(layer, texelSpacing, latitudeClosestToEquator) {
    var imageryProvider = layer._imageryProvider;
    var tilingScheme = imageryProvider.tilingScheme;
    var ellipsoid = tilingScheme.ellipsoid;
    var latitudeFactor = !(layer._imageryProvider.tilingScheme instanceof GeographicTilingScheme) ? Math.cos(latitudeClosestToEquator) : 1;
    var tilingSchemeRectangle = tilingScheme.rectangle;
    var levelZeroMaximumTexelSpacing = ellipsoid.maximumRadius * tilingSchemeRectangle.width * latitudeFactor / (imageryProvider.tileWidth * tilingScheme.getNumberOfXTilesAtLevel(0));
    var twoToTheLevelPower = levelZeroMaximumTexelSpacing / texelSpacing;
    var level = Math.log(twoToTheLevelPower) / Math.log(2);
    var rounded = Math.round(level);
    return rounded | 0;
}
module.exports = ImageryLayer;
},{"../Core/BoundingRectangle":97,"../Core/Cartesian2":101,"../Core/Cartesian4":103,"../Core/Color":111,"../Core/ComponentDatatype":113,"../Core/FeatureDetection":141,"../Core/GeographicTilingScheme":144,"../Core/IndexDatatype":162,"../Core/Math":174,"../Core/PixelFormat":181,"../Core/PrimitiveType":193,"../Core/Rectangle":201,"../Core/TerrainProvider":219,"../Core/TileProviderError":220,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/BufferUsage":339,"../Renderer/ClearCommand":340,"../Renderer/DrawCommand":344,"../Renderer/MipmapHint":346,"../Renderer/ShaderSource":355,"../Renderer/TextureMagnificationFilter":357,"../Renderer/TextureMinificationFilter":358,"../Renderer/TextureWrap":359,"../Shaders/ReprojectWebMercatorFS":576,"../Shaders/ReprojectWebMercatorVS":577,"../ThirdParty/when":596,"./Imagery":395,"./ImageryState":400,"./TileImagery":449}],397:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), CesiumMath = require('../Core/Math'), Rectangle = require('../Core/Rectangle'), when = require('../ThirdParty/when'), ImageryLayer = require('./ImageryLayer');
'use strict';
var ImageryLayerCollection = function ImageryLayerCollection() {
    this._layers = [];
    this.layerAdded = new Event();
    this.layerRemoved = new Event();
    this.layerMoved = new Event();
    this.layerShownOrHidden = new Event();
};
defineProperties(ImageryLayerCollection.prototype, {
    length: {
        get: function () {
            return this._layers.length;
        }
    }
});
ImageryLayerCollection.prototype.add = function (layer, index) {
    var hasIndex = defined(index);
    if (!defined(layer)) {
        throw new DeveloperError('layer is required.');
    }
    if (hasIndex) {
        if (index < 0) {
            throw new DeveloperError('index must be greater than or equal to zero.');
        } else if (index > this._layers.length) {
            throw new DeveloperError('index must be less than or equal to the number of layers.');
        }
    }
    if (!hasIndex) {
        index = this._layers.length;
        this._layers.push(layer);
    } else {
        this._layers.splice(index, 0, layer);
    }
    this._update();
    this.layerAdded.raiseEvent(layer, index);
};
ImageryLayerCollection.prototype.addImageryProvider = function (imageryProvider, index) {
    if (!defined(imageryProvider)) {
        throw new DeveloperError('imageryProvider is required.');
    }
    var layer = new ImageryLayer(imageryProvider);
    this.add(layer, index);
    return layer;
};
ImageryLayerCollection.prototype.remove = function (layer, destroy) {
    destroy = defaultValue(destroy, true);
    var index = this._layers.indexOf(layer);
    if (index !== -1) {
        this._layers.splice(index, 1);
        this._update();
        this.layerRemoved.raiseEvent(layer, index);
        if (destroy) {
            layer.destroy();
        }
        return true;
    }
    return false;
};
ImageryLayerCollection.prototype.removeAll = function (destroy) {
    destroy = defaultValue(destroy, true);
    var layers = this._layers;
    for (var i = 0, len = layers.length; i < len; i++) {
        var layer = layers[i];
        this.layerRemoved.raiseEvent(layer, i);
        if (destroy) {
            layer.destroy();
        }
    }
    this._layers = [];
};
ImageryLayerCollection.prototype.contains = function (layer) {
    return this.indexOf(layer) !== -1;
};
ImageryLayerCollection.prototype.indexOf = function (layer) {
    return this._layers.indexOf(layer);
};
ImageryLayerCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.', 'index');
    }
    return this._layers[index];
};
function getLayerIndex(layers, layer) {
    if (!defined(layer)) {
        throw new DeveloperError('layer is required.');
    }
    var index = layers.indexOf(layer);
    if (index === -1) {
        throw new DeveloperError('layer is not in this collection.');
    }
    return index;
}
function swapLayers(collection, i, j) {
    var arr = collection._layers;
    i = CesiumMath.clamp(i, 0, arr.length - 1);
    j = CesiumMath.clamp(j, 0, arr.length - 1);
    if (i === j) {
        return;
    }
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
    collection._update();
    collection.layerMoved.raiseEvent(temp, j, i);
}
ImageryLayerCollection.prototype.raise = function (layer) {
    var index = getLayerIndex(this._layers, layer);
    swapLayers(this, index, index + 1);
};
ImageryLayerCollection.prototype.lower = function (layer) {
    var index = getLayerIndex(this._layers, layer);
    swapLayers(this, index, index - 1);
};
ImageryLayerCollection.prototype.raiseToTop = function (layer) {
    var index = getLayerIndex(this._layers, layer);
    if (index === this._layers.length - 1) {
        return;
    }
    this._layers.splice(index, 1);
    this._layers.push(layer);
    this._update();
    this.layerMoved.raiseEvent(layer, this._layers.length - 1, index);
};
ImageryLayerCollection.prototype.lowerToBottom = function (layer) {
    var index = getLayerIndex(this._layers, layer);
    if (index === 0) {
        return;
    }
    this._layers.splice(index, 1);
    this._layers.splice(0, 0, layer);
    this._update();
    this.layerMoved.raiseEvent(layer, 0, index);
};
ImageryLayerCollection.prototype.pickImageryLayerFeatures = function (ray, scene) {
    var pickedPosition = scene.globe.pick(ray, scene);
    if (!defined(pickedPosition)) {
        return undefined;
    }
    var pickedLocation = scene.globe.ellipsoid.cartesianToCartographic(pickedPosition);
    var tilesToRender = scene.globe._surface._tilesToRender;
    var length = tilesToRender.length;
    var pickedTile;
    for (var textureIndex = 0; !defined(pickedTile) && textureIndex < tilesToRender.length; ++textureIndex) {
        var tile = tilesToRender[textureIndex];
        if (Rectangle.contains(tile.rectangle, pickedLocation)) {
            pickedTile = tile;
        }
    }
    if (!defined(pickedTile)) {
        return undefined;
    }
    var tileExtent = pickedTile.rectangle;
    var imageryTiles = pickedTile.data.imagery;
    var promises = [];
    for (var i = imageryTiles.length - 1; i >= 0; --i) {
        var terrainImagery = imageryTiles[i];
        var imagery = terrainImagery.readyImagery;
        if (!defined(imagery)) {
            continue;
        }
        var provider = imagery.imageryLayer.imageryProvider;
        if (!defined(provider.pickFeatures)) {
            continue;
        }
        var promise = provider.pickFeatures(imagery.x, imagery.y, imagery.level, pickedLocation.longitude, pickedLocation.latitude);
        if (!defined(promise)) {
            continue;
        }
        promises.push(promise);
    }
    if (promises.length === 0) {
        return undefined;
    }
    return when.all(promises, function (results) {
        var features = [];
        for (var resultIndex = 0; resultIndex < results.length; ++resultIndex) {
            var result = results[resultIndex];
            if (defined(result) && result.length > 0) {
                for (var featureIndex = 0; featureIndex < result.length; ++featureIndex) {
                    var feature = result[featureIndex];
                    if (!defined(feature.position)) {
                        feature.position = pickedLocation;
                    }
                    features.push(feature);
                }
            }
        }
        return features;
    });
};
ImageryLayerCollection.prototype.isDestroyed = function () {
    return false;
};
ImageryLayerCollection.prototype.destroy = function () {
    this.removeAll(true);
    return destroyObject(this);
};
ImageryLayerCollection.prototype._update = function () {
    var isBaseLayer = true;
    var layers = this._layers;
    var layersShownOrHidden;
    var layer;
    for (var i = 0, len = layers.length; i < len; ++i) {
        layer = layers[i];
        layer._layerIndex = i;
        if (layer.show) {
            layer._isBaseLayer = isBaseLayer;
            isBaseLayer = false;
        } else {
            layer._isBaseLayer = false;
        }
        if (layer.show !== layer._show) {
            if (defined(layer._show)) {
                if (!defined(layersShownOrHidden)) {
                    layersShownOrHidden = [];
                }
                layersShownOrHidden.push(layer);
            }
            layer._show = layer.show;
        }
    }
    if (defined(layersShownOrHidden)) {
        for (i = 0, len = layersShownOrHidden.length; i < len; ++i) {
            layer = layersShownOrHidden[i];
            this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);
        }
    }
};
module.exports = ImageryLayerCollection;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/Math":174,"../Core/Rectangle":201,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../ThirdParty/when":596,"./ImageryLayer":396}],398:[function(require,module,exports){
var defined = require('../Core/defined');
'use strict';
var ImageryLayerFeatureInfo = function () {
    this.name = undefined;
    this.description = undefined;
    this.position = undefined;
    this.data = undefined;
};
ImageryLayerFeatureInfo.prototype.configureNameFromProperties = function (properties) {
    var namePropertyPrecedence = 10;
    var nameProperty;
    for (var key in properties) {
        if (properties.hasOwnProperty(key) && properties[key]) {
            var lowerKey = key.toLowerCase();
            if (namePropertyPrecedence > 1 && lowerKey === 'name') {
                namePropertyPrecedence = 1;
                nameProperty = key;
            } else if (namePropertyPrecedence > 2 && lowerKey === 'title') {
                namePropertyPrecedence = 2;
                nameProperty = key;
            } else if (namePropertyPrecedence > 3 && /name/i.test(key)) {
                namePropertyPrecedence = 3;
                nameProperty = key;
            } else if (namePropertyPrecedence > 4 && /title/i.test(key)) {
                namePropertyPrecedence = 4;
                nameProperty = key;
            }
        }
    }
    if (defined(nameProperty)) {
        this.name = properties[nameProperty];
    }
};
ImageryLayerFeatureInfo.prototype.configureDescriptionFromProperties = function (properties) {
    function describe(properties) {
        var html = '<table class="cesium-infoBox-defaultTable">';
        for (var key in properties) {
            if (properties.hasOwnProperty(key)) {
                var value = properties[key];
                if (defined(value)) {
                    if (typeof value === 'object') {
                        html += '<tr><td>' + key + '</td><td>' + describe(value) + '</td></tr>';
                    } else {
                        html += '<tr><td>' + key + '</td><td>' + value + '</td></tr>';
                    }
                }
            }
        }
        html += '</table>';
        return html;
    }
    this.description = describe(properties);
};
module.exports = ImageryLayerFeatureInfo;
},{"../Core/defined":245}],399:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), loadImage = require('../Core/loadImage'), loadImageViaBlob = require('../Core/loadImageViaBlob'), throttleRequestByServer = require('../Core/throttleRequestByServer');
'use strict';
var ImageryProvider = function ImageryProvider() {
    this.defaultAlpha = undefined;
    this.defaultBrightness = undefined;
    this.defaultContrast = undefined;
    this.defaultHue = undefined;
    this.defaultSaturation = undefined;
    this.defaultGamma = undefined;
    DeveloperError.throwInstantiationError();
};
defineProperties(ImageryProvider.prototype, {
    ready: { get: DeveloperError.throwInstantiationError },
    rectangle: { get: DeveloperError.throwInstantiationError },
    tileWidth: { get: DeveloperError.throwInstantiationError },
    tileHeight: { get: DeveloperError.throwInstantiationError },
    maximumLevel: { get: DeveloperError.throwInstantiationError },
    minimumLevel: { get: DeveloperError.throwInstantiationError },
    tilingScheme: { get: DeveloperError.throwInstantiationError },
    tileDiscardPolicy: { get: DeveloperError.throwInstantiationError },
    errorEvent: { get: DeveloperError.throwInstantiationError },
    credit: { get: DeveloperError.throwInstantiationError },
    proxy: { get: DeveloperError.throwInstantiationError },
    hasAlphaChannel: { get: DeveloperError.throwInstantiationError }
});
ImageryProvider.prototype.getTileCredits = DeveloperError.throwInstantiationError;
ImageryProvider.prototype.requestImage = DeveloperError.throwInstantiationError;
ImageryProvider.prototype.pickFeatures = DeveloperError.throwInstantiationError;
ImageryProvider.loadImage = function (imageryProvider, url) {
    if (defined(imageryProvider.tileDiscardPolicy)) {
        return throttleRequestByServer(url, loadImageViaBlob);
    }
    return throttleRequestByServer(url, loadImage);
};
module.exports = ImageryProvider;
},{"../Core/DeveloperError":123,"../Core/defineProperties":244,"../Core/defined":245,"../Core/loadImage":259,"../Core/loadImageViaBlob":260,"../Core/throttleRequestByServer":272}],400:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var ImageryState = {
        UNLOADED: 0,
        TRANSITIONING: 1,
        RECEIVED: 2,
        TEXTURE_LOADED: 3,
        READY: 4,
        FAILED: 5,
        INVALID: 6,
        PLACEHOLDER: 7
    };
module.exports = freezeObject(ImageryState);
},{"../Core/freezeObject":249}],401:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), NearFarScalar = require('../Core/NearFarScalar'), Billboard = require('./Billboard'), HorizontalOrigin = require('./HorizontalOrigin'), LabelStyle = require('./LabelStyle'), VerticalOrigin = require('./VerticalOrigin');
'use strict';
function rebindAllGlyphs(label) {
    if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {
        label._labelCollection._labelsToUpdate.push(label);
    }
    label._rebindAllGlyphs = true;
}
function repositionAllGlyphs(label) {
    if (!label._rebindAllGlyphs && !label._repositionAllGlyphs) {
        label._labelCollection._labelsToUpdate.push(label);
    }
    label._repositionAllGlyphs = true;
}
var Label = function (options, labelCollection) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (defined(options.translucencyByDistance) && options.translucencyByDistance.far <= options.translucencyByDistance.near) {
        throw new DeveloperError('translucencyByDistance.far must be greater than translucencyByDistance.near.');
    }
    if (defined(options.pixelOffsetScaleByDistance) && options.pixelOffsetScaleByDistance.far <= options.pixelOffsetScaleByDistance.near) {
        throw new DeveloperError('pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near.');
    }
    this._text = defaultValue(options.text, '');
    this._show = defaultValue(options.show, true);
    this._font = defaultValue(options.font, '30px sans-serif');
    this._fillColor = Color.clone(defaultValue(options.fillColor, Color.WHITE));
    this._outlineColor = Color.clone(defaultValue(options.outlineColor, Color.BLACK));
    this._outlineWidth = defaultValue(options.outlineWidth, 1);
    this._style = defaultValue(options.style, LabelStyle.FILL);
    this._verticalOrigin = defaultValue(options.verticalOrigin, VerticalOrigin.BOTTOM);
    this._horizontalOrigin = defaultValue(options.horizontalOrigin, HorizontalOrigin.LEFT);
    this._pixelOffset = Cartesian2.clone(defaultValue(options.pixelOffset, Cartesian2.ZERO));
    this._eyeOffset = Cartesian3.clone(defaultValue(options.eyeOffset, Cartesian3.ZERO));
    this._position = Cartesian3.clone(defaultValue(options.position, Cartesian3.ZERO));
    this._scale = defaultValue(options.scale, 1);
    this._id = options.id;
    this._translucencyByDistance = options.translucencyByDistance;
    this._pixelOffsetScaleByDistance = options.pixelOffsetScaleByDistance;
    this._labelCollection = labelCollection;
    this._glyphs = [];
    this._rebindAllGlyphs = true;
    this._repositionAllGlyphs = true;
};
defineProperties(Label.prototype, {
    show: {
        get: function () {
            return this._show;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._show !== value) {
                this._show = value;
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.show = value;
                    }
                }
            }
        }
    },
    position: {
        get: function () {
            return this._position;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var position = this._position;
            if (!Cartesian3.equals(position, value)) {
                Cartesian3.clone(value, position);
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.position = value;
                    }
                }
            }
        }
    },
    text: {
        get: function () {
            return this._text;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._text !== value) {
                this._text = value;
                rebindAllGlyphs(this);
            }
        }
    },
    font: {
        get: function () {
            return this._font;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._font !== value) {
                this._font = value;
                rebindAllGlyphs(this);
            }
        }
    },
    fillColor: {
        get: function () {
            return this._fillColor;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var fillColor = this._fillColor;
            if (!Color.equals(fillColor, value)) {
                Color.clone(value, fillColor);
                rebindAllGlyphs(this);
            }
        }
    },
    outlineColor: {
        get: function () {
            return this._outlineColor;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var outlineColor = this._outlineColor;
            if (!Color.equals(outlineColor, value)) {
                Color.clone(value, outlineColor);
                rebindAllGlyphs(this);
            }
        }
    },
    outlineWidth: {
        get: function () {
            return this._outlineWidth;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._outlineWidth !== value) {
                this._outlineWidth = value;
                rebindAllGlyphs(this);
            }
        }
    },
    style: {
        get: function () {
            return this._style;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._style !== value) {
                this._style = value;
                rebindAllGlyphs(this);
            }
        }
    },
    pixelOffset: {
        get: function () {
            return this._pixelOffset;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var pixelOffset = this._pixelOffset;
            if (!Cartesian2.equals(pixelOffset, value)) {
                Cartesian2.clone(value, pixelOffset);
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.pixelOffset = value;
                    }
                }
            }
        }
    },
    translucencyByDistance: {
        get: function () {
            return this._translucencyByDistance;
        },
        set: function (value) {
            if (defined(value) && value.far <= value.near) {
                throw new DeveloperError('far distance must be greater than near distance.');
            }
            var translucencyByDistance = this._translucencyByDistance;
            if (!NearFarScalar.equals(translucencyByDistance, value)) {
                this._translucencyByDistance = NearFarScalar.clone(value, translucencyByDistance);
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.translucencyByDistance = value;
                    }
                }
            }
        }
    },
    pixelOffsetScaleByDistance: {
        get: function () {
            return this._pixelOffsetScaleByDistance;
        },
        set: function (value) {
            if (defined(value) && value.far <= value.near) {
                throw new DeveloperError('far distance must be greater than near distance.');
            }
            var pixelOffsetScaleByDistance = this._pixelOffsetScaleByDistance;
            if (!NearFarScalar.equals(pixelOffsetScaleByDistance, value)) {
                this._pixelOffsetScaleByDistance = NearFarScalar.clone(value, pixelOffsetScaleByDistance);
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.pixelOffsetScaleByDistance = value;
                    }
                }
            }
        }
    },
    eyeOffset: {
        get: function () {
            return this._eyeOffset;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var eyeOffset = this._eyeOffset;
            if (!Cartesian3.equals(eyeOffset, value)) {
                Cartesian3.clone(value, eyeOffset);
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.eyeOffset = value;
                    }
                }
            }
        }
    },
    horizontalOrigin: {
        get: function () {
            return this._horizontalOrigin;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._horizontalOrigin !== value) {
                this._horizontalOrigin = value;
                repositionAllGlyphs(this);
            }
        }
    },
    verticalOrigin: {
        get: function () {
            return this._verticalOrigin;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._verticalOrigin !== value) {
                this._verticalOrigin = value;
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.verticalOrigin = value;
                    }
                }
                repositionAllGlyphs(this);
            }
        }
    },
    scale: {
        get: function () {
            return this._scale;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (this._scale !== value) {
                this._scale = value;
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.scale = value;
                    }
                }
                repositionAllGlyphs(this);
            }
        }
    },
    id: {
        get: function () {
            return this._id;
        },
        set: function (value) {
            if (this._id !== value) {
                this._id = value;
                var glyphs = this._glyphs;
                for (var i = 0, len = glyphs.length; i < len; i++) {
                    var glyph = glyphs[i];
                    if (defined(glyph.billboard)) {
                        glyph.billboard.id = value;
                    }
                }
            }
        }
    }
});
Label.prototype.computeScreenSpacePosition = function (scene) {
    if (!defined(scene)) {
        throw new DeveloperError('context is required.');
    }
    var labelCollection = this._labelCollection;
    var modelMatrix = labelCollection.modelMatrix;
    var actualPosition = Billboard._computeActualPosition(this._position, scene.frameState, modelMatrix);
    var windowCoordinates = Billboard._computeScreenSpacePosition(modelMatrix, actualPosition, this._eyeOffset, this._pixelOffset, scene);
    windowCoordinates.y = scene.canvas.clientHeight - windowCoordinates.y;
    return windowCoordinates;
};
Label.prototype.equals = function (other) {
    return this === other || defined(other) && this._show === other._show && this._scale === other._scale && this._style === other._style && this._verticalOrigin === other._verticalOrigin && this._horizontalOrigin === other._horizontalOrigin && this._text === other._text && this._font === other._font && Cartesian3.equals(this._position, other._position) && Color.equals(this._fillColor, other._fillColor) && Color.equals(this._outlineColor, other._outlineColor) && Cartesian2.equals(this._pixelOffset, other._pixelOffset) && Cartesian3.equals(this._eyeOffset, other._eyeOffset) && NearFarScalar.equals(this._translucencyByDistance, other._translucencyByDistance) && NearFarScalar.equals(this._pixelOffsetScaleByDistance, other._pixelOffsetScaleByDistance) && this._id === other._id;
};
Label.prototype.isDestroyed = function () {
    return false;
};
module.exports = Label;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/NearFarScalar":178,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./Billboard":368,"./HorizontalOrigin":394,"./LabelStyle":403,"./VerticalOrigin":454}],402:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Matrix4 = require('../Core/Matrix4'), writeTextToCanvas = require('../Core/writeTextToCanvas'), BillboardCollection = require('./BillboardCollection'), HorizontalOrigin = require('./HorizontalOrigin'), Label = require('./Label'), LabelStyle = require('./LabelStyle'), TextureAtlas = require('./TextureAtlas'), VerticalOrigin = require('./VerticalOrigin');
'use strict';
function Glyph() {
    this.textureInfo = undefined;
    this.dimensions = undefined;
    this.billboard = undefined;
}
function GlyphTextureInfo(labelCollection, index, dimensions) {
    this.labelCollection = labelCollection;
    this.index = index;
    this.dimensions = dimensions;
}
var writeTextToCanvasParameters = {};
function createGlyphCanvas(character, font, fillColor, outlineColor, outlineWidth, style, verticalOrigin) {
    writeTextToCanvasParameters.font = font;
    writeTextToCanvasParameters.fillColor = fillColor;
    writeTextToCanvasParameters.strokeColor = outlineColor;
    writeTextToCanvasParameters.strokeWidth = outlineWidth;
    if (verticalOrigin === VerticalOrigin.BOTTOM) {
        writeTextToCanvasParameters.textBaseline = 'bottom';
    } else if (verticalOrigin === VerticalOrigin.TOP) {
        writeTextToCanvasParameters.textBaseline = 'top';
    } else {
        writeTextToCanvasParameters.textBaseline = 'middle';
    }
    writeTextToCanvasParameters.fill = style === LabelStyle.FILL || style === LabelStyle.FILL_AND_OUTLINE;
    writeTextToCanvasParameters.stroke = style === LabelStyle.OUTLINE || style === LabelStyle.FILL_AND_OUTLINE;
    return writeTextToCanvas(character, writeTextToCanvasParameters);
}
function unbindGlyph(labelCollection, glyph) {
    glyph.textureInfo = undefined;
    glyph.dimensions = undefined;
    var billboard = glyph.billboard;
    if (defined(billboard)) {
        billboard.show = false;
        billboard.image = undefined;
        labelCollection._spareBillboards.push(billboard);
        glyph.billboard = undefined;
    }
}
function addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {
    textureAtlas.addImage(id, canvas).then(function (index, id) {
        glyphTextureInfo.index = index;
    });
}
function rebindAllGlyphs(labelCollection, label) {
    var text = label._text;
    var textLength = text.length;
    var glyphs = label._glyphs;
    var glyphsLength = glyphs.length;
    var glyph;
    var glyphIndex;
    var textIndex;
    if (textLength < glyphsLength) {
        for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {
            unbindGlyph(labelCollection, glyphs[glyphIndex]);
        }
    }
    glyphs.length = textLength;
    var glyphTextureCache = labelCollection._glyphTextureCache;
    for (textIndex = 0; textIndex < textLength; ++textIndex) {
        var character = text.charAt(textIndex);
        var font = label._font;
        var fillColor = label._fillColor;
        var outlineColor = label._outlineColor;
        var outlineWidth = label._outlineWidth;
        var style = label._style;
        var verticalOrigin = label._verticalOrigin;
        var id = JSON.stringify([
                character,
                font,
                fillColor.toRgba(),
                outlineColor.toRgba(),
                outlineWidth,
                +style,
                +verticalOrigin
            ]);
        var glyphTextureInfo = glyphTextureCache[id];
        if (!defined(glyphTextureInfo)) {
            var canvas = createGlyphCanvas(character, font, fillColor, outlineColor, outlineWidth, style, verticalOrigin);
            glyphTextureInfo = new GlyphTextureInfo(labelCollection, -1, canvas.dimensions);
            glyphTextureCache[id] = glyphTextureInfo;
            if (canvas.width > 0 && canvas.height > 0) {
                addGlyphToTextureAtlas(labelCollection._textureAtlas, id, canvas, glyphTextureInfo);
            }
        }
        glyph = glyphs[textIndex];
        if (defined(glyph)) {
            if (glyphTextureInfo.index === -1) {
                unbindGlyph(labelCollection, glyph);
            } else {
                if (defined(glyph.textureInfo)) {
                    glyph.textureInfo = undefined;
                }
            }
        } else {
            glyph = new Glyph();
            glyphs[textIndex] = glyph;
        }
        glyph.textureInfo = glyphTextureInfo;
        glyph.dimensions = glyphTextureInfo.dimensions;
        if (glyphTextureInfo.index !== -1) {
            var billboard = glyph.billboard;
            if (!defined(billboard)) {
                if (labelCollection._spareBillboards.length > 0) {
                    billboard = labelCollection._spareBillboards.pop();
                } else {
                    billboard = labelCollection._billboardCollection.add({ collection: labelCollection });
                }
                glyph.billboard = billboard;
            }
            billboard.show = label._show;
            billboard.position = label._position;
            billboard.eyeOffset = label._eyeOffset;
            billboard.pixelOffset = label._pixelOffset;
            billboard.horizontalOrigin = HorizontalOrigin.LEFT;
            billboard.verticalOrigin = label._verticalOrigin;
            billboard.scale = label._scale;
            billboard.pickPrimitive = label;
            billboard.id = label._id;
            billboard.image = id;
            billboard.translucencyByDistance = label._translucencyByDistance;
            billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;
        }
    }
    label._repositionAllGlyphs = true;
}
var glyphPixelOffset = new Cartesian2();
function repositionAllGlyphs(label, resolutionScale) {
    var glyphs = label._glyphs;
    var glyph;
    var dimensions;
    var totalWidth = 0;
    var maxHeight = 0;
    var glyphIndex = 0;
    var glyphLength = glyphs.length;
    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
        glyph = glyphs[glyphIndex];
        dimensions = glyph.dimensions;
        totalWidth += dimensions.computedWidth;
        maxHeight = Math.max(maxHeight, dimensions.height);
    }
    var scale = label._scale;
    var horizontalOrigin = label._horizontalOrigin;
    var widthOffset = 0;
    if (horizontalOrigin === HorizontalOrigin.CENTER) {
        widthOffset -= totalWidth / 2 * scale;
    } else if (horizontalOrigin === HorizontalOrigin.RIGHT) {
        widthOffset -= totalWidth * scale;
    }
    glyphPixelOffset.x = widthOffset * resolutionScale;
    glyphPixelOffset.y = 0;
    var verticalOrigin = label._verticalOrigin;
    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
        glyph = glyphs[glyphIndex];
        dimensions = glyph.dimensions;
        if (verticalOrigin === VerticalOrigin.BOTTOM || dimensions.height === maxHeight) {
            glyphPixelOffset.y = -dimensions.descent * scale;
        } else if (verticalOrigin === VerticalOrigin.TOP) {
            glyphPixelOffset.y = -(maxHeight - dimensions.height) * scale - dimensions.descent * scale;
        } else if (verticalOrigin === VerticalOrigin.CENTER) {
            glyphPixelOffset.y = -(maxHeight - dimensions.height) / 2 * scale - dimensions.descent * scale;
        }
        glyphPixelOffset.y *= resolutionScale;
        if (defined(glyph.billboard)) {
            glyph.billboard._setTranslate(glyphPixelOffset);
        }
        glyphPixelOffset.x += dimensions.computedWidth * scale * resolutionScale;
    }
}
function destroyLabel(labelCollection, label) {
    var glyphs = label._glyphs;
    for (var i = 0, len = glyphs.length; i < len; ++i) {
        unbindGlyph(labelCollection, glyphs[i]);
    }
    label._labelCollection = undefined;
    destroyObject(label);
}
var LabelCollection = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._textureAtlas = undefined;
    this._billboardCollection = new BillboardCollection();
    this._billboardCollection.destroyTextureAtlas = false;
    this._spareBillboards = [];
    this._glyphTextureCache = {};
    this._labels = [];
    this._labelsToUpdate = [];
    this._totalGlyphCount = 0;
    this._resolutionScale = undefined;
    this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));
    this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);
};
defineProperties(LabelCollection.prototype, {
    length: {
        get: function () {
            return this._labels.length;
        }
    }
});
LabelCollection.prototype.add = function (options) {
    var label = new Label(options, this);
    this._labels.push(label);
    this._labelsToUpdate.push(label);
    return label;
};
LabelCollection.prototype.remove = function (label) {
    if (defined(label) && label._labelCollection === this) {
        var index = this._labels.indexOf(label);
        if (index !== -1) {
            this._labels.splice(index, 1);
            destroyLabel(this, label);
            return true;
        }
    }
    return false;
};
LabelCollection.prototype.removeAll = function () {
    var labels = this._labels;
    for (var i = 0, len = labels.length; i < len; ++i) {
        destroyLabel(this, labels[i]);
    }
    labels.length = 0;
};
LabelCollection.prototype.contains = function (label) {
    return defined(label) && label._labelCollection === this;
};
LabelCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    return this._labels[index];
};
LabelCollection.prototype.update = function (context, frameState, commandList) {
    var billboardCollection = this._billboardCollection;
    billboardCollection.modelMatrix = this.modelMatrix;
    billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;
    if (!defined(this._textureAtlas)) {
        this._textureAtlas = new TextureAtlas({ context: context });
        billboardCollection.textureAtlas = this._textureAtlas;
    }
    var uniformState = context.uniformState;
    var resolutionScale = uniformState.resolutionScale;
    var resolutionChanged = this._resolutionScale !== resolutionScale;
    this._resolutionScale = resolutionScale;
    var labelsToUpdate;
    if (resolutionChanged) {
        labelsToUpdate = this._labels;
    } else {
        labelsToUpdate = this._labelsToUpdate;
    }
    for (var i = 0, len = labelsToUpdate.length; i < len; ++i) {
        var label = labelsToUpdate[i];
        if (label.isDestroyed()) {
            continue;
        }
        var preUpdateGlyphCount = label._glyphs.length;
        if (label._rebindAllGlyphs) {
            rebindAllGlyphs(this, label);
            label._rebindAllGlyphs = false;
        }
        if (resolutionChanged || label._repositionAllGlyphs) {
            repositionAllGlyphs(label, resolutionScale);
            label._repositionAllGlyphs = false;
        }
        var glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;
        this._totalGlyphCount += glyphCountDifference;
    }
    this._labelsToUpdate.length = 0;
    billboardCollection.update(context, frameState, commandList);
};
LabelCollection.prototype.isDestroyed = function () {
    return false;
};
LabelCollection.prototype.destroy = function () {
    this.removeAll();
    this._billboardCollection = this._billboardCollection.destroy();
    this._textureAtlas = this._textureAtlas && this._textureAtlas.destroy();
    return destroyObject(this);
};
module.exports = LabelCollection;
},{"../Core/Cartesian2":101,"../Core/DeveloperError":123,"../Core/Matrix4":177,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Core/writeTextToCanvas":273,"./BillboardCollection":369,"./HorizontalOrigin":394,"./Label":401,"./LabelStyle":403,"./TextureAtlas":448,"./VerticalOrigin":454}],403:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var LabelStyle = {
        FILL: 0,
        OUTLINE: 1,
        FILL_AND_OUTLINE: 2
    };
module.exports = freezeObject(LabelStyle);
},{"../Core/freezeObject":249}],404:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), clone = require('../Core/clone'), Color = require('../Core/Color'), combine = require('../Core/combine'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), isArray = require('../Core/isArray'), loadImage = require('../Core/loadImage'), Matrix2 = require('../Core/Matrix2'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), CubeMap = require('../Renderer/CubeMap'), Texture = require('../Renderer/Texture'), BumpMapMaterial = require('../Shaders/Materials/BumpMapMaterial'), CheckerboardMaterial = require('../Shaders/Materials/CheckerboardMaterial'), DotMaterial = require('../Shaders/Materials/DotMaterial'), FadeMaterial = require('../Shaders/Materials/FadeMaterial'), GridMaterial = require('../Shaders/Materials/GridMaterial'), NormalMapMaterial = require('../Shaders/Materials/NormalMapMaterial'), PolylineArrowMaterial = require('../Shaders/Materials/PolylineArrowMaterial'), PolylineGlowMaterial = require('../Shaders/Materials/PolylineGlowMaterial'), PolylineOutlineMaterial = require('../Shaders/Materials/PolylineOutlineMaterial'), RimLightingMaterial = require('../Shaders/Materials/RimLightingMaterial'), StripeMaterial = require('../Shaders/Materials/StripeMaterial'), WaterMaterial = require('../Shaders/Materials/Water'), when = require('../ThirdParty/when');
'use strict';
var Material = function (options) {
    this.type = undefined;
    this.shaderSource = undefined;
    this.materials = undefined;
    this.uniforms = undefined;
    this._uniforms = undefined;
    this.translucent = undefined;
    this._strict = undefined;
    this._template = undefined;
    this._count = undefined;
    this._texturePaths = {};
    this._loadedImages = [];
    this._loadedCubeMaps = [];
    this._textures = {};
    this._updateFunctions = [];
    initializeMaterial(options, this);
    defineProperties(this, {
        type: {
            value: this.type,
            writable: false
        }
    });
    if (!defined(Material._uniformList[this.type])) {
        Material._uniformList[this.type] = Object.keys(this._uniforms);
    }
};
Material._uniformList = {};
Material.fromType = function (type, uniforms) {
    if (!defined(Material._materialCache.getMaterial(type))) {
        throw new DeveloperError('material with type \'' + type + '\' does not exist.');
    }
    var material = new Material({ fabric: { type: type } });
    if (defined(uniforms)) {
        for (var name in uniforms) {
            if (uniforms.hasOwnProperty(name)) {
                material.uniforms[name] = uniforms[name];
            }
        }
    }
    return material;
};
Material.prototype.isTranslucent = function () {
    if (defined(this.translucent)) {
        if (typeof this.translucent === 'function') {
            return this.translucent();
        }
        return this.translucent;
    }
    var translucent = true;
    var funcs = this._translucentFunctions;
    var length = funcs.length;
    for (var i = 0; i < length; ++i) {
        var func = funcs[i];
        if (typeof func === 'function') {
            translucent = translucent && func();
        } else {
            translucent = translucent && func;
        }
        if (!translucent) {
            break;
        }
    }
    return translucent;
};
Material.prototype.update = function (context) {
    var i;
    var uniformId;
    var loadedImages = this._loadedImages;
    var length = loadedImages.length;
    for (i = 0; i < length; ++i) {
        var loadedImage = loadedImages[i];
        uniformId = loadedImage.id;
        var image = loadedImage.image;
        var texture = Material._textureCache.getTexture(this._texturePaths[uniformId]);
        if (!defined(texture)) {
            texture = context.createTexture2D({ source: image });
            Material._textureCache.addTexture(this._texturePaths[uniformId], texture);
        }
        this._textures[uniformId] = texture;
        var uniformDimensionsName = uniformId + 'Dimensions';
        if (this.uniforms.hasOwnProperty(uniformDimensionsName)) {
            var uniformDimensions = this.uniforms[uniformDimensionsName];
            uniformDimensions.x = texture._width;
            uniformDimensions.y = texture._height;
        }
    }
    loadedImages.length = 0;
    var loadedCubeMaps = this._loadedCubeMaps;
    length = loadedCubeMaps.length;
    for (i = 0; i < length; ++i) {
        var loadedCubeMap = loadedCubeMaps[i];
        uniformId = loadedCubeMap.id;
        var images = loadedCubeMap.images;
        var cubeMap = Material._textureCache.getTexture(this._texturePaths[uniformId]);
        if (!defined(cubeMap)) {
            cubeMap = context.createCubeMap({
                source: {
                    positiveX: images[0],
                    negativeX: images[1],
                    positiveY: images[2],
                    negativeY: images[3],
                    positiveZ: images[4],
                    negativeZ: images[5]
                }
            });
            Material._textureCache.addTexture(this._texturePaths[uniformId], cubeMap);
        }
        this._textures[uniformId] = cubeMap;
    }
    loadedCubeMaps.length = 0;
    var updateFunctions = this._updateFunctions;
    length = updateFunctions.length;
    for (i = 0; i < length; ++i) {
        updateFunctions[i](this, context);
    }
    var subMaterials = this.materials;
    for (var name in subMaterials) {
        if (subMaterials.hasOwnProperty(name)) {
            subMaterials[name].update(context);
        }
    }
};
Material.prototype.isDestroyed = function () {
    return false;
};
Material.prototype.destroy = function () {
    var materials = this.materials;
    var uniforms = this.uniforms;
    for (var uniformId in uniforms) {
        if (uniforms.hasOwnProperty(uniformId)) {
            var path = this._texturePaths[uniformId];
            Material._textureCache.releaseTexture(path);
        }
    }
    for (var material in materials) {
        if (materials.hasOwnProperty(material)) {
            materials[material].destroy();
        }
    }
    return destroyObject(this);
};
function initializeMaterial(options, result) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    result._strict = defaultValue(options.strict, false);
    result._count = defaultValue(options.count, 0);
    result._template = clone(defaultValue(options.fabric, defaultValue.EMPTY_OBJECT));
    result._template.uniforms = clone(defaultValue(result._template.uniforms, defaultValue.EMPTY_OBJECT));
    result._template.materials = clone(defaultValue(result._template.materials, defaultValue.EMPTY_OBJECT));
    result.type = defined(result._template.type) ? result._template.type : createGuid();
    result.shaderSource = '';
    result.materials = {};
    result.uniforms = {};
    result._uniforms = {};
    result._translucentFunctions = [];
    var translucent;
    var cachedMaterial = Material._materialCache.getMaterial(result.type);
    if (defined(cachedMaterial)) {
        var template = clone(cachedMaterial.fabric, true);
        result._template = combine(result._template, template, true);
        translucent = cachedMaterial.translucent;
    }
    checkForTemplateErrors(result);
    if (!defined(cachedMaterial)) {
        Material._materialCache.addMaterial(result.type, result);
    }
    createMethodDefinition(result);
    createUniforms(result);
    createSubMaterials(result);
    var defaultTranslucent = result._translucentFunctions.length === 0 ? true : undefined;
    translucent = defaultValue(translucent, defaultTranslucent);
    translucent = defaultValue(options.translucent, translucent);
    if (defined(translucent)) {
        if (typeof translucent === 'function') {
            var wrappedTranslucent = function () {
                return translucent(result);
            };
            result._translucentFunctions.push(wrappedTranslucent);
        } else {
            result._translucentFunctions.push(translucent);
        }
    }
}
function checkForValidProperties(object, properties, result, throwNotFound) {
    if (defined(object)) {
        for (var property in object) {
            if (object.hasOwnProperty(property)) {
                var hasProperty = properties.indexOf(property) !== -1;
                if (throwNotFound && !hasProperty || !throwNotFound && hasProperty) {
                    result(property, properties);
                }
            }
        }
    }
}
function invalidNameError(property, properties) {
    var errorString = 'fabric: property name \'' + property + '\' is not valid. It should be ';
    for (var i = 0; i < properties.length; i++) {
        var propertyName = '\'' + properties[i] + '\'';
        errorString += i === properties.length - 1 ? 'or ' + propertyName + '.' : propertyName + ', ';
    }
    throw new DeveloperError(errorString);
}
function duplicateNameError(property, properties) {
    var errorString = 'fabric: uniforms and materials cannot share the same property \'' + property + '\'';
    throw new DeveloperError(errorString);
}
var templateProperties = [
        'type',
        'materials',
        'uniforms',
        'components',
        'source'
    ];
var componentProperties = [
        'diffuse',
        'specular',
        'shininess',
        'normal',
        'emission',
        'alpha'
    ];
function checkForTemplateErrors(material) {
    var template = material._template;
    var uniforms = template.uniforms;
    var materials = template.materials;
    var components = template.components;
    if (defined(components) && defined(template.source)) {
        throw new DeveloperError('fabric: cannot have source and components in the same template.');
    }
    checkForValidProperties(template, templateProperties, invalidNameError, true);
    checkForValidProperties(components, componentProperties, invalidNameError, true);
    var materialNames = [];
    for (var property in materials) {
        if (materials.hasOwnProperty(property)) {
            materialNames.push(property);
        }
    }
    checkForValidProperties(uniforms, materialNames, duplicateNameError, false);
}
function createMethodDefinition(material) {
    var components = material._template.components;
    var source = material._template.source;
    if (defined(source)) {
        material.shaderSource += source + '\n';
    } else {
        material.shaderSource += 'czm_material czm_getMaterial(czm_materialInput materialInput)\n{\n';
        material.shaderSource += 'czm_material material = czm_getDefaultMaterial(materialInput);\n';
        if (defined(components)) {
            for (var component in components) {
                if (components.hasOwnProperty(component)) {
                    material.shaderSource += 'material.' + component + ' = ' + components[component] + ';\n';
                }
            }
        }
        material.shaderSource += 'return material;\n}\n';
    }
}
var matrixMap = {
        'mat2': Matrix2,
        'mat3': Matrix3,
        'mat4': Matrix4
    };
function createTexture2DUpdateFunction(uniformId) {
    return function (material, context) {
        var uniforms = material.uniforms;
        var uniformValue = uniforms[uniformId];
        var texture = material._textures[uniformId];
        var uniformDimensionsName;
        var uniformDimensions;
        if (uniformValue instanceof Texture && uniformValue !== texture) {
            Material._textureCache.releaseTexture(material._texturePaths[uniformId]);
            material._texturePaths[uniformId] = undefined;
            material._textures[uniformId] = uniformValue;
            uniformDimensionsName = uniformId + 'Dimensions';
            if (uniforms.hasOwnProperty(uniformDimensionsName)) {
                uniformDimensions = uniforms[uniformDimensionsName];
                uniformDimensions.x = uniformValue._width;
                uniformDimensions.y = uniformValue._height;
            }
            return;
        }
        if (!defined(texture)) {
            material._texturePaths[uniformId] = undefined;
            texture = material._textures[uniformId] = context.defaultTexture;
            uniformDimensionsName = uniformId + 'Dimensions';
            if (uniforms.hasOwnProperty(uniformDimensionsName)) {
                uniformDimensions = uniforms[uniformDimensionsName];
                uniformDimensions.x = texture._width;
                uniformDimensions.y = texture._height;
            }
        }
        if (uniformValue === Material.DefaultImageId) {
            return;
        }
        if (uniformValue !== material._texturePaths[uniformId]) {
            var newTexture = Material._textureCache.getTexture(uniformValue);
            if (defined(newTexture)) {
                Material._textureCache.releaseTexture(material._texturePaths[uniformId]);
                material._textures[uniformId] = newTexture;
            } else {
                when(loadImage(uniformValue), function (image) {
                    material._loadedImages.push({
                        id: uniformId,
                        image: image
                    });
                });
            }
            material._texturePaths[uniformId] = uniformValue;
        }
    };
}
function createCubeMapUpdateFunction(uniformId) {
    return function (material, context) {
        var uniformValue = material.uniforms[uniformId];
        if (uniformValue instanceof CubeMap) {
            Material._textureCache.releaseTexture(material._texturePaths[uniformId]);
            material._texturePaths[uniformId] = undefined;
            material._textures[uniformId] = uniformValue;
            return;
        }
        if (!defined(material._textures[uniformId])) {
            material._texturePaths[uniformId] = undefined;
            material._textures[uniformId] = context.defaultCubeMap;
        }
        if (uniformValue === Material.DefaultCubeMapId) {
            return;
        }
        var path = uniformValue.positiveX + uniformValue.negativeX + uniformValue.positiveY + uniformValue.negativeY + uniformValue.positiveZ + uniformValue.negativeZ;
        if (path !== material._texturePaths[uniformId]) {
            var newTexture = Material._textureCache.getTexture(path);
            if (defined(newTexture)) {
                Material._textureCache.releaseTexture(material._texturePaths[uniformId]);
                material._textures[uniformId] = newTexture;
            } else {
                var promises = [
                        loadImage(uniformValue.positiveX),
                        loadImage(uniformValue.negativeX),
                        loadImage(uniformValue.positiveY),
                        loadImage(uniformValue.negativeY),
                        loadImage(uniformValue.positiveZ),
                        loadImage(uniformValue.negativeZ)
                    ];
                when.all(promises).then(function (images) {
                    material._loadedCubeMaps.push({
                        id: uniformId,
                        images: images
                    });
                });
            }
            material._texturePaths[uniformId] = path;
        }
    };
}
function createUniforms(material) {
    var uniforms = material._template.uniforms;
    for (var uniformId in uniforms) {
        if (uniforms.hasOwnProperty(uniformId)) {
            createUniform(material, uniformId);
        }
    }
}
function createUniform(material, uniformId) {
    var strict = material._strict;
    var materialUniforms = material._template.uniforms;
    var uniformValue = materialUniforms[uniformId];
    var uniformType = getUniformType(uniformValue);
    if (!defined(uniformType)) {
        throw new DeveloperError('fabric: uniform \'' + uniformId + '\' has invalid type.');
    } else if (uniformType === 'channels') {
        if (replaceToken(material, uniformId, uniformValue, false) === 0 && strict) {
            throw new DeveloperError('strict: shader source does not use channels \'' + uniformId + '\'.');
        }
    } else {
        if (uniformType === 'sampler2D') {
            var imageDimensionsUniformName = uniformId + 'Dimensions';
            if (getNumberOfTokens(material, imageDimensionsUniformName) > 0) {
                materialUniforms[imageDimensionsUniformName] = {
                    type: 'ivec3',
                    x: 1,
                    y: 1
                };
                createUniform(material, imageDimensionsUniformName);
            }
        }
        var uniformDeclarationRegex = new RegExp('uniform\\s+' + uniformType + '\\s+' + uniformId + '\\s*;');
        if (!uniformDeclarationRegex.test(material.shaderSource)) {
            var uniformDeclaration = 'uniform ' + uniformType + ' ' + uniformId + ';';
            material.shaderSource = uniformDeclaration + material.shaderSource;
        }
        var newUniformId = uniformId + '_' + material._count++;
        if (replaceToken(material, uniformId, newUniformId) === 1 && strict) {
            throw new DeveloperError('strict: shader source does not use uniform \'' + uniformId + '\'.');
        }
        material.uniforms[uniformId] = uniformValue;
        if (uniformType === 'sampler2D') {
            material._uniforms[newUniformId] = function () {
                return material._textures[uniformId];
            };
            material._updateFunctions.push(createTexture2DUpdateFunction(uniformId));
        } else if (uniformType === 'samplerCube') {
            material._uniforms[newUniformId] = function () {
                return material._textures[uniformId];
            };
            material._updateFunctions.push(createCubeMapUpdateFunction(uniformId));
        } else if (uniformType.indexOf('mat') !== -1) {
            var scratchMatrix = new matrixMap[uniformType]();
            material._uniforms[newUniformId] = function () {
                return matrixMap[uniformType].fromColumnMajorArray(material.uniforms[uniformId], scratchMatrix);
            };
        } else {
            material._uniforms[newUniformId] = function () {
                return material.uniforms[uniformId];
            };
        }
    }
}
function getUniformType(uniformValue) {
    var uniformType = uniformValue.type;
    if (!defined(uniformType)) {
        var type = typeof uniformValue;
        if (type === 'number') {
            uniformType = 'float';
        } else if (type === 'boolean') {
            uniformType = 'bool';
        } else if (type === 'string') {
            if (/^([rgba]){1,4}$/i.test(uniformValue)) {
                uniformType = 'channels';
            } else if (uniformValue === Material.DefaultCubeMapId) {
                uniformType = 'samplerCube';
            } else {
                uniformType = 'sampler2D';
            }
        } else if (type === 'object') {
            if (isArray(uniformValue)) {
                if (uniformValue.length === 4 || uniformValue.length === 9 || uniformValue.length === 16) {
                    uniformType = 'mat' + Math.sqrt(uniformValue.length);
                }
            } else {
                var numAttributes = 0;
                for (var attribute in uniformValue) {
                    if (uniformValue.hasOwnProperty(attribute)) {
                        numAttributes += 1;
                    }
                }
                if (numAttributes >= 2 && numAttributes <= 4) {
                    uniformType = 'vec' + numAttributes;
                } else if (numAttributes === 6) {
                    uniformType = 'samplerCube';
                }
            }
        }
    }
    return uniformType;
}
function createSubMaterials(material) {
    var strict = material._strict;
    var subMaterialTemplates = material._template.materials;
    for (var subMaterialId in subMaterialTemplates) {
        if (subMaterialTemplates.hasOwnProperty(subMaterialId)) {
            var subMaterial = new Material({
                    strict: strict,
                    fabric: subMaterialTemplates[subMaterialId],
                    count: material._count
                });
            material._count = subMaterial._count;
            material._uniforms = combine(material._uniforms, subMaterial._uniforms, true);
            material.materials[subMaterialId] = subMaterial;
            material._translucentFunctions = material._translucentFunctions.concat(subMaterial._translucentFunctions);
            var originalMethodName = 'czm_getMaterial';
            var newMethodName = originalMethodName + '_' + material._count++;
            replaceToken(subMaterial, originalMethodName, newMethodName);
            material.shaderSource = subMaterial.shaderSource + material.shaderSource;
            var materialMethodCall = newMethodName + '(materialInput)';
            if (replaceToken(material, subMaterialId, materialMethodCall) === 0 && strict) {
                throw new DeveloperError('strict: shader source does not use material \'' + subMaterialId + '\'.');
            }
        }
    }
}
function replaceToken(material, token, newToken, excludePeriod) {
    excludePeriod = defaultValue(excludePeriod, true);
    var count = 0;
    var suffixChars = '([\\w])?';
    var prefixChars = '([\\w' + (excludePeriod ? '.' : '') + '])?';
    var regExp = new RegExp(prefixChars + token + suffixChars, 'g');
    material.shaderSource = material.shaderSource.replace(regExp, function ($0, $1, $2) {
        if ($1 || $2) {
            return $0;
        }
        count += 1;
        return newToken;
    });
    return count;
}
function getNumberOfTokens(material, token, excludePeriod) {
    return replaceToken(material, token, token, excludePeriod);
}
Material._textureCache = {
    _textures: {},
    addTexture: function (path, texture) {
        this._textures[path] = {
            texture: texture,
            count: 1
        };
    },
    getTexture: function (path) {
        var entry = this._textures[path];
        if (defined(entry)) {
            entry.count++;
            return entry.texture;
        }
        return undefined;
    },
    releaseTexture: function (path) {
        var entry = this._textures[path];
        if (defined(entry) && --entry.count === 0) {
            entry.texture = entry.texture && entry.texture.destroy();
            this._textures[path] = undefined;
        }
    }
};
Material._materialCache = {
    _materials: {},
    addMaterial: function (type, materialTemplate) {
        this._materials[type] = materialTemplate;
    },
    getMaterial: function (type) {
        return this._materials[type];
    }
};
Material.DefaultImageId = 'czm_defaultImage';
Material.DefaultCubeMapId = 'czm_defaultCubeMap';
Material.ColorType = 'Color';
Material._materialCache.addMaterial(Material.ColorType, {
    fabric: {
        type: Material.ColorType,
        uniforms: { color: new Color(1, 0, 0, 0.5) },
        components: {
            diffuse: 'color.rgb',
            alpha: 'color.a'
        }
    },
    translucent: function (material) {
        return material.uniforms.color.alpha < 1;
    }
});
Material.ImageType = 'Image';
Material._materialCache.addMaterial(Material.ImageType, {
    fabric: {
        type: Material.ImageType,
        uniforms: {
            image: Material.DefaultImageId,
            repeat: new Cartesian2(1, 1)
        },
        components: {
            diffuse: 'texture2D(image, fract(repeat * materialInput.st)).rgb',
            alpha: 'texture2D(image, fract(repeat * materialInput.st)).a'
        }
    },
    translucent: true
});
Material.DiffuseMapType = 'DiffuseMap';
Material._materialCache.addMaterial(Material.DiffuseMapType, {
    fabric: {
        type: Material.DiffuseMapType,
        uniforms: {
            image: Material.DefaultImageId,
            channels: 'rgb',
            repeat: new Cartesian2(1, 1)
        },
        components: { diffuse: 'texture2D(image, fract(repeat * materialInput.st)).channels' }
    },
    translucent: false
});
Material.AlphaMapType = 'AlphaMap';
Material._materialCache.addMaterial(Material.AlphaMapType, {
    fabric: {
        type: Material.AlphaMapType,
        uniforms: {
            image: Material.DefaultImageId,
            channel: 'a',
            repeat: new Cartesian2(1, 1)
        },
        components: { alpha: 'texture2D(image, fract(repeat * materialInput.st)).channel' }
    },
    translucent: true
});
Material.SpecularMapType = 'SpecularMap';
Material._materialCache.addMaterial(Material.SpecularMapType, {
    fabric: {
        type: Material.SpecularMapType,
        uniforms: {
            image: Material.DefaultImageId,
            channel: 'r',
            repeat: new Cartesian2(1, 1)
        },
        components: { specular: 'texture2D(image, fract(repeat * materialInput.st)).channel' }
    },
    translucent: false
});
Material.EmissionMapType = 'EmissionMap';
Material._materialCache.addMaterial(Material.EmissionMapType, {
    fabric: {
        type: Material.EmissionMapType,
        uniforms: {
            image: Material.DefaultImageId,
            channels: 'rgb',
            repeat: new Cartesian2(1, 1)
        },
        components: { emission: 'texture2D(image, fract(repeat * materialInput.st)).channels' }
    },
    translucent: false
});
Material.BumpMapType = 'BumpMap';
Material._materialCache.addMaterial(Material.BumpMapType, {
    fabric: {
        type: Material.BumpMapType,
        uniforms: {
            image: Material.DefaultImageId,
            channel: 'r',
            strength: 0.8,
            repeat: new Cartesian2(1, 1)
        },
        source: BumpMapMaterial
    },
    translucent: false
});
Material.NormalMapType = 'NormalMap';
Material._materialCache.addMaterial(Material.NormalMapType, {
    fabric: {
        type: Material.NormalMapType,
        uniforms: {
            image: Material.DefaultImageId,
            channels: 'rgb',
            strength: 0.8,
            repeat: new Cartesian2(1, 1)
        },
        source: NormalMapMaterial
    },
    translucent: false
});
Material.GridType = 'Grid';
Material._materialCache.addMaterial(Material.GridType, {
    fabric: {
        type: Material.GridType,
        uniforms: {
            color: new Color(0, 1, 0, 1),
            cellAlpha: 0.1,
            lineCount: new Cartesian2(8, 8),
            lineThickness: new Cartesian2(1, 1),
            lineOffset: new Cartesian2(0, 0)
        },
        source: GridMaterial
    },
    translucent: function (material) {
        var uniforms = material.uniforms;
        return uniforms.color.alpha < 1 || uniforms.cellAlpha < 1;
    }
});
Material.StripeType = 'Stripe';
Material._materialCache.addMaterial(Material.StripeType, {
    fabric: {
        type: Material.StripeType,
        uniforms: {
            horizontal: true,
            evenColor: new Color(1, 1, 1, 0.5),
            oddColor: new Color(0, 0, 1, 0.5),
            offset: 0,
            repeat: 5
        },
        source: StripeMaterial
    },
    translucent: function (material) {
        var uniforms = material.uniforms;
        return uniforms.evenColor.alpha < 1 || uniforms.oddColor.alpha < 0;
    }
});
Material.CheckerboardType = 'Checkerboard';
Material._materialCache.addMaterial(Material.CheckerboardType, {
    fabric: {
        type: Material.CheckerboardType,
        uniforms: {
            lightColor: new Color(1, 1, 1, 0.5),
            darkColor: new Color(0, 0, 0, 0.5),
            repeat: new Cartesian2(5, 5)
        },
        source: CheckerboardMaterial
    },
    translucent: function (material) {
        var uniforms = material.uniforms;
        return uniforms.lightColor.alpha < 1 || uniforms.darkColor.alpha < 0;
    }
});
Material.DotType = 'Dot';
Material._materialCache.addMaterial(Material.DotType, {
    fabric: {
        type: Material.DotType,
        uniforms: {
            lightColor: new Color(1, 1, 0, 0.75),
            darkColor: new Color(0, 1, 1, 0.75),
            repeat: new Cartesian2(5, 5)
        },
        source: DotMaterial
    },
    translucent: function (material) {
        var uniforms = material.uniforms;
        return uniforms.lightColor.alpha < 1 || uniforms.darkColor.alpha < 0;
    }
});
Material.WaterType = 'Water';
Material._materialCache.addMaterial(Material.WaterType, {
    fabric: {
        type: Material.WaterType,
        uniforms: {
            baseWaterColor: new Color(0.2, 0.3, 0.6, 1),
            blendColor: new Color(0, 1, 0.699, 1),
            specularMap: Material.DefaultImageId,
            normalMap: Material.DefaultImageId,
            frequency: 10,
            animationSpeed: 0.01,
            amplitude: 1,
            specularIntensity: 0.5,
            fadeFactor: 1
        },
        source: WaterMaterial
    },
    translucent: function (material) {
        var uniforms = material.uniforms;
        return uniforms.baseWaterColor.alpha < 1 || uniforms.blendColor.alpha < 0;
    }
});
Material.RimLightingType = 'RimLighting';
Material._materialCache.addMaterial(Material.RimLightingType, {
    fabric: {
        type: Material.RimLightingType,
        uniforms: {
            color: new Color(1, 0, 0, 0.7),
            rimColor: new Color(1, 1, 1, 0.4),
            width: 0.3
        },
        source: RimLightingMaterial
    },
    translucent: function (material) {
        var uniforms = material.uniforms;
        return uniforms.color.alpha < 1 || uniforms.rimColor.alpha < 0;
    }
});
Material.FadeType = 'Fade';
Material._materialCache.addMaterial(Material.FadeType, {
    fabric: {
        type: Material.FadeType,
        uniforms: {
            fadeInColor: new Color(1, 0, 0, 1),
            fadeOutColor: new Color(0, 0, 0, 0),
            maximumDistance: 0.5,
            repeat: true,
            fadeDirection: {
                x: true,
                y: true
            },
            time: new Cartesian2(0.5, 0.5)
        },
        source: FadeMaterial
    },
    translucent: function (material) {
        var uniforms = material.uniforms;
        return uniforms.fadeInColor.alpha < 1 || uniforms.fadeOutColor.alpha < 0;
    }
});
Material.PolylineArrowType = 'PolylineArrow';
Material._materialCache.addMaterial(Material.PolylineArrowType, {
    fabric: {
        type: Material.PolylineArrowType,
        uniforms: { color: new Color(1, 1, 1, 1) },
        source: PolylineArrowMaterial
    },
    translucent: true
});
Material.PolylineGlowType = 'PolylineGlow';
Material._materialCache.addMaterial(Material.PolylineGlowType, {
    fabric: {
        type: Material.PolylineGlowType,
        uniforms: {
            color: new Color(0, 0.5, 1, 1),
            glowPower: 0.25
        },
        source: PolylineGlowMaterial
    },
    translucent: true
});
Material.PolylineOutlineType = 'PolylineOutline';
Material._materialCache.addMaterial(Material.PolylineOutlineType, {
    fabric: {
        type: Material.PolylineOutlineType,
        uniforms: {
            color: new Color(1, 1, 1, 1),
            outlineColor: new Color(1, 0, 0, 1),
            outlineWidth: 1
        },
        source: PolylineOutlineMaterial
    },
    translucent: function (material) {
        var uniforms = material.uniforms;
        return uniforms.color.alpha < 1 || uniforms.outlineColor.alpha < 1;
    }
});
module.exports = Material;
},{"../Core/Cartesian2":101,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Matrix2":175,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/clone":240,"../Core/combine":241,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Core/isArray":253,"../Core/loadImage":259,"../Renderer/CubeMap":342,"../Renderer/Texture":356,"../Shaders/Materials/BumpMapMaterial":556,"../Shaders/Materials/CheckerboardMaterial":557,"../Shaders/Materials/DotMaterial":558,"../Shaders/Materials/FadeMaterial":559,"../Shaders/Materials/GridMaterial":560,"../Shaders/Materials/NormalMapMaterial":561,"../Shaders/Materials/PolylineArrowMaterial":562,"../Shaders/Materials/PolylineGlowMaterial":563,"../Shaders/Materials/PolylineOutlineMaterial":564,"../Shaders/Materials/RimLightingMaterial":565,"../Shaders/Materials/StripeMaterial":566,"../Shaders/Materials/Water":567,"../ThirdParty/when":596}],405:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), freezeObject = require('../Core/freezeObject'), VertexFormat = require('../Core/VertexFormat'), AllMaterialAppearanceFS = require('../Shaders/Appearances/AllMaterialAppearanceFS'), AllMaterialAppearanceVS = require('../Shaders/Appearances/AllMaterialAppearanceVS'), BasicMaterialAppearanceFS = require('../Shaders/Appearances/BasicMaterialAppearanceFS'), BasicMaterialAppearanceVS = require('../Shaders/Appearances/BasicMaterialAppearanceVS'), TexturedMaterialAppearanceFS = require('../Shaders/Appearances/TexturedMaterialAppearanceFS'), TexturedMaterialAppearanceVS = require('../Shaders/Appearances/TexturedMaterialAppearanceVS'), Appearance = require('./Appearance'), Material = require('./Material');
'use strict';
var MaterialAppearance = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var translucent = defaultValue(options.translucent, true);
    var closed = defaultValue(options.closed, false);
    var materialSupport = defaultValue(options.materialSupport, MaterialAppearance.MaterialSupport.TEXTURED);
    this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
    this.translucent = translucent;
    this._vertexShaderSource = defaultValue(options.vertexShaderSource, materialSupport.vertexShaderSource);
    this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, materialSupport.fragmentShaderSource);
    this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);
    this._closed = closed;
    this._materialSupport = materialSupport;
    this._vertexFormat = materialSupport.vertexFormat;
    this._flat = defaultValue(options.flat, false);
    this._faceForward = defaultValue(options.faceForward, !closed);
};
defineProperties(MaterialAppearance.prototype, {
    vertexShaderSource: {
        get: function () {
            return this._vertexShaderSource;
        }
    },
    fragmentShaderSource: {
        get: function () {
            return this._fragmentShaderSource;
        }
    },
    renderState: {
        get: function () {
            return this._renderState;
        }
    },
    closed: {
        get: function () {
            return this._closed;
        }
    },
    materialSupport: {
        get: function () {
            return this._materialSupport;
        }
    },
    vertexFormat: {
        get: function () {
            return this._vertexFormat;
        }
    },
    flat: {
        get: function () {
            return this._flat;
        }
    },
    faceForward: {
        get: function () {
            return this._faceForward;
        }
    }
});
MaterialAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;
MaterialAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;
MaterialAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;
MaterialAppearance.MaterialSupport = {
    BASIC: freezeObject({
        vertexFormat: VertexFormat.POSITION_AND_NORMAL,
        vertexShaderSource: BasicMaterialAppearanceVS,
        fragmentShaderSource: BasicMaterialAppearanceFS
    }),
    TEXTURED: freezeObject({
        vertexFormat: VertexFormat.POSITION_NORMAL_AND_ST,
        vertexShaderSource: TexturedMaterialAppearanceVS,
        fragmentShaderSource: TexturedMaterialAppearanceFS
    }),
    ALL: freezeObject({
        vertexFormat: VertexFormat.ALL,
        vertexShaderSource: AllMaterialAppearanceVS,
        fragmentShaderSource: AllMaterialAppearanceFS
    })
};
module.exports = MaterialAppearance;
},{"../Core/VertexFormat":228,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/freezeObject":249,"../Shaders/Appearances/AllMaterialAppearanceFS":459,"../Shaders/Appearances/AllMaterialAppearanceVS":460,"../Shaders/Appearances/BasicMaterialAppearanceFS":461,"../Shaders/Appearances/BasicMaterialAppearanceVS":462,"../Shaders/Appearances/TexturedMaterialAppearanceFS":471,"../Shaders/Appearances/TexturedMaterialAppearanceVS":472,"./Appearance":366,"./Material":404}],406:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), clone = require('../Core/clone'), combine = require('../Core/combine'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), deprecationWarning = require('../Core/deprecationWarning'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), IndexDatatype = require('../Core/IndexDatatype'), loadArrayBuffer = require('../Core/loadArrayBuffer'), loadImage = require('../Core/loadImage'), loadText = require('../Core/loadText'), CesiumMath = require('../Core/Math'), Matrix2 = require('../Core/Matrix2'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), PrimitiveType = require('../Core/PrimitiveType'), Quaternion = require('../Core/Quaternion'), Queue = require('../Core/Queue'), RuntimeError = require('../Core/RuntimeError'), BufferUsage = require('../Renderer/BufferUsage'), DrawCommand = require('../Renderer/DrawCommand'), ShaderSource = require('../Renderer/ShaderSource'), TextureMinificationFilter = require('../Renderer/TextureMinificationFilter'), TextureWrap = require('../Renderer/TextureWrap'), gltfDefaults = require('../ThirdParty/gltfDefaults'), Uri = require('../ThirdParty/Uri'), when = require('../ThirdParty/when'), getModelAccessor = require('./getModelAccessor'), ModelAnimationCache = require('./ModelAnimationCache'), ModelAnimationCollection = require('./ModelAnimationCollection'), ModelMaterial = require('./ModelMaterial'), ModelMesh = require('./ModelMesh'), ModelNode = require('./ModelNode'), Pass = require('./Pass'), SceneMode = require('./SceneMode');
'use strict';
var yUpToZUp = Matrix4.fromRotationTranslation(Matrix3.fromRotationX(CesiumMath.PI_OVER_TWO));
var ModelState = {
        NEEDS_LOAD: 0,
        LOADING: 1,
        LOADED: 2,
        FAILED: 3
    };
function LoadResources() {
    this.buffersToCreate = new Queue();
    this.buffers = {};
    this.pendingBufferLoads = 0;
    this.programsToCreate = new Queue();
    this.shaders = {};
    this.pendingShaderLoads = 0;
    this.texturesToCreate = new Queue();
    this.pendingTextureLoads = 0;
    this.createSamplers = true;
    this.createSkins = true;
    this.createRuntimeAnimations = true;
    this.createVertexArrays = true;
    this.createRenderStates = true;
    this.createUniformMaps = true;
    this.createRuntimeNodes = true;
    this.skinnedNodesNames = [];
}
LoadResources.prototype.finishedPendingLoads = function () {
    return this.pendingBufferLoads === 0 && this.pendingShaderLoads === 0 && this.pendingTextureLoads === 0;
};
LoadResources.prototype.finishedResourceCreation = function () {
    return this.buffersToCreate.length === 0 && this.programsToCreate.length === 0 && this.texturesToCreate.length === 0;
};
LoadResources.prototype.finishedBuffersCreation = function () {
    return this.pendingBufferLoads === 0 && this.buffersToCreate.length === 0;
};
LoadResources.prototype.finishedProgramCreation = function () {
    return this.pendingShaderLoads === 0 && this.programsToCreate.length === 0;
};
LoadResources.prototype.finishedTextureCreation = function () {
    return this.pendingTextureLoads === 0 && this.texturesToCreate.length === 0;
};
var CachedGltf = function (options) {
    this._gltf = gltfDefaults(options.gltf);
    this.ready = options.ready;
    this.modelsToLoad = [];
    this.count = 0;
};
defineProperties(CachedGltf.prototype, {
    gltf: {
        set: function (value) {
            this._gltf = gltfDefaults(value);
        },
        get: function () {
            return this._gltf;
        }
    }
});
var gltfCache = {};
function getAnimationIds(cachedGltf) {
    var animationIds = [];
    if (defined(cachedGltf) && defined(cachedGltf.gltf)) {
        var animations = cachedGltf.gltf.animations;
        for (var name in animations) {
            if (animations.hasOwnProperty(name)) {
                animationIds.push(name);
            }
        }
    }
    return animationIds;
}
var Model = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var cacheKey = options.cacheKey;
    this._cacheKey = cacheKey;
    this._cachedGltf = undefined;
    this._releaseGltfJson = defaultValue(options.releaseGltfJson, false);
    this._animationIds = undefined;
    var cachedGltf;
    if (defined(cacheKey) && defined(gltfCache[cacheKey]) && gltfCache[cacheKey].ready) {
        cachedGltf = gltfCache[cacheKey];
        ++cachedGltf.count;
    } else {
        if (defined(options.gltf)) {
            cachedGltf = new CachedGltf({
                gltf: options.gltf,
                ready: true
            });
            cachedGltf.count = 1;
            if (defined(cacheKey)) {
                gltfCache[cacheKey] = cachedGltf;
            }
        }
    }
    setCachedGltf(this, cachedGltf);
    this._basePath = defaultValue(options.basePath, '');
    var docUri = new Uri(document.location.href);
    var modelUri = new Uri(this._basePath);
    this._baseUri = modelUri.resolve(docUri);
    this.show = defaultValue(options.show, true);
    this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));
    this._modelMatrix = Matrix4.clone(this.modelMatrix);
    this.scale = defaultValue(options.scale, 1);
    this._scale = this.scale;
    this.minimumPixelSize = defaultValue(options.minimumPixelSize, 0);
    this._minimumPixelSize = this.minimumPixelSize;
    this.id = options.id;
    this._id = options.id;
    this.pickPrimitive = options.pickPrimitive;
    this._allowPicking = defaultValue(options.allowPicking, true);
    this._readyToRender = new Event();
    this._ready = false;
    this._readyPromise = when.defer();
    this.activeAnimations = new ModelAnimationCollection(this);
    this._asynchronous = defaultValue(options.asynchronous, true);
    this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);
    this._debugShowBoudingVolume = false;
    this.debugWireframe = defaultValue(options.debugWireframe, false);
    this._debugWireframe = false;
    this._computedModelMatrix = new Matrix4();
    this._initialRadius = undefined;
    this._boundingSphere = undefined;
    this._state = ModelState.NEEDS_LOAD;
    this._loadError = undefined;
    this._loadResources = undefined;
    this._perNodeShowDirty = false;
    this._cesiumAnimationsDirty = false;
    this._maxDirtyNumber = 0;
    this._runtime = {
        animations: undefined,
        rootNodes: undefined,
        nodes: undefined,
        nodesByName: undefined,
        skinnedNodes: undefined,
        meshesByName: undefined,
        materialsByName: undefined,
        materialsById: undefined
    };
    this._uniformMaps = {};
    this._rendererResources = {
        buffers: {},
        vertexArrays: {},
        programs: {},
        pickPrograms: {},
        textures: {},
        samplers: {},
        renderStates: {}
    };
    this._cachedRendererResources = undefined;
    this._loadRendererResourcesFromCache = false;
    this._nodeCommands = [];
    this._pickIds = [];
};
function setCachedGltf(model, cachedGltf) {
    model._cachedGltf = cachedGltf;
    model._animationIds = getAnimationIds(cachedGltf);
}
defineProperties(Model.prototype, {
    gltf: {
        get: function () {
            return defined(this._cachedGltf) ? this._cachedGltf.gltf : undefined;
        }
    },
    releaseGltfJson: {
        get: function () {
            return this._releaseGltfJson;
        }
    },
    cacheKey: {
        get: function () {
            return this._cacheKey;
        }
    },
    basePath: {
        get: function () {
            return this._basePath;
        }
    },
    boundingSphere: {
        get: function () {
            if (this._state !== ModelState.LOADED) {
                throw new DeveloperError('The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.');
            }
            this._boundingSphere.radius = this.scale * Matrix4.getMaximumScale(this.modelMatrix) * this._initialRadius;
            return this._boundingSphere;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    readyToRender: {
        get: function () {
            deprecationWarning('Model.readyToRender', 'Model.readyToRender was deprecated in Cesium 1.6 and will be removed in Cesium 1.9.  Use Model.readyPromise instead.');
            return this._readyToRender;
        }
    },
    readyPromise: {
        get: function () {
            return this._readyPromise;
        }
    },
    asynchronous: {
        get: function () {
            return this._asynchronous;
        }
    },
    allowPicking: {
        get: function () {
            return this._allowPicking;
        }
    }
});
Model.fromGltf = function (options) {
    if (!defined(options) || !defined(options.url)) {
        throw new DeveloperError('options.url is required');
    }
    var url = options.url;
    var basePath = '';
    var i = url.lastIndexOf('/');
    if (i !== -1) {
        basePath = url.substring(0, i + 1);
    }
    var cacheKey = options.cacheKey;
    if (!defined(cacheKey)) {
        var docUri = new Uri(document.location.href);
        var modelUri = new Uri(url);
        cacheKey = modelUri.resolve(docUri).toString();
    }
    options = clone(options);
    options.basePath = basePath;
    options.cacheKey = cacheKey;
    var model = new Model(options);
    var cachedGltf = gltfCache[cacheKey];
    if (!defined(cachedGltf)) {
        cachedGltf = new CachedGltf({ ready: false });
        cachedGltf.count = 1;
        cachedGltf.modelsToLoad.push(model);
        setCachedGltf(model, cachedGltf);
        gltfCache[cacheKey] = cachedGltf;
        loadText(url, options.headers).then(function (data) {
            cachedGltf.gltf = JSON.parse(data);
            var models = cachedGltf.modelsToLoad;
            var length = models.length;
            for (var i = 0; i < length; ++i) {
                var m = models[i];
                if (!m.isDestroyed()) {
                    setCachedGltf(m, cachedGltf);
                }
            }
            cachedGltf.modelsToLoad = undefined;
            cachedGltf.ready = true;
        }).otherwise(getFailedLoadFunction(model, 'gltf', url));
    } else if (!cachedGltf.ready) {
        ++cachedGltf.count;
        cachedGltf.modelsToLoad.push(model);
    }
    return model;
};
Model._gltfCache = gltfCache;
function getRuntime(model, runtimeName, name) {
    if (model._state !== ModelState.LOADED) {
        throw new DeveloperError('The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.');
    }
    if (!defined(name)) {
        throw new DeveloperError('name is required.');
    }
    return model._runtime[runtimeName][name];
}
Model.prototype.getNode = function (name) {
    var node = getRuntime(this, 'nodesByName', name);
    return defined(node) ? node.publicNode : undefined;
};
Model.prototype.getMesh = function (name) {
    return getRuntime(this, 'meshesByName', name);
};
Model.prototype.getMaterial = function (name) {
    return getRuntime(this, 'materialsByName', name);
};
var aMinScratch = new Cartesian3();
var aMaxScratch = new Cartesian3();
function computeBoundingSphere(gltf) {
    var gltfNodes = gltf.nodes;
    var gltfMeshes = gltf.meshes;
    var gltfAccessors = gltf.accessors;
    var rootNodes = gltf.scenes[gltf.scene].nodes;
    var rootNodesLength = rootNodes.length;
    var nodeStack = [];
    var min = new Cartesian3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    var max = new Cartesian3(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
    for (var i = 0; i < rootNodesLength; ++i) {
        var n = gltfNodes[rootNodes[i]];
        n._transformToRoot = getTransform(n);
        nodeStack.push(n);
        while (nodeStack.length > 0) {
            n = nodeStack.pop();
            var transformToRoot = n._transformToRoot;
            var meshes = defaultValue(n.meshes, defined(n.instanceSkin) ? n.instanceSkin.meshes : undefined);
            if (defined(meshes)) {
                var meshesLength = meshes.length;
                for (var j = 0; j < meshesLength; ++j) {
                    var primitives = gltfMeshes[meshes[j]].primitives;
                    var primitivesLength = primitives.length;
                    for (var m = 0; m < primitivesLength; ++m) {
                        var position = primitives[m].attributes.POSITION;
                        if (defined(position)) {
                            var accessor = gltfAccessors[position];
                            var aMin = Cartesian3.fromArray(accessor.min, 0, aMinScratch);
                            var aMax = Cartesian3.fromArray(accessor.max, 0, aMaxScratch);
                            if (defined(min) && defined(max)) {
                                Matrix4.multiplyByPoint(transformToRoot, aMin, aMin);
                                Matrix4.multiplyByPoint(transformToRoot, aMax, aMax);
                                Cartesian3.minimumByComponent(min, aMin, min);
                                Cartesian3.maximumByComponent(max, aMax, max);
                            }
                        }
                    }
                }
            }
            var children = n.children;
            var childrenLength = children.length;
            for (var k = 0; k < childrenLength; ++k) {
                var child = gltfNodes[children[k]];
                child._transformToRoot = getTransform(child);
                Matrix4.multiplyTransformation(transformToRoot, child._transformToRoot, child._transformToRoot);
                nodeStack.push(child);
            }
            delete n._transformToRoot;
        }
    }
    var boundingSphere = BoundingSphere.fromCornerPoints(min, max);
    return BoundingSphere.transformWithoutScale(boundingSphere, yUpToZUp, boundingSphere);
}
function getFailedLoadFunction(model, type, path) {
    return function () {
        model._loadError = new RuntimeError('Failed to load external ' + type + ': ' + path);
        model._state = ModelState.FAILED;
    };
}
function bufferLoad(model, name) {
    return function (arrayBuffer) {
        var loadResources = model._loadResources;
        loadResources.buffers[name] = arrayBuffer;
        --loadResources.pendingBufferLoads;
    };
}
function parseBuffers(model) {
    var buffers = model.gltf.buffers;
    for (var name in buffers) {
        if (buffers.hasOwnProperty(name)) {
            ++model._loadResources.pendingBufferLoads;
            var buffer = buffers[name];
            var uri = new Uri(buffer.uri);
            var bufferPath = uri.resolve(model._baseUri).toString();
            loadArrayBuffer(bufferPath).then(bufferLoad(model, name)).otherwise(getFailedLoadFunction(model, 'buffer', bufferPath));
        }
    }
}
function parseBufferViews(model) {
    var bufferViews = model.gltf.bufferViews;
    for (var name in bufferViews) {
        if (bufferViews.hasOwnProperty(name)) {
            model._loadResources.buffersToCreate.enqueue(name);
        }
    }
}
function shaderLoad(model, name) {
    return function (source) {
        var loadResources = model._loadResources;
        loadResources.shaders[name] = source;
        --loadResources.pendingShaderLoads;
    };
}
function parseShaders(model) {
    var shaders = model.gltf.shaders;
    for (var name in shaders) {
        if (shaders.hasOwnProperty(name)) {
            ++model._loadResources.pendingShaderLoads;
            var shader = shaders[name];
            var uri = new Uri(shader.uri);
            var shaderPath = uri.resolve(model._baseUri).toString();
            loadText(shaderPath).then(shaderLoad(model, name)).otherwise(getFailedLoadFunction(model, 'shader', shaderPath));
        }
    }
}
function parsePrograms(model) {
    var programs = model.gltf.programs;
    for (var name in programs) {
        if (programs.hasOwnProperty(name)) {
            model._loadResources.programsToCreate.enqueue(name);
        }
    }
}
function imageLoad(model, name) {
    return function (image) {
        var loadResources = model._loadResources;
        --loadResources.pendingTextureLoads;
        loadResources.texturesToCreate.enqueue({
            name: name,
            image: image
        });
    };
}
function parseTextures(model) {
    var images = model.gltf.images;
    var textures = model.gltf.textures;
    for (var name in textures) {
        if (textures.hasOwnProperty(name)) {
            ++model._loadResources.pendingTextureLoads;
            var texture = textures[name];
            var uri = new Uri(images[texture.source].uri);
            var imagePath = uri.resolve(model._baseUri).toString();
            loadImage(imagePath).then(imageLoad(model, name)).otherwise(getFailedLoadFunction(model, 'image', imagePath));
        }
    }
}
var nodeAxisScratch = new Cartesian3();
var nodeTranslationScratch = new Cartesian3();
var nodeQuaternionScratch = new Quaternion();
var nodeScaleScratch = new Cartesian3();
function getTransform(node) {
    if (defined(node.matrix)) {
        return Matrix4.fromArray(node.matrix);
    }
    var axis = Cartesian3.fromArray(node.rotation, 0, nodeAxisScratch);
    return Matrix4.fromTranslationQuaternionRotationScale(Cartesian3.fromArray(node.translation, 0, nodeTranslationScratch), Quaternion.fromAxisAngle(axis, node.rotation[3], nodeQuaternionScratch), Cartesian3.fromArray(node.scale, 0, nodeScaleScratch));
}
function parseNodes(model) {
    var runtimeNodes = {};
    var runtimeNodesByName = {};
    var skinnedNodes = [];
    var skinnedNodesNames = model._loadResources.skinnedNodesNames;
    var nodes = model.gltf.nodes;
    for (var name in nodes) {
        if (nodes.hasOwnProperty(name)) {
            var node = nodes[name];
            var runtimeNode = {
                    matrix: undefined,
                    translation: undefined,
                    rotation: undefined,
                    scale: undefined,
                    computedShow: true,
                    transformToRoot: new Matrix4(),
                    computedMatrix: new Matrix4(),
                    dirtyNumber: 0,
                    commands: [],
                    inverseBindMatrices: undefined,
                    bindShapeMatrix: undefined,
                    joints: [],
                    computedJointMatrices: [],
                    jointName: node.jointName,
                    children: [],
                    parents: [],
                    publicNode: undefined
                };
            runtimeNode.publicNode = new ModelNode(model, node, runtimeNode, name, getTransform(node));
            runtimeNodes[name] = runtimeNode;
            runtimeNodesByName[node.name] = runtimeNode;
            if (defined(node.instanceSkin)) {
                skinnedNodesNames.push(name);
                skinnedNodes.push(runtimeNode);
            }
        }
    }
    model._runtime.nodes = runtimeNodes;
    model._runtime.nodesByName = runtimeNodesByName;
    model._runtime.skinnedNodes = skinnedNodes;
}
function parseMaterials(model) {
    var runtimeMaterials = {};
    var runtimeMaterialsById = {};
    var materials = model.gltf.materials;
    var uniformMaps = model._uniformMaps;
    for (var name in materials) {
        if (materials.hasOwnProperty(name)) {
            uniformMaps[name] = {
                uniformMap: undefined,
                values: undefined,
                jointMatrixUniformName: undefined
            };
            var material = materials[name];
            var modelMaterial = new ModelMaterial(model, material, name);
            runtimeMaterials[material.name] = modelMaterial;
            runtimeMaterialsById[name] = modelMaterial;
        }
    }
    model._runtime.materialsByName = runtimeMaterials;
    model._runtime.materialsById = runtimeMaterialsById;
}
function parseMeshes(model) {
    var runtimeMeshes = {};
    var runtimeMaterialsById = model._runtime.materialsById;
    var meshes = model.gltf.meshes;
    for (var name in meshes) {
        if (meshes.hasOwnProperty(name)) {
            var mesh = meshes[name];
            runtimeMeshes[mesh.name] = new ModelMesh(mesh, runtimeMaterialsById, name);
        }
    }
    model._runtime.meshesByName = runtimeMeshes;
}
function parse(model) {
    if (!model._loadRendererResourcesFromCache) {
        parseBuffers(model);
        parseBufferViews(model);
        parseShaders(model);
        parsePrograms(model);
        parseTextures(model);
    }
    parseMaterials(model);
    parseMeshes(model);
    parseNodes(model);
}
function createBuffers(model, context) {
    var loadResources = model._loadResources;
    if (loadResources.pendingBufferLoads !== 0) {
        return;
    }
    var raw;
    var bufferView;
    var bufferViews = model.gltf.bufferViews;
    var buffers = loadResources.buffers;
    var rendererBuffers = model._rendererResources.buffers;
    while (loadResources.buffersToCreate.length > 0) {
        var bufferViewName = loadResources.buffersToCreate.dequeue();
        bufferView = bufferViews[bufferViewName];
        if (bufferView.target === WebGLRenderingContext.ARRAY_BUFFER) {
            raw = new Uint8Array(buffers[bufferView.buffer], bufferView.byteOffset, bufferView.byteLength);
            var vertexBuffer = context.createVertexBuffer(raw, BufferUsage.STATIC_DRAW);
            vertexBuffer.vertexArrayDestroyable = false;
            rendererBuffers[bufferViewName] = vertexBuffer;
        }
    }
    var accessors = model.gltf.accessors;
    for (var name in accessors) {
        if (accessors.hasOwnProperty(name)) {
            var accessor = accessors[name];
            bufferView = bufferViews[accessor.bufferView];
            if (bufferView.target === WebGLRenderingContext.ELEMENT_ARRAY_BUFFER && !defined(rendererBuffers[accessor.bufferView])) {
                raw = new Uint8Array(buffers[bufferView.buffer], bufferView.byteOffset, bufferView.byteLength);
                var indexBuffer = context.createIndexBuffer(raw, BufferUsage.STATIC_DRAW, accessor.componentType);
                indexBuffer.vertexArrayDestroyable = false;
                rendererBuffers[accessor.bufferView] = indexBuffer;
            }
        }
    }
}
function createAttributeLocations(attributes) {
    var attributeLocations = {};
    var length = attributes.length;
    for (var i = 0; i < length; ++i) {
        attributeLocations[attributes[i]] = i;
    }
    return attributeLocations;
}
function createProgram(name, model, context) {
    var programs = model.gltf.programs;
    var shaders = model._loadResources.shaders;
    var program = programs[name];
    var attributeLocations = createAttributeLocations(program.attributes);
    var vs = shaders[program.vertexShader];
    var fs = shaders[program.fragmentShader];
    model._rendererResources.programs[name] = context.createShaderProgram(vs, fs, attributeLocations);
    if (model.allowPicking) {
        var pickFS = new ShaderSource({
                sources: [fs],
                pickColorQualifier: 'uniform'
            });
        model._rendererResources.pickPrograms[name] = context.createShaderProgram(vs, pickFS, attributeLocations);
    }
}
function createPrograms(model, context) {
    var loadResources = model._loadResources;
    var name;
    if (loadResources.pendingShaderLoads !== 0) {
        return;
    }
    if (model.asynchronous) {
        if (loadResources.programsToCreate.length > 0) {
            name = loadResources.programsToCreate.dequeue();
            createProgram(name, model, context);
        }
    } else {
        while (loadResources.programsToCreate.length > 0) {
            name = loadResources.programsToCreate.dequeue();
            createProgram(name, model, context);
        }
    }
}
function createSamplers(model, context) {
    var loadResources = model._loadResources;
    if (loadResources.createSamplers) {
        loadResources.createSamplers = false;
        var rendererSamplers = model._rendererResources.samplers;
        var samplers = model.gltf.samplers;
        for (var name in samplers) {
            if (samplers.hasOwnProperty(name)) {
                var sampler = samplers[name];
                rendererSamplers[name] = context.createSampler({
                    wrapS: sampler.wrapS,
                    wrapT: sampler.wrapT,
                    minificationFilter: sampler.minFilter,
                    magnificationFilter: sampler.magFilter
                });
            }
        }
    }
}
function createTexture(gltfTexture, model, context) {
    var textures = model.gltf.textures;
    var texture = textures[gltfTexture.name];
    var rendererSamplers = model._rendererResources.samplers;
    var sampler = rendererSamplers[texture.sampler];
    var mipmap = sampler.minificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || sampler.minificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || sampler.minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || sampler.minificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR;
    var requiresNpot = mipmap || sampler.wrapS === TextureWrap.REPEAT || sampler.wrapS === TextureWrap.MIRRORED_REPEAT || sampler.wrapT === TextureWrap.REPEAT || sampler.wrapT === TextureWrap.MIRRORED_REPEAT;
    var source = gltfTexture.image;
    var npot = !CesiumMath.isPowerOfTwo(source.width) || !CesiumMath.isPowerOfTwo(source.height);
    if (requiresNpot && npot) {
        var canvas = document.createElement('canvas');
        canvas.width = CesiumMath.nextPowerOfTwo(source.width);
        canvas.height = CesiumMath.nextPowerOfTwo(source.height);
        var canvasContext = canvas.getContext('2d');
        canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
        source = canvas;
    }
    var tx;
    if (texture.target === WebGLRenderingContext.TEXTURE_2D) {
        tx = context.createTexture2D({
            source: source,
            pixelFormat: texture.internalFormat,
            pixelDatatype: texture.type,
            flipY: false
        });
    }
    if (mipmap) {
        tx.generateMipmap();
    }
    tx.sampler = sampler;
    model._rendererResources.textures[gltfTexture.name] = tx;
}
function createTextures(model, context) {
    var loadResources = model._loadResources;
    var gltfTexture;
    if (model.asynchronous) {
        if (loadResources.texturesToCreate.length > 0) {
            gltfTexture = loadResources.texturesToCreate.dequeue();
            createTexture(gltfTexture, model, context);
        }
    } else {
        while (loadResources.texturesToCreate.length > 0) {
            gltfTexture = loadResources.texturesToCreate.dequeue();
            createTexture(gltfTexture, model, context);
        }
    }
}
function getAttributeLocations(model, primitive) {
    var gltf = model.gltf;
    var programs = gltf.programs;
    var techniques = gltf.techniques;
    var materials = gltf.materials;
    var attributeLocations = {};
    var technique = techniques[materials[primitive.material].instanceTechnique.technique];
    var parameters = technique.parameters;
    var pass = technique.passes[technique.pass];
    var instanceProgram = pass.instanceProgram;
    var attributes = instanceProgram.attributes;
    var programAttributeLocations = model._rendererResources.programs[instanceProgram.program].vertexAttributes;
    for (var location in programAttributeLocations) {
        if (programAttributeLocations.hasOwnProperty(location)) {
            var parameter = parameters[attributes[location]];
            attributeLocations[parameter.semantic] = programAttributeLocations[location].index;
        }
    }
    return attributeLocations;
}
function searchForest(forest, jointName) {
    var length = forest.length;
    for (var i = 0; i < length; ++i) {
        var stack = [forest[i]];
        while (stack.length > 0) {
            var n = stack.pop();
            if (n.jointName === jointName) {
                return n;
            }
            var children = n.children;
            var childrenLength = children.length;
            for (var k = 0; k < childrenLength; ++k) {
                stack.push(children[k]);
            }
        }
    }
    return undefined;
}
function createJoints(model, runtimeSkins) {
    var gltf = model.gltf;
    var skins = gltf.skins;
    var nodes = gltf.nodes;
    var runtimeNodes = model._runtime.nodes;
    var skinnedNodesNames = model._loadResources.skinnedNodesNames;
    var length = skinnedNodesNames.length;
    for (var j = 0; j < length; ++j) {
        var name = skinnedNodesNames[j];
        var skinnedNode = runtimeNodes[name];
        var instanceSkin = nodes[name].instanceSkin;
        var runtimeSkin = runtimeSkins[instanceSkin.skin];
        skinnedNode.inverseBindMatrices = runtimeSkin.inverseBindMatrices;
        skinnedNode.bindShapeMatrix = runtimeSkin.bindShapeMatrix;
        var forest = [];
        var gltfSkeletons = instanceSkin.skeletons;
        var skeletonsLength = gltfSkeletons.length;
        for (var k = 0; k < skeletonsLength; ++k) {
            forest.push(runtimeNodes[gltfSkeletons[k]]);
        }
        var gltfJointNames = skins[instanceSkin.skin].jointNames;
        var jointNamesLength = gltfJointNames.length;
        for (var i = 0; i < jointNamesLength; ++i) {
            var jointName = gltfJointNames[i];
            skinnedNode.joints.push(searchForest(forest, jointName));
        }
    }
}
function createSkins(model) {
    var loadResources = model._loadResources;
    if (!loadResources.finishedBuffersCreation()) {
        return;
    }
    if (!loadResources.createSkins) {
        return;
    }
    loadResources.createSkins = false;
    var gltf = model.gltf;
    var accessors = gltf.accessors;
    var skins = gltf.skins;
    var runtimeSkins = {};
    for (var name in skins) {
        if (skins.hasOwnProperty(name)) {
            var skin = skins[name];
            var accessor = accessors[skin.inverseBindMatrices];
            var bindShapeMatrix;
            if (!Matrix4.equals(skin.bindShapeMatrix, Matrix4.IDENTITY)) {
                bindShapeMatrix = Matrix4.clone(skin.bindShapeMatrix);
            }
            runtimeSkins[name] = {
                inverseBindMatrices: ModelAnimationCache.getSkinInverseBindMatrices(model, accessor),
                bindShapeMatrix: bindShapeMatrix
            };
        }
    }
    createJoints(model, runtimeSkins);
}
function getChannelEvaluator(model, runtimeNode, targetPath, spline) {
    return function (localAnimationTime) {
        runtimeNode[targetPath] = spline.evaluate(localAnimationTime, runtimeNode[targetPath]);
        runtimeNode.dirtyNumber = model._maxDirtyNumber;
    };
}
function createRuntimeAnimations(model) {
    var loadResources = model._loadResources;
    if (!loadResources.finishedPendingLoads()) {
        return;
    }
    if (!loadResources.createRuntimeAnimations) {
        return;
    }
    loadResources.createRuntimeAnimations = false;
    model._runtime.animations = {};
    var runtimeNodes = model._runtime.nodes;
    var animations = model.gltf.animations;
    var accessors = model.gltf.accessors;
    var name;
    for (var animationName in animations) {
        if (animations.hasOwnProperty(animationName)) {
            var animation = animations[animationName];
            var channels = animation.channels;
            var parameters = animation.parameters;
            var samplers = animation.samplers;
            var parameterValues = {};
            for (name in parameters) {
                if (parameters.hasOwnProperty(name)) {
                    parameterValues[name] = ModelAnimationCache.getAnimationParameterValues(model, accessors[parameters[name]]);
                }
            }
            var startTime = Number.MAX_VALUE;
            var stopTime = -Number.MAX_VALUE;
            var length = channels.length;
            var channelEvaluators = new Array(length);
            for (var i = 0; i < length; ++i) {
                var channel = channels[i];
                var target = channel.target;
                var sampler = samplers[channel.sampler];
                var times = parameterValues[sampler.input];
                startTime = Math.min(startTime, times[0]);
                stopTime = Math.max(stopTime, times[times.length - 1]);
                var spline = ModelAnimationCache.getAnimationSpline(model, animationName, animation, channel.sampler, sampler, parameterValues);
                channelEvaluators[i] = getChannelEvaluator(model, runtimeNodes[target.id], target.path, spline);
            }
            model._runtime.animations[animationName] = {
                startTime: startTime,
                stopTime: stopTime,
                channelEvaluators: channelEvaluators
            };
        }
    }
}
function createVertexArrays(model, context) {
    var loadResources = model._loadResources;
    if (!loadResources.finishedBuffersCreation() || !loadResources.finishedProgramCreation()) {
        return;
    }
    if (!loadResources.createVertexArrays) {
        return;
    }
    loadResources.createVertexArrays = false;
    var rendererBuffers = model._rendererResources.buffers;
    var rendererVertexArrays = model._rendererResources.vertexArrays;
    var gltf = model.gltf;
    var accessors = gltf.accessors;
    var meshes = gltf.meshes;
    for (var meshName in meshes) {
        if (meshes.hasOwnProperty(meshName)) {
            var primitives = meshes[meshName].primitives;
            var primitivesLength = primitives.length;
            for (var i = 0; i < primitivesLength; ++i) {
                var primitive = primitives[i];
                var attributeLocations = getAttributeLocations(model, primitive);
                var attrs = [];
                var primitiveAttributes = primitive.attributes;
                for (var attrName in primitiveAttributes) {
                    if (primitiveAttributes.hasOwnProperty(attrName)) {
                        var attributeLocation = attributeLocations[attrName];
                        if (defined(attributeLocation)) {
                            var a = accessors[primitiveAttributes[attrName]];
                            attrs.push({
                                index: attributeLocation,
                                vertexBuffer: rendererBuffers[a.bufferView],
                                componentsPerAttribute: getModelAccessor(a).componentsPerAttribute,
                                componentDatatype: a.componentType,
                                normalize: false,
                                offsetInBytes: a.byteOffset,
                                strideInBytes: a.byteStride
                            });
                        }
                    }
                }
                var accessor = accessors[primitive.indices];
                var indexBuffer = rendererBuffers[accessor.bufferView];
                rendererVertexArrays[meshName + '.primitive.' + i] = context.createVertexArray(attrs, indexBuffer);
            }
        }
    }
}
function getBooleanStates(states) {
    var booleanStates = {};
    booleanStates[WebGLRenderingContext.BLEND] = false;
    booleanStates[WebGLRenderingContext.CULL_FACE] = false;
    booleanStates[WebGLRenderingContext.DEPTH_TEST] = false;
    booleanStates[WebGLRenderingContext.POLYGON_OFFSET_FILL] = false;
    booleanStates[WebGLRenderingContext.SCISSOR_TEST] = false;
    var enable = states.enable;
    var length = enable.length;
    var i;
    for (i = 0; i < length; ++i) {
        booleanStates[enable[i]] = true;
    }
    return booleanStates;
}
function createRenderStates(model, context) {
    var loadResources = model._loadResources;
    if (loadResources.createRenderStates) {
        loadResources.createRenderStates = false;
        var rendererRenderStates = model._rendererResources.renderStates;
        var techniques = model.gltf.techniques;
        for (var name in techniques) {
            if (techniques.hasOwnProperty(name)) {
                var technique = techniques[name];
                var pass = technique.passes[technique.pass];
                var states = pass.states;
                var booleanStates = getBooleanStates(states);
                var statesFunctions = defaultValue(states.functions, defaultValue.EMPTY_OBJECT);
                var blendColor = defaultValue(statesFunctions.blendColor, [
                        0,
                        0,
                        0,
                        0
                    ]);
                var blendEquationSeparate = defaultValue(statesFunctions.blendEquationSeparate, [
                        WebGLRenderingContext.FUNC_ADD,
                        WebGLRenderingContext.FUNC_ADD
                    ]);
                var blendFuncSeparate = defaultValue(statesFunctions.blendFuncSeparate, [
                        WebGLRenderingContext.ONE,
                        WebGLRenderingContext.ONE,
                        WebGLRenderingContext.ZERO,
                        WebGLRenderingContext.ZERO
                    ]);
                var colorMask = defaultValue(statesFunctions.colorMask, [
                        true,
                        true,
                        true,
                        true
                    ]);
                var depthRange = defaultValue(statesFunctions.depthRange, [
                        0,
                        1
                    ]);
                var polygonOffset = defaultValue(statesFunctions.polygonOffset, [
                        0,
                        0
                    ]);
                var scissor = defaultValue(statesFunctions.scissor, [
                        0,
                        0,
                        0,
                        0
                    ]);
                rendererRenderStates[name] = context.createRenderState({
                    frontFace: defined(statesFunctions.frontFace) ? statesFunctions.frontFace[0] : WebGLRenderingContext.CCW,
                    cull: {
                        enabled: booleanStates[WebGLRenderingContext.CULL_FACE],
                        face: defined(statesFunctions.cullFace) ? statesFunctions.cullFace[0] : WebGLRenderingContext.BACK
                    },
                    lineWidth: defined(statesFunctions.lineWidth) ? statesFunctions.lineWidth[0] : 1,
                    polygonOffset: {
                        enabled: booleanStates[WebGLRenderingContext.POLYGON_OFFSET_FILL],
                        factor: polygonOffset[0],
                        units: polygonOffset[1]
                    },
                    scissorTest: {
                        enabled: booleanStates[WebGLRenderingContext.SCISSOR_TEST],
                        rectangle: {
                            x: scissor[0],
                            y: scissor[1],
                            width: scissor[2],
                            height: scissor[3]
                        }
                    },
                    depthRange: {
                        near: depthRange[0],
                        far: depthRange[1]
                    },
                    depthTest: {
                        enabled: booleanStates[WebGLRenderingContext.DEPTH_TEST],
                        func: defined(statesFunctions.depthFunc) ? statesFunctions.depthFunc[0] : WebGLRenderingContext.LESS
                    },
                    colorMask: {
                        red: colorMask[0],
                        green: colorMask[1],
                        blue: colorMask[2],
                        alpha: colorMask[3]
                    },
                    depthMask: defined(statesFunctions.depthMask) ? statesFunctions.depthMask[0] : true,
                    blending: {
                        enabled: booleanStates[WebGLRenderingContext.BLEND],
                        color: {
                            red: blendColor[0],
                            green: blendColor[1],
                            blue: blendColor[2],
                            alpha: blendColor[3]
                        },
                        equationRgb: blendEquationSeparate[0],
                        equationAlpha: blendEquationSeparate[1],
                        functionSourceRgb: blendFuncSeparate[0],
                        functionSourceAlpha: blendFuncSeparate[1],
                        functionDestinationRgb: blendFuncSeparate[2],
                        functionDestinationAlpha: blendFuncSeparate[3]
                    }
                });
            }
        }
    }
}
var gltfSemanticUniforms = {
        MODEL: function (uniformState) {
            return function () {
                return uniformState.model;
            };
        },
        VIEW: function (uniformState) {
            return function () {
                return uniformState.view;
            };
        },
        PROJECTION: function (uniformState) {
            return function () {
                return uniformState.projection;
            };
        },
        MODELVIEW: function (uniformState) {
            return function () {
                return uniformState.modelView;
            };
        },
        MODELVIEWPROJECTION: function (uniformState) {
            return function () {
                return uniformState.modelViewProjection;
            };
        },
        MODELINVERSE: function (uniformState) {
            return function () {
                return uniformState.inverseModel;
            };
        },
        VIEWINVERSE: function (uniformState) {
            return function () {
                return uniformState.inverseView;
            };
        },
        PROJECTIONINVERSE: function (uniformState) {
            return function () {
                return uniformState.inverseProjection;
            };
        },
        MODELVIEWINVERSE: function (uniformState) {
            return function () {
                return uniformState.inverseModelView;
            };
        },
        MODELVIEWPROJECTIONINVERSE: function (uniformState) {
            return function () {
                return uniformState.inverseModelViewProjection;
            };
        },
        MODELINVERSETRANSPOSE: function (uniformState) {
            return function () {
                return uniformState.inverseTranposeModel;
            };
        },
        MODELVIEWINVERSETRANSPOSE: function (uniformState) {
            return function () {
                return uniformState.normal;
            };
        },
        VIEWPORT: function (uniformState) {
            return function () {
                return uniformState.viewportCartesian4;
            };
        }
    };
function getScalarUniformFunction(value, model) {
    var that = {
            value: value,
            clone: function (source, result) {
                return source;
            },
            func: function () {
                return that.value;
            }
        };
    return that;
}
function getVec2UniformFunction(value, model) {
    var that = {
            value: Cartesian2.fromArray(value),
            clone: Cartesian2.clone,
            func: function () {
                return that.value;
            }
        };
    return that;
}
function getVec3UniformFunction(value, model) {
    var that = {
            value: Cartesian3.fromArray(value),
            clone: Cartesian3.clone,
            func: function () {
                return that.value;
            }
        };
    return that;
}
function getVec4UniformFunction(value, model) {
    var that = {
            value: Cartesian4.fromArray(value),
            clone: Cartesian4.clone,
            func: function () {
                return that.value;
            }
        };
    return that;
}
function getMat2UniformFunction(value, model) {
    var that = {
            value: Matrix2.fromColumnMajorArray(value),
            clone: Matrix2.clone,
            func: function () {
                return that.value;
            }
        };
    return that;
}
function getMat3UniformFunction(value, model) {
    var that = {
            value: Matrix3.fromColumnMajorArray(value),
            clone: Matrix3.clone,
            func: function () {
                return that.value;
            }
        };
    return that;
}
function getMat4UniformFunction(value, model) {
    var that = {
            value: Matrix4.fromColumnMajorArray(value),
            clone: Matrix4.clone,
            func: function () {
                return that.value;
            }
        };
    return that;
}
function getTextureUniformFunction(value, model) {
    var that = {
            value: model._rendererResources.textures[value],
            clone: function (source, result) {
                return source;
            },
            func: function () {
                return that.value;
            }
        };
    return that;
}
var gltfUniformFunctions = {};
if (typeof WebGLRenderingContext !== 'undefined') {
    gltfUniformFunctions[WebGLRenderingContext.FLOAT] = getScalarUniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.FLOAT_VEC2] = getVec2UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.FLOAT_VEC3] = getVec3UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.FLOAT_VEC4] = getVec4UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.INT] = getScalarUniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.INT_VEC2] = getVec2UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.INT_VEC3] = getVec3UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.INT_VEC4] = getVec4UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.BOOL] = getScalarUniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.BOOL_VEC2] = getVec2UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.BOOL_VEC3] = getVec3UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.BOOL_VEC4] = getVec4UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.FLOAT_MAT2] = getMat2UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.FLOAT_MAT3] = getMat3UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.FLOAT_MAT4] = getMat4UniformFunction;
    gltfUniformFunctions[WebGLRenderingContext.SAMPLER_2D] = getTextureUniformFunction;
}
function getUniformFunctionFromSource(source, model) {
    var runtimeNode = model._runtime.nodes[source];
    return function () {
        return runtimeNode.computedMatrix;
    };
}
function createUniformMaps(model, context) {
    var loadResources = model._loadResources;
    if (!loadResources.finishedTextureCreation() || !loadResources.finishedProgramCreation()) {
        return;
    }
    if (!loadResources.createUniformMaps) {
        return;
    }
    loadResources.createUniformMaps = false;
    var gltf = model.gltf;
    var materials = gltf.materials;
    var techniques = gltf.techniques;
    var programs = gltf.programs;
    var uniformMaps = model._uniformMaps;
    for (var materialName in materials) {
        if (materials.hasOwnProperty(materialName)) {
            var material = materials[materialName];
            var instanceTechnique = material.instanceTechnique;
            var instanceParameters = instanceTechnique.values;
            var technique = techniques[instanceTechnique.technique];
            var parameters = technique.parameters;
            var pass = technique.passes[technique.pass];
            var instanceProgram = pass.instanceProgram;
            var uniforms = instanceProgram.uniforms;
            var uniformMap = {};
            var uniformValues = {};
            var jointMatrixUniformName;
            for (var name in uniforms) {
                if (uniforms.hasOwnProperty(name)) {
                    var parameterName = uniforms[name];
                    var parameter = parameters[parameterName];
                    if (defined(instanceParameters[parameterName])) {
                        var uv = gltfUniformFunctions[parameter.type](instanceParameters[parameterName], model);
                        uniformMap[name] = uv.func;
                        uniformValues[parameterName] = uv;
                    } else if (defined(parameter.semantic)) {
                        if (parameter.semantic !== 'JOINTMATRIX') {
                            uniformMap[name] = gltfSemanticUniforms[parameter.semantic](context.uniformState);
                        } else {
                            jointMatrixUniformName = name;
                        }
                    } else if (defined(parameter.source)) {
                        uniformMap[name] = getUniformFunctionFromSource(parameter.source, model);
                    } else if (defined(parameter.value)) {
                        var uv2 = gltfUniformFunctions[parameter.type](parameter.value, model);
                        uniformMap[name] = uv2.func;
                        uniformValues[parameterName] = uv2;
                    }
                }
            }
            var u = uniformMaps[materialName];
            u.uniformMap = uniformMap;
            u.values = uniformValues;
            u.jointMatrixUniformName = jointMatrixUniformName;
        }
    }
}
function createPickColorFunction(color) {
    return function () {
        return color;
    };
}
function createJointMatricesFunction(runtimeNode) {
    return function () {
        return runtimeNode.computedJointMatrices;
    };
}
function createCommand(model, gltfNode, runtimeNode, context) {
    var nodeCommands = model._nodeCommands;
    var pickIds = model._pickIds;
    var allowPicking = model.allowPicking;
    var runtimeMeshes = model._runtime.meshesByName;
    var debugShowBoundingVolume = model.debugShowBoundingVolume;
    var resources = model._rendererResources;
    var rendererVertexArrays = resources.vertexArrays;
    var rendererPrograms = resources.programs;
    var rendererPickPrograms = resources.pickPrograms;
    var rendererRenderStates = resources.renderStates;
    var uniformMaps = model._uniformMaps;
    var gltf = model.gltf;
    var accessors = gltf.accessors;
    var gltfMeshes = gltf.meshes;
    var techniques = gltf.techniques;
    var materials = gltf.materials;
    var meshes = defined(gltfNode.meshes) ? gltfNode.meshes : gltfNode.instanceSkin.meshes;
    var meshesLength = meshes.length;
    for (var j = 0; j < meshesLength; ++j) {
        var name = meshes[j];
        var mesh = gltfMeshes[name];
        var primitives = mesh.primitives;
        var length = primitives.length;
        for (var i = 0; i < length; ++i) {
            var primitive = primitives[i];
            var ix = accessors[primitive.indices];
            var instanceTechnique = materials[primitive.material].instanceTechnique;
            var technique = techniques[instanceTechnique.technique];
            var pass = technique.passes[technique.pass];
            var instanceProgram = pass.instanceProgram;
            var boundingSphere;
            var positionAttribute = primitive.attributes.POSITION;
            if (defined(positionAttribute)) {
                var a = accessors[positionAttribute];
                boundingSphere = BoundingSphere.fromCornerPoints(Cartesian3.fromArray(a.min), Cartesian3.fromArray(a.max));
            }
            var vertexArray = rendererVertexArrays[name + '.primitive.' + i];
            var count = ix.count;
            var offset = ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType);
            var um = uniformMaps[primitive.material];
            var uniformMap = um.uniformMap;
            if (defined(um.jointMatrixUniformName)) {
                var jointUniformMap = {};
                jointUniformMap[um.jointMatrixUniformName] = createJointMatricesFunction(runtimeNode);
                uniformMap = combine(uniformMap, jointUniformMap);
            }
            var rs = rendererRenderStates[instanceTechnique.technique];
            var isTranslucent = rs.blending.enabled;
            var owner = {
                    primitive: defaultValue(model.pickPrimitive, model),
                    id: model.id,
                    node: runtimeNode.publicNode,
                    mesh: runtimeMeshes[mesh.name]
                };
            var command = new DrawCommand({
                    boundingVolume: new BoundingSphere(),
                    modelMatrix: new Matrix4(),
                    primitiveType: primitive.primitive,
                    vertexArray: vertexArray,
                    count: count,
                    offset: offset,
                    shaderProgram: rendererPrograms[instanceProgram.program],
                    uniformMap: uniformMap,
                    renderState: rs,
                    owner: owner,
                    pass: isTranslucent ? Pass.TRANSLUCENT : Pass.OPAQUE
                });
            var pickCommand;
            if (allowPicking) {
                var pickId = context.createPickId(owner);
                pickIds.push(pickId);
                var pickUniformMap = combine(uniformMap, { czm_pickColor: createPickColorFunction(pickId.color) });
                pickCommand = new DrawCommand({
                    boundingVolume: new BoundingSphere(),
                    modelMatrix: new Matrix4(),
                    primitiveType: primitive.primitive,
                    vertexArray: vertexArray,
                    count: count,
                    offset: offset,
                    shaderProgram: rendererPickPrograms[instanceProgram.program],
                    uniformMap: pickUniformMap,
                    renderState: rs,
                    owner: owner,
                    pass: isTranslucent ? Pass.TRANSLUCENT : Pass.OPAQUE
                });
            }
            var nodeCommand = {
                    show: true,
                    boundingSphere: boundingSphere,
                    command: command,
                    pickCommand: pickCommand
                };
            runtimeNode.commands.push(nodeCommand);
            nodeCommands.push(nodeCommand);
        }
    }
}
function createRuntimeNodes(model, context) {
    var loadResources = model._loadResources;
    if (!loadResources.finishedPendingLoads() || !loadResources.finishedResourceCreation()) {
        return;
    }
    if (!loadResources.createRuntimeNodes) {
        return;
    }
    loadResources.createRuntimeNodes = false;
    var rootNodes = [];
    var runtimeNodes = model._runtime.nodes;
    var gltf = model.gltf;
    var nodes = gltf.nodes;
    var scene = gltf.scenes[gltf.scene];
    var sceneNodes = scene.nodes;
    var length = sceneNodes.length;
    var stack = [];
    var axis = new Cartesian3();
    for (var i = 0; i < length; ++i) {
        stack.push({
            parentRuntimeNode: undefined,
            gltfNode: nodes[sceneNodes[i]],
            id: sceneNodes[i]
        });
        while (stack.length > 0) {
            var n = stack.pop();
            var parentRuntimeNode = n.parentRuntimeNode;
            var gltfNode = n.gltfNode;
            var runtimeNode = runtimeNodes[n.id];
            if (runtimeNode.parents.length === 0) {
                if (defined(gltfNode.matrix)) {
                    runtimeNode.matrix = Matrix4.fromColumnMajorArray(gltfNode.matrix);
                } else {
                    axis = Cartesian3.fromArray(gltfNode.rotation, 0, axis);
                    runtimeNode.translation = Cartesian3.fromArray(gltfNode.translation);
                    runtimeNode.rotation = Quaternion.fromAxisAngle(axis, gltfNode.rotation[3]);
                    runtimeNode.scale = Cartesian3.fromArray(gltfNode.scale);
                }
            }
            if (defined(parentRuntimeNode)) {
                parentRuntimeNode.children.push(runtimeNode);
                runtimeNode.parents.push(parentRuntimeNode);
            } else {
                rootNodes.push(runtimeNode);
            }
            if (defined(gltfNode.meshes) || defined(gltfNode.instanceSkin)) {
                createCommand(model, gltfNode, runtimeNode, context);
            }
            var children = gltfNode.children;
            var childrenLength = children.length;
            for (var k = 0; k < childrenLength; ++k) {
                stack.push({
                    parentRuntimeNode: runtimeNode,
                    gltfNode: nodes[children[k]],
                    id: children[k]
                });
            }
        }
    }
    model._runtime.rootNodes = rootNodes;
    model._runtime.nodes = runtimeNodes;
}
function createResources(model, context) {
    if (model._loadRendererResourcesFromCache) {
        var resources = model._rendererResources;
        var cachedResources = model._cachedRendererResources;
        resources.buffers = cachedResources.buffers;
        resources.vertexArrays = cachedResources.vertexArrays;
        resources.programs = cachedResources.programs;
        resources.pickPrograms = cachedResources.pickPrograms;
        resources.textures = cachedResources.textures;
        resources.samplers = cachedResources.samplers;
        resources.renderStates = cachedResources.renderStates;
    } else {
        createBuffers(model, context);
        createPrograms(model, context);
        createSamplers(model, context);
        createTextures(model, context);
    }
    createSkins(model);
    createRuntimeAnimations(model);
    if (!model._loadRendererResourcesFromCache) {
        createVertexArrays(model, context);
        createRenderStates(model, context);
    }
    createUniformMaps(model, context);
    createRuntimeNodes(model, context);
}
function getNodeMatrix(node, result) {
    var publicNode = node.publicNode;
    var publicMatrix = publicNode.matrix;
    if (publicNode.useMatrix && defined(publicMatrix)) {
        Matrix4.clone(publicMatrix, result);
    } else if (defined(node.matrix)) {
        Matrix4.clone(node.matrix, result);
    } else {
        Matrix4.fromTranslationQuaternionRotationScale(node.translation, node.rotation, node.scale, result);
        publicNode.setMatrix(result);
    }
}
var scratchNodeStack = [];
function updateNodeHierarchyModelMatrix(model, modelTransformChanged, justLoaded) {
    var maxDirtyNumber = model._maxDirtyNumber;
    var allowPicking = model.allowPicking;
    var rootNodes = model._runtime.rootNodes;
    var length = rootNodes.length;
    var nodeStack = scratchNodeStack;
    var computedModelMatrix = model._computedModelMatrix;
    for (var i = 0; i < length; ++i) {
        var n = rootNodes[i];
        getNodeMatrix(n, n.transformToRoot);
        nodeStack.push(n);
        while (nodeStack.length > 0) {
            n = nodeStack.pop();
            var transformToRoot = n.transformToRoot;
            var commands = n.commands;
            if (n.dirtyNumber === maxDirtyNumber || modelTransformChanged || justLoaded) {
                var commandsLength = commands.length;
                if (commandsLength > 0) {
                    for (var j = 0; j < commandsLength; ++j) {
                        var primitiveCommand = commands[j];
                        var command = primitiveCommand.command;
                        Matrix4.multiplyTransformation(computedModelMatrix, transformToRoot, command.modelMatrix);
                        BoundingSphere.transform(primitiveCommand.boundingSphere, command.modelMatrix, command.boundingVolume);
                        if (allowPicking) {
                            var pickCommand = primitiveCommand.pickCommand;
                            Matrix4.clone(command.modelMatrix, pickCommand.modelMatrix);
                            BoundingSphere.clone(command.boundingVolume, pickCommand.boundingVolume);
                        }
                    }
                } else {
                    n.computedMatrix = Matrix4.multiplyTransformation(computedModelMatrix, transformToRoot, n.computedMatrix);
                }
            }
            var children = n.children;
            var childrenLength = children.length;
            for (var k = 0; k < childrenLength; ++k) {
                var child = children[k];
                child.dirtyNumber = Math.max(child.dirtyNumber, n.dirtyNumber);
                if (child.dirtyNumber === maxDirtyNumber || justLoaded) {
                    getNodeMatrix(child, child.transformToRoot);
                    Matrix4.multiplyTransformation(transformToRoot, child.transformToRoot, child.transformToRoot);
                }
                nodeStack.push(child);
            }
        }
    }
    ++model._maxDirtyNumber;
}
var scratchObjectSpace = new Matrix4();
function applySkins(model) {
    var skinnedNodes = model._runtime.skinnedNodes;
    var length = skinnedNodes.length;
    for (var i = 0; i < length; ++i) {
        var node = skinnedNodes[i];
        scratchObjectSpace = Matrix4.inverseTransformation(node.transformToRoot, scratchObjectSpace);
        var computedJointMatrices = node.computedJointMatrices;
        var joints = node.joints;
        var bindShapeMatrix = node.bindShapeMatrix;
        var inverseBindMatrices = node.inverseBindMatrices;
        var inverseBindMatricesLength = inverseBindMatrices.length;
        for (var m = 0; m < inverseBindMatricesLength; ++m) {
            if (!defined(computedJointMatrices[m])) {
                computedJointMatrices[m] = new Matrix4();
            }
            computedJointMatrices[m] = Matrix4.multiplyTransformation(scratchObjectSpace, joints[m].transformToRoot, computedJointMatrices[m]);
            computedJointMatrices[m] = Matrix4.multiplyTransformation(computedJointMatrices[m], inverseBindMatrices[m], computedJointMatrices[m]);
            if (defined(bindShapeMatrix)) {
                computedJointMatrices[m] = Matrix4.multiplyTransformation(computedJointMatrices[m], bindShapeMatrix, computedJointMatrices[m]);
            }
        }
    }
}
function updatePerNodeShow(model) {
    var rootNodes = model._runtime.rootNodes;
    var length = rootNodes.length;
    var nodeStack = scratchNodeStack;
    for (var i = 0; i < length; ++i) {
        var n = rootNodes[i];
        n.computedShow = n.publicNode.show;
        nodeStack.push(n);
        while (nodeStack.length > 0) {
            n = nodeStack.pop();
            var show = n.computedShow;
            var nodeCommands = n.commands;
            var nodeCommandsLength = nodeCommands.length;
            for (var j = 0; j < nodeCommandsLength; ++j) {
                nodeCommands[j].show = show;
            }
            var children = n.children;
            var childrenLength = children.length;
            for (var k = 0; k < childrenLength; ++k) {
                var child = children[k];
                child.computedShow = show && child.publicNode.show;
                nodeStack.push(child);
            }
        }
    }
}
function updatePickIds(model, context) {
    var id = model.id;
    if (model._id !== id) {
        model._id = id;
        var pickIds = model._pickIds;
        var length = pickIds.length;
        for (var i = 0; i < length; ++i) {
            pickIds[i].object.id = id;
        }
    }
}
function updateWireframe(model) {
    if (model._debugWireframe !== model.debugWireframe) {
        model._debugWireframe = model.debugWireframe;
        var primitiveType = model.debugWireframe ? PrimitiveType.LINES : PrimitiveType.TRIANGLES;
        var nodeCommands = model._nodeCommands;
        var length = nodeCommands.length;
        for (var i = 0; i < length; ++i) {
            nodeCommands[i].command.primitiveType = primitiveType;
        }
    }
}
function updateShowBoundingVolume(model) {
    if (model.debugShowBoundingVolume !== model._debugShowBoundingVolume) {
        model._debugShowBoundingVolume = model.debugShowBoundingVolume;
        var debugShowBoundingVolume = model.debugShowBoundingVolume;
        var nodeCommands = model._nodeCommands;
        var length = nodeCommands.length;
        for (var i = 0; i < length; i++) {
            nodeCommands[i].command.debugShowBoundingVolume = debugShowBoundingVolume;
        }
    }
}
var scratchDrawingBufferDimensions = new Cartesian2();
var scratchToCenter = new Cartesian3();
var scratchProj = new Cartesian3();
function scaleInPixels(positionWC, radius, context, frameState) {
    var camera = frameState.camera;
    var frustum = camera.frustum;
    var toCenter = Cartesian3.subtract(camera.positionWC, positionWC, scratchToCenter);
    var proj = Cartesian3.multiplyByScalar(camera.directionWC, Cartesian3.dot(toCenter, camera.directionWC), scratchProj);
    var distance = Math.max(frustum.near, Cartesian3.magnitude(proj) - radius);
    scratchDrawingBufferDimensions.x = context.drawingBufferWidth;
    scratchDrawingBufferDimensions.y = context.drawingBufferHeight;
    var pixelSize = frustum.getPixelSize(scratchDrawingBufferDimensions, distance);
    var pixelScale = Math.max(pixelSize.x, pixelSize.y);
    return pixelScale;
}
var scratchPosition = new Cartesian3();
function getScale(model, context, frameState) {
    var scale = model.scale;
    if (model.minimumPixelSize !== 0) {
        var maxPixelSize = Math.max(context.drawingBufferWidth, context.drawingBufferHeight);
        var m = model.modelMatrix;
        scratchPosition.x = m[12];
        scratchPosition.y = m[13];
        scratchPosition.z = m[14];
        var radius = model.boundingSphere.radius;
        var metersPerPixel = scaleInPixels(scratchPosition, radius, context, frameState);
        var pixelsPerMeter = 1 / metersPerPixel;
        var diameterInPixels = Math.min(pixelsPerMeter * (2 * radius), maxPixelSize);
        if (diameterInPixels < model.minimumPixelSize) {
            scale = model.minimumPixelSize * metersPerPixel / (2 * model._initialRadius);
        }
    }
    return scale;
}
function releaseCachedGltf(model) {
    if (defined(model._cacheKey) && defined(model._cachedGltf) && --model._cachedGltf.count === 0) {
        delete gltfCache[model._cacheKey];
    }
    model._cachedGltf = undefined;
}
var CachedRendererResources = function (context, cacheKey) {
    this.buffers = undefined;
    this.vertexArrays = undefined;
    this.programs = undefined;
    this.pickPrograms = undefined;
    this.textures = undefined;
    this.samplers = undefined;
    this.renderStates = undefined;
    this.ready = false;
    this.context = context;
    this.cacheKey = cacheKey;
    this.count = 0;
};
function destroy(property) {
    for (var name in property) {
        if (property.hasOwnProperty(name)) {
            property[name].destroy();
        }
    }
}
function destroyCachedRendererResources(resources) {
    destroy(resources.buffers);
    destroy(resources.vertexArrays);
    destroy(resources.programs);
    destroy(resources.pickPrograms);
    destroy(resources.textures);
}
CachedRendererResources.prototype.release = function () {
    if (--this.count === 0) {
        if (defined(this.cacheKey)) {
            delete this.context.cache.modelRendererResourceCache[this.cacheKey];
        }
        destroyCachedRendererResources(this);
        return destroyObject(this);
    }
    return undefined;
};
Model.prototype.update = function (context, frameState, commandList) {
    if (frameState.mode !== SceneMode.SCENE3D) {
        return;
    }
    if (this._state === ModelState.NEEDS_LOAD && defined(this.gltf)) {
        var cachedRendererResources;
        var cacheKey = this.cacheKey;
        if (defined(cacheKey)) {
            context.cache.modelRendererResourceCache = defaultValue(context.cache.modelRendererResourceCache, {});
            var modelCaches = context.cache.modelRendererResourceCache;
            cachedRendererResources = modelCaches[this.cacheKey];
            if (defined(cachedRendererResources)) {
                if (!cachedRendererResources.ready) {
                    return;
                }
                ++cachedRendererResources.count;
                this._loadRendererResourcesFromCache = true;
            } else {
                cachedRendererResources = new CachedRendererResources(context, cacheKey);
                cachedRendererResources.count = 1;
                modelCaches[this.cacheKey] = cachedRendererResources;
            }
            this._cachedRendererResources = cachedRendererResources;
        } else {
            cachedRendererResources = new CachedRendererResources(context);
            cachedRendererResources.count = 1;
            this._cachedRendererResources = cachedRendererResources;
        }
        this._state = ModelState.LOADING;
        this._boundingSphere = computeBoundingSphere(this.gltf);
        this._initialRadius = this._boundingSphere.radius;
        this._loadResources = new LoadResources();
        parse(this);
    }
    var justLoaded = false;
    if (this._state === ModelState.FAILED) {
        throw this._loadError;
    }
    if (this._state === ModelState.LOADING) {
        createResources(this, context);
        var loadResources = this._loadResources;
        if (loadResources.finishedPendingLoads() && loadResources.finishedResourceCreation()) {
            this._state = ModelState.LOADED;
            this._loadResources = undefined;
            var resources = this._rendererResources;
            var cachedResources = this._cachedRendererResources;
            cachedResources.buffers = resources.buffers;
            cachedResources.vertexArrays = resources.vertexArrays;
            cachedResources.programs = resources.programs;
            cachedResources.pickPrograms = resources.pickPrograms;
            cachedResources.textures = resources.textures;
            cachedResources.samplers = resources.samplers;
            cachedResources.renderStates = resources.renderStates;
            cachedResources.ready = true;
            if (this.releaseGltfJson) {
                releaseCachedGltf(this);
            }
            justLoaded = true;
        }
    }
    var show = this.show && this.scale !== 0;
    if (show && this._state === ModelState.LOADED || justLoaded) {
        var animated = this.activeAnimations.update(frameState) || this._cesiumAnimationsDirty;
        this._cesiumAnimationsDirty = false;
        var modelTransformChanged = !Matrix4.equals(this._modelMatrix, this.modelMatrix) || this._scale !== this.scale || this._minimumPixelSize !== this.minimumPixelSize || this.minimumPixelSize !== 0;
        if (modelTransformChanged || justLoaded) {
            Matrix4.clone(this.modelMatrix, this._modelMatrix);
            this._scale = this.scale;
            this._minimumPixelSize = this.minimumPixelSize;
            var scale = getScale(this, context, frameState);
            var computedModelMatrix = this._computedModelMatrix;
            Matrix4.multiplyByUniformScale(this.modelMatrix, scale, computedModelMatrix);
            Matrix4.multiplyTransformation(computedModelMatrix, yUpToZUp, computedModelMatrix);
        }
        if (animated || modelTransformChanged || justLoaded) {
            updateNodeHierarchyModelMatrix(this, modelTransformChanged, justLoaded);
            if (animated || justLoaded) {
                applySkins(this);
            }
        }
        if (this._perNodeShowDirty) {
            this._perNodeShowDirty = false;
            updatePerNodeShow(this);
        }
        updatePickIds(this, context);
        updateWireframe(this);
        updateShowBoundingVolume(this);
    }
    if (justLoaded) {
        var model = this;
        frameState.afterRender.push(function () {
            model._ready = true;
            model._readyToRender.raiseEvent(model);
            model.readyPromise.resolve(model);
        });
        return;
    }
    if (show) {
        var passes = frameState.passes;
        var nodeCommands = this._nodeCommands;
        var length = nodeCommands.length;
        var i;
        var nc;
        if (passes.render) {
            for (i = 0; i < length; ++i) {
                nc = nodeCommands[i];
                if (nc.show) {
                    commandList.push(nc.command);
                }
            }
        }
        if (passes.pick) {
            for (i = 0; i < length; ++i) {
                nc = nodeCommands[i];
                if (nc.show) {
                    commandList.push(nc.pickCommand);
                }
            }
        }
    }
};
Model.prototype.isDestroyed = function () {
    return false;
};
Model.prototype.destroy = function () {
    this._rendererResources = undefined;
    this._cachedRendererResources = this._cachedRendererResources && this._cachedRendererResources.release();
    var pickIds = this._pickIds;
    var length = pickIds.length;
    for (var i = 0; i < length; ++i) {
        pickIds[i].destroy();
    }
    releaseCachedGltf(this);
    return destroyObject(this);
};
module.exports = Model;
},{"../Core/BoundingSphere":98,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/IndexDatatype":162,"../Core/Math":174,"../Core/Matrix2":175,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/PrimitiveType":193,"../Core/Quaternion":197,"../Core/Queue":199,"../Core/RuntimeError":207,"../Core/clone":240,"../Core/combine":241,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/deprecationWarning":246,"../Core/destroyObject":247,"../Core/loadArrayBuffer":257,"../Core/loadImage":259,"../Core/loadText":262,"../Renderer/BufferUsage":339,"../Renderer/DrawCommand":344,"../Renderer/ShaderSource":355,"../Renderer/TextureMinificationFilter":358,"../Renderer/TextureWrap":359,"../ThirdParty/Uri":587,"../ThirdParty/gltfDefaults":588,"../ThirdParty/when":596,"./ModelAnimationCache":408,"./ModelAnimationCollection":409,"./ModelMaterial":412,"./ModelMesh":413,"./ModelNode":414,"./Pass":419,"./SceneMode":438,"./getModelAccessor":456}],407:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defineProperties = require('../Core/defineProperties'), Event = require('../Core/Event'), JulianDate = require('../Core/JulianDate'), ModelAnimationLoop = require('./ModelAnimationLoop'), ModelAnimationState = require('./ModelAnimationState');
'use strict';
var ModelAnimation = function (options, model, runtimeAnimation) {
    this._name = options.name;
    this._startTime = JulianDate.clone(options.startTime);
    this._delay = defaultValue(options.delay, 0);
    this._stopTime = options.stopTime;
    this.removeOnStop = defaultValue(options.removeOnStop, false);
    this._speedup = defaultValue(options.speedup, 1);
    this._reverse = defaultValue(options.reverse, false);
    this._loop = defaultValue(options.loop, ModelAnimationLoop.NONE);
    this.start = new Event();
    this.update = new Event();
    this.stop = new Event();
    this._state = ModelAnimationState.STOPPED;
    this._runtimeAnimation = runtimeAnimation;
    this._computedStartTime = undefined;
    this._duration = undefined;
    var that = this;
    this._raiseStartEvent = function () {
        that.start.raiseEvent(model, that);
    };
    this._updateEventTime = 0;
    this._raiseUpdateEvent = function () {
        that.update.raiseEvent(model, that, that._updateEventTime);
    };
    this._raiseStopEvent = function () {
        that.stop.raiseEvent(model, that);
    };
};
defineProperties(ModelAnimation.prototype, {
    name: {
        get: function () {
            return this._name;
        }
    },
    startTime: {
        get: function () {
            return this._startTime;
        }
    },
    delay: {
        get: function () {
            return this._delay;
        }
    },
    stopTime: {
        get: function () {
            return this._stopTime;
        }
    },
    speedup: {
        get: function () {
            return this._speedup;
        }
    },
    reverse: {
        get: function () {
            return this._reverse;
        }
    },
    loop: {
        get: function () {
            return this._loop;
        }
    }
});
module.exports = ModelAnimation;
},{"../Core/Event":138,"../Core/JulianDate":168,"../Core/defaultValue":243,"../Core/defineProperties":244,"./ModelAnimationLoop":410,"./ModelAnimationState":411}],408:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), LinearSpline = require('../Core/LinearSpline'), Matrix4 = require('../Core/Matrix4'), Quaternion = require('../Core/Quaternion'), QuaternionSpline = require('../Core/QuaternionSpline'), getModelAccessor = require('./getModelAccessor');
'use strict';
var ModelAnimationCache = function () {
};
function getAccessorKey(model, accessor) {
    var gltf = model.gltf;
    var buffers = gltf.buffers;
    var bufferViews = gltf.bufferViews;
    var bufferView = bufferViews[accessor.bufferView];
    var buffer = buffers[bufferView.buffer];
    var byteOffset = bufferView.byteOffset + accessor.byteOffset;
    var byteLength = accessor.count * getModelAccessor(accessor).componentsPerAttribute;
    return model.cacheKey + '//' + defaultValue(buffer.path, '') + '/' + byteOffset + '/' + byteLength;
}
var cachedAnimationParameters = {};
var axisScratch = new Cartesian3();
ModelAnimationCache.getAnimationParameterValues = function (model, accessor) {
    var key = getAccessorKey(model, accessor);
    var values = cachedAnimationParameters[key];
    if (!defined(values)) {
        var buffers = model._loadResources.buffers;
        var gltf = model.gltf;
        var bufferViews = gltf.bufferViews;
        var bufferView = bufferViews[accessor.bufferView];
        var componentType = accessor.componentType;
        var type = accessor.type;
        var count = accessor.count;
        var typedArray = getModelAccessor(accessor).createArrayBufferView(buffers[bufferView.buffer], bufferView.byteOffset + accessor.byteOffset, count);
        var i;
        if (componentType === WebGLRenderingContext.FLOAT && type === 'SCALAR') {
            values = typedArray;
        } else if (componentType === WebGLRenderingContext.FLOAT && type === 'VEC3') {
            values = new Array(count);
            for (i = 0; i < count; ++i) {
                values[i] = Cartesian3.fromArray(typedArray, 3 * i);
            }
        } else if (componentType === WebGLRenderingContext.FLOAT && type === 'VEC4') {
            values = new Array(count);
            for (i = 0; i < count; ++i) {
                var byteOffset = 4 * i;
                values[i] = Quaternion.fromAxisAngle(Cartesian3.fromArray(typedArray, byteOffset, axisScratch), typedArray[byteOffset + 3]);
            }
        }
        if (defined(model.cacheKey)) {
            cachedAnimationParameters[key] = values;
        }
    }
    return values;
};
var cachedAnimationSplines = {};
function getAnimationSplineKey(model, animationName, samplerName) {
    return model.cacheKey + '//' + animationName + '/' + samplerName;
}
var ConstantSpline = function (value) {
    this._value = value;
};
ConstantSpline.prototype.evaluate = function (time, result) {
    return this._value;
};
ModelAnimationCache.getAnimationSpline = function (model, animationName, animation, samplerName, sampler, parameterValues) {
    var key = getAnimationSplineKey(model, animationName, samplerName);
    var spline = cachedAnimationSplines[key];
    if (!defined(spline)) {
        var times = parameterValues[sampler.input];
        var accessor = model.gltf.accessors[animation.parameters[sampler.output]];
        var controlPoints = parameterValues[sampler.output];
        if (times.length === 1 && controlPoints.length === 1) {
            spline = new ConstantSpline(controlPoints[0]);
        } else {
            var componentType = accessor.componentType;
            var type = accessor.type;
            if (sampler.interpolation === 'LINEAR') {
                if (componentType === WebGLRenderingContext.FLOAT && type === 'VEC3') {
                    spline = new LinearSpline({
                        times: times,
                        points: controlPoints
                    });
                } else if (componentType === WebGLRenderingContext.FLOAT && type === 'VEC4') {
                    spline = new QuaternionSpline({
                        times: times,
                        points: controlPoints
                    });
                }
            }
        }
        if (defined(model.cacheKey)) {
            cachedAnimationSplines[key] = spline;
        }
    }
    return spline;
};
var cachedSkinInverseBindMatrices = {};
ModelAnimationCache.getSkinInverseBindMatrices = function (model, accessor) {
    var key = getAccessorKey(model, accessor);
    var matrices = cachedSkinInverseBindMatrices[key];
    if (!defined(matrices)) {
        var buffers = model._loadResources.buffers;
        var gltf = model.gltf;
        var bufferViews = gltf.bufferViews;
        var bufferView = bufferViews[accessor.bufferView];
        var componentType = accessor.componentType;
        var type = accessor.type;
        var count = accessor.count;
        var typedArray = getModelAccessor(accessor).createArrayBufferView(buffers[bufferView.buffer], bufferView.byteOffset + accessor.byteOffset, count);
        matrices = new Array(count);
        if (componentType === WebGLRenderingContext.FLOAT && type === 'MAT4') {
            for (var i = 0; i < count; ++i) {
                matrices[i] = Matrix4.fromArray(typedArray, 16 * i);
            }
        }
        cachedSkinInverseBindMatrices[key] = matrices;
    }
    return matrices;
};
module.exports = ModelAnimationCache;
},{"../Core/Cartesian3":102,"../Core/LinearSpline":173,"../Core/Matrix4":177,"../Core/Quaternion":197,"../Core/QuaternionSpline":198,"../Core/defaultValue":243,"../Core/defined":245,"./getModelAccessor":456}],409:[function(require,module,exports){
var clone = require('../Core/clone'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), JulianDate = require('../Core/JulianDate'), CesiumMath = require('../Core/Math'), ModelAnimation = require('./ModelAnimation'), ModelAnimationLoop = require('./ModelAnimationLoop'), ModelAnimationState = require('./ModelAnimationState');
'use strict';
var ModelAnimationCollection = function (model) {
    this.animationAdded = new Event();
    this.animationRemoved = new Event();
    this._model = model;
    this._scheduledAnimations = [];
    this._previousTime = undefined;
};
defineProperties(ModelAnimationCollection.prototype, {
    length: {
        get: function () {
            return this._scheduledAnimations.length;
        }
    }
});
ModelAnimationCollection.prototype.add = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var model = this._model;
    var animations = model._runtime.animations;
    if (!defined(animations)) {
        throw new DeveloperError('Animations are not loaded.  Wait for the model\'s readyToRender event or ready property.');
    }
    var animation = animations[options.name];
    if (!defined(animation)) {
        throw new DeveloperError('options.name must be a valid animation name.');
    }
    if (defined(options.speedup) && options.speedup <= 0) {
        throw new DeveloperError('options.speedup must be greater than zero.');
    }
    var scheduledAnimation = new ModelAnimation(options, model, animation);
    this._scheduledAnimations.push(scheduledAnimation);
    this.animationAdded.raiseEvent(model, scheduledAnimation);
    return scheduledAnimation;
};
ModelAnimationCollection.prototype.addAll = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(this._model._runtime.animations)) {
        throw new DeveloperError('Animations are not loaded.  Wait for the model\'s readyToRender event or ready property.');
    }
    if (defined(options.speedup) && options.speedup <= 0) {
        throw new DeveloperError('options.speedup must be greater than zero.');
    }
    options = clone(options);
    var scheduledAnimations = [];
    var animationIds = this._model._animationIds;
    var length = animationIds.length;
    for (var i = 0; i < length; ++i) {
        options.name = animationIds[i];
        scheduledAnimations.push(this.add(options));
    }
    return scheduledAnimations;
};
ModelAnimationCollection.prototype.remove = function (animation) {
    if (defined(animation)) {
        var animations = this._scheduledAnimations;
        var i = animations.indexOf(animation);
        if (i !== -1) {
            animations.splice(i, 1);
            this.animationRemoved.raiseEvent(this._model, animation);
            return true;
        }
    }
    return false;
};
ModelAnimationCollection.prototype.removeAll = function () {
    var model = this._model;
    var animations = this._scheduledAnimations;
    var length = animations.length;
    this._scheduledAnimations = [];
    for (var i = 0; i < length; ++i) {
        this.animationRemoved.raiseEvent(model, animations[i]);
    }
};
ModelAnimationCollection.prototype.contains = function (animation) {
    if (defined(animation)) {
        return this._scheduledAnimations.indexOf(animation) !== -1;
    }
    return false;
};
ModelAnimationCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    return this._scheduledAnimations[index];
};
function animateChannels(runtimeAnimation, localAnimationTime) {
    var channelEvaluators = runtimeAnimation.channelEvaluators;
    var length = channelEvaluators.length;
    for (var i = 0; i < length; ++i) {
        channelEvaluators[i](localAnimationTime);
    }
}
var animationsToRemove = [];
function createAnimationRemovedFunction(modelAnimationCollection, model, animation) {
    return function () {
        modelAnimationCollection.animationRemoved.raiseEvent(model, animation);
    };
}
ModelAnimationCollection.prototype.update = function (frameState) {
    if (JulianDate.equals(frameState.time, this._previousTime)) {
        return false;
    }
    this._previousTime = JulianDate.clone(frameState.time, this._previousTime);
    var animationOccured = false;
    var sceneTime = frameState.time;
    var model = this._model;
    var scheduledAnimations = this._scheduledAnimations;
    var length = scheduledAnimations.length;
    for (var i = 0; i < length; ++i) {
        var scheduledAnimation = scheduledAnimations[i];
        var runtimeAnimation = scheduledAnimation._runtimeAnimation;
        if (!defined(scheduledAnimation._computedStartTime)) {
            scheduledAnimation._computedStartTime = JulianDate.addSeconds(defaultValue(scheduledAnimation.startTime, sceneTime), scheduledAnimation.delay, new JulianDate());
        }
        if (!defined(scheduledAnimation._duration)) {
            scheduledAnimation._duration = runtimeAnimation.stopTime * (1 / scheduledAnimation.speedup);
        }
        var startTime = scheduledAnimation._computedStartTime;
        var duration = scheduledAnimation._duration;
        var stopTime = scheduledAnimation.stopTime;
        var delta = duration !== 0 ? JulianDate.secondsDifference(sceneTime, startTime) / duration : 0;
        var pastStartTime = delta >= 0;
        var play = pastStartTime && (delta <= 1 || (scheduledAnimation.loop === ModelAnimationLoop.REPEAT || scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT)) && (!defined(stopTime) || JulianDate.lessThanOrEquals(sceneTime, stopTime));
        if (play) {
            if (scheduledAnimation._state === ModelAnimationState.STOPPED) {
                scheduledAnimation._state = ModelAnimationState.ANIMATING;
                if (scheduledAnimation.start.numberOfListeners > 0) {
                    frameState.afterRender.push(scheduledAnimation._raiseStartEvent);
                }
            }
            if (scheduledAnimation.loop === ModelAnimationLoop.REPEAT) {
                delta = delta - Math.floor(delta);
            } else if (scheduledAnimation.loop === ModelAnimationLoop.MIRRORED_REPEAT) {
                var floor = Math.floor(delta);
                var fract = delta - floor;
                delta = floor % 2 === 1 ? 1 - fract : fract;
            }
            if (scheduledAnimation.reverse) {
                delta = 1 - delta;
            }
            var localAnimationTime = delta * duration * scheduledAnimation.speedup;
            localAnimationTime = CesiumMath.clamp(localAnimationTime, runtimeAnimation.startTime, runtimeAnimation.stopTime);
            animateChannels(runtimeAnimation, localAnimationTime);
            if (scheduledAnimation.update.numberOfListeners > 0) {
                scheduledAnimation._updateEventTime = localAnimationTime;
                frameState.afterRender.push(scheduledAnimation._raiseUpdateEvent);
            }
            animationOccured = true;
        } else {
            if (pastStartTime && scheduledAnimation._state === ModelAnimationState.ANIMATING) {
                scheduledAnimation._state = ModelAnimationState.STOPPED;
                if (scheduledAnimation.stop.numberOfListeners > 0) {
                    frameState.afterRender.push(scheduledAnimation._raiseStopEvent);
                }
                if (scheduledAnimation.removeOnStop) {
                    animationsToRemove.push(scheduledAnimation);
                }
            }
        }
    }
    length = animationsToRemove.length;
    for (var j = 0; j < length; ++j) {
        var animationToRemove = animationsToRemove[j];
        scheduledAnimations.splice(scheduledAnimations.indexOf(animationToRemove), 1);
        frameState.afterRender.push(createAnimationRemovedFunction(this, model, animationToRemove));
    }
    animationsToRemove.length = 0;
    return animationOccured;
};
module.exports = ModelAnimationCollection;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/JulianDate":168,"../Core/Math":174,"../Core/clone":240,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./ModelAnimation":407,"./ModelAnimationLoop":410,"./ModelAnimationState":411}],410:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var ModelAnimationLoop = {
        NONE: 0,
        REPEAT: 1,
        MIRRORED_REPEAT: 2
    };
module.exports = freezeObject(ModelAnimationLoop);
},{"../Core/freezeObject":249}],411:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
module.exports = freezeObject({
    STOPPED: 0,
    ANIMATING: 1
});
},{"../Core/freezeObject":249}],412:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError');
'use strict';
var ModelMaterial = function (model, material, id) {
    this._name = material.name;
    this._id = id;
    this._uniformMap = model._uniformMaps[id];
};
defineProperties(ModelMaterial.prototype, {
    name: {
        get: function () {
            return this._name;
        }
    },
    id: {
        get: function () {
            return this._id;
        }
    }
});
ModelMaterial.prototype.setValue = function (name, value) {
    if (!defined(name)) {
        throw new DeveloperError('name is required.');
    }
    var v = this._uniformMap.values[name];
    if (!defined(v)) {
        throw new DeveloperError('name must match a parameter name in the material\'s technique that is targetable and not optimized out.');
    }
    v.value = v.clone(value, v.value);
};
ModelMaterial.prototype.getValue = function (name) {
    if (!defined(name)) {
        throw new DeveloperError('name is required.');
    }
    var v = this._uniformMap.values[name];
    if (!defined(v)) {
        return undefined;
    }
    return v.value;
};
module.exports = ModelMaterial;
},{"../Core/DeveloperError":123,"../Core/defineProperties":244,"../Core/defined":245}],413:[function(require,module,exports){
var defineProperties = require('../Core/defineProperties');
'use strict';
var ModelMesh = function (mesh, runtimeMaterialsById, id) {
    var materials = [];
    var primitives = mesh.primitives;
    var length = primitives.length;
    for (var i = 0; i < length; ++i) {
        var p = primitives[i];
        materials[i] = runtimeMaterialsById[p.material];
    }
    this._name = mesh.name;
    this._materials = materials;
    this._id = id;
};
defineProperties(ModelMesh.prototype, {
    name: {
        get: function () {
            return this._name;
        }
    },
    id: {
        get: function () {
            return this._id;
        }
    },
    materials: {
        get: function () {
            return this._materials;
        }
    }
});
module.exports = ModelMesh;
},{"../Core/defineProperties":244}],414:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defineProperties = require('../Core/defineProperties'), Matrix4 = require('../Core/Matrix4');
'use strict';
var ModelNode = function (model, node, runtimeNode, id, matrix) {
    this._model = model;
    this._runtimeNode = runtimeNode;
    this._name = node.name;
    this._id = id;
    this.useMatrix = false;
    this._show = true;
    this._matrix = Matrix4.clone(matrix);
};
defineProperties(ModelNode.prototype, {
    name: {
        get: function () {
            return this._name;
        }
    },
    id: {
        get: function () {
            return this._id;
        }
    },
    show: {
        get: function () {
            return this._show;
        },
        set: function (value) {
            if (this._show !== value) {
                this._show = value;
                this._model._perNodeShowDirty = true;
            }
        }
    },
    matrix: {
        get: function () {
            return this._matrix;
        },
        set: function (value) {
            this._matrix = Matrix4.clone(value, this._matrix);
            this.useMatrix = true;
            var model = this._model;
            model._cesiumAnimationsDirty = true;
            this._runtimeNode.dirtyNumber = model._maxDirtyNumber;
        }
    }
});
ModelNode.prototype.setMatrix = function (matrix) {
    Matrix4.clone(matrix, this._matrix);
};
module.exports = ModelNode;
},{"../Core/Matrix4":177,"../Core/defaultValue":243,"../Core/defineProperties":244}],415:[function(require,module,exports){
var buildModuleUrl = require('../Core/buildModuleUrl'), Cartesian3 = require('../Core/Cartesian3'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), Ellipsoid = require('../Core/Ellipsoid'), IauOrientationAxes = require('../Core/IauOrientationAxes'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), Simon1994PlanetaryPositions = require('../Core/Simon1994PlanetaryPositions'), Transforms = require('../Core/Transforms'), EllipsoidPrimitive = require('./EllipsoidPrimitive'), Material = require('./Material');
'use strict';
var Moon = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var url = options.textureUrl;
    if (!defined(url)) {
        url = buildModuleUrl('Assets/Textures/moonSmall.jpg');
    }
    this.show = defaultValue(options.show, true);
    this.textureUrl = url;
    this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.MOON);
    this.onlySunLighting = defaultValue(options.onlySunLighting, true);
    this._ellipsoidPrimitive = new EllipsoidPrimitive({
        radii: this.ellipsoid.radii,
        material: Material.fromType(Material.ImageType),
        _owner: this
    });
    this._ellipsoidPrimitive.material.translucent = false;
    this._axes = new IauOrientationAxes();
};
defineProperties(Moon.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    }
});
var icrfToFixed = new Matrix3();
var rotationScratch = new Matrix3();
var translationScratch = new Cartesian3();
Moon.prototype.update = function (context, frameState, commandList) {
    if (!this.show) {
        return;
    }
    var ellipsoidPrimitive = this._ellipsoidPrimitive;
    ellipsoidPrimitive.material.uniforms.image = this.textureUrl;
    ellipsoidPrimitive.onlySunLighting = this.onlySunLighting;
    var date = frameState.time;
    if (!defined(Transforms.computeIcrfToFixedMatrix(date, icrfToFixed))) {
        Transforms.computeTemeToPseudoFixedMatrix(date, icrfToFixed);
    }
    var rotation = this._axes.evaluate(date, rotationScratch);
    Matrix3.transpose(rotation, rotation);
    Matrix3.multiply(icrfToFixed, rotation, rotation);
    var translation = Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(date, translationScratch);
    Matrix3.multiplyByVector(icrfToFixed, translation, translation);
    Matrix4.fromRotationTranslation(rotation, translation, ellipsoidPrimitive.modelMatrix);
    ellipsoidPrimitive.update(context, frameState, commandList);
};
Moon.prototype.isDestroyed = function () {
    return false;
};
Moon.prototype.destroy = function () {
    this._ellipsoidPrimitive = this._ellipsoidPrimitive && this._ellipsoidPrimitive.destroy();
    return destroyObject(this);
};
module.exports = Moon;
},{"../Core/Cartesian3":102,"../Core/Ellipsoid":130,"../Core/IauOrientationAxes":160,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/Simon1994PlanetaryPositions":211,"../Core/Transforms":226,"../Core/buildModuleUrl":239,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"./EllipsoidPrimitive":384,"./Material":404}],416:[function(require,module,exports){
var Color = require('../Core/Color'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), PixelFormat = require('../Core/PixelFormat'), ClearCommand = require('../Renderer/ClearCommand'), PixelDatatype = require('../Renderer/PixelDatatype'), RenderState = require('../Renderer/RenderState'), ShaderSource = require('../Renderer/ShaderSource'), AdjustTranslucentFS = require('../Shaders/AdjustTranslucentFS'), CompositeOITFS = require('../Shaders/CompositeOITFS'), BlendEquation = require('./BlendEquation'), BlendFunction = require('./BlendFunction');
'use strict';
var OIT = function (context) {
    var extensionsSupported = context.floatingPointTexture && context.depthTexture;
    this._translucentMRTSupport = context.drawBuffers && extensionsSupported;
    this._translucentMultipassSupport = !this._translucentMRTSupport && extensionsSupported;
    this._opaqueTexture = undefined;
    this._accumulationTexture = undefined;
    this._depthTexture = undefined;
    this._opaqueFBO = undefined;
    this._translucentFBO = undefined;
    this._alphaFBO = undefined;
    this._adjustTranslucentFBO = undefined;
    this._adjustAlphaFBO = undefined;
    this._opaqueClearCommand = new ClearCommand({
        color: new Color(0, 0, 0, 0),
        owner: this
    });
    this._translucentMRTClearCommand = new ClearCommand({
        color: new Color(0, 0, 0, 1),
        owner: this
    });
    this._translucentMultipassClearCommand = new ClearCommand({
        color: new Color(0, 0, 0, 0),
        owner: this
    });
    this._alphaClearCommand = new ClearCommand({
        color: new Color(1, 1, 1, 1),
        owner: this
    });
    this._translucentRenderStateCache = {};
    this._alphaRenderStateCache = {};
    this._translucentShaderCache = {};
    this._alphaShaderCache = {};
    this._compositeCommand = undefined;
    this._adjustTranslucentCommand = undefined;
    this._adjustAlphaCommand = undefined;
};
function destroyTextures(oit) {
    oit._opaqueTexture = oit._opaqueTexture && !oit._opaqueTexture.isDestroyed() && oit._opaqueTexture.destroy();
    oit._accumulationTexture = oit._accumulationTexture && !oit._accumulationTexture.isDestroyed() && oit._accumulationTexture.destroy();
    oit._revealageTexture = oit._revealageTexture && !oit._revealageTexture.isDestroyed() && oit._revealageTexture.destroy();
    oit._depthTexture = oit._depthTexture && !oit._depthTexture.isDestroyed() && oit._depthTexture.destroy();
}
function destroyFramebuffers(oit) {
    oit._opaqueFBO = oit._opaqueFBO && !oit._opaqueFBO.isDestroyed() && oit._opaqueFBO.destroy();
    oit._translucentFBO = oit._translucentFBO && !oit._translucentFBO.isDestroyed() && oit._translucentFBO.destroy();
    oit._alphaFBO = oit._alphaFBO && !oit._alphaFBO.isDestroyed() && oit._alphaFBO.destroy();
    oit._adjustTranslucentFBO = oit._adjustTranslucentFBO && !oit._adjustTranslucentFBO.isDestroyed() && oit._adjustTranslucentFBO.destroy();
    oit._adjustAlphaFBO = oit._adjustAlphaFBO && !oit._adjustAlphaFBO.isDestroyed() && oit._adjustAlphaFBO.destroy();
}
function destroyResources(oit) {
    destroyTextures(oit);
    destroyFramebuffers(oit);
}
function updateTextures(oit, context, width, height) {
    destroyTextures(oit);
    oit._opaqueTexture = context.createTexture2D({
        width: width,
        height: height,
        pixelFormat: PixelFormat.RGBA,
        pixelDatatype: PixelDatatype.UNSIGNED_BYTE
    });
    oit._accumulationTexture = context.createTexture2D({
        width: width,
        height: height,
        pixelFormat: PixelFormat.RGBA,
        pixelDatatype: PixelDatatype.FLOAT
    });
    oit._revealageTexture = context.createTexture2D({
        width: width,
        height: height,
        pixelFormat: PixelFormat.RGBA,
        pixelDatatype: PixelDatatype.FLOAT
    });
    oit._depthTexture = context.createTexture2D({
        width: width,
        height: height,
        pixelFormat: PixelFormat.DEPTH_COMPONENT,
        pixelDatatype: PixelDatatype.UNSIGNED_SHORT
    });
}
function updateFramebuffers(oit, context) {
    destroyFramebuffers(oit);
    var completeFBO = WebGLRenderingContext.FRAMEBUFFER_COMPLETE;
    var supported = true;
    if (oit._translucentMRTSupport) {
        oit._translucentFBO = context.createFramebuffer({
            colorTextures: [
                oit._accumulationTexture,
                oit._revealageTexture
            ],
            depthTexture: oit._depthTexture,
            destroyAttachments: false
        });
        oit._adjustTranslucentFBO = context.createFramebuffer({
            colorTextures: [
                oit._accumulationTexture,
                oit._revealageTexture
            ],
            destroyAttachments: false
        });
        if (oit._translucentFBO.status !== completeFBO || oit._adjustTranslucentFBO.status !== completeFBO) {
            destroyFramebuffers(oit);
            oit._translucentMRTSupport = false;
        }
    }
    if (!oit._translucentMRTSupport) {
        oit._translucentFBO = context.createFramebuffer({
            colorTextures: [oit._accumulationTexture],
            depthTexture: oit._depthTexture,
            destroyAttachments: false
        });
        oit._alphaFBO = context.createFramebuffer({
            colorTextures: [oit._revealageTexture],
            depthTexture: oit._depthTexture,
            destroyAttachments: false
        });
        oit._adjustTranslucentFBO = context.createFramebuffer({
            colorTextures: [oit._accumulationTexture],
            destroyAttachments: false
        });
        oit._adjustAlphaFBO = context.createFramebuffer({
            colorTextures: [oit._revealageTexture],
            destroyAttachments: false
        });
        var translucentComplete = oit._translucentFBO.status === completeFBO;
        var alphaComplete = oit._alphaFBO.status === completeFBO;
        var adjustTranslucentComplete = oit._adjustTranslucentFBO.status === completeFBO;
        var adjustAlphaComplete = oit._adjustAlphaFBO.status === completeFBO;
        if (!translucentComplete || !alphaComplete || !adjustTranslucentComplete || !adjustAlphaComplete) {
            destroyResources(oit);
            oit._translucentMultipassSupport = false;
            supported = false;
        }
    }
    if (supported) {
        oit._opaqueFBO = context.createFramebuffer({
            colorTextures: [oit._opaqueTexture],
            depthTexture: oit._depthTexture,
            destroyAttachments: false
        });
    }
    return supported;
}
OIT.prototype.update = function (context) {
    if (!this.isSupported()) {
        return;
    }
    var width = context.drawingBufferWidth;
    var height = context.drawingBufferHeight;
    var opaqueTexture = this._opaqueTexture;
    var textureChanged = !defined(opaqueTexture) || opaqueTexture.width !== width || opaqueTexture.height !== height;
    if (textureChanged) {
        updateTextures(this, context, width, height);
    }
    if (!defined(this._opaqueFBO) || textureChanged) {
        if (!updateFramebuffers(this, context)) {
            return;
        }
    }
    var that = this;
    var fs;
    var uniformMap;
    if (!defined(this._compositeCommand)) {
        fs = new ShaderSource({ sources: [CompositeOITFS] });
        if (this._translucentMRTSupport) {
            fs.defines.push('MRT');
        }
        uniformMap = {
            u_opaque: function () {
                return that._opaqueTexture;
            },
            u_accumulation: function () {
                return that._accumulationTexture;
            },
            u_revealage: function () {
                return that._revealageTexture;
            }
        };
        this._compositeCommand = context.createViewportQuadCommand(fs, {
            renderState: context.createRenderState(),
            uniformMap: uniformMap,
            owner: this
        });
    }
    if (!defined(this._adjustTranslucentCommand)) {
        if (this._translucentMRTSupport) {
            fs = new ShaderSource({
                defines: ['MRT'],
                sources: [AdjustTranslucentFS]
            });
            uniformMap = {
                u_bgColor: function () {
                    return that._translucentMRTClearCommand.color;
                },
                u_depthTexture: function () {
                    return that._depthTexture;
                }
            };
            this._adjustTranslucentCommand = context.createViewportQuadCommand(fs, {
                renderState: context.createRenderState(),
                uniformMap: uniformMap,
                owner: this
            });
        } else if (this._translucentMultipassSupport) {
            fs = new ShaderSource({ sources: [AdjustTranslucentFS] });
            uniformMap = {
                u_bgColor: function () {
                    return that._translucentMultipassClearCommand.color;
                },
                u_depthTexture: function () {
                    return that._depthTexture;
                }
            };
            this._adjustTranslucentCommand = context.createViewportQuadCommand(fs, {
                renderState: context.createRenderState(),
                uniformMap: uniformMap,
                owner: this
            });
            uniformMap = {
                u_bgColor: function () {
                    return that._alphaClearCommand.color;
                },
                u_depthTexture: function () {
                    return that._depthTexture;
                }
            };
            this._adjustAlphaCommand = context.createViewportQuadCommand(fs, {
                renderState: context.createRenderState(),
                uniformMap: uniformMap,
                owner: this
            });
        }
    }
};
var translucentMRTBlend = {
        enabled: true,
        color: new Color(0, 0, 0, 0),
        equationRgb: BlendEquation.ADD,
        equationAlpha: BlendEquation.ADD,
        functionSourceRgb: BlendFunction.ONE,
        functionDestinationRgb: BlendFunction.ONE,
        functionSourceAlpha: BlendFunction.ZERO,
        functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA
    };
var translucentColorBlend = {
        enabled: true,
        color: new Color(0, 0, 0, 0),
        equationRgb: BlendEquation.ADD,
        equationAlpha: BlendEquation.ADD,
        functionSourceRgb: BlendFunction.ONE,
        functionDestinationRgb: BlendFunction.ONE,
        functionSourceAlpha: BlendFunction.ONE,
        functionDestinationAlpha: BlendFunction.ONE
    };
var translucentAlphaBlend = {
        enabled: true,
        color: new Color(0, 0, 0, 0),
        equationRgb: BlendEquation.ADD,
        equationAlpha: BlendEquation.ADD,
        functionSourceRgb: BlendFunction.ZERO,
        functionDestinationRgb: BlendFunction.ONE_MINUS_SOURCE_ALPHA,
        functionSourceAlpha: BlendFunction.ZERO,
        functionDestinationAlpha: BlendFunction.ONE_MINUS_SOURCE_ALPHA
    };
function getTranslucentRenderState(context, translucentBlending, cache, renderState) {
    var translucentState = cache[renderState.id];
    if (!defined(translucentState)) {
        var rs = RenderState.clone(renderState);
        rs.depthMask = false;
        rs.blending = translucentBlending;
        translucentState = context.createRenderState(rs);
        cache[renderState.id] = translucentState;
    }
    return translucentState;
}
function getTranslucentMRTRenderState(oit, context, renderState) {
    return getTranslucentRenderState(context, translucentMRTBlend, oit._translucentRenderStateCache, renderState);
}
function getTranslucentColorRenderState(oit, context, renderState) {
    return getTranslucentRenderState(context, translucentColorBlend, oit._translucentRenderStateCache, renderState);
}
function getTranslucentAlphaRenderState(oit, context, renderState) {
    return getTranslucentRenderState(context, translucentAlphaBlend, oit._alphaRenderStateCache, renderState);
}
var mrtShaderSource = '    vec3 Ci = czm_gl_FragColor.rgb * czm_gl_FragColor.a;\n' + '    float ai = czm_gl_FragColor.a;\n' + '    float wzi = czm_alphaWeight(ai);\n' + '    gl_FragData[0] = vec4(Ci * wzi, ai);\n' + '    gl_FragData[1] = vec4(ai * wzi);\n';
var colorShaderSource = '    vec3 Ci = czm_gl_FragColor.rgb * czm_gl_FragColor.a;\n' + '    float ai = czm_gl_FragColor.a;\n' + '    float wzi = czm_alphaWeight(ai);\n' + '    gl_FragColor = vec4(Ci, ai) * wzi;\n';
var alphaShaderSource = '    float ai = czm_gl_FragColor.a;\n' + '    gl_FragColor = vec4(ai);\n';
function getTranslucentShaderProgram(context, shaderProgram, cache, source) {
    var id = shaderProgram.id;
    var shader = cache[id];
    if (!defined(shader)) {
        var attributeLocations = shaderProgram._attributeLocations;
        var fs = shaderProgram.fragmentShaderSource.clone();
        fs.sources = fs.sources.map(function (source) {
            source = source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, 'void czm_translucent_main()');
            source = source.replace(/gl_FragColor/g, 'czm_gl_FragColor');
            source = source.replace(/\bdiscard\b/g, 'czm_discard = true');
            source = source.replace(/czm_phong/g, 'czm_translucentPhong');
            return source;
        });
        fs.sources.splice(0, 0, (source.indexOf('gl_FragData') !== -1 ? '#extension GL_EXT_draw_buffers : enable \n' : '') + 'vec4 czm_gl_FragColor;\n' + 'bool czm_discard = false;\n');
        fs.sources.push('void main()\n' + '{\n' + '    czm_translucent_main();\n' + '    if (czm_discard)\n' + '    {\n' + '        discard;\n' + '    }\n' + source + '}\n');
        shader = context.createShaderProgram(shaderProgram.vertexShaderSource, fs, attributeLocations);
        cache[id] = shader;
    }
    return shader;
}
function getTranslucentMRTShaderProgram(oit, context, shaderProgram) {
    return getTranslucentShaderProgram(context, shaderProgram, oit._translucentShaderCache, mrtShaderSource);
}
function getTranslucentColorShaderProgram(oit, context, shaderProgram) {
    return getTranslucentShaderProgram(context, shaderProgram, oit._translucentShaderCache, colorShaderSource);
}
function getTranslucentAlphaShaderProgram(oit, context, shaderProgram) {
    return getTranslucentShaderProgram(context, shaderProgram, oit._alphaShaderCache, alphaShaderSource);
}
function executeTranslucentCommandsSortedMultipass(oit, scene, executeFunction, passState, commands) {
    var command;
    var renderState;
    var shaderProgram;
    var j;
    var context = scene.context;
    var framebuffer = passState.framebuffer;
    var length = commands.length;
    passState.framebuffer = oit._adjustTranslucentFBO;
    oit._adjustTranslucentCommand.execute(context, passState);
    passState.framebuffer = oit._adjustAlphaFBO;
    oit._adjustAlphaCommand.execute(context, passState);
    var debugFramebuffer = oit._opaqueFBO;
    passState.framebuffer = oit._translucentFBO;
    for (j = 0; j < length; ++j) {
        command = commands[j];
        if (!defined(command.oit) || command.shaderProgram.id !== command.oit.shaderProgramId) {
            command.oit = {
                colorRenderState: getTranslucentColorRenderState(oit, context, command.renderState),
                alphaRenderState: getTranslucentAlphaRenderState(oit, context, command.renderState),
                colorShaderProgram: getTranslucentColorShaderProgram(oit, context, command.shaderProgram),
                alphaShaderProgram: getTranslucentAlphaShaderProgram(oit, context, command.shaderProgram),
                shaderProgramId: command.shaderProgram.id
            };
        }
        renderState = command.oit.colorRenderState;
        shaderProgram = command.oit.colorShaderProgram;
        executeFunction(command, scene, context, passState, renderState, shaderProgram, debugFramebuffer);
    }
    passState.framebuffer = oit._alphaFBO;
    for (j = 0; j < length; ++j) {
        command = commands[j];
        renderState = command.oit.alphaRenderState;
        shaderProgram = command.oit.alphaShaderProgram;
        executeFunction(command, scene, context, passState, renderState, shaderProgram, debugFramebuffer);
    }
    passState.framebuffer = framebuffer;
}
function executeTranslucentCommandsSortedMRT(oit, scene, executeFunction, passState, commands) {
    var context = scene.context;
    var framebuffer = passState.framebuffer;
    var length = commands.length;
    passState.framebuffer = oit._adjustTranslucentFBO;
    oit._adjustTranslucentCommand.execute(context, passState);
    var debugFramebuffer = oit._opaqueFBO;
    passState.framebuffer = oit._translucentFBO;
    for (var j = 0; j < length; ++j) {
        var command = commands[j];
        if (!defined(command.oit) || command.shaderProgram.id !== command.oit.shaderProgramId) {
            command.oit = {
                translucentRenderState: getTranslucentMRTRenderState(oit, context, command.renderState),
                translucentShaderProgram: getTranslucentMRTShaderProgram(oit, context, command.shaderProgram),
                shaderProgramId: command.shaderProgram.id
            };
        }
        var renderState = command.oit.translucentRenderState;
        var shaderProgram = command.oit.translucentShaderProgram;
        executeFunction(command, scene, context, passState, renderState, shaderProgram, debugFramebuffer);
    }
    passState.framebuffer = framebuffer;
}
OIT.prototype.executeCommands = function (scene, executeFunction, passState, commands) {
    if (this._translucentMRTSupport) {
        executeTranslucentCommandsSortedMRT(this, scene, executeFunction, passState, commands);
        return;
    }
    executeTranslucentCommandsSortedMultipass(this, scene, executeFunction, passState, commands);
};
OIT.prototype.execute = function (context, passState) {
    this._compositeCommand.execute(context, passState);
};
OIT.prototype.clear = function (context, passState, clearColor) {
    var framebuffer = passState.framebuffer;
    passState.framebuffer = this._opaqueFBO;
    Color.clone(clearColor, this._opaqueClearCommand.color);
    this._opaqueClearCommand.execute(context, passState);
    passState.framebuffer = this._translucentFBO;
    var translucentClearCommand = this._translucentMRTSupport ? this._translucentMRTClearCommand : this._translucentMultipassClearCommand;
    translucentClearCommand.execute(context, passState);
    if (this._translucentMultipassSupport) {
        passState.framebuffer = this._alphaFBO;
        this._alphaClearCommand.execute(context, passState);
    }
    passState.framebuffer = framebuffer;
};
OIT.prototype.getColorFramebuffer = function () {
    return this._opaqueFBO;
};
OIT.prototype.isSupported = function () {
    return this._translucentMRTSupport || this._translucentMultipassSupport;
};
OIT.prototype.isDestroyed = function () {
    return false;
};
OIT.prototype.destroy = function () {
    destroyResources(this);
    if (defined(this._compositeCommand)) {
        this._compositeCommand.shaderProgram = this._compositeCommand.shaderProgram && this._compositeCommand.shaderProgram.destroy();
    }
    if (defined(this._adjustTranslucentCommand)) {
        this._adjustTranslucentCommand.shaderProgram = this._adjustTranslucentCommand.shaderProgram && this._adjustTranslucentCommand.shaderProgram.destroy();
    }
    if (defined(this._adjustAlphaCommand)) {
        this._adjustAlphaCommand.shaderProgram = this._adjustAlphaCommand.shaderProgram && this._adjustAlphaCommand.shaderProgram.destroy();
    }
    var name;
    var cache = this._translucentShaderCache;
    for (name in cache) {
        if (cache.hasOwnProperty(name) && defined(cache[name])) {
            cache[name].destroy();
        }
    }
    this._translucentShaderCache = {};
    cache = this._alphaShaderCache;
    for (name in cache) {
        if (cache.hasOwnProperty(name) && defined(cache[name])) {
            cache[name].destroy();
        }
    }
    this._alphaShaderCache = {};
    return destroyObject(this);
};
module.exports = OIT;
},{"../Core/Color":111,"../Core/PixelFormat":181,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/ClearCommand":340,"../Renderer/PixelDatatype":349,"../Renderer/RenderState":350,"../Renderer/ShaderSource":355,"../Shaders/AdjustTranslucentFS":458,"../Shaders/CompositeOITFS":547,"./BlendEquation":372,"./BlendFunction":373}],417:[function(require,module,exports){
var Credit = require('../Core/Credit'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), Rectangle = require('../Core/Rectangle'), WebMercatorTilingScheme = require('../Core/WebMercatorTilingScheme'), ImageryProvider = require('./ImageryProvider');
'use strict';
var trailingSlashRegex = /\/$/;
var defaultCredit = new Credit('MapQuest, Open Street Map and contributors, CC-BY-SA');
var OpenStreetMapImageryProvider = function OpenStreetMapImageryProvider(options) {
    options = defaultValue(options, {});
    var url = defaultValue(options.url, '//a.tile.openstreetmap.org/');
    if (!trailingSlashRegex.test(url)) {
        url = url + '/';
    }
    this._url = url;
    this._fileExtension = defaultValue(options.fileExtension, 'png');
    this._proxy = options.proxy;
    this._tileDiscardPolicy = options.tileDiscardPolicy;
    this._tilingScheme = new WebMercatorTilingScheme();
    this._tileWidth = 256;
    this._tileHeight = 256;
    this._minimumLevel = defaultValue(options.minimumLevel, 0);
    this._maximumLevel = defaultValue(options.maximumLevel, 18);
    this._rectangle = defaultValue(options.rectangle, this._tilingScheme.rectangle);
    var swTile = this._tilingScheme.positionToTileXY(Rectangle.southwest(this._rectangle), this._minimumLevel);
    var neTile = this._tilingScheme.positionToTileXY(Rectangle.northeast(this._rectangle), this._minimumLevel);
    var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
    if (tileCount > 4) {
        throw new DeveloperError('The imagery provider\'s rectangle and minimumLevel indicate that there are ' + tileCount + ' tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.');
    }
    this._errorEvent = new Event();
    this._ready = true;
    var credit = defaultValue(options.credit, defaultCredit);
    if (typeof credit === 'string') {
        credit = new Credit(credit);
    }
    this._credit = credit;
};
function buildImageUrl(imageryProvider, x, y, level) {
    var url = imageryProvider._url + level + '/' + x + '/' + y + '.' + imageryProvider._fileExtension;
    var proxy = imageryProvider._proxy;
    if (defined(proxy)) {
        url = proxy.getURL(url);
    }
    return url;
}
defineProperties(OpenStreetMapImageryProvider.prototype, {
    url: {
        get: function () {
            return this._url;
        }
    },
    proxy: {
        get: function () {
            return this._proxy;
        }
    },
    tileWidth: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            return this._tileWidth;
        }
    },
    tileHeight: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            return this._tileHeight;
        }
    },
    maximumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            return this._maximumLevel;
        }
    },
    minimumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            return this._minimumLevel;
        }
    },
    tilingScheme: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            return this._tilingScheme;
        }
    },
    rectangle: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
            }
            return this._rectangle;
        }
    },
    tileDiscardPolicy: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            return this._tileDiscardPolicy;
        }
    },
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    credit: {
        get: function () {
            return this._credit;
        }
    },
    hasAlphaChannel: {
        get: function () {
            return true;
        }
    }
});
OpenStreetMapImageryProvider.prototype.getTileCredits = function (x, y, level) {
    return undefined;
};
OpenStreetMapImageryProvider.prototype.requestImage = function (x, y, level) {
    if (!this._ready) {
        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }
    var url = buildImageUrl(this, x, y, level);
    return ImageryProvider.loadImage(this, url);
};
OpenStreetMapImageryProvider.prototype.pickFeatures = function () {
    return undefined;
};
module.exports = OpenStreetMapImageryProvider;
},{"../Core/Credit":118,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/Rectangle":201,"../Core/WebMercatorTilingScheme":234,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./ImageryProvider":399}],418:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Matrix4 = require('../Core/Matrix4'), CullingVolume = require('./CullingVolume');
'use strict';
var OrthographicFrustum = function () {
    this.left = undefined;
    this._left = undefined;
    this.right = undefined;
    this._right = undefined;
    this.top = undefined;
    this._top = undefined;
    this.bottom = undefined;
    this._bottom = undefined;
    this.near = 1;
    this._near = this.near;
    this.far = 500000000;
    this._far = this.far;
    this._cullingVolume = new CullingVolume();
    this._orthographicMatrix = new Matrix4();
};
function update(frustum) {
    if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {
        throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
    }
    if (frustum.top !== frustum._top || frustum.bottom !== frustum._bottom || frustum.left !== frustum._left || frustum.right !== frustum._right || frustum.near !== frustum._near || frustum.far !== frustum._far) {
        if (frustum.left > frustum.right) {
            throw new DeveloperError('right must be greater than left.');
        }
        if (frustum.bottom > frustum.top) {
            throw new DeveloperError('top must be greater than bottom.');
        }
        if (frustum.near <= 0 || frustum.near > frustum.far) {
            throw new DeveloperError('near must be greater than zero and less than far.');
        }
        frustum._left = frustum.left;
        frustum._right = frustum.right;
        frustum._top = frustum.top;
        frustum._bottom = frustum.bottom;
        frustum._near = frustum.near;
        frustum._far = frustum.far;
        frustum._orthographicMatrix = Matrix4.computeOrthographicOffCenter(frustum.left, frustum.right, frustum.bottom, frustum.top, frustum.near, frustum.far, frustum._orthographicMatrix);
    }
}
defineProperties(OrthographicFrustum.prototype, {
    projectionMatrix: {
        get: function () {
            update(this);
            return this._orthographicMatrix;
        }
    }
});
var getPlanesRight = new Cartesian3();
var getPlanesNearCenter = new Cartesian3();
var getPlanesPoint = new Cartesian3();
var negateScratch = new Cartesian3();
OrthographicFrustum.prototype.computeCullingVolume = function (position, direction, up) {
    if (!defined(position)) {
        throw new DeveloperError('position is required.');
    }
    if (!defined(direction)) {
        throw new DeveloperError('direction is required.');
    }
    if (!defined(up)) {
        throw new DeveloperError('up is required.');
    }
    var planes = this._cullingVolume.planes;
    var t = this.top;
    var b = this.bottom;
    var r = this.right;
    var l = this.left;
    var n = this.near;
    var f = this.far;
    var right = Cartesian3.cross(direction, up, getPlanesRight);
    var nearCenter = getPlanesNearCenter;
    Cartesian3.multiplyByScalar(direction, n, nearCenter);
    Cartesian3.add(position, nearCenter, nearCenter);
    var point = getPlanesPoint;
    Cartesian3.multiplyByScalar(right, l, point);
    Cartesian3.add(nearCenter, point, point);
    var plane = planes[0];
    if (!defined(plane)) {
        plane = planes[0] = new Cartesian4();
    }
    plane.x = right.x;
    plane.y = right.y;
    plane.z = right.z;
    plane.w = -Cartesian3.dot(right, point);
    Cartesian3.multiplyByScalar(right, r, point);
    Cartesian3.add(nearCenter, point, point);
    plane = planes[1];
    if (!defined(plane)) {
        plane = planes[1] = new Cartesian4();
    }
    plane.x = -right.x;
    plane.y = -right.y;
    plane.z = -right.z;
    plane.w = -Cartesian3.dot(Cartesian3.negate(right, negateScratch), point);
    Cartesian3.multiplyByScalar(up, b, point);
    Cartesian3.add(nearCenter, point, point);
    plane = planes[2];
    if (!defined(plane)) {
        plane = planes[2] = new Cartesian4();
    }
    plane.x = up.x;
    plane.y = up.y;
    plane.z = up.z;
    plane.w = -Cartesian3.dot(up, point);
    Cartesian3.multiplyByScalar(up, t, point);
    Cartesian3.add(nearCenter, point, point);
    plane = planes[3];
    if (!defined(plane)) {
        plane = planes[3] = new Cartesian4();
    }
    plane.x = -up.x;
    plane.y = -up.y;
    plane.z = -up.z;
    plane.w = -Cartesian3.dot(Cartesian3.negate(up, negateScratch), point);
    plane = planes[4];
    if (!defined(plane)) {
        plane = planes[4] = new Cartesian4();
    }
    plane.x = direction.x;
    plane.y = direction.y;
    plane.z = direction.z;
    plane.w = -Cartesian3.dot(direction, nearCenter);
    Cartesian3.multiplyByScalar(direction, f, point);
    Cartesian3.add(position, point, point);
    plane = planes[5];
    if (!defined(plane)) {
        plane = planes[5] = new Cartesian4();
    }
    plane.x = -direction.x;
    plane.y = -direction.y;
    plane.z = -direction.z;
    plane.w = -Cartesian3.dot(Cartesian3.negate(direction, negateScratch), point);
    return this._cullingVolume;
};
OrthographicFrustum.prototype.getPixelSize = function (drawingBufferDimensions, distance, result) {
    update(this);
    if (!defined(drawingBufferDimensions)) {
        throw new DeveloperError('drawingBufferDimensions is required.');
    }
    if (drawingBufferDimensions.x <= 0) {
        throw new DeveloperError('drawingBufferDimensions.x must be greater than zero.');
    }
    if (drawingBufferDimensions.y <= 0) {
        throw new DeveloperError('drawingBufferDimensions.y must be greater than zero.');
    }
    var frustumWidth = this.right - this.left;
    var frustumHeight = this.top - this.bottom;
    var pixelWidth = frustumWidth / drawingBufferDimensions.x;
    var pixelHeight = frustumHeight / drawingBufferDimensions.y;
    if (!defined(result)) {
        return new Cartesian2(pixelWidth, pixelHeight);
    }
    result.x = pixelWidth;
    result.y = pixelHeight;
    return result;
};
OrthographicFrustum.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new OrthographicFrustum();
    }
    result.left = this.left;
    result.right = this.right;
    result.top = this.top;
    result.bottom = this.bottom;
    result.near = this.near;
    result.far = this.far;
    result._left = undefined;
    result._right = undefined;
    result._top = undefined;
    result._bottom = undefined;
    result._near = undefined;
    result._far = undefined;
    return result;
};
OrthographicFrustum.prototype.equals = function (other) {
    return defined(other) && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
};
module.exports = OrthographicFrustum;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/DeveloperError":123,"../Core/Matrix4":177,"../Core/defineProperties":244,"../Core/defined":245,"./CullingVolume":381}],419:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var Pass = {
        OPAQUE: 0,
        TRANSLUCENT: 1,
        OVERLAY: 2
    };
module.exports = freezeObject(Pass);
},{"../Core/freezeObject":249}],420:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defineProperties = require('../Core/defineProperties'), VertexFormat = require('../Core/VertexFormat'), PerInstanceColorAppearanceFS = require('../Shaders/Appearances/PerInstanceColorAppearanceFS'), PerInstanceColorAppearanceVS = require('../Shaders/Appearances/PerInstanceColorAppearanceVS'), PerInstanceFlatColorAppearanceFS = require('../Shaders/Appearances/PerInstanceFlatColorAppearanceFS'), PerInstanceFlatColorAppearanceVS = require('../Shaders/Appearances/PerInstanceFlatColorAppearanceVS'), Appearance = require('./Appearance');
'use strict';
var PerInstanceColorAppearance = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var translucent = defaultValue(options.translucent, true);
    var closed = defaultValue(options.closed, false);
    var flat = defaultValue(options.flat, false);
    var vs = flat ? PerInstanceFlatColorAppearanceVS : PerInstanceColorAppearanceVS;
    var fs = flat ? PerInstanceFlatColorAppearanceFS : PerInstanceColorAppearanceFS;
    var vertexFormat = flat ? PerInstanceColorAppearance.FLAT_VERTEX_FORMAT : PerInstanceColorAppearance.VERTEX_FORMAT;
    this.material = undefined;
    this.translucent = translucent;
    this._vertexShaderSource = defaultValue(options.vertexShaderSource, vs);
    this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, fs);
    this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);
    this._closed = closed;
    this._vertexFormat = vertexFormat;
    this._flat = flat;
    this._faceForward = defaultValue(options.faceForward, !closed);
};
defineProperties(PerInstanceColorAppearance.prototype, {
    vertexShaderSource: {
        get: function () {
            return this._vertexShaderSource;
        }
    },
    fragmentShaderSource: {
        get: function () {
            return this._fragmentShaderSource;
        }
    },
    renderState: {
        get: function () {
            return this._renderState;
        }
    },
    closed: {
        get: function () {
            return this._closed;
        }
    },
    vertexFormat: {
        get: function () {
            return this._vertexFormat;
        }
    },
    flat: {
        get: function () {
            return this._flat;
        }
    },
    faceForward: {
        get: function () {
            return this._faceForward;
        }
    }
});
PerInstanceColorAppearance.VERTEX_FORMAT = VertexFormat.POSITION_AND_NORMAL;
PerInstanceColorAppearance.FLAT_VERTEX_FORMAT = VertexFormat.POSITION_ONLY;
PerInstanceColorAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;
PerInstanceColorAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;
PerInstanceColorAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;
module.exports = PerInstanceColorAppearance;
},{"../Core/VertexFormat":228,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Shaders/Appearances/PerInstanceColorAppearanceFS":465,"../Shaders/Appearances/PerInstanceColorAppearanceVS":466,"../Shaders/Appearances/PerInstanceFlatColorAppearanceFS":467,"../Shaders/Appearances/PerInstanceFlatColorAppearanceVS":468,"./Appearance":366}],421:[function(require,module,exports){
var Color = require('../Core/Color'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), getTimestamp = require('../Core/getTimestamp'), getElement = require('../Widgets/getElement');
'use strict';
var defaultFpsColor = Color.fromCssColorString('#e52');
var defaultFrameTimeColor = Color.fromCssColorString('#de3');
var defaultBackgroundColor = Color.fromCssColorString('rgba(40, 40, 40, 0.7)');
var PerformanceDisplay = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var container = getElement(options.container);
    if (!defined(container)) {
        throw new DeveloperError('container is required');
    }
    this._container = container;
    this._fpsColor = defaultValue(options.fpsColor, defaultFpsColor).toCssColorString();
    this._frameTimeColor = defaultValue(options.frameTimeColor, defaultFrameTimeColor).toCssColorString();
    this._backgroundColor = defaultValue(options.backgroundColor, defaultBackgroundColor).toCssColorString();
    this._font = defaultValue(options.font, 'bold 12px Helvetica,Arial,sans-serif');
    var display = document.createElement('div');
    var fpsElement = document.createElement('div');
    this._fpsText = document.createTextNode('');
    fpsElement.appendChild(this._fpsText);
    fpsElement.style.color = this._fpsColor;
    var msElement = document.createElement('div');
    this._msText = document.createTextNode('');
    msElement.style.color = this._frameTimeColor;
    msElement.appendChild(this._msText);
    display.appendChild(fpsElement);
    display.appendChild(msElement);
    display.style['z-index'] = 1;
    display.style['background-color'] = this._backgroundColor;
    display.style.font = this._font;
    display.style.padding = '7px';
    display.style['border-radius'] = '5px';
    display.style.border = '1px solid #444';
    this._container.appendChild(display);
    this._lastFpsSampleTime = undefined;
    this._frameCount = 0;
    this._time = undefined;
    this._fps = 0;
    this._frameTime = 0;
};
PerformanceDisplay.prototype.update = function () {
    if (!defined(this._time)) {
        this._lastFpsSampleTime = getTimestamp();
        this._time = getTimestamp();
        return;
    }
    var previousTime = this._time;
    var time = getTimestamp();
    this._time = time;
    var frameTime = time - previousTime;
    this._frameCount++;
    var fps = this._fps;
    var fpsElapsedTime = time - this._lastFpsSampleTime;
    if (fpsElapsedTime > 1000) {
        fps = this._frameCount * 1000 / fpsElapsedTime | 0;
        this._lastFpsSampleTime = time;
        this._frameCount = 0;
    }
    if (fps !== this._fps) {
        this._fpsText.nodeValue = fps + ' FPS';
        this._fps = fps;
    }
    if (frameTime !== this._frameTime) {
        this._msText.nodeValue = frameTime.toFixed(2) + ' MS';
        this._frameTime = frameTime;
    }
};
PerformanceDisplay.prototype.destroy = function () {
    return destroyObject(this);
};
module.exports = PerformanceDisplay;
},{"../Core/Color":111,"../Core/DeveloperError":123,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"../Core/getTimestamp":252,"../Widgets/getElement":628}],422:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), PerspectiveOffCenterFrustum = require('./PerspectiveOffCenterFrustum');
'use strict';
var PerspectiveFrustum = function () {
    this._offCenterFrustum = new PerspectiveOffCenterFrustum();
    this.fov = undefined;
    this._fov = undefined;
    this._fovy = undefined;
    this.aspectRatio = undefined;
    this._aspectRatio = undefined;
    this.near = 1;
    this._near = this.near;
    this.far = 500000000;
    this._far = this.far;
};
function update(frustum) {
    if (!defined(frustum.fov) || !defined(frustum.aspectRatio) || !defined(frustum.near) || !defined(frustum.far)) {
        throw new DeveloperError('fov, aspectRatio, near, or far parameters are not set.');
    }
    var f = frustum._offCenterFrustum;
    if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far) {
        if (frustum.fov < 0 || frustum.fov >= Math.PI) {
            throw new DeveloperError('fov must be in the range [0, PI).');
        }
        if (frustum.aspectRatio < 0) {
            throw new DeveloperError('aspectRatio must be positive.');
        }
        if (frustum.near < 0 || frustum.near > frustum.far) {
            throw new DeveloperError('near must be greater than zero and less than far.');
        }
        frustum._aspectRatio = frustum.aspectRatio;
        frustum._fov = frustum.fov;
        frustum._fovy = frustum.aspectRatio <= 1 ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2;
        frustum._near = frustum.near;
        frustum._far = frustum.far;
        f.top = frustum.near * Math.tan(0.5 * frustum._fovy);
        f.bottom = -f.top;
        f.right = frustum.aspectRatio * f.top;
        f.left = -f.right;
        f.near = frustum.near;
        f.far = frustum.far;
    }
}
defineProperties(PerspectiveFrustum.prototype, {
    projectionMatrix: {
        get: function () {
            update(this);
            return this._offCenterFrustum.projectionMatrix;
        }
    },
    infiniteProjectionMatrix: {
        get: function () {
            update(this);
            return this._offCenterFrustum.infiniteProjectionMatrix;
        }
    },
    fovy: {
        get: function () {
            update(this);
            return this._fovy;
        }
    }
});
PerspectiveFrustum.prototype.computeCullingVolume = function (position, direction, up) {
    update(this);
    return this._offCenterFrustum.computeCullingVolume(position, direction, up);
};
PerspectiveFrustum.prototype.getPixelSize = function (drawingBufferDimensions, distance, result) {
    update(this);
    return this._offCenterFrustum.getPixelSize(drawingBufferDimensions, distance, result);
};
PerspectiveFrustum.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new PerspectiveFrustum();
    }
    result.aspectRatio = this.aspectRatio;
    result.fov = this.fov;
    result.near = this.near;
    result.far = this.far;
    result._aspectRatio = undefined;
    result._fov = undefined;
    result._near = undefined;
    result._far = undefined;
    this._offCenterFrustum.clone(result._offCenterFrustum);
    return result;
};
PerspectiveFrustum.prototype.equals = function (other) {
    if (!defined(other)) {
        return false;
    }
    update(this);
    update(other);
    return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);
};
module.exports = PerspectiveFrustum;
},{"../Core/DeveloperError":123,"../Core/defineProperties":244,"../Core/defined":245,"./PerspectiveOffCenterFrustum":423}],423:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Matrix4 = require('../Core/Matrix4'), CullingVolume = require('./CullingVolume');
'use strict';
var PerspectiveOffCenterFrustum = function () {
    this.left = undefined;
    this._left = undefined;
    this.right = undefined;
    this._right = undefined;
    this.top = undefined;
    this._top = undefined;
    this.bottom = undefined;
    this._bottom = undefined;
    this.near = 1;
    this._near = this.near;
    this.far = 500000000;
    this._far = this.far;
    this._cullingVolume = new CullingVolume();
    this._perspectiveMatrix = new Matrix4();
    this._infinitePerspective = new Matrix4();
};
function update(frustum) {
    if (!defined(frustum.right) || !defined(frustum.left) || !defined(frustum.top) || !defined(frustum.bottom) || !defined(frustum.near) || !defined(frustum.far)) {
        throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');
    }
    var t = frustum.top;
    var b = frustum.bottom;
    var r = frustum.right;
    var l = frustum.left;
    var n = frustum.near;
    var f = frustum.far;
    if (t !== frustum._top || b !== frustum._bottom || l !== frustum._left || r !== frustum._right || n !== frustum._near || f !== frustum._far) {
        if (frustum.near <= 0 || frustum.near > frustum.far) {
            throw new DeveloperError('near must be greater than zero and less than far.');
        }
        frustum._left = l;
        frustum._right = r;
        frustum._top = t;
        frustum._bottom = b;
        frustum._near = n;
        frustum._far = f;
        frustum._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f, frustum._perspectiveMatrix);
        frustum._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n, frustum._infinitePerspective);
    }
}
defineProperties(PerspectiveOffCenterFrustum.prototype, {
    projectionMatrix: {
        get: function () {
            update(this);
            return this._perspectiveMatrix;
        }
    },
    infiniteProjectionMatrix: {
        get: function () {
            update(this);
            return this._infinitePerspective;
        }
    }
});
var getPlanesRight = new Cartesian3();
var getPlanesNearCenter = new Cartesian3();
var getPlanesFarCenter = new Cartesian3();
var getPlanesNormal = new Cartesian3();
PerspectiveOffCenterFrustum.prototype.computeCullingVolume = function (position, direction, up) {
    if (!defined(position)) {
        throw new DeveloperError('position is required.');
    }
    if (!defined(direction)) {
        throw new DeveloperError('direction is required.');
    }
    if (!defined(up)) {
        throw new DeveloperError('up is required.');
    }
    var planes = this._cullingVolume.planes;
    var t = this.top;
    var b = this.bottom;
    var r = this.right;
    var l = this.left;
    var n = this.near;
    var f = this.far;
    var right = Cartesian3.cross(direction, up, getPlanesRight);
    var nearCenter = getPlanesNearCenter;
    Cartesian3.multiplyByScalar(direction, n, nearCenter);
    Cartesian3.add(position, nearCenter, nearCenter);
    var farCenter = getPlanesFarCenter;
    Cartesian3.multiplyByScalar(direction, f, farCenter);
    Cartesian3.add(position, farCenter, farCenter);
    var normal = getPlanesNormal;
    Cartesian3.multiplyByScalar(right, l, normal);
    Cartesian3.add(nearCenter, normal, normal);
    Cartesian3.subtract(normal, position, normal);
    Cartesian3.normalize(normal, normal);
    Cartesian3.cross(normal, up, normal);
    var plane = planes[0];
    if (!defined(plane)) {
        plane = planes[0] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, position);
    Cartesian3.multiplyByScalar(right, r, normal);
    Cartesian3.add(nearCenter, normal, normal);
    Cartesian3.subtract(normal, position, normal);
    Cartesian3.normalize(normal, normal);
    Cartesian3.cross(up, normal, normal);
    plane = planes[1];
    if (!defined(plane)) {
        plane = planes[1] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, position);
    Cartesian3.multiplyByScalar(up, b, normal);
    Cartesian3.add(nearCenter, normal, normal);
    Cartesian3.subtract(normal, position, normal);
    Cartesian3.normalize(normal, normal);
    Cartesian3.cross(right, normal, normal);
    plane = planes[2];
    if (!defined(plane)) {
        plane = planes[2] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, position);
    Cartesian3.multiplyByScalar(up, t, normal);
    Cartesian3.add(nearCenter, normal, normal);
    Cartesian3.subtract(normal, position, normal);
    Cartesian3.normalize(normal, normal);
    Cartesian3.cross(normal, right, normal);
    plane = planes[3];
    if (!defined(plane)) {
        plane = planes[3] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, position);
    plane = planes[4];
    if (!defined(plane)) {
        plane = planes[4] = new Cartesian4();
    }
    plane.x = direction.x;
    plane.y = direction.y;
    plane.z = direction.z;
    plane.w = -Cartesian3.dot(direction, nearCenter);
    Cartesian3.negate(direction, normal);
    plane = planes[5];
    if (!defined(plane)) {
        plane = planes[5] = new Cartesian4();
    }
    plane.x = normal.x;
    plane.y = normal.y;
    plane.z = normal.z;
    plane.w = -Cartesian3.dot(normal, farCenter);
    return this._cullingVolume;
};
PerspectiveOffCenterFrustum.prototype.getPixelSize = function (drawingBufferDimensions, distance, result) {
    update(this);
    if (!defined(drawingBufferDimensions)) {
        throw new DeveloperError('drawingBufferDimensions is required.');
    }
    var width = drawingBufferDimensions.x;
    var height = drawingBufferDimensions.y;
    if (width <= 0) {
        throw new DeveloperError('drawingBufferDimensions.x must be greater than zero.');
    }
    if (height <= 0) {
        throw new DeveloperError('drawingBufferDimensions.y must be greater than zero.');
    }
    distance = defaultValue(distance, this.near);
    var inverseNear = 1 / this.near;
    var tanTheta = this.top * inverseNear;
    var pixelHeight = 2 * distance * tanTheta / height;
    tanTheta = this.right * inverseNear;
    var pixelWidth = 2 * distance * tanTheta / width;
    if (!defined(result)) {
        return new Cartesian2(pixelWidth, pixelHeight);
    }
    result.x = pixelWidth;
    result.y = pixelHeight;
    return result;
};
PerspectiveOffCenterFrustum.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new PerspectiveOffCenterFrustum();
    }
    result.right = this.right;
    result.left = this.left;
    result.top = this.top;
    result.bottom = this.bottom;
    result.near = this.near;
    result.far = this.far;
    result._left = undefined;
    result._right = undefined;
    result._top = undefined;
    result._bottom = undefined;
    result._near = undefined;
    result._far = undefined;
    return result;
};
PerspectiveOffCenterFrustum.prototype.equals = function (other) {
    return defined(other) && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;
};
module.exports = PerspectiveOffCenterFrustum;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/DeveloperError":123,"../Core/Matrix4":177,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./CullingVolume":381}],424:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Matrix4 = require('../Core/Matrix4'), PolylinePipeline = require('../Core/PolylinePipeline'), Material = require('./Material');
'use strict';
var Polyline = function (options, polylineCollection) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._show = defaultValue(options.show, true);
    this._width = defaultValue(options.width, 1);
    this._loop = defaultValue(options.loop, false);
    this._material = options.material;
    if (!defined(this._material)) {
        this._material = Material.fromType(Material.ColorType, { color: new Color(1, 1, 1, 1) });
    }
    var positions = options.positions;
    if (!defined(positions)) {
        positions = [];
    }
    this._positions = positions;
    this._actualPositions = PolylinePipeline.removeDuplicates(positions);
    if (!defined(this._actualPositions)) {
        this._actualPositions = positions;
    }
    if (this._loop && this._actualPositions.length > 2) {
        if (this._actualPositions === this._positions) {
            this._actualPositions = positions.slice();
        }
        this._actualPositions.push(Cartesian3.clone(this._actualPositions[0]));
    }
    this._length = this._actualPositions.length;
    this._id = options.id;
    var modelMatrix;
    if (defined(polylineCollection)) {
        modelMatrix = Matrix4.clone(polylineCollection.modelMatrix);
    }
    this._modelMatrix = modelMatrix;
    this._segments = PolylinePipeline.wrapLongitude(this._actualPositions, modelMatrix);
    this._actualLength = undefined;
    this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
    this._polylineCollection = polylineCollection;
    this._dirty = false;
    this._pickId = undefined;
    this._boundingVolume = BoundingSphere.fromPoints(this._actualPositions);
    this._boundingVolumeWC = BoundingSphere.transform(this._boundingVolume, this._modelMatrix);
    this._boundingVolume2D = new BoundingSphere();
};
var SHOW_INDEX = Polyline.SHOW_INDEX = 0;
var WIDTH_INDEX = Polyline.WIDTH_INDEX = 1;
var POSITION_INDEX = Polyline.POSITION_INDEX = 2;
var MATERIAL_INDEX = Polyline.MATERIAL_INDEX = 3;
var POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX = 4;
var NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES = 5;
function makeDirty(polyline, propertyChanged) {
    ++polyline._propertiesChanged[propertyChanged];
    var polylineCollection = polyline._polylineCollection;
    if (defined(polylineCollection)) {
        polylineCollection._updatePolyline(polyline, propertyChanged);
        polyline._dirty = true;
    }
}
defineProperties(Polyline.prototype, {
    show: {
        get: function () {
            return this._show;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (value !== this._show) {
                this._show = value;
                makeDirty(this, SHOW_INDEX);
            }
        }
    },
    positions: {
        get: function () {
            return this._positions;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var positions = PolylinePipeline.removeDuplicates(value);
            if (!defined(positions)) {
                positions = value;
            }
            if (this._loop && positions.length > 2) {
                if (positions === value) {
                    positions = value.slice();
                }
                positions.push(Cartesian3.clone(positions[0]));
            }
            if (this._actualPositions.length !== positions.length || this._actualPositions.length !== this._length) {
                makeDirty(this, POSITION_SIZE_INDEX);
            }
            this._positions = value;
            this._actualPositions = positions;
            this._length = positions.length;
            this._boundingVolume = BoundingSphere.fromPoints(this._actualPositions, this._boundingVolume);
            this._boundingVolumeWC = BoundingSphere.transform(this._boundingVolume, this._modelMatrix, this._boundingVolumeWC);
            makeDirty(this, POSITION_INDEX);
            this.update();
        }
    },
    material: {
        get: function () {
            return this._material;
        },
        set: function (material) {
            if (!defined(material)) {
                throw new DeveloperError('material is required.');
            }
            if (this._material !== material) {
                this._material = material;
                makeDirty(this, MATERIAL_INDEX);
            }
        }
    },
    width: {
        get: function () {
            return this._width;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            var width = this._width;
            if (value !== width) {
                this._width = value;
                makeDirty(this, WIDTH_INDEX);
            }
        }
    },
    loop: {
        get: function () {
            return this._loop;
        },
        set: function (value) {
            if (!defined(value)) {
                throw new DeveloperError('value is required.');
            }
            if (value !== this._loop) {
                var positions = this._actualPositions;
                if (value) {
                    if (positions.length > 2 && !Cartesian3.equals(positions[0], positions[positions.length - 1])) {
                        if (positions.length === this._positions.length) {
                            this._actualPositions = positions = this._positions.slice();
                        }
                        positions.push(Cartesian3.clone(positions[0]));
                    }
                } else {
                    if (positions.length > 2 && Cartesian3.equals(positions[0], positions[positions.length - 1])) {
                        if (positions.length - 1 === this._positions.length) {
                            this._actualPositions = this._positions;
                        } else {
                            positions.pop();
                        }
                    }
                }
                this._loop = value;
                makeDirty(this, POSITION_SIZE_INDEX);
            }
        }
    },
    id: {
        get: function () {
            return this._id;
        },
        set: function (value) {
            this._id = value;
            if (defined(this._pickId)) {
                this._pickId.object.id = value;
            }
        }
    }
});
Polyline.prototype.update = function () {
    var modelMatrix = Matrix4.IDENTITY;
    if (defined(this._polylineCollection)) {
        modelMatrix = this._polylineCollection.modelMatrix;
    }
    var segmentPositionsLength = this._segments.positions.length;
    var segmentLengths = this._segments.lengths;
    var positionsChanged = this._propertiesChanged[POSITION_INDEX] > 0 || this._propertiesChanged[POSITION_SIZE_INDEX] > 0;
    if (!Matrix4.equals(modelMatrix, this._modelMatrix) || positionsChanged) {
        this._segments = PolylinePipeline.wrapLongitude(this._actualPositions, modelMatrix);
        this._boundingVolumeWC = BoundingSphere.transform(this._boundingVolume, modelMatrix, this._boundingVolumeWC);
    }
    this._modelMatrix = modelMatrix;
    if (this._segments.positions.length !== segmentPositionsLength) {
        makeDirty(this, POSITION_SIZE_INDEX);
    } else {
        var length = segmentLengths.length;
        for (var i = 0; i < length; ++i) {
            if (segmentLengths[i] !== this._segments.lengths[i]) {
                makeDirty(this, POSITION_SIZE_INDEX);
                break;
            }
        }
    }
};
Polyline.prototype.getPickId = function (context) {
    if (!defined(this._pickId)) {
        this._pickId = context.createPickId({
            primitive: this,
            collection: this._polylineCollection,
            id: this._id
        });
    }
    return this._pickId;
};
Polyline.prototype._clean = function () {
    this._dirty = false;
    var properties = this._propertiesChanged;
    for (var k = 0; k < NUMBER_OF_PROPERTIES - 1; ++k) {
        properties[k] = 0;
    }
};
Polyline.prototype._destroy = function () {
    this._pickId = this._pickId && this._pickId.destroy();
    this._material = this._material && this._material.destroy();
    this._polylineCollection = undefined;
};
module.exports = Polyline;
},{"../Core/BoundingSphere":98,"../Core/Cartesian3":102,"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Matrix4":177,"../Core/PolylinePipeline":189,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"./Material":404}],425:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Cartographic = require('../Core/Cartographic'), Color = require('../Core/Color'), ComponentDatatype = require('../Core/ComponentDatatype'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), EncodedCartesian3 = require('../Core/EncodedCartesian3'), IndexDatatype = require('../Core/IndexDatatype'), Intersect = require('../Core/Intersect'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), BufferUsage = require('../Renderer/BufferUsage'), DrawCommand = require('../Renderer/DrawCommand'), ShaderSource = require('../Renderer/ShaderSource'), PolylineCommon = require('../Shaders/PolylineCommon'), PolylineFS = require('../Shaders/PolylineFS'), PolylineVS = require('../Shaders/PolylineVS'), BlendingState = require('./BlendingState'), Material = require('./Material'), Pass = require('./Pass'), Polyline = require('./Polyline'), SceneMode = require('./SceneMode');
'use strict';
var SHOW_INDEX = Polyline.SHOW_INDEX;
var WIDTH_INDEX = Polyline.WIDTH_INDEX;
var POSITION_INDEX = Polyline.POSITION_INDEX;
var MATERIAL_INDEX = Polyline.MATERIAL_INDEX;
var POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;
var NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;
var attributeLocations = {
        texCoordExpandWidthAndShow: 0,
        position3DHigh: 1,
        position3DLow: 2,
        position2DHigh: 3,
        position2DLow: 4,
        prevPosition3DHigh: 5,
        prevPosition3DLow: 6,
        prevPosition2DHigh: 7,
        prevPosition2DLow: 8,
        nextPosition3DHigh: 9,
        nextPosition3DLow: 10,
        nextPosition2DHigh: 11,
        nextPosition2DLow: 12,
        pickColor: 13
    };
var PolylineCollection = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));
    this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);
    this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);
    this._opaqueRS = undefined;
    this._translucentRS = undefined;
    this._colorCommands = [];
    this._pickCommands = [];
    this._polylinesUpdated = false;
    this._polylinesRemoved = false;
    this._createVertexArray = false;
    this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
    this._polylines = [];
    this._polylineBuckets = {};
    this._buffersUsage = [
        {
            bufferUsage: BufferUsage.STATIC_DRAW,
            frameCount: 0
        },
        {
            bufferUsage: BufferUsage.STATIC_DRAW,
            frameCount: 0
        },
        {
            bufferUsage: BufferUsage.STATIC_DRAW,
            frameCount: 0
        }
    ];
    this._mode = undefined;
    this._polylinesToUpdate = [];
    this._vertexArrays = [];
    this._positionBuffer = undefined;
    this._pickColorBuffer = undefined;
    this._texCoordExpandWidthAndShowBuffer = undefined;
};
defineProperties(PolylineCollection.prototype, {
    length: {
        get: function () {
            removePolylines(this);
            return this._polylines.length;
        }
    }
});
PolylineCollection.prototype.add = function (polyline) {
    var p = new Polyline(polyline, this);
    p._index = this._polylines.length;
    this._polylines.push(p);
    this._createVertexArray = true;
    return p;
};
PolylineCollection.prototype.remove = function (polyline) {
    if (this.contains(polyline)) {
        this._polylines[polyline._index] = undefined;
        this._polylinesRemoved = true;
        this._createVertexArray = true;
        if (defined(polyline._bucket)) {
            var bucket = polyline._bucket;
            bucket.shaderProgram = bucket.shaderProgram && bucket.shaderProgram.destroy();
            bucket.pickShaderProgram = bucket.pickShaderProgram && bucket.pickShaderProgram.destroy();
        }
        polyline._destroy();
        return true;
    }
    return false;
};
PolylineCollection.prototype.removeAll = function () {
    releaseShaders(this);
    destroyPolylines(this);
    this._polylineBuckets = {};
    this._polylinesRemoved = false;
    this._polylines.length = 0;
    this._polylinesToUpdate.length = 0;
    this._createVertexArray = true;
};
PolylineCollection.prototype.contains = function (polyline) {
    return defined(polyline) && polyline._polylineCollection === this;
};
PolylineCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    removePolylines(this);
    return this._polylines[index];
};
PolylineCollection.prototype.update = function (context, frameState, commandList) {
    removePolylines(this);
    if (this._polylines.length === 0) {
        return;
    }
    updateMode(this, frameState);
    var projection = frameState.mapProjection;
    var polyline;
    var properties = this._propertiesChanged;
    if (this._createVertexArray || computeNewBuffersUsage(this)) {
        createVertexArrays(this, context, projection);
    } else if (this._polylinesUpdated) {
        var polylinesToUpdate = this._polylinesToUpdate;
        if (this._mode !== SceneMode.SCENE3D) {
            var updateLength = polylinesToUpdate.length;
            for (var i = 0; i < updateLength; ++i) {
                polyline = polylinesToUpdate[i];
                polyline.update();
            }
        }
        if (properties[POSITION_SIZE_INDEX] || properties[MATERIAL_INDEX]) {
            createVertexArrays(this, context, projection);
        } else {
            var length = polylinesToUpdate.length;
            var polylineBuckets = this._polylineBuckets;
            for (var ii = 0; ii < length; ++ii) {
                polyline = polylinesToUpdate[ii];
                properties = polyline._propertiesChanged;
                var bucket = polyline._bucket;
                var index = 0;
                for (var x in polylineBuckets) {
                    if (polylineBuckets.hasOwnProperty(x)) {
                        if (polylineBuckets[x] === bucket) {
                            if (properties[POSITION_INDEX] || properties[SHOW_INDEX] || properties[WIDTH_INDEX]) {
                                bucket.writeUpdate(index, polyline, this._positionBuffer, this._texCoordExpandWidthAndShowBuffer, projection);
                            }
                            break;
                        }
                        index += polylineBuckets[x].lengthOfPositions;
                    }
                }
                polyline._clean();
            }
        }
        polylinesToUpdate.length = 0;
        this._polylinesUpdated = false;
    }
    properties = this._propertiesChanged;
    for (var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
        properties[k] = 0;
    }
    var modelMatrix = Matrix4.IDENTITY;
    if (frameState.mode === SceneMode.SCENE3D) {
        modelMatrix = this.modelMatrix;
    }
    var pass = frameState.passes;
    var useDepthTest = frameState.morphTime !== 0;
    if (!defined(this._opaqueRS) || this._opaqueRS.depthTest.enabled !== useDepthTest) {
        this._opaqueRS = context.createRenderState({
            depthMask: useDepthTest,
            depthTest: { enabled: useDepthTest }
        });
    }
    if (!defined(this._translucentRS) || this._translucentRS.depthTest.enabled !== useDepthTest) {
        this._translucentRS = context.createRenderState({
            blending: BlendingState.ALPHA_BLEND,
            depthMask: !useDepthTest,
            depthTest: { enabled: useDepthTest }
        });
    }
    if (pass.render) {
        var colorList = this._colorCommands;
        createCommandLists(this, context, frameState, colorList, commandList, modelMatrix, true);
    }
    if (pass.pick) {
        var pickList = this._pickCommands;
        createCommandLists(this, context, frameState, pickList, commandList, modelMatrix, false);
    }
};
var boundingSphereScratch = new BoundingSphere();
var boundingSphereScratch2 = new BoundingSphere();
function createCommandLists(polylineCollection, context, frameState, commands, commandList, modelMatrix, renderPass) {
    var commandsLength = commands.length;
    var commandIndex = 0;
    var cloneBoundingSphere = true;
    var vertexArrays = polylineCollection._vertexArrays;
    var debugShowBoundingVolume = polylineCollection.debugShowBoundingVolume;
    var length = vertexArrays.length;
    for (var m = 0; m < length; ++m) {
        var va = vertexArrays[m];
        var buckets = va.buckets;
        var bucketLength = buckets.length;
        for (var n = 0; n < bucketLength; ++n) {
            var bucketLocator = buckets[n];
            var offset = bucketLocator.offset;
            var sp = renderPass ? bucketLocator.bucket.shaderProgram : bucketLocator.bucket.pickShaderProgram;
            var polylines = bucketLocator.bucket.polylines;
            var polylineLength = polylines.length;
            var currentId;
            var currentMaterial;
            var count = 0;
            var command;
            for (var s = 0; s < polylineLength; ++s) {
                var polyline = polylines[s];
                var mId = createMaterialId(polyline._material);
                if (mId !== currentId) {
                    if (defined(currentId) && count > 0) {
                        var translucent = currentMaterial.isTranslucent();
                        if (commandIndex >= commandsLength) {
                            command = new DrawCommand({ owner: polylineCollection });
                            commands.push(command);
                        } else {
                            command = commands[commandIndex];
                        }
                        ++commandIndex;
                        command.boundingVolume = BoundingSphere.clone(boundingSphereScratch, command.boundingVolume);
                        command.modelMatrix = modelMatrix;
                        command.shaderProgram = sp;
                        command.vertexArray = va.va;
                        command.renderState = translucent ? polylineCollection._translucentRS : polylineCollection._opaqueRS;
                        command.pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;
                        command.debugShowBoundingVolume = renderPass ? debugShowBoundingVolume : false;
                        command.uniformMap = currentMaterial._uniforms;
                        command.count = count;
                        command.offset = offset;
                        offset += count;
                        count = 0;
                        cloneBoundingSphere = true;
                        commandList.push(command);
                    }
                    currentMaterial = polyline._material;
                    currentMaterial.update(context);
                    currentId = mId;
                }
                var locators = polyline._locatorBuckets;
                var locatorLength = locators.length;
                for (var t = 0; t < locatorLength; ++t) {
                    var locator = locators[t];
                    if (locator.locator === bucketLocator) {
                        count += locator.count;
                    }
                }
                var boundingVolume;
                if (frameState.mode === SceneMode.SCENE3D) {
                    boundingVolume = polyline._boundingVolumeWC;
                } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {
                    boundingVolume = polyline._boundingVolume2D;
                } else if (frameState.mode === SceneMode.SCENE2D) {
                    if (defined(polyline._boundingVolume2D)) {
                        boundingVolume = BoundingSphere.clone(polyline._boundingVolume2D, boundingSphereScratch2);
                        boundingVolume.center.x = 0;
                    }
                } else if (defined(polyline._boundingVolumeWC) && defined(polyline._boundingVolume2D)) {
                    boundingVolume = BoundingSphere.union(polyline._boundingVolumeWC, polyline._boundingVolume2D, boundingSphereScratch2);
                }
                if (cloneBoundingSphere) {
                    cloneBoundingSphere = false;
                    BoundingSphere.clone(boundingVolume, boundingSphereScratch);
                } else {
                    BoundingSphere.union(boundingVolume, boundingSphereScratch, boundingSphereScratch);
                }
            }
            if (defined(currentId) && count > 0) {
                if (commandIndex >= commandsLength) {
                    command = new DrawCommand({ owner: polylineCollection });
                    commands.push(command);
                } else {
                    command = commands[commandIndex];
                }
                ++commandIndex;
                command.boundingVolume = BoundingSphere.clone(boundingSphereScratch, command.boundingVolume);
                command.modelMatrix = modelMatrix;
                command.shaderProgram = sp;
                command.vertexArray = va.va;
                command.renderState = currentMaterial.isTranslucent() ? polylineCollection._translucentRS : polylineCollection._opaqueRS;
                command.pass = currentMaterial.isTranslucent() ? Pass.TRANSLUCENT : Pass.OPAQUE;
                command.debugShowBoundingVolume = renderPass ? debugShowBoundingVolume : false;
                command.uniformMap = currentMaterial._uniforms;
                command.count = count;
                command.offset = offset;
                cloneBoundingSphere = true;
                commandList.push(command);
            }
            currentId = undefined;
        }
    }
    commands.length = commandIndex;
}
PolylineCollection.prototype.isDestroyed = function () {
    return false;
};
PolylineCollection.prototype.destroy = function () {
    destroyVertexArrays(this);
    releaseShaders(this);
    destroyPolylines(this);
    return destroyObject(this);
};
function computeNewBuffersUsage(collection) {
    var buffersUsage = collection._buffersUsage;
    var usageChanged = false;
    var properties = collection._propertiesChanged;
    for (var k = 0; k < NUMBER_OF_PROPERTIES - 2; ++k) {
        var bufferUsage = buffersUsage[k];
        if (properties[k]) {
            if (bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW) {
                usageChanged = true;
                bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;
                bufferUsage.frameCount = 100;
            } else {
                bufferUsage.frameCount = 100;
            }
        } else {
            if (bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW) {
                if (bufferUsage.frameCount === 0) {
                    usageChanged = true;
                    bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;
                } else {
                    bufferUsage.frameCount--;
                }
            }
        }
    }
    return usageChanged;
}
var emptyVertexBuffer = [
        0,
        0,
        0
    ];
function createVertexArrays(collection, context, projection) {
    collection._createVertexArray = false;
    releaseShaders(collection);
    destroyVertexArrays(collection);
    sortPolylinesIntoBuckets(collection);
    var totalIndices = [[]];
    var indices = totalIndices[0];
    var vertexBufferOffset = [0];
    var offset = 0;
    var vertexArrayBuckets = [[]];
    var totalLength = 0;
    var polylineBuckets = collection._polylineBuckets;
    var x;
    var bucket;
    for (x in polylineBuckets) {
        if (polylineBuckets.hasOwnProperty(x)) {
            bucket = polylineBuckets[x];
            bucket.updateShader(context);
            totalLength += bucket.lengthOfPositions;
        }
    }
    if (totalLength > 0) {
        var mode = collection._mode;
        var positionArray = new Float32Array(6 * totalLength * 3);
        var pickColorArray = new Uint8Array(totalLength * 4);
        var texCoordExpandWidthAndShowArray = new Float32Array(totalLength * 4);
        var position3DArray;
        var positionIndex = 0;
        var colorIndex = 0;
        var texCoordExpandWidthAndShowIndex = 0;
        for (x in polylineBuckets) {
            if (polylineBuckets.hasOwnProperty(x)) {
                bucket = polylineBuckets[x];
                bucket.write(positionArray, pickColorArray, texCoordExpandWidthAndShowArray, positionIndex, colorIndex, texCoordExpandWidthAndShowIndex, context, projection);
                if (mode === SceneMode.MORPHING) {
                    if (!defined(position3DArray)) {
                        position3DArray = new Float32Array(6 * totalLength * 3);
                    }
                    bucket.writeForMorph(position3DArray, positionIndex);
                }
                var bucketLength = bucket.lengthOfPositions;
                positionIndex += 6 * bucketLength * 3;
                colorIndex += bucketLength * 4;
                texCoordExpandWidthAndShowIndex += bucketLength * 4;
                offset = bucket.updateIndices(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);
            }
        }
        var positionBufferUsage = collection._buffersUsage[POSITION_INDEX].bufferUsage;
        var showBufferUsage = collection._buffersUsage[SHOW_INDEX].bufferUsage;
        var widthBufferUsage = collection._buffersUsage[WIDTH_INDEX].bufferUsage;
        var texCoordExpandWidthAndShowBufferUsage = showBufferUsage === BufferUsage.STREAM_DRAW || widthBufferUsage === BufferUsage.STREAM_DRAW ? BufferUsage.STREAM_DRAW : BufferUsage.STATIC_DRAW;
        collection._positionBuffer = context.createVertexBuffer(positionArray, positionBufferUsage);
        var position3DBuffer;
        if (defined(position3DArray)) {
            position3DBuffer = context.createVertexBuffer(position3DArray, positionBufferUsage);
        }
        collection._pickColorBuffer = context.createVertexBuffer(pickColorArray, BufferUsage.STATIC_DRAW);
        collection._texCoordExpandWidthAndShowBuffer = context.createVertexBuffer(texCoordExpandWidthAndShowArray, texCoordExpandWidthAndShowBufferUsage);
        var pickColorSizeInBytes = 4 * Uint8Array.BYTES_PER_ELEMENT;
        var positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;
        var texCoordExpandWidthAndShowSizeInBytes = 4 * Float32Array.BYTES_PER_ELEMENT;
        var vbo = 0;
        var numberOfIndicesArrays = totalIndices.length;
        for (var k = 0; k < numberOfIndicesArrays; ++k) {
            indices = totalIndices[k];
            if (indices.length > 0) {
                var indicesArray = new Uint16Array(indices);
                var indexBuffer = context.createIndexBuffer(indicesArray, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
                vbo += vertexBufferOffset[k];
                var positionHighOffset = 6 * (k * (positionSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * positionSizeInBytes);
                var positionLowOffset = positionSizeInBytes + positionHighOffset;
                var prevPositionHighOffset = positionSizeInBytes + positionLowOffset;
                var prevPositionLowOffset = positionSizeInBytes + prevPositionHighOffset;
                var nextPositionHighOffset = positionSizeInBytes + prevPositionLowOffset;
                var nextPositionLowOffset = positionSizeInBytes + nextPositionHighOffset;
                var vertexPickColorBufferOffset = k * (pickColorSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * pickColorSizeInBytes;
                var vertexTexCoordExpandWidthAndShowBufferOffset = k * (texCoordExpandWidthAndShowSizeInBytes * CesiumMath.SIXTY_FOUR_KILOBYTES) - vbo * texCoordExpandWidthAndShowSizeInBytes;
                var attributes = [
                        {
                            index: attributeLocations.position3DHigh,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: positionHighOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.position3DLow,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: positionLowOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.position2DHigh,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: positionHighOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.position2DLow,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: positionLowOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.prevPosition3DHigh,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: prevPositionHighOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.prevPosition3DLow,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: prevPositionLowOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.prevPosition2DHigh,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: prevPositionHighOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.prevPosition2DLow,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: prevPositionLowOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.nextPosition3DHigh,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: nextPositionHighOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.nextPosition3DLow,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: nextPositionLowOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.nextPosition2DHigh,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: nextPositionHighOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.nextPosition2DLow,
                            componentsPerAttribute: 3,
                            componentDatatype: ComponentDatatype.FLOAT,
                            offsetInBytes: nextPositionLowOffset,
                            strideInBytes: 6 * positionSizeInBytes
                        },
                        {
                            index: attributeLocations.texCoordExpandWidthAndShow,
                            componentsPerAttribute: 4,
                            componentDatatype: ComponentDatatype.FLOAT,
                            vertexBuffer: collection._texCoordExpandWidthAndShowBuffer,
                            offsetInBytes: vertexTexCoordExpandWidthAndShowBufferOffset
                        },
                        {
                            index: attributeLocations.pickColor,
                            componentsPerAttribute: 4,
                            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,
                            vertexBuffer: collection._pickColorBuffer,
                            offsetInBytes: vertexPickColorBufferOffset,
                            normalize: true
                        }
                    ];
                var buffer3D;
                var bufferProperty3D;
                var buffer2D;
                var bufferProperty2D;
                if (mode === SceneMode.SCENE3D) {
                    buffer3D = collection._positionBuffer;
                    bufferProperty3D = 'vertexBuffer';
                    buffer2D = emptyVertexBuffer;
                    bufferProperty2D = 'value';
                } else if (mode === SceneMode.SCENE2D || mode === SceneMode.COLUMBUS_VIEW) {
                    buffer3D = emptyVertexBuffer;
                    bufferProperty3D = 'value';
                    buffer2D = collection._positionBuffer;
                    bufferProperty2D = 'vertexBuffer';
                } else {
                    buffer3D = position3DBuffer;
                    bufferProperty3D = 'vertexBuffer';
                    buffer2D = collection._positionBuffer;
                    bufferProperty2D = 'vertexBuffer';
                }
                attributes[0][bufferProperty3D] = buffer3D;
                attributes[1][bufferProperty3D] = buffer3D;
                attributes[2][bufferProperty2D] = buffer2D;
                attributes[3][bufferProperty2D] = buffer2D;
                attributes[4][bufferProperty3D] = buffer3D;
                attributes[5][bufferProperty3D] = buffer3D;
                attributes[6][bufferProperty2D] = buffer2D;
                attributes[7][bufferProperty2D] = buffer2D;
                attributes[8][bufferProperty3D] = buffer3D;
                attributes[9][bufferProperty3D] = buffer3D;
                attributes[10][bufferProperty2D] = buffer2D;
                attributes[11][bufferProperty2D] = buffer2D;
                var va = context.createVertexArray(attributes, indexBuffer);
                collection._vertexArrays.push({
                    va: va,
                    buckets: vertexArrayBuckets[k]
                });
            }
        }
    }
}
var scratchUniformArray = [];
function createMaterialId(material) {
    var uniforms = Material._uniformList[material.type];
    var length = uniforms.length;
    scratchUniformArray.length = 2 * length;
    var index = 0;
    for (var i = 0; i < length; ++i) {
        var uniform = uniforms[i];
        scratchUniformArray[index] = uniform;
        scratchUniformArray[index + 1] = material._uniforms[uniform]();
        index += 2;
    }
    return material.type + ':' + JSON.stringify(scratchUniformArray);
}
function sortPolylinesIntoBuckets(collection) {
    var mode = collection._mode;
    var modelMatrix = collection._modelMatrix;
    var polylineBuckets = collection._polylineBuckets = {};
    var polylines = collection._polylines;
    var length = polylines.length;
    for (var i = 0; i < length; ++i) {
        var p = polylines[i];
        if (p._actualPositions.length > 1) {
            p.update();
            var material = p.material;
            var value = polylineBuckets[material.type];
            if (!defined(value)) {
                value = polylineBuckets[material.type] = new PolylineBucket(material, mode, modelMatrix);
            }
            value.addPolyline(p);
        }
    }
}
function updateMode(collection, frameState) {
    var mode = frameState.mode;
    if (collection._mode !== mode || !Matrix4.equals(collection._modelMatrix, collection.modelMatrix)) {
        collection._mode = mode;
        collection._modelMatrix = Matrix4.clone(collection.modelMatrix);
        collection._createVertexArray = true;
    }
}
function removePolylines(collection) {
    if (collection._polylinesRemoved) {
        collection._polylinesRemoved = false;
        var polylines = [];
        var length = collection._polylines.length;
        for (var i = 0, j = 0; i < length; ++i) {
            var polyline = collection._polylines[i];
            if (defined(polyline)) {
                polyline._index = j++;
                polylines.push(polyline);
            }
        }
        collection._polylines = polylines;
    }
}
function releaseShaders(collection) {
    var polylines = collection._polylines;
    var length = polylines.length;
    for (var i = 0; i < length; ++i) {
        if (defined(polylines[i])) {
            var bucket = polylines[i]._bucket;
            if (defined(bucket)) {
                bucket.shaderProgram = bucket.shaderProgram && bucket.shaderProgram.destroy();
            }
        }
    }
}
function destroyVertexArrays(collection) {
    var length = collection._vertexArrays.length;
    for (var t = 0; t < length; ++t) {
        collection._vertexArrays[t].va.destroy();
    }
    collection._vertexArrays.length = 0;
}
PolylineCollection.prototype._updatePolyline = function (polyline, propertyChanged) {
    this._polylinesUpdated = true;
    this._polylinesToUpdate.push(polyline);
    ++this._propertiesChanged[propertyChanged];
};
function destroyPolylines(collection) {
    var polylines = collection._polylines;
    var length = polylines.length;
    for (var i = 0; i < length; ++i) {
        if (defined(polylines[i])) {
            polylines[i]._destroy();
        }
    }
}
function VertexArrayBucketLocator(count, offset, bucket) {
    this.count = count;
    this.offset = offset;
    this.bucket = bucket;
}
var PolylineBucket = function (material, mode, modelMatrix) {
    this.polylines = [];
    this.lengthOfPositions = 0;
    this.material = material;
    this.shaderProgram = undefined;
    this.pickShaderProgram = undefined;
    this.mode = mode;
    this.modelMatrix = modelMatrix;
};
PolylineBucket.prototype.addPolyline = function (p) {
    var polylines = this.polylines;
    polylines.push(p);
    p._actualLength = this.getPolylinePositionsLength(p);
    this.lengthOfPositions += p._actualLength;
    p._bucket = this;
};
PolylineBucket.prototype.updateShader = function (context) {
    if (defined(this.shaderProgram)) {
        return;
    }
    var vs = new ShaderSource({
            sources: [
                PolylineCommon,
                PolylineVS
            ]
        });
    var fs = new ShaderSource({
            sources: [
                this.material.shaderSource,
                PolylineFS
            ]
        });
    var fsPick = new ShaderSource({
            sources: fs.sources,
            pickColorQualifier: 'varying'
        });
    this.shaderProgram = context.createShaderProgram(vs, fs, attributeLocations);
    this.pickShaderProgram = context.createShaderProgram(vs, fsPick, attributeLocations);
};
function intersectsIDL(polyline) {
    return Cartesian3.dot(Cartesian3.UNIT_X, polyline._boundingVolume.center) < 0 || polyline._boundingVolume.intersect(Cartesian4.UNIT_Y) === Intersect.INTERSECTING;
}
PolylineBucket.prototype.getPolylinePositionsLength = function (polyline) {
    var length;
    if (this.mode === SceneMode.SCENE3D || !intersectsIDL(polyline)) {
        length = polyline._actualPositions.length;
        return length * 4 - 4;
    }
    var count = 0;
    var segmentLengths = polyline._segments.lengths;
    length = segmentLengths.length;
    for (var i = 0; i < length; ++i) {
        count += segmentLengths[i] * 4 - 4;
    }
    return count;
};
var scratchWritePosition = new Cartesian3();
var scratchWritePrevPosition = new Cartesian3();
var scratchWriteNextPosition = new Cartesian3();
var scratchWriteVector = new Cartesian3();
PolylineBucket.prototype.write = function (positionArray, pickColorArray, texCoordExpandWidthAndShowArray, positionIndex, colorIndex, texCoordExpandWidthAndShowIndex, context, projection) {
    var mode = this.mode;
    var polylines = this.polylines;
    var length = polylines.length;
    for (var i = 0; i < length; ++i) {
        var polyline = polylines[i];
        var width = polyline.width;
        var show = polyline.show && width > 0;
        var segments = this.getSegments(polyline, projection);
        var positions = segments.positions;
        var lengths = segments.lengths;
        var positionsLength = positions.length;
        var pickColor = polyline.getPickId(context).color;
        var segmentIndex = 0;
        var count = 0;
        var position;
        for (var j = 0; j < positionsLength; ++j) {
            if (j === 0) {
                if (polyline._loop) {
                    position = positions[positionsLength - 2];
                } else {
                    position = scratchWriteVector;
                    Cartesian3.subtract(positions[0], positions[1], position);
                    Cartesian3.add(positions[0], position, position);
                }
            } else {
                position = positions[j - 1];
            }
            scratchWritePrevPosition.x = position.x;
            scratchWritePrevPosition.y = position.y;
            scratchWritePrevPosition.z = mode !== SceneMode.SCENE2D ? position.z : 0;
            position = positions[j];
            scratchWritePosition.x = position.x;
            scratchWritePosition.y = position.y;
            scratchWritePosition.z = mode !== SceneMode.SCENE2D ? position.z : 0;
            if (j === positionsLength - 1) {
                if (polyline._loop) {
                    position = positions[1];
                } else {
                    position = scratchWriteVector;
                    Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);
                    Cartesian3.add(positions[positionsLength - 1], position, position);
                }
            } else {
                position = positions[j + 1];
            }
            scratchWriteNextPosition.x = position.x;
            scratchWriteNextPosition.y = position.y;
            scratchWriteNextPosition.z = mode !== SceneMode.SCENE2D ? position.z : 0;
            var segmentLength = lengths[segmentIndex];
            if (j === count + segmentLength) {
                count += segmentLength;
                ++segmentIndex;
            }
            var segmentStart = j - count === 0;
            var segmentEnd = j === count + lengths[segmentIndex] - 1;
            var startK = segmentStart ? 2 : 0;
            var endK = segmentEnd ? 2 : 4;
            for (var k = startK; k < endK; ++k) {
                EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);
                EncodedCartesian3.writeElements(scratchWritePrevPosition, positionArray, positionIndex + 6);
                EncodedCartesian3.writeElements(scratchWriteNextPosition, positionArray, positionIndex + 12);
                pickColorArray[colorIndex] = Color.floatToByte(pickColor.red);
                pickColorArray[colorIndex + 1] = Color.floatToByte(pickColor.green);
                pickColorArray[colorIndex + 2] = Color.floatToByte(pickColor.blue);
                pickColorArray[colorIndex + 3] = Color.floatToByte(pickColor.alpha);
                var direction = k - 2 < 0 ? -1 : 1;
                texCoordExpandWidthAndShowArray[texCoordExpandWidthAndShowIndex] = j / (positionsLength - 1);
                texCoordExpandWidthAndShowArray[texCoordExpandWidthAndShowIndex + 1] = 2 * (k % 2) - 1;
                texCoordExpandWidthAndShowArray[texCoordExpandWidthAndShowIndex + 2] = direction * width;
                texCoordExpandWidthAndShowArray[texCoordExpandWidthAndShowIndex + 3] = show;
                positionIndex += 6 * 3;
                colorIndex += 4;
                texCoordExpandWidthAndShowIndex += 4;
            }
        }
    }
};
var morphPositionScratch = new Cartesian3();
var morphPrevPositionScratch = new Cartesian3();
var morphNextPositionScratch = new Cartesian3();
var morphVectorScratch = new Cartesian3();
PolylineBucket.prototype.writeForMorph = function (positionArray, positionIndex) {
    var modelMatrix = this.modelMatrix;
    var polylines = this.polylines;
    var length = polylines.length;
    for (var i = 0; i < length; ++i) {
        var polyline = polylines[i];
        var positions = polyline._segments.positions;
        var lengths = polyline._segments.lengths;
        var positionsLength = positions.length;
        var segmentIndex = 0;
        var count = 0;
        for (var j = 0; j < positionsLength; ++j) {
            var prevPosition;
            if (j === 0) {
                if (polyline._loop) {
                    prevPosition = positions[positionsLength - 2];
                } else {
                    prevPosition = morphVectorScratch;
                    Cartesian3.subtract(positions[0], positions[1], prevPosition);
                    Cartesian3.add(positions[0], prevPosition, prevPosition);
                }
            } else {
                prevPosition = positions[j - 1];
            }
            prevPosition = Matrix4.multiplyByPoint(modelMatrix, prevPosition, morphPrevPositionScratch);
            var position = Matrix4.multiplyByPoint(modelMatrix, positions[j], morphPositionScratch);
            var nextPosition;
            if (j === positionsLength - 1) {
                if (polyline._loop) {
                    nextPosition = positions[1];
                } else {
                    nextPosition = morphVectorScratch;
                    Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], nextPosition);
                    Cartesian3.add(positions[positionsLength - 1], nextPosition, nextPosition);
                }
            } else {
                nextPosition = positions[j + 1];
            }
            nextPosition = Matrix4.multiplyByPoint(modelMatrix, nextPosition, morphNextPositionScratch);
            var segmentLength = lengths[segmentIndex];
            if (j === count + segmentLength) {
                count += segmentLength;
                ++segmentIndex;
            }
            var segmentStart = j - count === 0;
            var segmentEnd = j === count + lengths[segmentIndex] - 1;
            var startK = segmentStart ? 2 : 0;
            var endK = segmentEnd ? 2 : 4;
            for (var k = startK; k < endK; ++k) {
                EncodedCartesian3.writeElements(position, positionArray, positionIndex);
                EncodedCartesian3.writeElements(prevPosition, positionArray, positionIndex + 6);
                EncodedCartesian3.writeElements(nextPosition, positionArray, positionIndex + 12);
                positionIndex += 6 * 3;
            }
        }
    }
};
var scratchSegmentLengths = new Array(1);
PolylineBucket.prototype.updateIndices = function (totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {
    var vaCount = vertexArrayBuckets.length - 1;
    var bucketLocator = new VertexArrayBucketLocator(0, offset, this);
    vertexArrayBuckets[vaCount].push(bucketLocator);
    var count = 0;
    var indices = totalIndices[totalIndices.length - 1];
    var indicesCount = 0;
    if (indices.length > 0) {
        indicesCount = indices[indices.length - 1] + 1;
    }
    var polylines = this.polylines;
    var length = polylines.length;
    for (var i = 0; i < length; ++i) {
        var polyline = polylines[i];
        polyline._locatorBuckets = [];
        var segments;
        if (this.mode === SceneMode.SCENE3D) {
            segments = scratchSegmentLengths;
            var positionsLength = polyline._actualPositions.length;
            if (positionsLength > 0) {
                segments[0] = positionsLength;
            } else {
                continue;
            }
        } else {
            segments = polyline._segments.lengths;
        }
        var numberOfSegments = segments.length;
        if (numberOfSegments > 0) {
            var segmentIndexCount = 0;
            for (var j = 0; j < numberOfSegments; ++j) {
                var segmentLength = segments[j] - 1;
                for (var k = 0; k < segmentLength; ++k) {
                    if (indicesCount + 4 >= CesiumMath.SIXTY_FOUR_KILOBYTES - 1) {
                        polyline._locatorBuckets.push({
                            locator: bucketLocator,
                            count: segmentIndexCount
                        });
                        segmentIndexCount = 0;
                        vertexBufferOffset.push(4);
                        indices = [];
                        totalIndices.push(indices);
                        indicesCount = 0;
                        bucketLocator.count = count;
                        count = 0;
                        offset = 0;
                        bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                        vertexArrayBuckets[++vaCount] = [bucketLocator];
                    }
                    indices.push(indicesCount, indicesCount + 2, indicesCount + 1);
                    indices.push(indicesCount + 1, indicesCount + 2, indicesCount + 3);
                    segmentIndexCount += 6;
                    count += 6;
                    offset += 6;
                    indicesCount += 4;
                }
            }
            polyline._locatorBuckets.push({
                locator: bucketLocator,
                count: segmentIndexCount
            });
            if (indicesCount + 4 >= CesiumMath.SIXTY_FOUR_KILOBYTES - 1) {
                vertexBufferOffset.push(0);
                indices = [];
                totalIndices.push(indices);
                indicesCount = 0;
                bucketLocator.count = count;
                offset = 0;
                count = 0;
                bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                vertexArrayBuckets[++vaCount] = [bucketLocator];
            }
        }
        polyline._clean();
    }
    bucketLocator.count = count;
    return offset;
};
PolylineBucket.prototype.getPolylineStartIndex = function (polyline) {
    var polylines = this.polylines;
    var positionIndex = 0;
    var length = polylines.length;
    for (var i = 0; i < length; ++i) {
        var p = polylines[i];
        if (p === polyline) {
            break;
        }
        positionIndex += p._actualLength;
    }
    return positionIndex;
};
var scratchSegments = {
        positions: undefined,
        lengths: undefined
    };
var scratchLengths = new Array(1);
var pscratch = new Cartesian3();
var scratchCartographic = new Cartographic();
PolylineBucket.prototype.getSegments = function (polyline, projection) {
    var positions = polyline._actualPositions;
    if (this.mode === SceneMode.SCENE3D) {
        scratchLengths[0] = positions.length;
        scratchSegments.positions = positions;
        scratchSegments.lengths = scratchLengths;
        return scratchSegments;
    }
    if (intersectsIDL(polyline)) {
        positions = polyline._segments.positions;
    }
    var ellipsoid = projection.ellipsoid;
    var newPositions = [];
    var modelMatrix = this.modelMatrix;
    var length = positions.length;
    var position;
    var p = pscratch;
    for (var n = 0; n < length; ++n) {
        position = positions[n];
        p = Matrix4.multiplyByPoint(modelMatrix, position, p);
        newPositions.push(projection.project(ellipsoid.cartesianToCartographic(p, scratchCartographic)));
    }
    if (newPositions.length > 0) {
        polyline._boundingVolume2D = BoundingSphere.fromPoints(newPositions, polyline._boundingVolume2D);
        var center2D = polyline._boundingVolume2D.center;
        polyline._boundingVolume2D.center = new Cartesian3(center2D.z, center2D.x, center2D.y);
    }
    scratchSegments.positions = newPositions;
    scratchSegments.lengths = polyline._segments.lengths;
    return scratchSegments;
};
var scratchPositionsArray;
var scratchTexCoordArray;
PolylineBucket.prototype.writeUpdate = function (index, polyline, positionBuffer, texCoordExpandWidthAndShowBuffer, projection) {
    var mode = this.mode;
    var positionsLength = polyline._actualLength;
    if (positionsLength) {
        index += this.getPolylineStartIndex(polyline);
        var positionArray = scratchPositionsArray;
        var texCoordExpandWidthAndShowArray = scratchTexCoordArray;
        var positionsArrayLength = 6 * positionsLength * 3;
        if (!defined(positionArray) || positionArray.length < positionsArrayLength) {
            positionArray = scratchPositionsArray = new Float32Array(positionsArrayLength);
            texCoordExpandWidthAndShowArray = scratchTexCoordArray = new Float32Array(positionsLength * 4);
        } else if (positionArray.length > positionsArrayLength) {
            positionArray = new Float32Array(positionArray.buffer, 0, positionsArrayLength);
            texCoordExpandWidthAndShowArray = new Float32Array(texCoordExpandWidthAndShowArray.buffer, 0, positionsLength * 4);
        }
        var positionIndex = 0;
        var texCoordExpandWidthAndShowIndex = 0;
        var segments = this.getSegments(polyline, projection);
        var positions = segments.positions;
        var lengths = segments.lengths;
        var segmentIndex = 0;
        var count = 0;
        var position;
        var width = polyline.width;
        var show = polyline.show && width > 0;
        positionsLength = positions.length;
        for (var i = 0; i < positionsLength; ++i) {
            if (i === 0) {
                if (polyline._loop) {
                    position = positions[positionsLength - 2];
                } else {
                    position = scratchWriteVector;
                    Cartesian3.subtract(positions[0], positions[1], position);
                    Cartesian3.add(positions[0], position, position);
                }
            } else {
                position = positions[i - 1];
            }
            scratchWritePrevPosition.x = position.x;
            scratchWritePrevPosition.y = position.y;
            scratchWritePrevPosition.z = mode !== SceneMode.SCENE2D ? position.z : 0;
            position = positions[i];
            scratchWritePosition.x = position.x;
            scratchWritePosition.y = position.y;
            scratchWritePosition.z = mode !== SceneMode.SCENE2D ? position.z : 0;
            if (i === positionsLength - 1) {
                if (polyline._loop) {
                    position = positions[1];
                } else {
                    position = scratchWriteVector;
                    Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);
                    Cartesian3.add(positions[positionsLength - 1], position, position);
                }
            } else {
                position = positions[i + 1];
            }
            scratchWriteNextPosition.x = position.x;
            scratchWriteNextPosition.y = position.y;
            scratchWriteNextPosition.z = mode !== SceneMode.SCENE2D ? position.z : 0;
            var segmentLength = lengths[segmentIndex];
            if (i === count + segmentLength) {
                count += segmentLength;
                ++segmentIndex;
            }
            var segmentStart = i - count === 0;
            var segmentEnd = i === count + lengths[segmentIndex] - 1;
            var startJ = segmentStart ? 2 : 0;
            var endJ = segmentEnd ? 2 : 4;
            for (var j = startJ; j < endJ; ++j) {
                EncodedCartesian3.writeElements(scratchWritePosition, positionArray, positionIndex);
                EncodedCartesian3.writeElements(scratchWritePrevPosition, positionArray, positionIndex + 6);
                EncodedCartesian3.writeElements(scratchWriteNextPosition, positionArray, positionIndex + 12);
                var direction = j - 2 < 0 ? -1 : 1;
                texCoordExpandWidthAndShowArray[texCoordExpandWidthAndShowIndex] = i / (positionsLength - 1);
                texCoordExpandWidthAndShowArray[texCoordExpandWidthAndShowIndex + 1] = 2 * (j % 2) - 1;
                texCoordExpandWidthAndShowArray[texCoordExpandWidthAndShowIndex + 2] = direction * width;
                texCoordExpandWidthAndShowArray[texCoordExpandWidthAndShowIndex + 3] = show;
                positionIndex += 6 * 3;
                texCoordExpandWidthAndShowIndex += 4;
            }
        }
        positionBuffer.copyFromArrayView(positionArray, 6 * 3 * Float32Array.BYTES_PER_ELEMENT * index);
        texCoordExpandWidthAndShowBuffer.copyFromArrayView(texCoordExpandWidthAndShowArray, 4 * Float32Array.BYTES_PER_ELEMENT * index);
    }
};
module.exports = PolylineCollection;
},{"../Core/BoundingSphere":98,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Cartographic":104,"../Core/Color":111,"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/EncodedCartesian3":137,"../Core/IndexDatatype":162,"../Core/Intersect":163,"../Core/Math":174,"../Core/Matrix4":177,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/BufferUsage":339,"../Renderer/DrawCommand":344,"../Renderer/ShaderSource":355,"../Shaders/PolylineCommon":568,"../Shaders/PolylineFS":569,"../Shaders/PolylineVS":570,"./BlendingState":374,"./Material":404,"./Pass":419,"./Polyline":424,"./SceneMode":438}],426:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defineProperties = require('../Core/defineProperties'), VertexFormat = require('../Core/VertexFormat'), PerInstanceFlatColorAppearanceFS = require('../Shaders/Appearances/PerInstanceFlatColorAppearanceFS'), PolylineColorAppearanceVS = require('../Shaders/Appearances/PolylineColorAppearanceVS'), PolylineCommon = require('../Shaders/PolylineCommon'), Appearance = require('./Appearance');
'use strict';
var defaultVertexShaderSource = PolylineCommon + '\n' + PolylineColorAppearanceVS;
var defaultFragmentShaderSource = PerInstanceFlatColorAppearanceFS;
var PolylineColorAppearance = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var translucent = defaultValue(options.translucent, true);
    var closed = false;
    var vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;
    this.material = undefined;
    this.translucent = translucent;
    this._vertexShaderSource = defaultValue(options.vertexShaderSource, defaultVertexShaderSource);
    this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, defaultFragmentShaderSource);
    this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);
    this._closed = closed;
    this._vertexFormat = vertexFormat;
};
defineProperties(PolylineColorAppearance.prototype, {
    vertexShaderSource: {
        get: function () {
            return this._vertexShaderSource;
        }
    },
    fragmentShaderSource: {
        get: function () {
            return this._fragmentShaderSource;
        }
    },
    renderState: {
        get: function () {
            return this._renderState;
        }
    },
    closed: {
        get: function () {
            return this._closed;
        }
    },
    vertexFormat: {
        get: function () {
            return this._vertexFormat;
        }
    }
});
PolylineColorAppearance.VERTEX_FORMAT = VertexFormat.POSITION_ONLY;
PolylineColorAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;
PolylineColorAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;
PolylineColorAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;
module.exports = PolylineColorAppearance;
},{"../Core/VertexFormat":228,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Shaders/Appearances/PerInstanceFlatColorAppearanceFS":467,"../Shaders/Appearances/PolylineColorAppearanceVS":469,"../Shaders/PolylineCommon":568,"./Appearance":366}],427:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), VertexFormat = require('../Core/VertexFormat'), PolylineMaterialAppearanceVS = require('../Shaders/Appearances/PolylineMaterialAppearanceVS'), PolylineCommon = require('../Shaders/PolylineCommon'), PolylineFS = require('../Shaders/PolylineFS'), Appearance = require('./Appearance'), Material = require('./Material');
'use strict';
var defaultVertexShaderSource = PolylineCommon + '\n' + PolylineMaterialAppearanceVS;
var defaultFragmentShaderSource = PolylineFS;
var PolylineMaterialAppearance = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var translucent = defaultValue(options.translucent, true);
    var closed = false;
    var vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;
    this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
    this.translucent = translucent;
    this._vertexShaderSource = defaultValue(options.vertexShaderSource, defaultVertexShaderSource);
    this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, defaultFragmentShaderSource);
    this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);
    this._closed = closed;
    this._vertexFormat = vertexFormat;
};
defineProperties(PolylineMaterialAppearance.prototype, {
    vertexShaderSource: {
        get: function () {
            return this._vertexShaderSource;
        }
    },
    fragmentShaderSource: {
        get: function () {
            return this._fragmentShaderSource;
        }
    },
    renderState: {
        get: function () {
            return this._renderState;
        }
    },
    closed: {
        get: function () {
            return this._closed;
        }
    },
    vertexFormat: {
        get: function () {
            return this._vertexFormat;
        }
    }
});
PolylineMaterialAppearance.VERTEX_FORMAT = VertexFormat.POSITION_AND_ST;
PolylineMaterialAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;
PolylineMaterialAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;
PolylineMaterialAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;
module.exports = PolylineMaterialAppearance;
},{"../Core/VertexFormat":228,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Shaders/Appearances/PolylineMaterialAppearanceVS":470,"../Shaders/PolylineCommon":568,"../Shaders/PolylineFS":569,"./Appearance":366,"./Material":404}],428:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), clone = require('../Core/clone'), combine = require('../Core/combine'), ComponentDatatype = require('../Core/ComponentDatatype'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), FeatureDetection = require('../Core/FeatureDetection'), Geometry = require('../Core/Geometry'), GeometryAttribute = require('../Core/GeometryAttribute'), GeometryAttributes = require('../Core/GeometryAttributes'), GeometryInstance = require('../Core/GeometryInstance'), GeometryInstanceAttribute = require('../Core/GeometryInstanceAttribute'), isArray = require('../Core/isArray'), Matrix4 = require('../Core/Matrix4'), subdivideArray = require('../Core/subdivideArray'), TaskProcessor = require('../Core/TaskProcessor'), BufferUsage = require('../Renderer/BufferUsage'), DrawCommand = require('../Renderer/DrawCommand'), ShaderSource = require('../Renderer/ShaderSource'), when = require('../ThirdParty/when'), CullFace = require('./CullFace'), Pass = require('./Pass'), PrimitivePipeline = require('./PrimitivePipeline'), PrimitiveState = require('./PrimitiveState'), SceneMode = require('./SceneMode');
'use strict';
var Primitive = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.geometryInstances = options.geometryInstances;
    this.appearance = options.appearance;
    this._appearance = undefined;
    this._material = undefined;
    this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));
    this._modelMatrix = new Matrix4();
    this.show = defaultValue(options.show, true);
    this._vertexCacheOptimize = defaultValue(options.vertexCacheOptimize, false);
    this._interleave = defaultValue(options.interleave, false);
    this._releaseGeometryInstances = defaultValue(options.releaseGeometryInstances, true);
    this._allowPicking = defaultValue(options.allowPicking, true);
    this._asynchronous = defaultValue(options.asynchronous, true);
    this._compressVertices = defaultValue(options.compressVertices, true);
    this.cull = defaultValue(options.cull, true);
    this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);
    this._translucent = undefined;
    this._state = PrimitiveState.READY;
    this._geometries = [];
    this._vaAttributes = undefined;
    this._error = undefined;
    this._numberOfInstances = 0;
    this._validModelMatrix = false;
    this._boundingSpheres = [];
    this._boundingSphereWC = [];
    this._boundingSphereCV = [];
    this._boundingSphere2D = [];
    this._boundingSphereMorph = [];
    this._perInstanceAttributeLocations = undefined;
    this._perInstanceAttributeCache = [];
    this._instanceIds = [];
    this._lastPerInstanceAttributeIndex = 0;
    this._dirtyAttributes = [];
    this._va = [];
    this._attributeLocations = undefined;
    this._primitiveType = undefined;
    this._frontFaceRS = undefined;
    this._backFaceRS = undefined;
    this._sp = undefined;
    this._pickRS = undefined;
    this._pickSP = undefined;
    this._pickIds = [];
    this._colorCommands = [];
    this._pickCommands = [];
    this._createGeometryResults = undefined;
    this._ready = false;
    this._readyPromise = when.defer();
};
defineProperties(Primitive.prototype, {
    vertexCacheOptimize: {
        get: function () {
            return this._vertexCacheOptimize;
        }
    },
    interleave: {
        get: function () {
            return this._interleave;
        }
    },
    releaseGeometryInstances: {
        get: function () {
            return this._releaseGeometryInstances;
        }
    },
    allowPicking: {
        get: function () {
            return this._allowPicking;
        }
    },
    asynchronous: {
        get: function () {
            return this._asynchronous;
        }
    },
    compressVertices: {
        get: function () {
            return this._compressVertices;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    readyPromise: {
        get: function () {
            return this._readyPromise;
        }
    }
});
function cloneAttribute(attribute) {
    return new GeometryAttribute({
        componentDatatype: attribute.componentDatatype,
        componentsPerAttribute: attribute.componentsPerAttribute,
        normalize: attribute.normalize,
        values: new attribute.values.constructor(attribute.values)
    });
}
function cloneGeometry(geometry) {
    var attributes = geometry.attributes;
    var newAttributes = new GeometryAttributes();
    for (var property in attributes) {
        if (attributes.hasOwnProperty(property) && defined(attributes[property])) {
            newAttributes[property] = cloneAttribute(attributes[property]);
        }
    }
    var indices;
    if (defined(geometry.indices)) {
        var sourceValues = geometry.indices;
        indices = new sourceValues.constructor(sourceValues);
    }
    return new Geometry({
        attributes: newAttributes,
        indices: indices,
        primitiveType: geometry.primitiveType,
        boundingSphere: BoundingSphere.clone(geometry.boundingSphere)
    });
}
function cloneGeometryInstanceAttribute(attribute) {
    return new GeometryInstanceAttribute({
        componentDatatype: attribute.componentDatatype,
        componentsPerAttribute: attribute.componentsPerAttribute,
        normalize: attribute.normalize,
        value: new attribute.value.constructor(attribute.value)
    });
}
function cloneInstance(instance, geometry) {
    var attributes = instance.attributes;
    var newAttributes = {};
    for (var property in attributes) {
        if (attributes.hasOwnProperty(property)) {
            newAttributes[property] = cloneGeometryInstanceAttribute(attributes[property]);
        }
    }
    return new GeometryInstance({
        geometry: geometry,
        modelMatrix: Matrix4.clone(instance.modelMatrix),
        attributes: newAttributes,
        pickPrimitive: instance.pickPrimitive,
        id: instance.id
    });
}
var positionRegex = /attribute\s+vec(?:3|4)\s+(.*)3DHigh;/g;
function createColumbusViewShader(primitive, vertexShaderSource, scene3DOnly) {
    var match;
    var forwardDecl = '';
    var attributes = '';
    var computeFunctions = '';
    while ((match = positionRegex.exec(vertexShaderSource)) !== null) {
        var name = match[1];
        var functionName = 'vec4 czm_compute' + name[0].toUpperCase() + name.substr(1) + '()';
        if (functionName !== 'vec4 czm_computePosition()') {
            forwardDecl += functionName + ';\n';
        }
        if (!scene3DOnly) {
            attributes += 'attribute vec3 ' + name + '2DHigh;\n' + 'attribute vec3 ' + name + '2DLow;\n';
            computeFunctions += functionName + '\n' + '{\n' + '    vec4 p;\n' + '    if (czm_morphTime == 1.0)\n' + '    {\n' + '        p = czm_translateRelativeToEye(' + name + '3DHigh, ' + name + '3DLow);\n' + '    }\n' + '    else if (czm_morphTime == 0.0)\n' + '    {\n' + '        p = czm_translateRelativeToEye(' + name + '2DHigh.zxy, ' + name + '2DLow.zxy);\n' + '    }\n' + '    else\n' + '    {\n' + '        p = czm_columbusViewMorph(\n' + '                czm_translateRelativeToEye(' + name + '2DHigh.zxy, ' + name + '2DLow.zxy),\n' + '                czm_translateRelativeToEye(' + name + '3DHigh, ' + name + '3DLow),\n' + '                czm_morphTime);\n' + '    }\n' + '    return p;\n' + '}\n\n';
        } else {
            computeFunctions += functionName + '\n' + '{\n' + '    return czm_translateRelativeToEye(' + name + '3DHigh, ' + name + '3DLow);\n' + '}\n\n';
        }
    }
    return [
        forwardDecl,
        attributes,
        vertexShaderSource,
        computeFunctions
    ].join('\n');
}
function createPickVertexShaderSource(vertexShaderSource) {
    var renamedVS = vertexShaderSource.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, 'void czm_old_main()');
    var pickMain = 'attribute vec4 pickColor; \n' + 'varying vec4 czm_pickColor; \n' + 'void main() \n' + '{ \n' + '    czm_old_main(); \n' + '    czm_pickColor = pickColor; \n' + '}';
    return renamedVS + '\n' + pickMain;
}
function appendShow(primitive, vertexShaderSource) {
    if (!defined(primitive._attributeLocations.show)) {
        return vertexShaderSource;
    }
    var renamedVS = vertexShaderSource.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, 'void czm_non_show_main()');
    var showMain = 'attribute float show;\n' + 'void main() \n' + '{ \n' + '    czm_non_show_main(); \n' + '    gl_Position *= show; \n' + '}';
    return renamedVS + '\n' + showMain;
}
function modifyForEncodedNormals(primitive, vertexShaderSource) {
    if (!primitive.compressVertices) {
        return vertexShaderSource;
    }
    var containsNormal = vertexShaderSource.search(/attribute\s+vec3\s+normal;/g) !== -1;
    var containsSt = vertexShaderSource.search(/attribute\s+vec2\s+st;/g) !== -1;
    if (!containsNormal && !containsSt) {
        return vertexShaderSource;
    }
    var containsTangent = vertexShaderSource.search(/attribute\s+vec3\s+tangent;/g) !== -1;
    var containsBinormal = vertexShaderSource.search(/attribute\s+vec3\s+binormal;/g) !== -1;
    var numComponents = containsSt && containsNormal ? 2 : 1;
    numComponents += containsTangent || containsBinormal ? 1 : 0;
    var type = numComponents > 1 ? 'vec' + numComponents : 'float';
    var attributeName = 'compressedAttributes';
    var attributeDecl = 'attribute ' + type + ' ' + attributeName + ';';
    var globalDecl = '';
    var decode = '';
    if (containsSt) {
        globalDecl += 'vec2 st;\n';
        var stComponent = numComponents > 1 ? attributeName + '.x' : attributeName;
        decode += '    st = czm_decompressTextureCoordinates(' + stComponent + ');\n';
    }
    if (containsNormal && containsTangent && containsBinormal) {
        globalDecl += 'vec3 normal;\n' + 'vec3 tangent;\n' + 'vec3 binormal;\n';
        decode += '    czm_octDecode(' + attributeName + '.' + (containsSt ? 'yz' : 'xy') + ', normal, tangent, binormal);\n';
    } else {
        if (containsNormal) {
            globalDecl += 'vec3 normal;\n';
            decode += '    normal = czm_octDecode(' + attributeName + (numComponents > 1 ? '.' + (containsSt ? 'y' : 'x') : '') + ');\n';
        }
        if (containsTangent) {
            globalDecl += 'vec3 tangent;\n';
            decode += '    tangent = czm_octDecode(' + attributeName + '.' + (containsSt && containsNormal ? 'z' : 'y') + ');\n';
        }
        if (containsBinormal) {
            globalDecl += 'vec3 binormal;\n';
            decode += '    binormal = czm_octDecode(' + attributeName + '.' + (containsSt && containsNormal ? 'z' : 'y') + ');\n';
        }
    }
    var modifiedVS = vertexShaderSource;
    modifiedVS = modifiedVS.replace(/attribute\s+vec3\s+normal;/g, '');
    modifiedVS = modifiedVS.replace(/attribute\s+vec2\s+st;/g, '');
    modifiedVS = modifiedVS.replace(/attribute\s+vec3\s+tangent;/g, '');
    modifiedVS = modifiedVS.replace(/attribute\s+vec3\s+binormal;/g, '');
    modifiedVS = modifiedVS.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, 'void czm_non_compressed_main()');
    var compressedMain = 'void main() \n' + '{ \n' + decode + '    czm_non_compressed_main(); \n' + '}';
    return [
        attributeDecl,
        globalDecl,
        modifiedVS,
        compressedMain
    ].join('\n');
}
function validateShaderMatching(shaderProgram, attributeLocations) {
    var shaderAttributes = shaderProgram.vertexAttributes;
    for (var name in shaderAttributes) {
        if (shaderAttributes.hasOwnProperty(name)) {
            if (!defined(attributeLocations[name])) {
                throw new DeveloperError('Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input \'' + name + '\', which was not computed as part of the Geometry.  Use the appearance\'s vertexFormat property when constructing the geometry.');
            }
        }
    }
}
function createPickIds(context, primitive, instances) {
    var pickColors = [];
    var length = instances.length;
    for (var i = 0; i < length; ++i) {
        var pickObject = { primitive: defaultValue(instances[i].pickPrimitive, primitive) };
        if (defined(instances[i].id)) {
            pickObject.id = instances[i].id;
        }
        var pickId = context.createPickId(pickObject);
        primitive._pickIds.push(pickId);
        pickColors.push(pickId.color);
    }
    return pickColors;
}
function getUniformFunction(uniforms, name) {
    return function () {
        return uniforms[name];
    };
}
var numberOfCreationWorkers = Math.max(FeatureDetection.hardwareConcurrency - 1, 1);
var createGeometryTaskProcessors;
var combineGeometryTaskProcessor = new TaskProcessor('combineGeometry', Number.POSITIVE_INFINITY);
Primitive.prototype.update = function (context, frameState, commandList) {
    if (!defined(this.geometryInstances) && this._va.length === 0 || defined(this.geometryInstances) && isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !defined(this.appearance) || frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly || !frameState.passes.render && !frameState.passes.pick) {
        return;
    }
    if (defined(this._error)) {
        throw this._error;
    }
    if (this._state === PrimitiveState.FAILED) {
        return;
    }
    var projection = frameState.mapProjection;
    var colorCommand;
    var pickCommand;
    var geometry;
    var attributes;
    var attribute;
    var length;
    var i;
    var j;
    var index;
    var promise;
    var instance;
    var instances;
    var clonedInstances;
    var geometries;
    var allowPicking = this.allowPicking;
    var instanceIds = this._instanceIds;
    var scene3DOnly = frameState.scene3DOnly;
    var that = this;
    if (this._state !== PrimitiveState.COMPLETE && this._state !== PrimitiveState.COMBINED) {
        if (this.asynchronous) {
            if (this._state === PrimitiveState.READY) {
                instances = isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
                this._numberOfInstances = length = instances.length;
                var promises = [];
                var subTasks = [];
                for (i = 0; i < length; ++i) {
                    geometry = instances[i].geometry;
                    instanceIds.push(instances[i].id);
                    if (!defined(geometry._workerName)) {
                        throw new DeveloperError('_workerName must be defined for asynchronous geometry.');
                    }
                    subTasks.push({
                        moduleName: geometry._workerName,
                        geometry: geometry
                    });
                }
                if (!defined(createGeometryTaskProcessors)) {
                    createGeometryTaskProcessors = new Array(numberOfCreationWorkers);
                    for (i = 0; i < numberOfCreationWorkers; i++) {
                        createGeometryTaskProcessors[i] = new TaskProcessor('createGeometry', Number.POSITIVE_INFINITY);
                    }
                }
                var subTask;
                subTasks = subdivideArray(subTasks, numberOfCreationWorkers);
                for (i = 0; i < subTasks.length; i++) {
                    var packedLength = 0;
                    var workerSubTasks = subTasks[i];
                    var workerSubTasksLength = workerSubTasks.length;
                    for (j = 0; j < workerSubTasksLength; ++j) {
                        subTask = workerSubTasks[j];
                        geometry = subTask.geometry;
                        if (defined(geometry.constructor.pack)) {
                            subTask.offset = packedLength;
                            packedLength += defaultValue(geometry.constructor.packedLength, geometry.packedLength);
                        }
                    }
                    var subTaskTransferableObjects;
                    if (packedLength > 0) {
                        var array = new Float64Array(packedLength);
                        subTaskTransferableObjects = [array.buffer];
                        for (j = 0; j < workerSubTasksLength; ++j) {
                            subTask = workerSubTasks[j];
                            geometry = subTask.geometry;
                            if (defined(geometry.constructor.pack)) {
                                geometry.constructor.pack(geometry, array, subTask.offset);
                                subTask.geometry = array;
                            }
                        }
                    }
                    promises.push(createGeometryTaskProcessors[i].scheduleTask({ subTasks: subTasks[i] }, subTaskTransferableObjects));
                }
                this._state = PrimitiveState.CREATING;
                when.all(promises, function (results) {
                    that._createGeometryResults = results;
                    that._state = PrimitiveState.CREATED;
                }).otherwise(function (error) {
                    setReady(that, frameState, PrimitiveState.FAILED, error);
                });
            } else if (this._state === PrimitiveState.CREATED) {
                var transferableObjects = [];
                instances = isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
                promise = combineGeometryTaskProcessor.scheduleTask(PrimitivePipeline.packCombineGeometryParameters({
                    createGeometryResults: this._createGeometryResults,
                    instances: instances,
                    pickIds: allowPicking ? createPickIds(context, this, instances) : undefined,
                    ellipsoid: projection.ellipsoid,
                    projection: projection,
                    elementIndexUintSupported: context.elementIndexUint,
                    scene3DOnly: scene3DOnly,
                    allowPicking: allowPicking,
                    vertexCacheOptimize: this.vertexCacheOptimize,
                    compressVertices: this.compressVertices,
                    modelMatrix: this.modelMatrix
                }, transferableObjects), transferableObjects);
                this._createGeometryResults = undefined;
                this._state = PrimitiveState.COMBINING;
                when(promise, function (packedResult) {
                    var result = PrimitivePipeline.unpackCombineGeometryResults(packedResult);
                    that._geometries = result.geometries;
                    that._attributeLocations = result.attributeLocations;
                    that._vaAttributes = result.vaAttributes;
                    that._perInstanceAttributeLocations = result.perInstanceAttributeLocations;
                    that.modelMatrix = Matrix4.clone(result.modelMatrix, that.modelMatrix);
                    that._validModelMatrix = !Matrix4.equals(that.modelMatrix, Matrix4.IDENTITY);
                    var validInstancesIndices = packedResult.validInstancesIndices;
                    var invalidInstancesIndices = packedResult.invalidInstancesIndices;
                    var instanceIds = that._instanceIds;
                    var reorderedInstanceIds = new Array(instanceIds.length);
                    var validLength = validInstancesIndices.length;
                    for (var i = 0; i < validLength; ++i) {
                        reorderedInstanceIds[i] = instanceIds[validInstancesIndices[i]];
                    }
                    var invalidLength = invalidInstancesIndices.length;
                    for (var j = 0; j < invalidLength; ++j) {
                        reorderedInstanceIds[validLength + j] = instanceIds[invalidInstancesIndices[j]];
                    }
                    that._instanceIds = reorderedInstanceIds;
                    that._state = defined(that._geometries) ? PrimitiveState.COMBINED : PrimitiveState.FAILED;
                }).otherwise(function (error) {
                    setReady(that, frameState, PrimitiveState.FAILED, error);
                });
            }
        } else {
            instances = isArray(this.geometryInstances) ? this.geometryInstances : [this.geometryInstances];
            this._numberOfInstances = length = instances.length;
            geometries = new Array(length);
            clonedInstances = new Array(length);
            var invalidInstances = [];
            var geometryIndex = 0;
            for (i = 0; i < length; i++) {
                instance = instances[i];
                geometry = instance.geometry;
                var createdGeometry;
                if (defined(geometry.attributes) && defined(geometry.primitiveType)) {
                    createdGeometry = cloneGeometry(geometry);
                } else {
                    createdGeometry = geometry.constructor.createGeometry(geometry);
                }
                if (defined(createdGeometry)) {
                    geometries[geometryIndex] = createdGeometry;
                    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);
                    instanceIds.push(instance.id);
                } else {
                    invalidInstances.push(instance);
                }
            }
            geometries.length = geometryIndex;
            clonedInstances.length = geometryIndex;
            var result = PrimitivePipeline.combineGeometry({
                    instances: clonedInstances,
                    invalidInstances: invalidInstances,
                    pickIds: allowPicking ? createPickIds(context, this, clonedInstances) : undefined,
                    ellipsoid: projection.ellipsoid,
                    projection: projection,
                    elementIndexUintSupported: context.elementIndexUint,
                    scene3DOnly: scene3DOnly,
                    allowPicking: allowPicking,
                    vertexCacheOptimize: this.vertexCacheOptimize,
                    compressVertices: this.compressVertices,
                    modelMatrix: this.modelMatrix
                });
            this._geometries = result.geometries;
            this._attributeLocations = result.attributeLocations;
            this._vaAttributes = result.vaAttributes;
            this._perInstanceAttributeLocations = result.vaAttributeLocations;
            this.modelMatrix = Matrix4.clone(result.modelMatrix, this.modelMatrix);
            this._validModelMatrix = !Matrix4.equals(this.modelMatrix, Matrix4.IDENTITY);
            for (i = 0; i < invalidInstances.length; ++i) {
                instance = invalidInstances[i];
                instanceIds.push(instance.id);
            }
            if (defined(this._geometries)) {
                this._state = PrimitiveState.COMBINED;
            } else {
                setReady(this, frameState, PrimitiveState.FAILED, undefined);
            }
        }
    }
    var attributeLocations = this._attributeLocations;
    if (this._state === PrimitiveState.COMBINED) {
        geometries = this._geometries;
        var vaAttributes = this._vaAttributes;
        var va = [];
        length = geometries.length;
        for (i = 0; i < length; ++i) {
            geometry = geometries[i];
            attributes = vaAttributes[i];
            var vaLength = attributes.length;
            for (j = 0; j < vaLength; ++j) {
                attribute = attributes[j];
                attribute.vertexBuffer = context.createVertexBuffer(attribute.values, BufferUsage.DYNAMIC_DRAW);
                delete attribute.values;
            }
            va.push(context.createVertexArrayFromGeometry({
                geometry: geometry,
                attributeLocations: attributeLocations,
                bufferUsage: BufferUsage.STATIC_DRAW,
                interleave: this._interleave,
                vertexArrayAttributes: attributes
            }));
            this._boundingSpheres.push(BoundingSphere.clone(geometry.boundingSphere));
            this._boundingSphereWC.push(new BoundingSphere());
            if (!scene3DOnly) {
                var center = geometry.boundingSphereCV.center;
                var x = center.x;
                var y = center.y;
                var z = center.z;
                center.x = z;
                center.y = x;
                center.z = y;
                this._boundingSphereCV.push(BoundingSphere.clone(geometry.boundingSphereCV));
                this._boundingSphere2D.push(new BoundingSphere());
                this._boundingSphereMorph.push(new BoundingSphere());
            }
        }
        this._va = va;
        this._primitiveType = geometries[0].primitiveType;
        if (this.releaseGeometryInstances) {
            this.geometryInstances = undefined;
        }
        this._geometries = undefined;
        setReady(this, frameState, PrimitiveState.COMPLETE, undefined);
    }
    if (!this.show || this._state !== PrimitiveState.COMPLETE) {
        return;
    }
    var appearance = this.appearance;
    var material = appearance.material;
    var createRS = false;
    var createSP = false;
    if (this._appearance !== appearance) {
        this._appearance = appearance;
        this._material = material;
        createRS = true;
        createSP = true;
    } else if (this._material !== material) {
        this._material = material;
        createSP = true;
    }
    var translucent = this._appearance.isTranslucent();
    if (this._translucent !== translucent) {
        this._translucent = translucent;
        createRS = true;
    }
    if (defined(this._material)) {
        this._material.update(context);
    }
    var twoPasses = appearance.closed && translucent;
    if (createRS) {
        var renderState = appearance.getRenderState();
        var rs;
        if (twoPasses) {
            rs = clone(renderState, false);
            rs.cull = {
                enabled: true,
                face: CullFace.BACK
            };
            this._frontFaceRS = context.createRenderState(rs);
            rs.cull.face = CullFace.FRONT;
            this._backFaceRS = context.createRenderState(rs);
        } else {
            this._frontFaceRS = context.createRenderState(renderState);
            this._backFaceRS = this._frontFaceRS;
        }
        if (allowPicking) {
            if (twoPasses) {
                rs = clone(renderState, false);
                rs.cull = { enabled: false };
                this._pickRS = context.createRenderState(rs);
            } else {
                this._pickRS = this._frontFaceRS;
            }
        } else {
            rs = clone(renderState, false);
            rs.colorMask = {
                red: false,
                green: false,
                blue: false,
                alpha: false
            };
            if (twoPasses) {
                rs.cull = { enabled: false };
                this._pickRS = context.createRenderState(rs);
            } else {
                this._pickRS = context.createRenderState(rs);
            }
        }
    }
    if (createSP) {
        var vs = createColumbusViewShader(this, appearance.vertexShaderSource, scene3DOnly);
        vs = appendShow(this, vs);
        vs = modifyForEncodedNormals(this, vs);
        var fs = appearance.getFragmentShaderSource();
        this._sp = context.replaceShaderProgram(this._sp, vs, fs, attributeLocations);
        validateShaderMatching(this._sp, attributeLocations);
        if (allowPicking) {
            var pickFS = new ShaderSource({
                    sources: [fs],
                    pickColorQualifier: 'varying'
                });
            this._pickSP = context.replaceShaderProgram(this._pickSP, createPickVertexShaderSource(vs), pickFS, attributeLocations);
        } else {
            this._pickSP = context.createShaderProgram(vs, fs, attributeLocations);
        }
        validateShaderMatching(this._pickSP, attributeLocations);
    }
    var colorCommands = this._colorCommands;
    var pickCommands = this._pickCommands;
    if (createRS || createSP) {
        var materialUniformMap = defined(material) ? material._uniforms : undefined;
        var appearanceUniformMap = {};
        var appearanceUniforms = appearance.uniforms;
        if (defined(appearanceUniforms)) {
            for (var name in appearanceUniforms) {
                if (appearanceUniforms.hasOwnProperty(name)) {
                    if (defined(materialUniformMap) && defined(materialUniformMap[name])) {
                        throw new DeveloperError('Appearance and material have a uniform with the same name: ' + name);
                    }
                    appearanceUniformMap[name] = getUniformFunction(appearanceUniforms, name);
                }
            }
        }
        var uniforms = combine(appearanceUniformMap, materialUniformMap);
        var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;
        colorCommands.length = this._va.length * (twoPasses ? 2 : 1);
        pickCommands.length = this._va.length;
        length = colorCommands.length;
        var m = 0;
        var vaIndex = 0;
        for (i = 0; i < length; ++i) {
            if (twoPasses) {
                colorCommand = colorCommands[i];
                if (!defined(colorCommand)) {
                    colorCommand = colorCommands[i] = new DrawCommand({
                        owner: this,
                        primitiveType: this._primitiveType
                    });
                }
                colorCommand.vertexArray = this._va[vaIndex];
                colorCommand.renderState = this._backFaceRS;
                colorCommand.shaderProgram = this._sp;
                colorCommand.uniformMap = uniforms;
                colorCommand.pass = pass;
                ++i;
            }
            colorCommand = colorCommands[i];
            if (!defined(colorCommand)) {
                colorCommand = colorCommands[i] = new DrawCommand({
                    owner: this,
                    primitiveType: this._primitiveType
                });
            }
            colorCommand.vertexArray = this._va[vaIndex];
            colorCommand.renderState = this._frontFaceRS;
            colorCommand.shaderProgram = this._sp;
            colorCommand.uniformMap = uniforms;
            colorCommand.pass = pass;
            pickCommand = pickCommands[m];
            if (!defined(pickCommand)) {
                pickCommand = pickCommands[m] = new DrawCommand({
                    owner: this,
                    primitiveType: this._primitiveType
                });
            }
            pickCommand.vertexArray = this._va[vaIndex];
            pickCommand.renderState = this._pickRS;
            pickCommand.shaderProgram = this._pickSP;
            pickCommand.uniformMap = uniforms;
            pickCommand.pass = pass;
            ++m;
            ++vaIndex;
        }
    }
    if (this._dirtyAttributes.length > 0) {
        attributes = this._dirtyAttributes;
        length = attributes.length;
        for (i = 0; i < length; ++i) {
            attribute = attributes[i];
            var value = attribute.value;
            var indices = attribute.indices;
            var indicesLength = indices.length;
            for (j = 0; j < indicesLength; ++j) {
                index = indices[j];
                var offset = index.offset;
                var count = index.count;
                var vaAttribute = index.attribute;
                var componentDatatype = vaAttribute.componentDatatype;
                var componentsPerAttribute = vaAttribute.componentsPerAttribute;
                var typedArray = ComponentDatatype.createTypedArray(componentDatatype, count * componentsPerAttribute);
                for (var k = 0; k < count; ++k) {
                    typedArray.set(value, k * componentsPerAttribute);
                }
                var offsetInBytes = offset * componentsPerAttribute * ComponentDatatype.getSizeInBytes(componentDatatype);
                vaAttribute.vertexBuffer.copyFromArrayView(typedArray, offsetInBytes);
            }
            attribute.dirty = false;
        }
        attributes.length = 0;
    }
    var modelMatrix;
    if (this._numberOfInstances > 1 && !this._validModelMatrix || frameState.mode !== SceneMode.SCENE3D) {
        modelMatrix = Matrix4.IDENTITY;
    } else {
        modelMatrix = this.modelMatrix;
    }
    if (!Matrix4.equals(modelMatrix, this._modelMatrix)) {
        Matrix4.clone(modelMatrix, this._modelMatrix);
        length = this._boundingSpheres.length;
        for (i = 0; i < length; ++i) {
            var boundingSphere = this._boundingSpheres[i];
            if (defined(boundingSphere)) {
                this._boundingSphereWC[i] = BoundingSphere.transform(boundingSphere, modelMatrix, this._boundingSphereWC[i]);
                if (!scene3DOnly) {
                    this._boundingSphere2D[i] = BoundingSphere.clone(this._boundingSphereCV[i], this._boundingSphere2D[i]);
                    this._boundingSphere2D[i].center.x = 0;
                    this._boundingSphereMorph[i] = BoundingSphere.union(this._boundingSphereWC[i], this._boundingSphereCV[i]);
                }
            }
        }
    }
    var boundingSpheres;
    if (frameState.mode === SceneMode.SCENE3D) {
        boundingSpheres = this._boundingSphereWC;
    } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {
        boundingSpheres = this._boundingSphereCV;
    } else if (frameState.mode === SceneMode.SCENE2D && defined(this._boundingSphere2D)) {
        boundingSpheres = this._boundingSphere2D;
    } else if (defined(this._boundingSphereMorph)) {
        boundingSpheres = this._boundingSphereMorph;
    }
    var passes = frameState.passes;
    if (passes.render) {
        length = colorCommands.length;
        for (i = 0; i < length; ++i) {
            var sphereIndex = twoPasses ? Math.floor(i / 2) : i;
            colorCommands[i].modelMatrix = modelMatrix;
            colorCommands[i].boundingVolume = boundingSpheres[sphereIndex];
            colorCommands[i].cull = this.cull;
            colorCommands[i].debugShowBoundingVolume = this.debugShowBoundingVolume;
            commandList.push(colorCommands[i]);
        }
    }
    if (passes.pick) {
        length = pickCommands.length;
        for (i = 0; i < length; ++i) {
            pickCommands[i].modelMatrix = modelMatrix;
            pickCommands[i].boundingVolume = boundingSpheres[i];
            pickCommands[i].cull = this.cull;
            commandList.push(pickCommands[i]);
        }
    }
};
function createGetFunction(name, perInstanceAttributes) {
    var attribute = perInstanceAttributes[name];
    return function () {
        if (defined(attribute) && defined(attribute.value)) {
            return perInstanceAttributes[name].value;
        }
        return attribute;
    };
}
function createSetFunction(name, perInstanceAttributes, dirtyList) {
    return function (value) {
        if (!defined(value) || !defined(value.length) || value.length < 1 || value.length > 4) {
            throw new DeveloperError('value must be and array with length between 1 and 4.');
        }
        var attribute = perInstanceAttributes[name];
        attribute.value = value;
        if (!attribute.dirty && attribute.valid) {
            dirtyList.push(attribute);
            attribute.dirty = true;
        }
    };
}
Primitive.prototype.getGeometryInstanceAttributes = function (id) {
    if (!defined(id)) {
        throw new DeveloperError('id is required');
    }
    if (!defined(this._perInstanceAttributeLocations)) {
        throw new DeveloperError('must call update before calling getGeometryInstanceAttributes');
    }
    var index = -1;
    var lastIndex = this._lastPerInstanceAttributeIndex;
    var ids = this._instanceIds;
    var length = ids.length;
    for (var i = 0; i < length; ++i) {
        var curIndex = (lastIndex + i) % length;
        if (id === ids[curIndex]) {
            index = curIndex;
            break;
        }
    }
    if (index === -1) {
        return undefined;
    }
    var attributes = this._perInstanceAttributeCache[index];
    if (defined(attributes)) {
        return attributes;
    }
    var perInstanceAttributes = this._perInstanceAttributeLocations[index];
    attributes = {};
    var properties = {};
    var hasProperties = false;
    for (var name in perInstanceAttributes) {
        if (perInstanceAttributes.hasOwnProperty(name)) {
            hasProperties = true;
            properties[name] = { get: createGetFunction(name, perInstanceAttributes) };
            if (name !== 'boundingSphere' && name !== 'boundingSphereCV') {
                properties[name].set = createSetFunction(name, perInstanceAttributes, this._dirtyAttributes);
            }
        }
    }
    if (hasProperties) {
        defineProperties(attributes, properties);
    }
    this._lastPerInstanceAttributeIndex = index;
    this._perInstanceAttributeCache[index] = attributes;
    return attributes;
};
Primitive.prototype.isDestroyed = function () {
    return false;
};
Primitive.prototype.destroy = function () {
    var length;
    var i;
    this._sp = this._sp && this._sp.destroy();
    this._pickSP = this._pickSP && this._pickSP.destroy();
    var va = this._va;
    length = va.length;
    for (i = 0; i < length; ++i) {
        va[i].destroy();
    }
    this._va = undefined;
    var pickIds = this._pickIds;
    length = pickIds.length;
    for (i = 0; i < length; ++i) {
        pickIds[i].destroy();
    }
    this._pickIds = undefined;
    return destroyObject(this);
};
function setReady(primitive, frameState, state, error) {
    primitive._error = error;
    primitive._state = state;
    frameState.afterRender.push(function () {
        primitive._ready = primitive._state === PrimitiveState.COMPLETE || primitive._state === PrimitiveState.FAILED;
        if (!defined(error)) {
            primitive._readyPromise.resolve(primitive);
        } else {
            primitive._readyPromise.reject(error);
        }
    });
}
module.exports = Primitive;
},{"../Core/BoundingSphere":98,"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/FeatureDetection":141,"../Core/Geometry":145,"../Core/GeometryAttribute":146,"../Core/GeometryAttributes":147,"../Core/GeometryInstance":148,"../Core/GeometryInstanceAttribute":149,"../Core/Matrix4":177,"../Core/TaskProcessor":217,"../Core/clone":240,"../Core/combine":241,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Core/isArray":253,"../Core/subdivideArray":271,"../Renderer/BufferUsage":339,"../Renderer/DrawCommand":344,"../Renderer/ShaderSource":355,"../ThirdParty/when":596,"./CullFace":380,"./Pass":419,"./PrimitivePipeline":430,"./PrimitiveState":431,"./SceneMode":438}],429:[function(require,module,exports){
var createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError');
'use strict';
var PrimitiveCollection = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this._primitives = [];
    this._guid = createGuid();
    this.show = defaultValue(options.show, true);
    this.destroyPrimitives = defaultValue(options.destroyPrimitives, true);
};
defineProperties(PrimitiveCollection.prototype, {
    length: {
        get: function () {
            return this._primitives.length;
        }
    }
});
PrimitiveCollection.prototype.add = function (primitive) {
    if (!defined(primitive)) {
        throw new DeveloperError('primitive is required.');
    }
    var external = primitive._external = primitive._external || {};
    var composites = external._composites = external._composites || {};
    composites[this._guid] = { collection: this };
    this._primitives.push(primitive);
    return primitive;
};
PrimitiveCollection.prototype.remove = function (primitive) {
    if (this.contains(primitive)) {
        var index = this._primitives.indexOf(primitive);
        if (index !== -1) {
            this._primitives.splice(index, 1);
            delete primitive._external._composites[this._guid];
            if (this.destroyPrimitives) {
                primitive.destroy();
            }
            return true;
        }
    }
    return false;
};
PrimitiveCollection.prototype.removeAndDestroy = function (primitive) {
    var removed = this.remove(primitive);
    if (removed && !this.destroyPrimitives) {
        primitive.destroy();
    }
    return removed;
};
PrimitiveCollection.prototype.removeAll = function () {
    if (this.destroyPrimitives) {
        var primitives = this._primitives;
        var length = primitives.length;
        for (var i = 0; i < length; ++i) {
            primitives[i].destroy();
        }
    }
    this._primitives = [];
};
PrimitiveCollection.prototype.contains = function (primitive) {
    return !!(defined(primitive) && primitive._external && primitive._external._composites && primitive._external._composites[this._guid]);
};
function getPrimitiveIndex(compositePrimitive, primitive) {
    if (!compositePrimitive.contains(primitive)) {
        throw new DeveloperError('primitive is not in this collection.');
    }
    return compositePrimitive._primitives.indexOf(primitive);
}
PrimitiveCollection.prototype.raise = function (primitive) {
    if (defined(primitive)) {
        var index = getPrimitiveIndex(this, primitive);
        var primitives = this._primitives;
        if (index !== primitives.length - 1) {
            var p = primitives[index];
            primitives[index] = primitives[index + 1];
            primitives[index + 1] = p;
        }
    }
};
PrimitiveCollection.prototype.raiseToTop = function (primitive) {
    if (defined(primitive)) {
        var index = getPrimitiveIndex(this, primitive);
        var primitives = this._primitives;
        if (index !== primitives.length - 1) {
            primitives.splice(index, 1);
            primitives.push(primitive);
        }
    }
};
PrimitiveCollection.prototype.lower = function (primitive) {
    if (defined(primitive)) {
        var index = getPrimitiveIndex(this, primitive);
        var primitives = this._primitives;
        if (index !== 0) {
            var p = primitives[index];
            primitives[index] = primitives[index - 1];
            primitives[index - 1] = p;
        }
    }
};
PrimitiveCollection.prototype.lowerToBottom = function (primitive) {
    if (defined(primitive)) {
        var index = getPrimitiveIndex(this, primitive);
        var primitives = this._primitives;
        if (index !== 0) {
            primitives.splice(index, 1);
            primitives.unshift(primitive);
        }
    }
};
PrimitiveCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    return this._primitives[index];
};
PrimitiveCollection.prototype.update = function (context, frameState, commandList) {
    if (!this.show) {
        return;
    }
    var primitives = this._primitives;
    for (var i = 0; i < primitives.length; ++i) {
        primitives[i].update(context, frameState, commandList);
    }
};
PrimitiveCollection.prototype.isDestroyed = function () {
    return false;
};
PrimitiveCollection.prototype.destroy = function () {
    this.removeAll();
    return destroyObject(this);
};
module.exports = PrimitiveCollection;
},{"../Core/DeveloperError":123,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247}],430:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), Color = require('../Core/Color'), ComponentDatatype = require('../Core/ComponentDatatype'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), Ellipsoid = require('../Core/Ellipsoid'), FeatureDetection = require('../Core/FeatureDetection'), GeographicProjection = require('../Core/GeographicProjection'), Geometry = require('../Core/Geometry'), GeometryAttribute = require('../Core/GeometryAttribute'), GeometryPipeline = require('../Core/GeometryPipeline'), IndexDatatype = require('../Core/IndexDatatype'), Matrix4 = require('../Core/Matrix4'), WebMercatorProjection = require('../Core/WebMercatorProjection');
'use strict';
if (!FeatureDetection.supportsTypedArrays()) {
    return {};
}
function transformToWorldCoordinates(instances, primitiveModelMatrix, scene3DOnly) {
    var toWorld = !scene3DOnly;
    var length = instances.length;
    var i;
    if (!toWorld && length > 1) {
        var modelMatrix = instances[0].modelMatrix;
        for (i = 1; i < length; ++i) {
            if (!Matrix4.equals(modelMatrix, instances[i].modelMatrix)) {
                toWorld = true;
                break;
            }
        }
    }
    if (toWorld) {
        for (i = 0; i < length; ++i) {
            GeometryPipeline.transformToWorldCoordinates(instances[i]);
        }
    } else {
        Matrix4.multiplyTransformation(primitiveModelMatrix, instances[0].modelMatrix, primitiveModelMatrix);
    }
}
function addGeometryPickColor(geometry, pickColor) {
    var attributes = geometry.attributes;
    var positionAttr = attributes.position;
    var numberOfComponents = 4 * (positionAttr.values.length / positionAttr.componentsPerAttribute);
    attributes.pickColor = new GeometryAttribute({
        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,
        componentsPerAttribute: 4,
        normalize: true,
        values: new Uint8Array(numberOfComponents)
    });
    var red = Color.floatToByte(pickColor.red);
    var green = Color.floatToByte(pickColor.green);
    var blue = Color.floatToByte(pickColor.blue);
    var alpha = Color.floatToByte(pickColor.alpha);
    var values = attributes.pickColor.values;
    for (var j = 0; j < numberOfComponents; j += 4) {
        values[j] = red;
        values[j + 1] = green;
        values[j + 2] = blue;
        values[j + 3] = alpha;
    }
}
function addPickColorAttribute(instances, pickIds) {
    var length = instances.length;
    for (var i = 0; i < length; ++i) {
        var instance = instances[i];
        var pickColor = pickIds[i];
        if (defined(instance.geometry)) {
            addGeometryPickColor(instance.geometry, pickColor);
        } else {
            addGeometryPickColor(instance.westHemisphereGeometry, pickColor);
            addGeometryPickColor(instance.eastHemisphereGeometry, pickColor);
        }
    }
}
function getCommonPerInstanceAttributeNames(instances) {
    var length = instances.length;
    var attributesInAllInstances = [];
    var attributes0 = instances[0].attributes;
    var name;
    for (name in attributes0) {
        if (attributes0.hasOwnProperty(name)) {
            var attribute = attributes0[name];
            var inAllInstances = true;
            for (var i = 1; i < length; ++i) {
                var otherAttribute = instances[i].attributes[name];
                if (!defined(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {
                    inAllInstances = false;
                    break;
                }
            }
            if (inAllInstances) {
                attributesInAllInstances.push(name);
            }
        }
    }
    return attributesInAllInstances;
}
function addPerInstanceAttributesToGeometry(instanceAttributes, geometry, names) {
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    var namesLength = names.length;
    for (var j = 0; j < namesLength; ++j) {
        var name = names[j];
        var attribute = instanceAttributes[name];
        var componentDatatype = attribute.componentDatatype;
        var value = attribute.value;
        var componentsPerAttribute = value.length;
        var buffer = ComponentDatatype.createTypedArray(componentDatatype, numberOfVertices * componentsPerAttribute);
        for (var k = 0; k < numberOfVertices; ++k) {
            buffer.set(value, k * componentsPerAttribute);
        }
        geometry.attributes[name] = new GeometryAttribute({
            componentDatatype: componentDatatype,
            componentsPerAttribute: componentsPerAttribute,
            normalize: attribute.normalize,
            values: buffer
        });
    }
}
function addPerInstanceAttributes(instances, names) {
    var length = instances.length;
    for (var i = 0; i < length; ++i) {
        var instance = instances[i];
        var instanceAttributes = instance.attributes;
        if (defined(instance.geometry)) {
            addPerInstanceAttributesToGeometry(instanceAttributes, instance.geometry, names);
        } else {
            addPerInstanceAttributesToGeometry(instanceAttributes, instance.westHemisphereGeometry, names);
            addPerInstanceAttributesToGeometry(instanceAttributes, instance.eastHemisphereGeometry, names);
        }
    }
}
function geometryPipeline(parameters) {
    var instances = parameters.instances;
    var pickIds = parameters.pickIds;
    var projection = parameters.projection;
    var uintIndexSupport = parameters.elementIndexUintSupported;
    var scene3DOnly = parameters.scene3DOnly;
    var allowPicking = parameters.allowPicking;
    var vertexCacheOptimize = parameters.vertexCacheOptimize;
    var compressVertices = parameters.compressVertices;
    var modelMatrix = parameters.modelMatrix;
    var i;
    var geometry;
    var length = instances.length;
    var primitiveType = instances[0].geometry.primitiveType;
    for (i = 1; i < length; ++i) {
        if (instances[i].geometry.primitiveType !== primitiveType) {
            throw new DeveloperError('All instance geometries must have the same primitiveType.');
        }
    }
    transformToWorldCoordinates(instances, modelMatrix, scene3DOnly);
    if (!scene3DOnly) {
        for (i = 0; i < length; ++i) {
            GeometryPipeline.splitLongitude(instances[i]);
        }
    }
    if (allowPicking) {
        addPickColorAttribute(instances, pickIds);
    }
    var perInstanceAttributeNames = getCommonPerInstanceAttributeNames(instances);
    addPerInstanceAttributes(instances, perInstanceAttributeNames);
    if (vertexCacheOptimize) {
        for (i = 0; i < length; ++i) {
            var instance = instances[i];
            if (defined(instance.geometry)) {
                GeometryPipeline.reorderForPostVertexCache(instance.geometry);
                GeometryPipeline.reorderForPreVertexCache(instance.geometry);
            } else {
                GeometryPipeline.reorderForPostVertexCache(instance.westHemisphereGeometry);
                GeometryPipeline.reorderForPreVertexCache(instance.westHemisphereGeometry);
                GeometryPipeline.reorderForPostVertexCache(instance.eastHemisphereGeometry);
                GeometryPipeline.reorderForPreVertexCache(instance.eastHemisphereGeometry);
            }
        }
    }
    var geometries = GeometryPipeline.combineInstances(instances);
    length = geometries.length;
    for (i = 0; i < length; ++i) {
        geometry = geometries[i];
        var attributes = geometry.attributes;
        var name;
        if (!scene3DOnly) {
            for (name in attributes) {
                if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {
                    var name3D = name + '3D';
                    var name2D = name + '2D';
                    GeometryPipeline.projectTo2D(geometry, name, name3D, name2D, projection);
                    if (defined(geometry.boundingSphere) && name === 'position') {
                        geometry.boundingSphereCV = BoundingSphere.fromVertices(geometry.attributes.position2D.values);
                    }
                    GeometryPipeline.encodeAttribute(geometry, name3D, name3D + 'High', name3D + 'Low');
                    GeometryPipeline.encodeAttribute(geometry, name2D, name2D + 'High', name2D + 'Low');
                }
            }
        } else {
            for (name in attributes) {
                if (attributes.hasOwnProperty(name) && attributes[name].componentDatatype === ComponentDatatype.DOUBLE) {
                    GeometryPipeline.encodeAttribute(geometry, name, name + '3DHigh', name + '3DLow');
                }
            }
        }
        if (compressVertices) {
            GeometryPipeline.compressVertices(geometry);
        }
    }
    if (!uintIndexSupport) {
        var splitGeometries = [];
        length = geometries.length;
        for (i = 0; i < length; ++i) {
            geometry = geometries[i];
            splitGeometries = splitGeometries.concat(GeometryPipeline.fitToUnsignedShortIndices(geometry));
        }
        geometries = splitGeometries;
    }
    return geometries;
}
function createPerInstanceVAAttributes(geometry, attributeLocations, names) {
    var vaAttributes = [];
    var attributes = geometry.attributes;
    var length = names.length;
    for (var i = 0; i < length; ++i) {
        var name = names[i];
        var attribute = attributes[name];
        var componentDatatype = attribute.componentDatatype;
        if (componentDatatype === ComponentDatatype.DOUBLE) {
            componentDatatype = ComponentDatatype.FLOAT;
        }
        var typedArray = ComponentDatatype.createTypedArray(componentDatatype, attribute.values);
        vaAttributes.push({
            index: attributeLocations[name],
            componentDatatype: componentDatatype,
            componentsPerAttribute: attribute.componentsPerAttribute,
            normalize: attribute.normalize,
            values: typedArray
        });
        delete attributes[name];
    }
    return vaAttributes;
}
function computePerInstanceAttributeLocationsForGeometry(instanceIndex, geometry, instanceAttributes, names, attributeLocations, vertexArrays, indices, offsets, vaIndices) {
    var numberOfVertices = Geometry.computeNumberOfVertices(geometry);
    if (!defined(indices[instanceIndex])) {
        indices[instanceIndex] = {
            boundingSphere: geometry.boundingSphere,
            boundingSphereCV: geometry.boundingSphereCV
        };
    }
    var namesLength = names.length;
    for (var j = 0; j < namesLength; ++j) {
        var name = names[j];
        var index = attributeLocations[name];
        var tempVertexCount = numberOfVertices;
        while (tempVertexCount > 0) {
            var vaIndex = defaultValue(vaIndices[name], 0);
            var va = vertexArrays[vaIndex];
            var vaLength = va.length;
            var attribute;
            for (var k = 0; k < vaLength; ++k) {
                attribute = va[k];
                if (attribute.index === index) {
                    break;
                }
            }
            if (!defined(indices[instanceIndex][name])) {
                indices[instanceIndex][name] = {
                    dirty: false,
                    valid: true,
                    value: instanceAttributes[name].value,
                    indices: []
                };
            }
            var size = attribute.values.length / attribute.componentsPerAttribute;
            var offset = defaultValue(offsets[name], 0);
            var count;
            if (offset + tempVertexCount < size) {
                count = tempVertexCount;
                indices[instanceIndex][name].indices.push({
                    attribute: attribute,
                    offset: offset,
                    count: count
                });
                offsets[name] = offset + tempVertexCount;
            } else {
                count = size - offset;
                indices[instanceIndex][name].indices.push({
                    attribute: attribute,
                    offset: offset,
                    count: count
                });
                offsets[name] = 0;
                vaIndices[name] = vaIndex + 1;
            }
            tempVertexCount -= count;
        }
    }
}
function computePerInstanceAttributeLocations(instances, invalidInstances, vertexArrays, attributeLocations, names) {
    var indices = [];
    var length = instances.length;
    var offsets = {};
    var vaIndices = {};
    var i;
    var instance;
    var attributes;
    for (i = 0; i < length; ++i) {
        instance = instances[i];
        attributes = instance.attributes;
        if (defined(instance.geometry)) {
            computePerInstanceAttributeLocationsForGeometry(i, instance.geometry, attributes, names, attributeLocations, vertexArrays, indices, offsets, vaIndices);
        }
    }
    for (i = 0; i < length; ++i) {
        instance = instances[i];
        attributes = instance.attributes;
        if (defined(instance.westHemisphereGeometry)) {
            computePerInstanceAttributeLocationsForGeometry(i, instance.westHemisphereGeometry, attributes, names, attributeLocations, vertexArrays, indices, offsets, vaIndices);
        }
    }
    for (i = 0; i < length; ++i) {
        instance = instances[i];
        attributes = instance.attributes;
        if (defined(instance.eastHemisphereGeometry)) {
            computePerInstanceAttributeLocationsForGeometry(i, instance.eastHemisphereGeometry, attributes, names, attributeLocations, vertexArrays, indices, offsets, vaIndices);
        }
    }
    length = invalidInstances.length;
    for (i = 0; i < length; ++i) {
        instance = invalidInstances[i];
        attributes = instance.attributes;
        var instanceAttributes = {};
        indices.push(instanceAttributes);
        var namesLength = names.length;
        for (var j = 0; j < namesLength; ++j) {
            var name = names[j];
            instanceAttributes[name] = {
                dirty: false,
                valid: false,
                value: attributes[name].value,
                indices: []
            };
        }
    }
    return indices;
}
var PrimitivePipeline = {};
PrimitivePipeline.combineGeometry = function (parameters) {
    var geometries;
    var attributeLocations;
    var perInstanceAttributes;
    var perInstanceAttributeNames;
    var length;
    var instances = parameters.instances;
    var invalidInstances = parameters.invalidInstances;
    if (instances.length > 0) {
        geometries = geometryPipeline(parameters);
        attributeLocations = GeometryPipeline.createAttributeLocations(geometries[0]);
        perInstanceAttributeNames = getCommonPerInstanceAttributeNames(instances);
        perInstanceAttributes = [];
        length = geometries.length;
        for (var i = 0; i < length; ++i) {
            var geometry = geometries[i];
            perInstanceAttributes.push(createPerInstanceVAAttributes(geometry, attributeLocations, perInstanceAttributeNames));
        }
    }
    perInstanceAttributeNames = defined(perInstanceAttributeNames) ? perInstanceAttributeNames : getCommonPerInstanceAttributeNames(invalidInstances);
    var indices = computePerInstanceAttributeLocations(instances, invalidInstances, perInstanceAttributes, attributeLocations, perInstanceAttributeNames);
    return {
        geometries: geometries,
        modelMatrix: parameters.modelMatrix,
        attributeLocations: attributeLocations,
        vaAttributes: perInstanceAttributes,
        vaAttributeLocations: indices,
        validInstancesIndices: parameters.validInstancesIndices,
        invalidInstancesIndices: parameters.invalidInstancesIndices
    };
};
function transferGeometry(geometry, transferableObjects) {
    var attributes = geometry.attributes;
    for (var name in attributes) {
        if (attributes.hasOwnProperty(name)) {
            var attribute = attributes[name];
            if (defined(attribute) && defined(attribute.values)) {
                transferableObjects.push(attribute.values.buffer);
            }
        }
    }
    if (defined(geometry.indices)) {
        transferableObjects.push(geometry.indices.buffer);
    }
}
function transferGeometries(geometries, transferableObjects) {
    var length = geometries.length;
    for (var i = 0; i < length; ++i) {
        transferGeometry(geometries[i], transferableObjects);
    }
}
function transferPerInstanceAttributes(perInstanceAttributes, transferableObjects) {
    var length = perInstanceAttributes.length;
    for (var i = 0; i < length; ++i) {
        var vaAttributes = perInstanceAttributes[i];
        var vaLength = vaAttributes.length;
        for (var j = 0; j < vaLength; ++j) {
            transferableObjects.push(vaAttributes[j].values.buffer);
        }
    }
}
function countCreateGeometryResults(items) {
    var count = 1;
    var length = items.length;
    for (var i = 0; i < length; i++) {
        var geometry = items[i];
        ++count;
        if (!defined(geometry)) {
            continue;
        }
        var attributes = geometry.attributes;
        count += 6 + 2 * BoundingSphere.packedLength + (defined(geometry.indices) ? geometry.indices.length : 0);
        for (var property in attributes) {
            if (attributes.hasOwnProperty(property) && defined(attributes[property])) {
                var attribute = attributes[property];
                count += 5 + attribute.values.length;
            }
        }
    }
    return count;
}
PrimitivePipeline.packCreateGeometryResults = function (items, transferableObjects) {
    var packedData = new Float64Array(countCreateGeometryResults(items));
    var stringTable = [];
    var stringHash = {};
    var length = items.length;
    var count = 0;
    packedData[count++] = length;
    for (var i = 0; i < length; i++) {
        var geometry = items[i];
        var validGeometry = defined(geometry);
        packedData[count++] = validGeometry ? 1 : 0;
        if (!validGeometry) {
            continue;
        }
        packedData[count++] = geometry.primitiveType;
        packedData[count++] = geometry.geometryType;
        var validBoundingSphere = defined(geometry.boundingSphere) ? 1 : 0;
        packedData[count++] = validBoundingSphere;
        if (validBoundingSphere) {
            BoundingSphere.pack(geometry.boundingSphere, packedData, count);
        }
        count += BoundingSphere.packedLength;
        var validBoundingSphereCV = defined(geometry.boundingSphereCV) ? 1 : 0;
        packedData[count++] = validBoundingSphereCV;
        if (validBoundingSphereCV) {
            BoundingSphere.pack(geometry.boundingSphereCV, packedData, count);
        }
        count += BoundingSphere.packedLength;
        var attributes = geometry.attributes;
        var attributesToWrite = [];
        for (var property in attributes) {
            if (attributes.hasOwnProperty(property) && defined(attributes[property])) {
                attributesToWrite.push(property);
                if (!defined(stringHash[property])) {
                    stringHash[property] = stringTable.length;
                    stringTable.push(property);
                }
            }
        }
        packedData[count++] = attributesToWrite.length;
        for (var q = 0; q < attributesToWrite.length; q++) {
            var name = attributesToWrite[q];
            var attribute = attributes[name];
            packedData[count++] = stringHash[name];
            packedData[count++] = attribute.componentDatatype;
            packedData[count++] = attribute.componentsPerAttribute;
            packedData[count++] = attribute.normalize ? 1 : 0;
            packedData[count++] = attribute.values.length;
            packedData.set(attribute.values, count);
            count += attribute.values.length;
        }
        var indicesLength = defined(geometry.indices) ? geometry.indices.length : 0;
        packedData[count++] = indicesLength;
        if (indicesLength > 0) {
            packedData.set(geometry.indices, count);
            count += indicesLength;
        }
    }
    transferableObjects.push(packedData.buffer);
    return {
        stringTable: stringTable,
        packedData: packedData
    };
};
PrimitivePipeline.unpackCreateGeometryResults = function (createGeometryResult) {
    var stringTable = createGeometryResult.stringTable;
    var packedGeometry = createGeometryResult.packedData;
    var i;
    var result = new Array(packedGeometry[0]);
    var resultIndex = 0;
    var packedGeometryIndex = 1;
    while (packedGeometryIndex < packedGeometry.length) {
        var valid = packedGeometry[packedGeometryIndex++] === 1;
        if (!valid) {
            result[resultIndex++] = undefined;
            continue;
        }
        var primitiveType = packedGeometry[packedGeometryIndex++];
        var geometryType = packedGeometry[packedGeometryIndex++];
        var boundingSphere;
        var boundingSphereCV;
        var validBoundingSphere = packedGeometry[packedGeometryIndex++] === 1;
        if (validBoundingSphere) {
            boundingSphere = BoundingSphere.unpack(packedGeometry, packedGeometryIndex);
        }
        packedGeometryIndex += BoundingSphere.packedLength;
        var validBoundingSphereCV = packedGeometry[packedGeometryIndex++] === 1;
        if (validBoundingSphereCV) {
            boundingSphereCV = BoundingSphere.unpack(packedGeometry, packedGeometryIndex);
        }
        packedGeometryIndex += BoundingSphere.packedLength;
        var length;
        var values;
        var componentsPerAttribute;
        var attributes = {};
        var numAttributes = packedGeometry[packedGeometryIndex++];
        for (i = 0; i < numAttributes; i++) {
            var name = stringTable[packedGeometry[packedGeometryIndex++]];
            var componentDatatype = packedGeometry[packedGeometryIndex++];
            componentsPerAttribute = packedGeometry[packedGeometryIndex++];
            var normalize = packedGeometry[packedGeometryIndex++] !== 0;
            length = packedGeometry[packedGeometryIndex++];
            values = ComponentDatatype.createTypedArray(componentDatatype, length);
            for (var valuesIndex = 0; valuesIndex < length; valuesIndex++) {
                values[valuesIndex] = packedGeometry[packedGeometryIndex++];
            }
            attributes[name] = new GeometryAttribute({
                componentDatatype: componentDatatype,
                componentsPerAttribute: componentsPerAttribute,
                normalize: normalize,
                values: values
            });
        }
        var indices;
        length = packedGeometry[packedGeometryIndex++];
        if (length > 0) {
            var numberOfVertices = values.length / componentsPerAttribute;
            indices = IndexDatatype.createTypedArray(numberOfVertices, length);
            for (i = 0; i < length; i++) {
                indices[i] = packedGeometry[packedGeometryIndex++];
            }
        }
        result[resultIndex++] = new Geometry({
            primitiveType: primitiveType,
            geometryType: geometryType,
            boundingSphere: boundingSphere,
            indices: indices,
            attributes: attributes
        });
    }
    return result;
};
function packPickIds(pickIds, transferableObjects) {
    var length = pickIds.length;
    var packedPickIds = new Uint32Array(pickIds.length);
    for (var i = 0; i < length; ++i) {
        packedPickIds[i] = pickIds[i].toRgba();
    }
    transferableObjects.push(packedPickIds.buffer);
    return packedPickIds;
}
function unpackPickIds(packedPickIds) {
    var length = packedPickIds.length;
    var pickIds = new Array(length);
    for (var i = 0; i < length; i++) {
        pickIds[i] = Color.fromRgba(packedPickIds[i]);
    }
    return pickIds;
}
function countInstancesForCombine(instances) {
    var length = instances.length;
    var count = 1 + length * 17;
    for (var i = 0; i < length; i++) {
        var attributes = instances[i].attributes;
        for (var property in attributes) {
            if (attributes.hasOwnProperty(property) && defined(attributes[property])) {
                var attribute = attributes[property];
                count += 5 + attribute.value.length;
            }
        }
    }
    return count;
}
function packInstancesForCombine(instances, transferableObjects) {
    var packedData = new Float64Array(countInstancesForCombine(instances));
    var stringHash = {};
    var stringTable = [];
    var length = instances.length;
    var count = 0;
    packedData[count++] = length;
    for (var i = 0; i < length; i++) {
        var instance = instances[i];
        Matrix4.pack(instance.modelMatrix, packedData, count);
        count += Matrix4.packedLength;
        var attributes = instance.attributes;
        var attributesToWrite = [];
        for (var property in attributes) {
            if (attributes.hasOwnProperty(property) && defined(attributes[property])) {
                attributesToWrite.push(property);
                if (!defined(stringHash[property])) {
                    stringHash[property] = stringTable.length;
                    stringTable.push(property);
                }
            }
        }
        packedData[count++] = attributesToWrite.length;
        for (var q = 0; q < attributesToWrite.length; q++) {
            var name = attributesToWrite[q];
            var attribute = attributes[name];
            packedData[count++] = stringHash[name];
            packedData[count++] = attribute.componentDatatype;
            packedData[count++] = attribute.componentsPerAttribute;
            packedData[count++] = attribute.normalize;
            packedData[count++] = attribute.value.length;
            packedData.set(attribute.value, count);
            count += attribute.value.length;
        }
    }
    transferableObjects.push(packedData.buffer);
    return {
        stringTable: stringTable,
        packedData: packedData
    };
}
function unpackInstancesForCombine(data) {
    var packedInstances = data.packedData;
    var stringTable = data.stringTable;
    var result = new Array(packedInstances[0]);
    var count = 0;
    var i = 1;
    while (i < packedInstances.length) {
        var modelMatrix = Matrix4.unpack(packedInstances, i);
        i += Matrix4.packedLength;
        var attributes = {};
        var numAttributes = packedInstances[i++];
        for (var x = 0; x < numAttributes; x++) {
            var name = stringTable[packedInstances[i++]];
            var componentDatatype = packedInstances[i++];
            var componentsPerAttribute = packedInstances[i++];
            var normalize = packedInstances[i++] !== 0;
            var length = packedInstances[i++];
            var value = ComponentDatatype.createTypedArray(componentDatatype, length);
            for (var valueIndex = 0; valueIndex < length; valueIndex++) {
                value[valueIndex] = packedInstances[i++];
            }
            attributes[name] = {
                componentDatatype: componentDatatype,
                componentsPerAttribute: componentsPerAttribute,
                normalize: normalize,
                value: value
            };
        }
        result[count++] = {
            attributes: attributes,
            modelMatrix: modelMatrix
        };
    }
    return result;
}
function countAttributeLocations(attributeLocations) {
    var length = attributeLocations.length;
    var count = 1 + length;
    for (var i = 0; i < length; i++) {
        var instance = attributeLocations[i];
        count += 2;
        count += defined(instance.boundingSphere) ? BoundingSphere.packedLength : 0;
        count += defined(instance.boundingSphereCV) ? BoundingSphere.packedLength : 0;
        for (var propertyName in instance) {
            if (instance.hasOwnProperty(propertyName) && defined(instance[propertyName]) && propertyName !== 'boundingSphere' && propertyName !== 'boundingSphereCV') {
                var property = instance[propertyName];
                count += 4 + property.indices.length * 3 + property.value.length;
            }
        }
    }
    return count;
}
function packAttributeLocations(attributeLocations, transferableObjects) {
    var packedData = new Float64Array(countAttributeLocations(attributeLocations));
    var stringTable = [];
    var attributeTable = [];
    var stringHash = {};
    var length = attributeLocations.length;
    var count = 0;
    packedData[count++] = length;
    for (var i = 0; i < length; i++) {
        var instance = attributeLocations[i];
        var boundingSphere = instance.boundingSphere;
        var hasBoundingSphere = defined(boundingSphere);
        packedData[count++] = hasBoundingSphere ? 1 : 0;
        if (hasBoundingSphere) {
            BoundingSphere.pack(boundingSphere, packedData, count);
            count += BoundingSphere.packedLength;
        }
        boundingSphere = instance.boundingSphereCV;
        hasBoundingSphere = defined(boundingSphere);
        packedData[count++] = hasBoundingSphere ? 1 : 0;
        if (hasBoundingSphere) {
            BoundingSphere.pack(boundingSphere, packedData, count);
            count += BoundingSphere.packedLength;
        }
        var propertiesToWrite = [];
        for (var propertyName in instance) {
            if (instance.hasOwnProperty(propertyName) && defined(instance[propertyName]) && propertyName !== 'boundingSphere' && propertyName !== 'boundingSphereCV') {
                propertiesToWrite.push(propertyName);
                if (!defined(stringHash[propertyName])) {
                    stringHash[propertyName] = stringTable.length;
                    stringTable.push(propertyName);
                }
            }
        }
        packedData[count++] = propertiesToWrite.length;
        for (var q = 0; q < propertiesToWrite.length; q++) {
            var name = propertiesToWrite[q];
            var property = instance[name];
            packedData[count++] = stringHash[name];
            packedData[count++] = property.valid ? 1 : 0;
            var indices = property.indices;
            var indicesLength = indices.length;
            packedData[count++] = indicesLength;
            for (var x = 0; x < indicesLength; x++) {
                var index = indices[x];
                packedData[count++] = index.count;
                packedData[count++] = index.offset;
                var tableIndex = attributeTable.indexOf(index.attribute);
                if (tableIndex === -1) {
                    tableIndex = attributeTable.length;
                    attributeTable.push(index.attribute);
                }
                packedData[count++] = tableIndex;
            }
            packedData[count++] = property.value.length;
            packedData.set(property.value, count);
            count += property.value.length;
        }
    }
    transferableObjects.push(packedData.buffer);
    return {
        stringTable: stringTable,
        packedData: packedData,
        attributeTable: attributeTable
    };
}
function unpackAttributeLocations(packedAttributeLocations, vaAttributes) {
    var stringTable = packedAttributeLocations.stringTable;
    var attributeTable = packedAttributeLocations.attributeTable;
    var packedData = packedAttributeLocations.packedData;
    var attributeLocations = new Array(packedData[0]);
    var attributeLocationsIndex = 0;
    var i = 1;
    var packedDataLength = packedData.length;
    while (i < packedDataLength) {
        var instance = {};
        var hasBoundingSphere = packedData[i++] === 1;
        if (hasBoundingSphere) {
            instance.boundingSphere = BoundingSphere.unpack(packedData, i);
            i += BoundingSphere.packedLength;
        }
        hasBoundingSphere = packedData[i++] === 1;
        if (hasBoundingSphere) {
            instance.boundingSphereCV = BoundingSphere.unpack(packedData, i);
            i += BoundingSphere.packedLength;
        }
        var numAttributes = packedData[i++];
        for (var x = 0; x < numAttributes; x++) {
            var name = stringTable[packedData[i++]];
            var valid = packedData[i++] === 1;
            var indicesLength = packedData[i++];
            var indices = indicesLength > 0 ? new Array(indicesLength) : undefined;
            for (var indicesIndex = 0; indicesIndex < indicesLength; indicesIndex++) {
                var index = {};
                index.count = packedData[i++];
                index.offset = packedData[i++];
                index.attribute = attributeTable[packedData[i++]];
                indices[indicesIndex] = index;
            }
            var valueLength = packedData[i++];
            var value = valid ? ComponentDatatype.createTypedArray(indices[0].attribute.componentDatatype, valueLength) : new Array(valueLength);
            for (var valueIndex = 0; valueIndex < valueLength; valueIndex++) {
                value[valueIndex] = packedData[i++];
            }
            instance[name] = {
                dirty: false,
                valid: valid,
                indices: indices,
                value: value
            };
        }
        attributeLocations[attributeLocationsIndex++] = instance;
    }
    return attributeLocations;
}
PrimitivePipeline.packCombineGeometryParameters = function (parameters, transferableObjects) {
    var createGeometryResults = parameters.createGeometryResults;
    var length = createGeometryResults.length;
    for (var i = 0; i < length; i++) {
        transferableObjects.push(createGeometryResults[i].packedData.buffer);
    }
    var packedPickIds;
    if (parameters.allowPicking) {
        packedPickIds = packPickIds(parameters.pickIds, transferableObjects);
    }
    return {
        createGeometryResults: parameters.createGeometryResults,
        packedInstances: packInstancesForCombine(parameters.instances, transferableObjects),
        packedPickIds: packedPickIds,
        ellipsoid: parameters.ellipsoid,
        isGeographic: parameters.projection instanceof GeographicProjection,
        elementIndexUintSupported: parameters.elementIndexUintSupported,
        scene3DOnly: parameters.scene3DOnly,
        allowPicking: parameters.allowPicking,
        vertexCacheOptimize: parameters.vertexCacheOptimize,
        compressVertices: parameters.compressVertices,
        modelMatrix: parameters.modelMatrix
    };
};
PrimitivePipeline.unpackCombineGeometryParameters = function (packedParameters) {
    var instances = unpackInstancesForCombine(packedParameters.packedInstances);
    var pickIds = packedParameters.allowPicking ? unpackPickIds(packedParameters.packedPickIds) : undefined;
    var createGeometryResults = packedParameters.createGeometryResults;
    var length = createGeometryResults.length;
    var instanceIndex = 0;
    var validInstances = [];
    var invalidInstances = [];
    var validInstancesIndices = [];
    var invalidInstancesIndices = [];
    var validPickIds = [];
    for (var resultIndex = 0; resultIndex < length; resultIndex++) {
        var geometries = PrimitivePipeline.unpackCreateGeometryResults(createGeometryResults[resultIndex]);
        var geometriesLength = geometries.length;
        for (var geometryIndex = 0; geometryIndex < geometriesLength; geometryIndex++) {
            var geometry = geometries[geometryIndex];
            var instance = instances[instanceIndex];
            if (defined(geometry)) {
                instance.geometry = geometry;
                validInstances.push(instance);
                validInstancesIndices.push(instanceIndex);
                validPickIds.push(pickIds[instanceIndex]);
            } else {
                invalidInstances.push(instance);
                invalidInstancesIndices.push(instanceIndex);
            }
            ++instanceIndex;
        }
    }
    var ellipsoid = Ellipsoid.clone(packedParameters.ellipsoid);
    var projection = packedParameters.isGeographic ? new GeographicProjection(ellipsoid) : new WebMercatorProjection(ellipsoid);
    return {
        instances: validInstances,
        invalidInstances: invalidInstances,
        validInstancesIndices: validInstancesIndices,
        invalidInstancesIndices: invalidInstancesIndices,
        pickIds: validPickIds,
        ellipsoid: ellipsoid,
        projection: projection,
        elementIndexUintSupported: packedParameters.elementIndexUintSupported,
        scene3DOnly: packedParameters.scene3DOnly,
        allowPicking: packedParameters.allowPicking,
        vertexCacheOptimize: packedParameters.vertexCacheOptimize,
        compressVertices: packedParameters.compressVertices,
        modelMatrix: Matrix4.clone(packedParameters.modelMatrix)
    };
};
PrimitivePipeline.packCombineGeometryResults = function (results, transferableObjects) {
    if (defined(results.geometries)) {
        transferGeometries(results.geometries, transferableObjects);
        transferPerInstanceAttributes(results.vaAttributes, transferableObjects);
    }
    return {
        geometries: results.geometries,
        attributeLocations: results.attributeLocations,
        vaAttributes: results.vaAttributes,
        packedVaAttributeLocations: packAttributeLocations(results.vaAttributeLocations, transferableObjects),
        modelMatrix: results.modelMatrix,
        validInstancesIndices: results.validInstancesIndices,
        invalidInstancesIndices: results.invalidInstancesIndices
    };
};
PrimitivePipeline.unpackCombineGeometryResults = function (packedResult) {
    return {
        geometries: packedResult.geometries,
        attributeLocations: packedResult.attributeLocations,
        vaAttributes: packedResult.vaAttributes,
        perInstanceAttributeLocations: unpackAttributeLocations(packedResult.packedVaAttributeLocations, packedResult.vaAttributes),
        modelMatrix: packedResult.modelMatrix
    };
};
module.exports = PrimitivePipeline;
},{"../Core/BoundingSphere":98,"../Core/Color":111,"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/Ellipsoid":130,"../Core/FeatureDetection":141,"../Core/GeographicProjection":143,"../Core/Geometry":145,"../Core/GeometryAttribute":146,"../Core/GeometryPipeline":150,"../Core/IndexDatatype":162,"../Core/Matrix4":177,"../Core/WebMercatorProjection":233,"../Core/defaultValue":243,"../Core/defined":245}],431:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var PrimitiveState = {
        READY: 0,
        CREATING: 1,
        CREATED: 2,
        COMBINING: 3,
        COMBINED: 4,
        COMPLETE: 5,
        FAILED: 6
    };
module.exports = freezeObject(PrimitiveState);
},{"../Core/freezeObject":249}],432:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defineProperties = require('../Core/defineProperties'), EllipsoidalOccluder = require('../Core/EllipsoidalOccluder');
'use strict';
var QuadtreeOccluders = function (options) {
    this._ellipsoid = new EllipsoidalOccluder(options.ellipsoid, Cartesian3.ZERO);
};
defineProperties(QuadtreeOccluders.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    }
});
module.exports = QuadtreeOccluders;
},{"../Core/Cartesian3":102,"../Core/EllipsoidalOccluder":136,"../Core/defineProperties":244}],433:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), getTimestamp = require('../Core/getTimestamp'), Queue = require('../Core/Queue'), Visibility = require('../Core/Visibility'), QuadtreeOccluders = require('./QuadtreeOccluders'), QuadtreeTile = require('./QuadtreeTile'), QuadtreeTileLoadState = require('./QuadtreeTileLoadState'), SceneMode = require('./SceneMode'), TileReplacementQueue = require('./TileReplacementQueue');
'use strict';
var QuadtreePrimitive = function QuadtreePrimitive(options) {
    if (!defined(options) || !defined(options.tileProvider)) {
        throw new DeveloperError('options.tileProvider is required.');
    }
    if (defined(options.tileProvider.quadtree)) {
        throw new DeveloperError('A QuadtreeTileProvider can only be used with a single QuadtreePrimitive');
    }
    this._tileProvider = options.tileProvider;
    this._tileProvider.quadtree = this;
    this._debug = {
        enableDebugOutput: false,
        maxDepth: 0,
        tilesVisited: 0,
        tilesCulled: 0,
        tilesRendered: 0,
        tilesWaitingForChildren: 0,
        lastMaxDepth: -1,
        lastTilesVisited: -1,
        lastTilesCulled: -1,
        lastTilesRendered: -1,
        lastTilesWaitingForChildren: -1,
        suspendLodUpdate: false
    };
    var tilingScheme = this._tileProvider.tilingScheme;
    var ellipsoid = tilingScheme.ellipsoid;
    this._tilesToRender = [];
    this._tileTraversalQueue = new Queue();
    this._tileLoadQueue = [];
    this._tileReplacementQueue = new TileReplacementQueue();
    this._levelZeroTiles = undefined;
    this._levelZeroTilesReady = false;
    this._loadQueueTimeSlice = 5;
    this.maximumScreenSpaceError = defaultValue(options.maximumScreenSpaceError, 2);
    this.tileCacheSize = defaultValue(options.tileCacheSize, 100);
    this._occluders = new QuadtreeOccluders({ ellipsoid: ellipsoid });
};
defineProperties(QuadtreePrimitive.prototype, {
    tileProvider: {
        get: function () {
            return this._tileProvider;
        }
    }
});
QuadtreePrimitive.prototype.invalidateAllTiles = function () {
    var replacementQueue = this._tileReplacementQueue;
    replacementQueue.head = undefined;
    replacementQueue.tail = undefined;
    replacementQueue.count = 0;
    var levelZeroTiles = this._levelZeroTiles;
    if (defined(levelZeroTiles)) {
        for (var i = 0; i < levelZeroTiles.length; ++i) {
            levelZeroTiles[i].freeResources();
        }
    }
    this._levelZeroTiles = undefined;
};
QuadtreePrimitive.prototype.forEachLoadedTile = function (tileFunction) {
    var tile = this._tileReplacementQueue.head;
    while (defined(tile)) {
        if (tile.state !== QuadtreeTileLoadState.START) {
            tileFunction(tile);
        }
        tile = tile.replacementNext;
    }
};
QuadtreePrimitive.prototype.forEachRenderedTile = function (tileFunction) {
    var tilesRendered = this._tilesToRender;
    for (var i = 0, len = tilesRendered.length; i < len; ++i) {
        tileFunction(tilesRendered[i]);
    }
};
QuadtreePrimitive.prototype.update = function (context, frameState, commandList) {
    this._tileProvider.beginUpdate(context, frameState, commandList);
    selectTilesForRendering(this, context, frameState);
    processTileLoadQueue(this, context, frameState);
    createRenderCommandsForSelectedTiles(this, context, frameState, commandList);
    this._tileProvider.endUpdate(context, frameState, commandList);
};
QuadtreePrimitive.prototype.isDestroyed = function () {
    return false;
};
QuadtreePrimitive.prototype.destroy = function () {
    this._tileProvider = this._tileProvider && this._tileProvider.destroy();
};
function selectTilesForRendering(primitive, context, frameState) {
    var debug = primitive._debug;
    if (debug.suspendLodUpdate) {
        return;
    }
    var i;
    var len;
    var tilesToRender = primitive._tilesToRender;
    tilesToRender.length = 0;
    var traversalQueue = primitive._tileTraversalQueue;
    traversalQueue.clear();
    debug.maxDepth = 0;
    debug.tilesVisited = 0;
    debug.tilesCulled = 0;
    debug.tilesRendered = 0;
    debug.tilesWaitingForChildren = 0;
    primitive._tileLoadQueue.length = 0;
    primitive._tileReplacementQueue.markStartOfRenderFrame();
    if (!defined(primitive._levelZeroTiles)) {
        if (primitive._tileProvider.ready) {
            var terrainTilingScheme = primitive._tileProvider.tilingScheme;
            primitive._levelZeroTiles = QuadtreeTile.createLevelZeroTiles(terrainTilingScheme);
        } else {
            return;
        }
    }
    primitive._occluders.ellipsoid.cameraPosition = frameState.camera.positionWC;
    var tileProvider = primitive._tileProvider;
    var occluders = primitive._occluders;
    var tile;
    var levelZeroTiles = primitive._levelZeroTiles;
    for (i = 0, len = levelZeroTiles.length; i < len; ++i) {
        tile = levelZeroTiles[i];
        primitive._tileReplacementQueue.markTileRendered(tile);
        if (tile.needsLoading) {
            queueTileLoad(primitive, tile);
        }
        if (tile.renderable && tileProvider.computeTileVisibility(tile, frameState, occluders) !== Visibility.NONE) {
            traversalQueue.enqueue(tile);
        } else {
            ++debug.tilesCulled;
            if (!tile.renderable) {
                ++debug.tilesWaitingForChildren;
            }
        }
    }
    while (defined(tile = traversalQueue.dequeue())) {
        ++debug.tilesVisited;
        primitive._tileReplacementQueue.markTileRendered(tile);
        if (tile.level > debug.maxDepth) {
            debug.maxDepth = tile.level;
        }
        if (screenSpaceError(primitive, context, frameState, tile) < primitive.maximumScreenSpaceError) {
            addTileToRenderList(primitive, tile);
        } else if (queueChildrenLoadAndDetermineIfChildrenAreAllRenderable(primitive, tile)) {
            var children = tile.children;
            for (i = 0, len = children.length; i < len; ++i) {
                if (tileProvider.computeTileVisibility(children[i], frameState, occluders) !== Visibility.NONE) {
                    traversalQueue.enqueue(children[i]);
                } else {
                    ++debug.tilesCulled;
                }
            }
        } else {
            ++debug.tilesWaitingForChildren;
            addTileToRenderList(primitive, tile);
        }
    }
    if (debug.enableDebugOutput) {
        if (debug.tilesVisited !== debug.lastTilesVisited || debug.tilesRendered !== debug.lastTilesRendered || debug.tilesCulled !== debug.lastTilesCulled || debug.maxDepth !== debug.lastMaxDepth || debug.tilesWaitingForChildren !== debug.lastTilesWaitingForChildren) {
            console.log('Visited ' + debug.tilesVisited + ', Rendered: ' + debug.tilesRendered + ', Culled: ' + debug.tilesCulled + ', Max Depth: ' + debug.maxDepth + ', Waiting for children: ' + debug.tilesWaitingForChildren);
            debug.lastTilesVisited = debug.tilesVisited;
            debug.lastTilesRendered = debug.tilesRendered;
            debug.lastTilesCulled = debug.tilesCulled;
            debug.lastMaxDepth = debug.maxDepth;
            debug.lastTilesWaitingForChildren = debug.tilesWaitingForChildren;
        }
    }
}
function screenSpaceError(primitive, context, frameState, tile) {
    if (frameState.mode === SceneMode.SCENE2D) {
        return screenSpaceError2D(primitive, context, frameState, tile);
    }
    var maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(tile.level);
    var distance = primitive._tileProvider.computeDistanceToTile(tile, frameState);
    tile._distance = distance;
    var height = context.drawingBufferHeight;
    var camera = frameState.camera;
    var frustum = camera.frustum;
    var fovy = frustum.fovy;
    return maxGeometricError * height / (2 * distance * Math.tan(0.5 * fovy));
}
function screenSpaceError2D(primitive, context, frameState, tile) {
    var camera = frameState.camera;
    var frustum = camera.frustum;
    var width = context.drawingBufferWidth;
    var height = context.drawingBufferHeight;
    var maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(tile.level);
    var pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(width, height);
    return maxGeometricError / pixelSize;
}
function addTileToRenderList(primitive, tile) {
    primitive._tilesToRender.push(tile);
    ++primitive._debug.tilesRendered;
}
function queueChildrenLoadAndDetermineIfChildrenAreAllRenderable(primitive, tile) {
    var allRenderable = true;
    var allUpsampledOnly = true;
    var children = tile.children;
    for (var i = 0, len = children.length; i < len; ++i) {
        var child = children[i];
        primitive._tileReplacementQueue.markTileRendered(child);
        allUpsampledOnly = allUpsampledOnly && child.upsampledFromParent;
        allRenderable = allRenderable && child.renderable;
        if (child.needsLoading) {
            queueTileLoad(primitive, child);
        }
    }
    if (!allRenderable) {
        ++primitive._debug.tilesWaitingForChildren;
    }
    return allRenderable && !allUpsampledOnly;
}
function queueTileLoad(primitive, tile) {
    primitive._tileLoadQueue.push(tile);
}
function processTileLoadQueue(primitive, context, frameState) {
    var tileLoadQueue = primitive._tileLoadQueue;
    var tileProvider = primitive._tileProvider;
    if (tileLoadQueue.length === 0) {
        return;
    }
    primitive._tileReplacementQueue.trimTiles(primitive.tileCacheSize);
    var startTime = getTimestamp();
    var timeSlice = primitive._loadQueueTimeSlice;
    var endTime = startTime + timeSlice;
    for (var len = tileLoadQueue.length - 1, i = len; i >= 0; --i) {
        var tile = tileLoadQueue[i];
        primitive._tileReplacementQueue.markTileRendered(tile);
        tileProvider.loadTile(context, frameState, tile);
        if (getTimestamp() >= endTime) {
            break;
        }
    }
}
function tileDistanceSortFunction(a, b) {
    return a._distance - b._distance;
}
function createRenderCommandsForSelectedTiles(primitive, context, frameState, commandList) {
    var tileProvider = primitive._tileProvider;
    var tilesToRender = primitive._tilesToRender;
    tilesToRender.sort(tileDistanceSortFunction);
    for (var i = 0, len = tilesToRender.length; i < len; ++i) {
        tileProvider.showTileThisFrame(tilesToRender[i], context, frameState, commandList);
    }
}
module.exports = QuadtreePrimitive;
},{"../Core/DeveloperError":123,"../Core/Queue":199,"../Core/Visibility":229,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/getTimestamp":252,"./QuadtreeOccluders":432,"./QuadtreeTile":434,"./QuadtreeTileLoadState":435,"./SceneMode":438,"./TileReplacementQueue":451}],434:[function(require,module,exports){
var defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), QuadtreeTileLoadState = require('./QuadtreeTileLoadState');
'use strict';
var QuadtreeTile = function QuadtreeTile(options) {
    if (!defined(options)) {
        throw new DeveloperError('options is required.');
    }
    if (!defined(options.x)) {
        throw new DeveloperError('options.x is required.');
    } else if (!defined(options.y)) {
        throw new DeveloperError('options.y is required.');
    } else if (options.x < 0 || options.y < 0) {
        throw new DeveloperError('options.x and options.y must be greater than or equal to zero.');
    }
    if (!defined(options.level)) {
        throw new DeveloperError('options.level is required and must be greater than or equal to zero.');
    }
    if (!defined(options.tilingScheme)) {
        throw new DeveloperError('options.tilingScheme is required.');
    }
    this._tilingScheme = options.tilingScheme;
    this._x = options.x;
    this._y = options.y;
    this._level = options.level;
    this._parent = options.parent;
    this._rectangle = this._tilingScheme.tileXYToRectangle(this._x, this._y, this._level);
    this._children = undefined;
    this._replacementPrevious = undefined;
    this._replacementNext = undefined;
    this._distance = 0;
    this.state = QuadtreeTileLoadState.START;
    this.renderable = false;
    this.upsampledFromParent = false;
    this.data = undefined;
};
QuadtreeTile.createLevelZeroTiles = function (tilingScheme) {
    if (!defined(tilingScheme)) {
        throw new DeveloperError('tilingScheme is required.');
    }
    var numberOfLevelZeroTilesX = tilingScheme.getNumberOfXTilesAtLevel(0);
    var numberOfLevelZeroTilesY = tilingScheme.getNumberOfYTilesAtLevel(0);
    var result = new Array(numberOfLevelZeroTilesX * numberOfLevelZeroTilesY);
    var index = 0;
    for (var y = 0; y < numberOfLevelZeroTilesY; ++y) {
        for (var x = 0; x < numberOfLevelZeroTilesX; ++x) {
            result[index++] = new QuadtreeTile({
                tilingScheme: tilingScheme,
                x: x,
                y: y,
                level: 0
            });
        }
    }
    return result;
};
defineProperties(QuadtreeTile.prototype, {
    tilingScheme: {
        get: function () {
            return this._tilingScheme;
        }
    },
    x: {
        get: function () {
            return this._x;
        }
    },
    y: {
        get: function () {
            return this._y;
        }
    },
    level: {
        get: function () {
            return this._level;
        }
    },
    parent: {
        get: function () {
            return this._parent;
        }
    },
    rectangle: {
        get: function () {
            return this._rectangle;
        }
    },
    children: {
        get: function () {
            if (!defined(this._children)) {
                var tilingScheme = this.tilingScheme;
                var level = this.level + 1;
                var x = this.x * 2;
                var y = this.y * 2;
                this._children = [
                    new QuadtreeTile({
                        tilingScheme: tilingScheme,
                        x: x,
                        y: y,
                        level: level,
                        parent: this
                    }),
                    new QuadtreeTile({
                        tilingScheme: tilingScheme,
                        x: x + 1,
                        y: y,
                        level: level,
                        parent: this
                    }),
                    new QuadtreeTile({
                        tilingScheme: tilingScheme,
                        x: x,
                        y: y + 1,
                        level: level,
                        parent: this
                    }),
                    new QuadtreeTile({
                        tilingScheme: tilingScheme,
                        x: x + 1,
                        y: y + 1,
                        level: level,
                        parent: this
                    })
                ];
            }
            return this._children;
        }
    },
    needsLoading: {
        get: function () {
            return this.state < QuadtreeTileLoadState.DONE;
        }
    },
    eligibleForUnloading: {
        get: function () {
            var result = true;
            if (defined(this.data)) {
                result = this.data.eligibleForUnloading;
                if (!defined(result)) {
                    result = true;
                }
            }
            return result;
        }
    }
});
QuadtreeTile.prototype.freeResources = function () {
    this.state = QuadtreeTileLoadState.START;
    this.renderable = false;
    this.upsampledFromParent = false;
    if (defined(this.data) && defined(this.data.freeResources)) {
        this.data.freeResources();
    }
    if (defined(this._children)) {
        for (var i = 0, len = this._children.length; i < len; ++i) {
            this._children[i].freeResources();
        }
        this._children = undefined;
    }
};
module.exports = QuadtreeTile;
},{"../Core/DeveloperError":123,"../Core/defineProperties":244,"../Core/defined":245,"./QuadtreeTileLoadState":435}],435:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var QuadtreeTileLoadState = {
        START: 0,
        LOADING: 1,
        DONE: 2,
        FAILED: 3
    };
module.exports = freezeObject(QuadtreeTileLoadState);
},{"../Core/freezeObject":249}],436:[function(require,module,exports){
var Color = require('../Core/Color'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Ellipsoid = require('../Core/Ellipsoid'), GeometryInstance = require('../Core/GeometryInstance'), CesiumMath = require('../Core/Math'), Rectangle = require('../Core/Rectangle'), RectangleGeometry = require('../Core/RectangleGeometry'), EllipsoidSurfaceAppearance = require('./EllipsoidSurfaceAppearance'), Material = require('./Material'), Primitive = require('./Primitive');
'use strict';
var RectanglePrimitive = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
    this._ellipsoid = undefined;
    this.rectangle = Rectangle.clone(options.rectangle);
    this._rectangle = undefined;
    this.granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
    this._granularity = undefined;
    this.height = defaultValue(options.height, 0);
    this._height = undefined;
    this.rotation = defaultValue(options.rotation, 0);
    this._rotation = undefined;
    this.textureRotationAngle = defaultValue(options.textureRotationAngle, 0);
    this._textureRotationAngle = undefined;
    this.show = defaultValue(options.show, true);
    var material = Material.fromType(Material.ColorType, { color: new Color(1, 1, 0, 0.5) });
    this.material = defaultValue(options.material, material);
    this.id = options.id;
    this._id = undefined;
    this.asynchronous = defaultValue(options.asynchronous, true);
    this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);
    this._primitive = undefined;
};
RectanglePrimitive.prototype.update = function (context, frameState, commandList) {
    if (!defined(this.ellipsoid)) {
        throw new DeveloperError('this.ellipsoid must be defined.');
    }
    if (!defined(this.material)) {
        throw new DeveloperError('this.material must be defined.');
    }
    if (this.granularity < 0) {
        throw new DeveloperError('this.granularity must be greater than zero.');
    }
    if (!this.show || !defined(this.rectangle)) {
        return;
    }
    if (!Rectangle.equals(this._rectangle, this.rectangle) || this._ellipsoid !== this.ellipsoid || this._granularity !== this.granularity || this._height !== this.height || this._rotation !== this.rotation || this._textureRotationAngle !== this.textureRotationAngle || this._id !== this.id) {
        this._rectangle = Rectangle.clone(this.rectangle, this._rectangle);
        this._ellipsoid = this.ellipsoid;
        this._granularity = this.granularity;
        this._height = this.height;
        this._rotation = this.rotation;
        this._textureRotationAngle = this.textureRotationAngle;
        this._id = this.id;
        var instance = new GeometryInstance({
                geometry: new RectangleGeometry({
                    rectangle: this.rectangle,
                    vertexFormat: EllipsoidSurfaceAppearance.VERTEX_FORMAT,
                    ellipsoid: this.ellipsoid,
                    granularity: this.granularity,
                    height: this.height,
                    rotation: this.rotation,
                    stRotation: this.textureRotationAngle
                }),
                id: this.id,
                pickPrimitive: this
            });
        if (defined(this._primitive)) {
            this._primitive.destroy();
        }
        this._primitive = new Primitive({
            geometryInstances: instance,
            appearance: new EllipsoidSurfaceAppearance({ aboveGround: this.height > 0 }),
            asynchronous: this.asynchronous
        });
    }
    var primitive = this._primitive;
    primitive.appearance.material = this.material;
    primitive.debugShowBoundingVolume = this.debugShowBoundingVolume;
    primitive.update(context, frameState, commandList);
};
RectanglePrimitive.prototype.isDestroyed = function () {
    return false;
};
RectanglePrimitive.prototype.destroy = function () {
    this._primitive = this._primitive && this._primitive.destroy();
    return destroyObject(this);
};
module.exports = RectanglePrimitive;
},{"../Core/Color":111,"../Core/DeveloperError":123,"../Core/Ellipsoid":130,"../Core/GeometryInstance":148,"../Core/Math":174,"../Core/Rectangle":201,"../Core/RectangleGeometry":202,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"./EllipsoidSurfaceAppearance":385,"./Material":404,"./Primitive":428}],437:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), BoundingSphere = require('../Core/BoundingSphere'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Color = require('../Core/Color'), ColorGeometryInstanceAttribute = require('../Core/ColorGeometryInstanceAttribute'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), EllipsoidGeometry = require('../Core/EllipsoidGeometry'), Event = require('../Core/Event'), GeographicProjection = require('../Core/GeographicProjection'), GeometryInstance = require('../Core/GeometryInstance'), GeometryPipeline = require('../Core/GeometryPipeline'), Intersect = require('../Core/Intersect'), Interval = require('../Core/Interval'), JulianDate = require('../Core/JulianDate'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), mergeSort = require('../Core/mergeSort'), Occluder = require('../Core/Occluder'), ShowGeometryInstanceAttribute = require('../Core/ShowGeometryInstanceAttribute'), ClearCommand = require('../Renderer/ClearCommand'), Context = require('../Renderer/Context'), PassState = require('../Renderer/PassState'), Camera = require('./Camera'), CreditDisplay = require('./CreditDisplay'), CullingVolume = require('./CullingVolume'), FrameState = require('./FrameState'), FrustumCommands = require('./FrustumCommands'), FXAA = require('./FXAA'), OIT = require('./OIT'), OrthographicFrustum = require('./OrthographicFrustum'), Pass = require('./Pass'), PerformanceDisplay = require('./PerformanceDisplay'), PerInstanceColorAppearance = require('./PerInstanceColorAppearance'), PerspectiveFrustum = require('./PerspectiveFrustum'), PerspectiveOffCenterFrustum = require('./PerspectiveOffCenterFrustum'), Primitive = require('./Primitive'), PrimitiveCollection = require('./PrimitiveCollection'), SceneMode = require('./SceneMode'), SceneTransforms = require('./SceneTransforms'), SceneTransitioner = require('./SceneTransitioner'), ScreenSpaceCameraController = require('./ScreenSpaceCameraController'), SunPostProcess = require('./SunPostProcess'), TweenCollection = require('./TweenCollection');
'use strict';
var Scene = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var canvas = options.canvas;
    var contextOptions = options.contextOptions;
    var creditContainer = options.creditContainer;
    if (!defined(canvas)) {
        throw new DeveloperError('options and options.canvas are required.');
    }
    var context = new Context(canvas, contextOptions);
    if (!defined(creditContainer)) {
        creditContainer = document.createElement('div');
        creditContainer.style.position = 'absolute';
        creditContainer.style.bottom = '0';
        creditContainer.style['text-shadow'] = '0px 0px 2px #000000';
        creditContainer.style.color = '#ffffff';
        creditContainer.style['font-size'] = '10px';
        creditContainer.style['padding-right'] = '5px';
        canvas.parentNode.appendChild(creditContainer);
    }
    this._id = createGuid();
    this._frameState = new FrameState(new CreditDisplay(creditContainer));
    this._frameState.scene3DOnly = defaultValue(options.scene3DOnly, false);
    this._passState = new PassState(context);
    this._canvas = canvas;
    this._context = context;
    this._globe = undefined;
    this._primitives = new PrimitiveCollection();
    this._pickFramebuffer = undefined;
    this._tweens = new TweenCollection();
    this._shaderFrameCount = 0;
    this._sunPostProcess = undefined;
    this._commandList = [];
    this._frustumCommandsList = [];
    this._overlayCommandList = [];
    this._oit = defaultValue(options.orderIndependentTranslucency, true) ? new OIT(context) : undefined;
    this._executeOITFunction = undefined;
    this._fxaa = new FXAA();
    this._clearColorCommand = new ClearCommand({
        color: new Color(),
        owner: this
    });
    this._depthClearCommand = new ClearCommand({
        depth: 1,
        owner: this
    });
    this._transitioner = new SceneTransitioner(this);
    this._renderError = new Event();
    this._preRender = new Event();
    this._postRender = new Event();
    this.rethrowRenderErrors = false;
    this.completeMorphOnUserInput = true;
    this.morphStart = new Event();
    this.morphComplete = new Event();
    this.skyBox = undefined;
    this.skyAtmosphere = undefined;
    this.sun = undefined;
    this.sunBloom = true;
    this._sunBloom = undefined;
    this.moon = undefined;
    this.backgroundColor = Color.clone(Color.BLACK);
    this._mode = SceneMode.SCENE3D;
    this._mapProjection = defined(options.mapProjection) ? options.mapProjection : new GeographicProjection();
    this.morphTime = 1;
    this.farToNearRatio = 1000;
    this.debugCommandFilter = undefined;
    this.debugShowCommands = false;
    this.debugShowFrustums = false;
    this._debugFrustumStatistics = undefined;
    this.debugShowFramesPerSecond = false;
    this.fxaaOrderIndependentTranslucency = true;
    this.fxaa = false;
    this._performanceDisplay = undefined;
    this._debugSphere = undefined;
    var camera = new Camera(this);
    this._camera = camera;
    this._screenSpaceCameraController = new ScreenSpaceCameraController(this);
    var near = camera.frustum.near;
    var far = camera.frustum.far;
    var numFrustums = Math.ceil(Math.log(far / near) / Math.log(this.farToNearRatio));
    updateFrustums(near, far, this.farToNearRatio, numFrustums, this._frustumCommandsList);
    updateFrameState(this, 0, JulianDate.now());
    this.initializeFrame();
};
defineProperties(Scene.prototype, {
    canvas: {
        get: function () {
            return this._canvas;
        }
    },
    drawingBufferHeight: {
        get: function () {
            return this._context.drawingBufferHeight;
        }
    },
    drawingBufferWidth: {
        get: function () {
            return this._context.drawingBufferWidth;
        }
    },
    maximumAliasedLineWidth: {
        get: function () {
            return this._context.maximumAliasedLineWidth;
        }
    },
    globe: {
        get: function () {
            return this._globe;
        },
        set: function (globe) {
            this._globe = this._globe && this._globe.destroy();
            this._globe = globe;
        }
    },
    primitives: {
        get: function () {
            return this._primitives;
        }
    },
    camera: {
        get: function () {
            return this._camera;
        }
    },
    screenSpaceCameraController: {
        get: function () {
            return this._screenSpaceCameraController;
        }
    },
    mapProjection: {
        get: function () {
            return this._mapProjection;
        }
    },
    frameState: {
        get: function () {
            return this._frameState;
        }
    },
    tweens: {
        get: function () {
            return this._tweens;
        }
    },
    imageryLayers: {
        get: function () {
            return this.globe.imageryLayers;
        }
    },
    terrainProvider: {
        get: function () {
            return this.globe.terrainProvider;
        },
        set: function (terrainProvider) {
            this.globe.terrainProvider = terrainProvider;
        }
    },
    renderError: {
        get: function () {
            return this._renderError;
        }
    },
    preRender: {
        get: function () {
            return this._preRender;
        }
    },
    postRender: {
        get: function () {
            return this._postRender;
        }
    },
    context: {
        get: function () {
            return this._context;
        }
    },
    debugFrustumStatistics: {
        get: function () {
            return this._debugFrustumStatistics;
        }
    },
    scene3DOnly: {
        get: function () {
            return this._frameState.scene3DOnly;
        }
    },
    orderIndependentTranslucency: {
        get: function () {
            return defined(this._oit);
        }
    },
    id: {
        get: function () {
            return this._id;
        }
    },
    mode: {
        get: function () {
            return this._mode;
        },
        set: function (value) {
            if (this.scene3DOnly && value !== SceneMode.SCENE3D) {
                throw new DeveloperError('Only SceneMode.SCENE3D is valid when scene3DOnly is true.');
            }
            this._mode = value;
        }
    }
});
var scratchOccluderBoundingSphere = new BoundingSphere();
var scratchOccluder;
function getOccluder(scene) {
    var globe = scene.globe;
    if (scene._mode === SceneMode.SCENE3D && defined(globe)) {
        var ellipsoid = globe.ellipsoid;
        scratchOccluderBoundingSphere.radius = ellipsoid.minimumRadius;
        scratchOccluder = Occluder.fromBoundingSphere(scratchOccluderBoundingSphere, scene._camera.positionWC, scratchOccluder);
        return scratchOccluder;
    }
    return undefined;
}
function clearPasses(passes) {
    passes.render = false;
    passes.pick = false;
}
function updateFrameState(scene, frameNumber, time) {
    var camera = scene._camera;
    var frameState = scene._frameState;
    frameState.mode = scene._mode;
    frameState.morphTime = scene.morphTime;
    frameState.mapProjection = scene.mapProjection;
    frameState.frameNumber = frameNumber;
    frameState.time = JulianDate.clone(time, frameState.time);
    frameState.camera = camera;
    frameState.cullingVolume = camera.frustum.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);
    frameState.occluder = getOccluder(scene);
    clearPasses(frameState.passes);
}
function updateFrustums(near, far, farToNearRatio, numFrustums, frustumCommandsList) {
    frustumCommandsList.length = numFrustums;
    for (var m = 0; m < numFrustums; ++m) {
        var curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);
        var curFar = Math.min(far, farToNearRatio * curNear);
        var frustumCommands = frustumCommandsList[m];
        if (!defined(frustumCommands)) {
            frustumCommands = frustumCommandsList[m] = new FrustumCommands(curNear, curFar);
        } else {
            frustumCommands.near = curNear;
            frustumCommands.far = curFar;
        }
    }
}
function insertIntoBin(scene, command, distance) {
    if (scene.debugShowFrustums) {
        command.debugOverlappingFrustums = 0;
    }
    var frustumCommandsList = scene._frustumCommandsList;
    var length = frustumCommandsList.length;
    for (var i = 0; i < length; ++i) {
        var frustumCommands = frustumCommandsList[i];
        var curNear = frustumCommands.near;
        var curFar = frustumCommands.far;
        if (distance.start > curFar) {
            continue;
        }
        if (distance.stop < curNear) {
            break;
        }
        if (command.pass === Pass.OPAQUE || command instanceof ClearCommand) {
            frustumCommands.opaqueCommands[frustumCommands.opaqueIndex++] = command;
        } else if (command.pass === Pass.TRANSLUCENT) {
            frustumCommands.translucentCommands[frustumCommands.translucentIndex++] = command;
        }
        if (scene.debugShowFrustums) {
            command.debugOverlappingFrustums |= 1 << i;
        }
        if (command.executeInClosestFrustum) {
            break;
        }
    }
    if (scene.debugShowFrustums) {
        var cf = scene._debugFrustumStatistics.commandsInFrustums;
        cf[command.debugOverlappingFrustums] = defined(cf[command.debugOverlappingFrustums]) ? cf[command.debugOverlappingFrustums] + 1 : 1;
        ++scene._debugFrustumStatistics.totalCommands;
    }
}
var scratchCullingVolume = new CullingVolume();
var distances = new Interval();
function createPotentiallyVisibleSet(scene) {
    var commandList = scene._commandList;
    var overlayList = scene._overlayCommandList;
    var cullingVolume = scene._frameState.cullingVolume;
    var camera = scene._camera;
    var direction = camera.directionWC;
    var position = camera.positionWC;
    if (scene.debugShowFrustums) {
        scene._debugFrustumStatistics = {
            totalCommands: 0,
            commandsInFrustums: {}
        };
    }
    var frustumCommandsList = scene._frustumCommandsList;
    var numberOfFrustums = frustumCommandsList.length;
    for (var n = 0; n < numberOfFrustums; ++n) {
        frustumCommandsList[n].opaqueIndex = 0;
        frustumCommandsList[n].translucentIndex = 0;
    }
    var near = Number.MAX_VALUE;
    var far = Number.MIN_VALUE;
    var undefBV = false;
    var occluder;
    if (scene._frameState.mode === SceneMode.SCENE3D) {
        occluder = scene._frameState.occluder;
    }
    var planes = scratchCullingVolume.planes;
    for (var m = 0; m < 5; ++m) {
        planes[m] = cullingVolume.planes[m];
    }
    cullingVolume = scratchCullingVolume;
    var length = commandList.length;
    for (var i = 0; i < length; ++i) {
        var command = commandList[i];
        var pass = command.pass;
        if (pass === Pass.OVERLAY) {
            overlayList.push(command);
        } else {
            var boundingVolume = command.boundingVolume;
            if (defined(boundingVolume)) {
                if (command.cull && (cullingVolume.computeVisibility(boundingVolume) === Intersect.OUTSIDE || defined(occluder) && !occluder.isBoundingSphereVisible(boundingVolume))) {
                    continue;
                }
                distances = BoundingSphere.computePlaneDistances(boundingVolume, position, direction, distances);
                near = Math.min(near, distances.start);
                far = Math.max(far, distances.stop);
            } else {
                distances.start = camera.frustum.near;
                distances.stop = camera.frustum.far;
                undefBV = !(command instanceof ClearCommand);
            }
            insertIntoBin(scene, command, distances);
        }
    }
    if (undefBV) {
        near = camera.frustum.near;
        far = camera.frustum.far;
    } else {
        near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);
        far = Math.max(Math.min(far, camera.frustum.far), near);
    }
    var farToNearRatio = scene.farToNearRatio;
    var numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));
    if (near !== Number.MAX_VALUE && (numFrustums !== numberOfFrustums || frustumCommandsList.length !== 0 && (near < frustumCommandsList[0].near || far > frustumCommandsList[numberOfFrustums - 1].far))) {
        updateFrustums(near, far, farToNearRatio, numFrustums, frustumCommandsList);
        createPotentiallyVisibleSet(scene);
    }
}
function getAttributeLocations(shaderProgram) {
    var attributeLocations = {};
    var attributes = shaderProgram.vertexAttributes;
    for (var a in attributes) {
        if (attributes.hasOwnProperty(a)) {
            attributeLocations[a] = attributes[a].index;
        }
    }
    return attributeLocations;
}
function createDebugFragmentShaderProgram(command, scene, shaderProgram) {
    var context = scene.context;
    var sp = defaultValue(shaderProgram, command.shaderProgram);
    var fs = sp.fragmentShaderSource.clone();
    fs.sources = fs.sources.map(function (source) {
        source = source.replace(/void\s+main\s*\(\s*(?:void)?\s*\)/g, 'void czm_Debug_main()');
        return source;
    });
    var newMain = 'void main() \n' + '{ \n' + '    czm_Debug_main(); \n';
    if (scene.debugShowCommands) {
        if (!defined(command._debugColor)) {
            command._debugColor = Color.fromRandom();
        }
        var c = command._debugColor;
        newMain += '    gl_FragColor.rgb *= vec3(' + c.red + ', ' + c.green + ', ' + c.blue + '); \n';
    }
    if (scene.debugShowFrustums) {
        var r = command.debugOverlappingFrustums & 1 << 0 ? '1.0' : '0.0';
        var g = command.debugOverlappingFrustums & 1 << 1 ? '1.0' : '0.0';
        var b = command.debugOverlappingFrustums & 1 << 2 ? '1.0' : '0.0';
        newMain += '    gl_FragColor.rgb *= vec3(' + r + ', ' + g + ', ' + b + '); \n';
    }
    newMain += '}';
    fs.sources.push(newMain);
    var attributeLocations = getAttributeLocations(sp);
    return context.createShaderProgram(sp.vertexShaderSource, fs, attributeLocations);
}
function executeDebugCommand(command, scene, passState, renderState, shaderProgram) {
    if (defined(command.shaderProgram) || defined(shaderProgram)) {
        var sp = createDebugFragmentShaderProgram(command, scene, shaderProgram);
        command.execute(scene.context, passState, renderState, sp);
        sp.destroy();
    }
}
var transformFrom2D = new Matrix4(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
transformFrom2D = Matrix4.inverseTransformation(transformFrom2D, transformFrom2D);
function executeCommand(command, scene, context, passState, renderState, shaderProgram, debugFramebuffer) {
    if (defined(scene.debugCommandFilter) && !scene.debugCommandFilter(command)) {
        return;
    }
    if (scene.debugShowCommands || scene.debugShowFrustums) {
        executeDebugCommand(command, scene, passState, renderState, shaderProgram);
    } else {
        command.execute(context, passState, renderState, shaderProgram);
    }
    if (command.debugShowBoundingVolume && defined(command.boundingVolume)) {
        if (defined(scene._debugSphere)) {
            scene._debugSphere.destroy();
        }
        var frameState = scene._frameState;
        var boundingVolume = command.boundingVolume;
        var radius = boundingVolume.radius;
        var center = boundingVolume.center;
        var geometry = GeometryPipeline.toWireframe(EllipsoidGeometry.createGeometry(new EllipsoidGeometry({
                radii: new Cartesian3(radius, radius, radius),
                vertexFormat: PerInstanceColorAppearance.FLAT_VERTEX_FORMAT
            })));
        if (frameState.mode !== SceneMode.SCENE3D) {
            center = Matrix4.multiplyByPoint(transformFrom2D, center, center);
            var projection = frameState.mapProjection;
            var centerCartographic = projection.unproject(center);
            center = projection.ellipsoid.cartographicToCartesian(centerCartographic);
        }
        scene._debugSphere = new Primitive({
            geometryInstances: new GeometryInstance({
                geometry: geometry,
                modelMatrix: Matrix4.multiplyByTranslation(Matrix4.IDENTITY, center, new Matrix4()),
                attributes: { color: new ColorGeometryInstanceAttribute(1, 0, 0, 1) }
            }),
            appearance: new PerInstanceColorAppearance({
                flat: true,
                translucent: false
            }),
            asynchronous: false
        });
        var commandList = [];
        scene._debugSphere.update(context, frameState, commandList);
        var framebuffer;
        if (defined(debugFramebuffer)) {
            framebuffer = passState.framebuffer;
            passState.framebuffer = debugFramebuffer;
        }
        commandList[0].execute(context, passState);
        if (defined(framebuffer)) {
            passState.framebuffer = framebuffer;
        }
    }
}
function isVisible(command, frameState) {
    if (!defined(command)) {
        return;
    }
    var occluder = frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;
    var cullingVolume = frameState.cullingVolume;
    var planes = scratchCullingVolume.planes;
    for (var k = 0; k < 5; ++k) {
        planes[k] = cullingVolume.planes[k];
    }
    cullingVolume = scratchCullingVolume;
    var boundingVolume = command.boundingVolume;
    return defined(command) && (!defined(command.boundingVolume) || !command.cull || cullingVolume.computeVisibility(boundingVolume) !== Intersect.OUTSIDE && (!defined(occluder) || occluder.isBoundingSphereVisible(boundingVolume)));
}
function translucentCompare(a, b, position) {
    return BoundingSphere.distanceSquaredTo(b.boundingVolume, position) - BoundingSphere.distanceSquaredTo(a.boundingVolume, position);
}
function executeTranslucentCommandsSorted(scene, executeFunction, passState, commands) {
    var context = scene.context;
    mergeSort(commands, translucentCompare, scene._camera.positionWC);
    var length = commands.length;
    for (var j = 0; j < length; ++j) {
        executeFunction(commands[j], scene, context, passState);
    }
}
var scratchPerspectiveFrustum = new PerspectiveFrustum();
var scratchPerspectiveOffCenterFrustum = new PerspectiveOffCenterFrustum();
var scratchOrthographicFrustum = new OrthographicFrustum();
function executeCommands(scene, passState, clearColor, picking) {
    var frameState = scene._frameState;
    var camera = scene._camera;
    var context = scene.context;
    var us = context.uniformState;
    var frustum;
    if (defined(camera.frustum.fov)) {
        frustum = camera.frustum.clone(scratchPerspectiveFrustum);
    } else if (defined(camera.frustum.infiniteProjectionMatrix)) {
        frustum = camera.frustum.clone(scratchPerspectiveOffCenterFrustum);
    } else {
        frustum = camera.frustum.clone(scratchOrthographicFrustum);
    }
    if (defined(scene.sun) && scene.sunBloom !== scene._sunBloom) {
        if (scene.sunBloom) {
            scene._sunPostProcess = new SunPostProcess();
        } else if (defined(scene._sunPostProcess)) {
            scene._sunPostProcess = scene._sunPostProcess.destroy();
        }
        scene._sunBloom = scene.sunBloom;
    } else if (!defined(scene.sun) && defined(scene._sunPostProcess)) {
        scene._sunPostProcess = scene._sunPostProcess.destroy();
        scene._sunBloom = false;
    }
    var skyBoxCommand = frameState.passes.render && defined(scene.skyBox) ? scene.skyBox.update(context, frameState) : undefined;
    var skyAtmosphereCommand = frameState.passes.render && defined(scene.skyAtmosphere) ? scene.skyAtmosphere.update(context, frameState) : undefined;
    var sunCommand = frameState.passes.render && defined(scene.sun) ? scene.sun.update(scene) : undefined;
    var sunVisible = isVisible(sunCommand, frameState);
    var clear = scene._clearColorCommand;
    Color.clone(clearColor, clear.color);
    clear.execute(context, passState);
    var renderTranslucentCommands = false;
    var i;
    var frustumCommandsList = scene._frustumCommandsList;
    var numFrustums = frustumCommandsList.length;
    for (i = 0; i < numFrustums; ++i) {
        if (frustumCommandsList[i].translucentIndex > 0) {
            renderTranslucentCommands = true;
            break;
        }
    }
    var useOIT = !picking && renderTranslucentCommands && defined(scene._oit) && scene._oit.isSupported();
    if (useOIT) {
        scene._oit.update(context);
        scene._oit.clear(context, passState, clearColor);
        useOIT = useOIT && scene._oit.isSupported();
    }
    var useFXAA = !picking && (scene.fxaa || useOIT && scene.fxaaOrderIndependentTranslucency);
    if (useFXAA) {
        scene._fxaa.update(context);
        scene._fxaa.clear(context, passState, clearColor);
    }
    var opaqueFramebuffer = passState.framebuffer;
    if (useOIT) {
        opaqueFramebuffer = scene._oit.getColorFramebuffer();
    } else if (useFXAA) {
        opaqueFramebuffer = scene._fxaa.getColorFramebuffer();
    }
    if (sunVisible && scene.sunBloom) {
        passState.framebuffer = scene._sunPostProcess.update(context);
    } else {
        passState.framebuffer = opaqueFramebuffer;
    }
    frustum.near = camera.frustum.near;
    frustum.far = camera.frustum.far;
    us.updateFrustum(frustum);
    if (defined(skyBoxCommand)) {
        executeCommand(skyBoxCommand, scene, context, passState);
    }
    if (defined(skyAtmosphereCommand)) {
        executeCommand(skyAtmosphereCommand, scene, context, passState);
    }
    if (defined(sunCommand) && sunVisible) {
        sunCommand.execute(context, passState);
        if (scene.sunBloom) {
            scene._sunPostProcess.execute(context, opaqueFramebuffer);
            passState.framebuffer = opaqueFramebuffer;
        }
    }
    var clearDepth = scene._depthClearCommand;
    var executeTranslucentCommands;
    if (useOIT) {
        if (!defined(scene._executeOITFunction)) {
            scene._executeOITFunction = function (scene, executeFunction, passState, commands) {
                scene._oit.executeCommands(scene, executeFunction, passState, commands);
            };
        }
        executeTranslucentCommands = scene._executeOITFunction;
    } else {
        executeTranslucentCommands = executeTranslucentCommandsSorted;
    }
    for (i = 0; i < numFrustums; ++i) {
        var index = numFrustums - i - 1;
        var frustumCommands = frustumCommandsList[index];
        frustum.near = frustumCommands.near;
        frustum.far = frustumCommands.far;
        if (index !== 0) {
            frustum.near *= 0.99;
        }
        us.updateFrustum(frustum);
        clearDepth.execute(context, passState);
        var commands = frustumCommands.opaqueCommands;
        var length = frustumCommands.opaqueIndex;
        for (var j = 0; j < length; ++j) {
            executeCommand(commands[j], scene, context, passState);
        }
        frustum.near = frustumCommands.near;
        us.updateFrustum(frustum);
        commands = frustumCommands.translucentCommands;
        commands.length = frustumCommands.translucentIndex;
        executeTranslucentCommands(scene, executeCommand, passState, commands);
    }
    if (useOIT) {
        passState.framebuffer = useFXAA ? scene._fxaa.getColorFramebuffer() : undefined;
        scene._oit.execute(context, passState);
    }
    if (useFXAA) {
        passState.framebuffer = undefined;
        scene._fxaa.execute(context, passState);
    }
}
function executeOverlayCommands(scene, passState) {
    var context = scene.context;
    var commandList = scene._overlayCommandList;
    var length = commandList.length;
    for (var i = 0; i < length; ++i) {
        commandList[i].execute(context, passState);
    }
}
function updatePrimitives(scene) {
    var context = scene.context;
    var frameState = scene._frameState;
    var commandList = scene._commandList;
    if (scene._globe) {
        scene._globe.update(context, frameState, commandList);
    }
    scene._primitives.update(context, frameState, commandList);
    if (defined(scene.moon)) {
        scene.moon.update(context, frameState, commandList);
    }
}
function callAfterRenderFunctions(frameState) {
    var functions = frameState.afterRender;
    for (var i = 0, length = functions.length; i < length; ++i) {
        functions[i]();
    }
    functions.length = 0;
}
Scene.prototype.initializeFrame = function () {
    if (this._shaderFrameCount++ === 120) {
        this._shaderFrameCount = 0;
        this._context.shaderCache.destroyReleasedShaderPrograms();
    }
    this._tweens.update();
    this._camera.update(this._mode);
    this._screenSpaceCameraController.update();
};
function render(scene, time) {
    if (!defined(time)) {
        time = JulianDate.now();
    }
    scene._preRender.raiseEvent(scene, time);
    var us = scene.context.uniformState;
    var frameState = scene._frameState;
    var frameNumber = CesiumMath.incrementWrap(frameState.frameNumber, 15000000, 1);
    updateFrameState(scene, frameNumber, time);
    frameState.passes.render = true;
    frameState.creditDisplay.beginFrame();
    var context = scene.context;
    us.update(context, frameState);
    scene._commandList.length = 0;
    scene._overlayCommandList.length = 0;
    updatePrimitives(scene);
    createPotentiallyVisibleSet(scene);
    var passState = scene._passState;
    executeCommands(scene, passState, defaultValue(scene.backgroundColor, Color.BLACK));
    executeOverlayCommands(scene, passState);
    frameState.creditDisplay.endFrame();
    if (scene.debugShowFramesPerSecond) {
        if (!defined(scene._performanceDisplay)) {
            var performanceContainer = document.createElement('div');
            performanceContainer.className = 'cesium-performanceDisplay';
            performanceContainer.style.position = 'absolute';
            performanceContainer.style.top = '50px';
            performanceContainer.style.right = '10px';
            var container = scene._canvas.parentNode;
            container.appendChild(performanceContainer);
            var performanceDisplay = new PerformanceDisplay({ container: performanceContainer });
            scene._performanceDisplay = performanceDisplay;
            scene._performanceContainer = performanceContainer;
        }
        scene._performanceDisplay.update();
    } else if (defined(scene._performanceDisplay)) {
        scene._performanceDisplay = scene._performanceDisplay && scene._performanceDisplay.destroy();
        scene._performanceContainer.parentNode.removeChild(scene._performanceContainer);
    }
    context.endFrame();
    callAfterRenderFunctions(frameState);
    scene._postRender.raiseEvent(scene, time);
}
Scene.prototype.render = function (time) {
    try {
        render(this, time);
    } catch (error) {
        this._renderError.raiseEvent(this, error);
        if (this.rethrowRenderErrors) {
            throw error;
        }
    }
};
Scene.prototype.clampLineWidth = function (width) {
    var context = this._context;
    return Math.max(context.minimumAliasedLineWidth, Math.min(width, context.maximumAliasedLineWidth));
};
var orthoPickingFrustum = new OrthographicFrustum();
var scratchOrigin = new Cartesian3();
var scratchDirection = new Cartesian3();
var scratchBufferDimensions = new Cartesian2();
var scratchPixelSize = new Cartesian2();
function getPickOrthographicCullingVolume(scene, drawingBufferPosition, width, height) {
    var camera = scene._camera;
    var frustum = camera.frustum;
    var drawingBufferWidth = scene.drawingBufferWidth;
    var drawingBufferHeight = scene.drawingBufferHeight;
    var x = 2 / drawingBufferWidth * drawingBufferPosition.x - 1;
    x *= (frustum.right - frustum.left) * 0.5;
    var y = 2 / drawingBufferHeight * (drawingBufferHeight - drawingBufferPosition.y) - 1;
    y *= (frustum.top - frustum.bottom) * 0.5;
    var origin = Cartesian3.clone(camera.position, scratchOrigin);
    Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);
    Cartesian3.add(scratchDirection, origin, origin);
    Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);
    Cartesian3.add(scratchDirection, origin, origin);
    Cartesian3.fromElements(origin.z, origin.x, origin.y, origin);
    scratchBufferDimensions.x = drawingBufferWidth;
    scratchBufferDimensions.y = drawingBufferHeight;
    var pixelSize = frustum.getPixelSize(scratchBufferDimensions, undefined, scratchPixelSize);
    var ortho = orthoPickingFrustum;
    ortho.right = pixelSize.x * 0.5;
    ortho.left = -ortho.right;
    ortho.top = pixelSize.y * 0.5;
    ortho.bottom = -ortho.top;
    ortho.near = frustum.near;
    ortho.far = frustum.far;
    return ortho.computeCullingVolume(origin, camera.directionWC, camera.upWC);
}
var perspPickingFrustum = new PerspectiveOffCenterFrustum();
function getPickPerspectiveCullingVolume(scene, drawingBufferPosition, width, height) {
    var camera = scene._camera;
    var frustum = camera.frustum;
    var near = frustum.near;
    var drawingBufferWidth = scene.drawingBufferWidth;
    var drawingBufferHeight = scene.drawingBufferHeight;
    var tanPhi = Math.tan(frustum.fovy * 0.5);
    var tanTheta = frustum.aspectRatio * tanPhi;
    var x = 2 / drawingBufferWidth * drawingBufferPosition.x - 1;
    var y = 2 / drawingBufferHeight * (drawingBufferHeight - drawingBufferPosition.y) - 1;
    var xDir = x * near * tanTheta;
    var yDir = y * near * tanPhi;
    scratchBufferDimensions.x = drawingBufferWidth;
    scratchBufferDimensions.y = drawingBufferHeight;
    var pixelSize = frustum.getPixelSize(scratchBufferDimensions, undefined, scratchPixelSize);
    var pickWidth = pixelSize.x * width * 0.5;
    var pickHeight = pixelSize.y * height * 0.5;
    var offCenter = perspPickingFrustum;
    offCenter.top = yDir + pickHeight;
    offCenter.bottom = yDir - pickHeight;
    offCenter.right = xDir + pickWidth;
    offCenter.left = xDir - pickWidth;
    offCenter.near = near;
    offCenter.far = frustum.far;
    return offCenter.computeCullingVolume(camera.positionWC, camera.directionWC, camera.upWC);
}
function getPickCullingVolume(scene, drawingBufferPosition, width, height) {
    if (scene._mode === SceneMode.SCENE2D) {
        return getPickOrthographicCullingVolume(scene, drawingBufferPosition, width, height);
    }
    return getPickPerspectiveCullingVolume(scene, drawingBufferPosition, width, height);
}
var rectangleWidth = 3;
var rectangleHeight = 3;
var scratchRectangle = new BoundingRectangle(0, 0, rectangleWidth, rectangleHeight);
var scratchColorZero = new Color(0, 0, 0, 0);
var scratchPosition = new Cartesian2();
Scene.prototype.pick = function (windowPosition) {
    if (!defined(windowPosition)) {
        throw new DeveloperError('windowPosition is undefined.');
    }
    var context = this._context;
    var us = context.uniformState;
    var frameState = this._frameState;
    var drawingBufferPosition = SceneTransforms.transformWindowToDrawingBuffer(this, windowPosition, scratchPosition);
    if (!defined(this._pickFramebuffer)) {
        this._pickFramebuffer = context.createPickFramebuffer();
    }
    updateFrameState(this, frameState.frameNumber, frameState.time);
    frameState.cullingVolume = getPickCullingVolume(this, drawingBufferPosition, rectangleWidth, rectangleHeight);
    frameState.passes.pick = true;
    us.update(context, frameState);
    this._commandList.length = 0;
    updatePrimitives(this);
    createPotentiallyVisibleSet(this);
    scratchRectangle.x = drawingBufferPosition.x - (rectangleWidth - 1) * 0.5;
    scratchRectangle.y = this.drawingBufferHeight - drawingBufferPosition.y - (rectangleHeight - 1) * 0.5;
    executeCommands(this, this._pickFramebuffer.begin(scratchRectangle), scratchColorZero, true);
    var object = this._pickFramebuffer.end(scratchRectangle);
    context.endFrame();
    callAfterRenderFunctions(frameState);
    return object;
};
Scene.prototype.drillPick = function (windowPosition) {
    if (!defined(windowPosition)) {
        throw new DeveloperError('windowPosition is undefined.');
    }
    var pickedObjects = [];
    var pickedResult = this.pick(windowPosition);
    while (defined(pickedResult) && defined(pickedResult.primitive)) {
        var primitive = pickedResult.primitive;
        pickedObjects.push(pickedResult);
        if (defined(primitive.show)) {
            primitive.show = false;
        } else if (typeof primitive.getGeometryInstanceAttributes === 'function') {
            var attributes = primitive.getGeometryInstanceAttributes(pickedResult.id);
            if (defined(attributes) && defined(attributes.show)) {
                attributes.show = ShowGeometryInstanceAttribute.toValue(false);
            }
        }
        pickedResult = this.pick(windowPosition);
    }
    for (var i = 0; i < pickedObjects.length; ++i) {
        var p = pickedObjects[i].primitive;
        if (defined(p.show)) {
            p.show = true;
        } else if (typeof p.getGeometryInstanceAttributes === 'function') {
            var attr = p.getGeometryInstanceAttributes(pickedObjects[i].id);
            if (defined(attr) && defined(attr.show)) {
                attr.show = ShowGeometryInstanceAttribute.toValue(true);
            }
        }
    }
    return pickedObjects;
};
Scene.prototype.completeMorph = function () {
    this._transitioner.completeMorph();
};
Scene.prototype.morphTo2D = function (duration) {
    var ellipsoid;
    var globe = this.globe;
    if (defined(globe)) {
        ellipsoid = globe.ellipsoid;
    } else {
        ellipsoid = this.mapProjection.ellipsoid;
    }
    duration = defaultValue(duration, 2);
    this._transitioner.morphTo2D(duration, ellipsoid);
};
Scene.prototype.morphToColumbusView = function (duration) {
    var ellipsoid;
    var globe = this.globe;
    if (defined(globe)) {
        ellipsoid = globe.ellipsoid;
    } else {
        ellipsoid = this.mapProjection.ellipsoid;
    }
    duration = defaultValue(duration, 2);
    this._transitioner.morphToColumbusView(duration, ellipsoid);
};
Scene.prototype.morphTo3D = function (duration) {
    var ellipsoid;
    var globe = this.globe;
    if (defined(globe)) {
        ellipsoid = globe.ellipsoid;
    } else {
        ellipsoid = this.mapProjection.ellipsoid;
    }
    duration = defaultValue(duration, 2);
    this._transitioner.morphTo3D(duration, ellipsoid);
};
Scene.prototype.isDestroyed = function () {
    return false;
};
Scene.prototype.destroy = function () {
    this._tweens.removeAll();
    this._screenSpaceCameraController = this._screenSpaceCameraController && this._screenSpaceCameraController.destroy();
    this._pickFramebuffer = this._pickFramebuffer && this._pickFramebuffer.destroy();
    this._primitives = this._primitives && this._primitives.destroy();
    this._globe = this._globe && this._globe.destroy();
    this.skyBox = this.skyBox && this.skyBox.destroy();
    this.skyAtmosphere = this.skyAtmosphere && this.skyAtmosphere.destroy();
    this._debugSphere = this._debugSphere && this._debugSphere.destroy();
    this.sun = this.sun && this.sun.destroy();
    this._sunPostProcess = this._sunPostProcess && this._sunPostProcess.destroy();
    this._transitioner.destroy();
    if (defined(this._oit)) {
        this._oit.destroy();
    }
    this._fxaa.destroy();
    this._context = this._context && this._context.destroy();
    this._frameState.creditDisplay.destroy();
    if (defined(this._performanceDisplay)) {
        this._performanceDisplay = this._performanceDisplay && this._performanceDisplay.destroy();
        this._performanceContainer.parentNode.removeChild(this._performanceContainer);
    }
    return destroyObject(this);
};
module.exports = Scene;
},{"../Core/BoundingRectangle":97,"../Core/BoundingSphere":98,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Color":111,"../Core/ColorGeometryInstanceAttribute":112,"../Core/DeveloperError":123,"../Core/EllipsoidGeometry":132,"../Core/Event":138,"../Core/GeographicProjection":143,"../Core/GeometryInstance":148,"../Core/GeometryPipeline":150,"../Core/Intersect":163,"../Core/Interval":166,"../Core/JulianDate":168,"../Core/Math":174,"../Core/Matrix4":177,"../Core/Occluder":179,"../Core/ShowGeometryInstanceAttribute":210,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Core/mergeSort":265,"../Renderer/ClearCommand":340,"../Renderer/Context":341,"../Renderer/PassState":347,"./Camera":375,"./CreditDisplay":379,"./CullingVolume":381,"./FXAA":386,"./FrameState":388,"./FrustumCommands":389,"./OIT":416,"./OrthographicFrustum":418,"./Pass":419,"./PerInstanceColorAppearance":420,"./PerformanceDisplay":421,"./PerspectiveFrustum":422,"./PerspectiveOffCenterFrustum":423,"./Primitive":428,"./PrimitiveCollection":429,"./SceneMode":438,"./SceneTransforms":439,"./SceneTransitioner":440,"./ScreenSpaceCameraController":441,"./SunPostProcess":446,"./TweenCollection":453}],438:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var SceneMode = {
        MORPHING: 0,
        COLUMBUS_VIEW: 1,
        SCENE2D: 2,
        SCENE3D: 3
    };
SceneMode.getMorphTime = function (value) {
    if (value === SceneMode.SCENE3D) {
        return 1;
    } else if (value === SceneMode.MORPHING) {
        return undefined;
    }
    return 0;
};
module.exports = freezeObject(SceneMode);
},{"../Core/freezeObject":249}],439:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Cartographic = require('../Core/Cartographic'), defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), SceneMode = require('./SceneMode');
'use strict';
var SceneTransforms = {};
var actualPositionScratch = new Cartesian4(0, 0, 0, 1);
var positionCC = new Cartesian4();
var viewProjectionScratch = new Matrix4();
SceneTransforms.wgs84ToWindowCoordinates = function (scene, position, result) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(position)) {
        throw new DeveloperError('position is required.');
    }
    var actualPosition = SceneTransforms.computeActualWgs84Position(scene.frameState, position, actualPositionScratch);
    if (!defined(actualPosition)) {
        return undefined;
    }
    var camera = scene.camera;
    var viewProjection = Matrix4.multiply(camera.frustum.projectionMatrix, camera.viewMatrix, viewProjectionScratch);
    Matrix4.multiplyByVector(viewProjection, Cartesian4.fromElements(actualPosition.x, actualPosition.y, actualPosition.z, 1, positionCC), positionCC);
    if (positionCC.z < 0 && scene.mode !== SceneMode.SCENE2D) {
        return undefined;
    }
    result = SceneTransforms.clipToGLWindowCoordinates(scene, positionCC, result);
    result.y = scene.canvas.clientHeight - result.y;
    return result;
};
SceneTransforms.wgs84ToDrawingBufferCoordinates = function (scene, position, result) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(position)) {
        throw new DeveloperError('position is required.');
    }
    var actualPosition = SceneTransforms.computeActualWgs84Position(scene.frameState, position, actualPositionScratch);
    if (!defined(actualPosition)) {
        return undefined;
    }
    var camera = scene.camera;
    var viewProjection = Matrix4.multiply(camera.frustum.projectionMatrix, camera.viewMatrix, viewProjectionScratch);
    Matrix4.multiplyByVector(viewProjection, Cartesian4.fromElements(actualPosition.x, actualPosition.y, actualPosition.z, 1, positionCC), positionCC);
    if (positionCC.z < 0 && scene.mode !== SceneMode.SCENE2D) {
        return undefined;
    }
    return SceneTransforms.clipToDrawingBufferCoordinates(scene, positionCC, result);
};
var projectedPosition = new Cartesian3();
var positionInCartographic = new Cartographic();
SceneTransforms.computeActualWgs84Position = function (frameState, position, result) {
    var mode = frameState.mode;
    if (mode === SceneMode.SCENE3D) {
        return Cartesian3.clone(position, result);
    }
    var projection = frameState.mapProjection;
    var cartographic = projection.ellipsoid.cartesianToCartographic(position, positionInCartographic);
    if (!defined(cartographic)) {
        return undefined;
    }
    projection.project(cartographic, projectedPosition);
    if (mode === SceneMode.COLUMBUS_VIEW) {
        return Cartesian3.fromElements(projectedPosition.z, projectedPosition.x, projectedPosition.y, result);
    }
    if (mode === SceneMode.SCENE2D) {
        return Cartesian3.fromElements(0, projectedPosition.x, projectedPosition.y, result);
    }
    var morphTime = frameState.morphTime;
    return Cartesian3.fromElements(CesiumMath.lerp(projectedPosition.z, position.x, morphTime), CesiumMath.lerp(projectedPosition.x, position.y, morphTime), CesiumMath.lerp(projectedPosition.y, position.z, morphTime), result);
};
var positionNDC = new Cartesian3();
var positionWC = new Cartesian3();
var viewport = new BoundingRectangle();
var viewportTransform = new Matrix4();
SceneTransforms.clipToGLWindowCoordinates = function (scene, position, result) {
    var canvas = scene.canvas;
    Cartesian3.divideByScalar(position, position.w, positionNDC);
    viewport.width = canvas.clientWidth;
    viewport.height = canvas.clientHeight;
    Matrix4.computeViewportTransformation(viewport, 0, 1, viewportTransform);
    Matrix4.multiplyByPoint(viewportTransform, positionNDC, positionWC);
    return Cartesian2.fromCartesian3(positionWC, result);
};
SceneTransforms.clipToDrawingBufferCoordinates = function (scene, position, result) {
    Cartesian3.divideByScalar(position, position.w, positionNDC);
    viewport.width = scene.drawingBufferWidth;
    viewport.height = scene.drawingBufferHeight;
    Matrix4.computeViewportTransformation(viewport, 0, 1, viewportTransform);
    Matrix4.multiplyByPoint(viewportTransform, positionNDC, positionWC);
    return Cartesian2.fromCartesian3(positionWC, result);
};
SceneTransforms.transformWindowToDrawingBuffer = function (scene, windowPosition, result) {
    var canvas = scene.canvas;
    var xScale = scene.drawingBufferWidth / canvas.clientWidth;
    var yScale = scene.drawingBufferHeight / canvas.clientHeight;
    return Cartesian2.fromElements(windowPosition.x * xScale, windowPosition.y * yScale, result);
};
module.exports = SceneTransforms;
},{"../Core/BoundingRectangle":97,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Cartographic":104,"../Core/DeveloperError":123,"../Core/Math":174,"../Core/Matrix4":177,"../Core/defined":245,"./SceneMode":438}],440:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), EasingFunction = require('../Core/EasingFunction'), Ellipsoid = require('../Core/Ellipsoid'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), ScreenSpaceEventHandler = require('../Core/ScreenSpaceEventHandler'), ScreenSpaceEventType = require('../Core/ScreenSpaceEventType'), Camera = require('./Camera'), OrthographicFrustum = require('./OrthographicFrustum'), PerspectiveFrustum = require('./PerspectiveFrustum'), SceneMode = require('./SceneMode');
'use strict';
var SceneTransitioner = function (scene, ellipsoid) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    this._scene = scene;
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    var maxRadii = ellipsoid.maximumRadius;
    var position = new Cartesian3(0, 0, 2 * maxRadii);
    var direction = new Cartesian3();
    direction = Cartesian3.normalize(Cartesian3.negate(position, direction), direction);
    var up = Cartesian3.clone(Cartesian3.UNIT_Y);
    var position2D = Matrix4.multiplyByPoint(Camera.TRANSFORM_2D, position, new Cartesian3());
    var direction2D = Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, direction, new Cartesian3());
    var up2D = Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, up, new Cartesian3());
    var frustum = new OrthographicFrustum();
    frustum.right = maxRadii * Math.PI;
    frustum.left = -frustum.right;
    frustum.top = frustum.right * (scene.drawingBufferHeight / scene.drawingBufferWidth);
    frustum.bottom = -frustum.top;
    this._camera2D = {
        position: position,
        direction: direction,
        up: up,
        position2D: position2D,
        direction2D: direction2D,
        up2D: up2D,
        frustum: frustum
    };
    position = new Cartesian3(0, -1, 1);
    position = Cartesian3.multiplyByScalar(Cartesian3.normalize(position, position), 5 * maxRadii, position);
    direction = new Cartesian3();
    direction = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.ZERO, position, direction), direction);
    var right = new Cartesian3();
    right = Cartesian3.normalize(Cartesian3.cross(direction, Cartesian3.UNIT_Z, right), right);
    up = new Cartesian3();
    up = Cartesian3.normalize(Cartesian3.cross(right, direction, up), up);
    position2D = Matrix4.multiplyByPoint(Camera.TRANSFORM_2D, position, new Cartesian3());
    direction2D = Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, direction, new Cartesian3());
    var right2D = Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D, right, new Cartesian3());
    up2D = new Cartesian3();
    up2D = Cartesian3.normalize(Cartesian3.cross(right2D, direction2D, up2D), up2D);
    frustum = new PerspectiveFrustum();
    frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;
    frustum.fov = CesiumMath.toRadians(60);
    this._cameraCV = {
        position: position,
        direction: direction,
        up: up,
        position2D: position2D,
        direction2D: direction2D,
        up2D: up2D,
        frustum: frustum
    };
    position = new Cartesian3();
    position = Cartesian3.multiplyByScalar(Cartesian3.normalize(new Cartesian3(0, -2, 1), position), 2 * maxRadii, position);
    direction = new Cartesian3();
    direction = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.ZERO, position, direction), direction);
    right = new Cartesian3();
    right = Cartesian3.normalize(Cartesian3.cross(direction, Cartesian3.UNIT_Z, right), right);
    up = new Cartesian3();
    up = Cartesian3.normalize(Cartesian3.cross(right, direction, up), up);
    this._camera3D = {
        position: position,
        direction: direction,
        up: up,
        frustum: frustum
    };
    this._currentTweens = [];
    this._morphHandler = undefined;
    this._morphCancelled = false;
    this._completeMorph = undefined;
};
SceneTransitioner.prototype.completeMorph = function () {
    if (defined(this._completeMorph)) {
        this._completeMorph();
    }
};
SceneTransitioner.prototype.morphTo2D = function (duration, ellipsoid) {
    if (defined(this._completeMorph)) {
        this._completeMorph();
    }
    var scene = this._scene;
    this._previousMode = scene.mode;
    if (this._previousMode === SceneMode.SCENE2D || this._previousMode === SceneMode.MORPHING) {
        return;
    }
    this._scene.morphStart.raiseEvent(this, this._previousMode, SceneMode.SCENE2D, true);
    updateFrustums(this);
    scene.mode = SceneMode.MORPHING;
    createMorphHandler(this, complete2DCallback);
    if (this._previousMode === SceneMode.COLUMBUS_VIEW) {
        morphFromColumbusViewTo2D(this, duration, ellipsoid, complete2DCallback);
    } else {
        morphFrom3DTo2D(this, duration, ellipsoid, complete2DCallback);
    }
    if (duration === 0 && defined(this._completeMorph)) {
        this._completeMorph();
    }
};
SceneTransitioner.prototype.morphToColumbusView = function (duration, ellipsoid) {
    if (defined(this._completeMorph)) {
        this._completeMorph();
    }
    var scene = this._scene;
    this._previousMode = scene.mode;
    if (this._previousMode === SceneMode.COLUMBUS_VIEW || this._previousMode === SceneMode.MORPHING) {
        return;
    }
    this._scene.morphStart.raiseEvent(this, this._previousMode, SceneMode.COLUMBUS_VIEW, true);
    updateFrustums(this);
    scene.mode = SceneMode.MORPHING;
    createMorphHandler(this, completeColumbusViewCallback);
    if (this._previousMode === SceneMode.SCENE2D) {
        morphFrom2DToColumbusView(this, duration, ellipsoid, completeColumbusViewCallback);
    } else {
        morphFrom3DToColumbusView(this, duration, this._cameraCV, completeColumbusViewCallback);
    }
    if (duration === 0 && defined(this._completeMorph)) {
        this._completeMorph();
    }
};
SceneTransitioner.prototype.morphTo3D = function (duration, ellipsoid) {
    if (defined(this._completeMorph)) {
        this._completeMorph();
    }
    var scene = this._scene;
    this._previousMode = scene.mode;
    if (this._previousMode === SceneMode.SCENE3D || this._previousMode === SceneMode.MORPHING) {
        return;
    }
    this._scene.morphStart.raiseEvent(this, this._previousMode, SceneMode.SCENE3D, true);
    updateFrustums(this);
    scene.mode = SceneMode.MORPHING;
    createMorphHandler(this, complete3DCallback);
    if (this._previousMode === SceneMode.SCENE2D) {
        morphFrom2DTo3D(this, duration, ellipsoid, complete3DCallback);
    } else {
        morphFromColumbusViewTo3D(this, duration, ellipsoid, complete3DCallback);
    }
    if (duration === 0 && defined(this._completeMorph)) {
        this._completeMorph();
    }
};
SceneTransitioner.prototype.isDestroyed = function () {
    return false;
};
SceneTransitioner.prototype.destroy = function () {
    destroyMorphHandler(this);
    return destroyObject(this);
};
function createMorphHandler(transitioner, completeMorphFunction) {
    if (transitioner._scene.completeMorphOnUserInput) {
        transitioner._morphHandler = new ScreenSpaceEventHandler(transitioner._scene.canvas);
        var completeMorph = function () {
            transitioner._morphCancelled = true;
            completeMorphFunction(transitioner);
        };
        transitioner._completeMorph = completeMorph;
        transitioner._morphHandler.setInputAction(completeMorph, ScreenSpaceEventType.LEFT_DOWN);
        transitioner._morphHandler.setInputAction(completeMorph, ScreenSpaceEventType.MIDDLE_DOWN);
        transitioner._morphHandler.setInputAction(completeMorph, ScreenSpaceEventType.RIGHT_DOWN);
        transitioner._morphHandler.setInputAction(completeMorph, ScreenSpaceEventType.WHEEL);
    }
}
function destroyMorphHandler(transitioner) {
    var tweens = transitioner._currentTweens;
    for (var i = 0; i < tweens.length; ++i) {
        tweens[i].cancelTween();
    }
    transitioner._currentTweens.length = 0;
    transitioner._morphHandler = transitioner._morphHandler && transitioner._morphHandler.destroy();
}
function morphFromColumbusViewTo3D(transitioner, duration, ellipsoid, complete) {
    var scene = transitioner._scene;
    var camera = scene.camera;
    camera.setTransform(Matrix4.IDENTITY);
    var startPos = camera.position;
    var startDir = camera.direction;
    var startUp = camera.up;
    var endPos = Cartesian3.clone(transitioner._camera2D.position);
    var endDir = Cartesian3.clone(transitioner._camera2D.direction);
    var endUp = Cartesian3.clone(transitioner._camera2D.up);
    var update = function (value) {
        camera.position = columbusViewMorph(startPos, endPos, value.time);
        camera.direction = columbusViewMorph(startDir, endDir, value.time);
        camera.up = columbusViewMorph(startUp, endUp, value.time);
        camera.right = Cartesian3.cross(camera.direction, camera.up, camera.right);
        Cartesian3.normalize(camera.right, camera.right);
    };
    var tween = scene.tweens.add({
            duration: duration,
            easingFunction: EasingFunction.QUARTIC_OUT,
            startObject: { time: 0 },
            stopObject: { time: 1 },
            update: update
        });
    transitioner._currentTweens.push(tween);
    addMorphTimeAnimations(transitioner, scene, 0, 1, duration, complete);
}
function morphFrom2DTo3D(transitioner, duration, ellipsoid, complete) {
    duration *= 0.5;
    var camera = transitioner._scene.camera;
    camera.setTransform(Matrix4.IDENTITY);
    morphOrthographicToPerspective(transitioner, duration, ellipsoid, function () {
        camera.frustum = transitioner._cameraCV.frustum.clone();
        morphFromColumbusViewTo3D(transitioner, duration, ellipsoid, complete);
    });
}
function columbusViewMorph(startPosition, endPosition, time) {
    return Cartesian3.lerp(startPosition, endPosition, time, new Cartesian3());
}
function morphPerspectiveToOrthographic(transitioner, duration, complete) {
    var scene = transitioner._scene;
    var camera = scene.camera;
    var startPos = camera.position;
    var startFOV = camera.frustum.fov;
    var endFOV = CesiumMath.RADIANS_PER_DEGREE * 0.5;
    var d = Cartesian3.magnitude(startPos) * Math.tan(startFOV * 0.5);
    camera.frustum.far = d / Math.tan(endFOV * 0.5) + 10000000;
    var update = function (value) {
        camera.frustum.fov = CesiumMath.lerp(startFOV, endFOV, value.time);
        var distance = d / Math.tan(camera.frustum.fov * 0.5);
        var pos = new Cartesian3();
        camera.position = Cartesian3.multiplyByScalar(Cartesian3.normalize(camera.position, pos), distance, pos);
    };
    var tween = scene.tweens.add({
            duration: duration,
            easingFunction: EasingFunction.QUARTIC_OUT,
            startObject: { time: 0 },
            stopObject: { time: 1 },
            update: update,
            complete: function () {
                camera.frustum = transitioner._camera2D.frustum.clone();
                complete(transitioner);
            }
        });
    transitioner._currentTweens.push(tween);
}
function morphFromColumbusViewTo2D(transitioner, duration, ellipsoid, complete) {
    var scene = transitioner._scene;
    var camera = scene.camera;
    camera.setTransform(Matrix4.IDENTITY);
    var maxRadii = ellipsoid.maximumRadius;
    var startPos = Cartesian3.clone(camera.position);
    var startDir = Cartesian3.clone(camera.direction);
    var startUp = Cartesian3.clone(camera.up);
    var tanPhi = Math.tan(transitioner._cameraCV.frustum.fovy * 0.5);
    var tanTheta = transitioner._cameraCV.frustum.aspectRatio * tanPhi;
    var d = maxRadii * Math.PI / tanTheta;
    var endPos = new Cartesian3();
    endPos = Cartesian3.multiplyByScalar(Cartesian3.normalize(transitioner._camera2D.position, endPos), d, endPos);
    var endDir = Cartesian3.clone(transitioner._camera2D.direction);
    var endUp = Cartesian3.clone(transitioner._camera2D.up);
    var updateCV = function (value) {
        camera.position = columbusViewMorph(startPos, endPos, value.time);
        camera.direction = columbusViewMorph(startDir, endDir, value.time);
        camera.up = columbusViewMorph(startUp, endUp, value.time);
        camera.right = Cartesian3.cross(camera.direction, camera.up, camera.right);
        Cartesian3.normalize(camera.right, camera.right);
    };
    duration *= 0.5;
    var tween = scene.tweens.add({
            duration: duration,
            easingFunction: EasingFunction.QUARTIC_OUT,
            startObject: { time: 0 },
            stopObject: { time: 1 },
            update: updateCV,
            complete: function () {
                morphPerspectiveToOrthographic(transitioner, duration, complete);
            }
        });
    transitioner._currentTweens.push(tween);
}
function morphFrom3DTo2D(transitioner, duration, ellipsoid, complete) {
    duration *= 0.5;
    var maxRadii = ellipsoid.maximumRadius;
    var tanPhi = Math.tan(transitioner._camera3D.frustum.fovy * 0.5);
    var tanTheta = transitioner._camera3D.frustum.aspectRatio * tanPhi;
    var d = maxRadii * Math.PI / tanTheta;
    var camera3DTo2D = {};
    var pos2D = new Cartesian3();
    camera3DTo2D.position2D = Cartesian3.multiplyByScalar(Cartesian3.normalize(transitioner._camera2D.position2D, pos2D), d, pos2D);
    camera3DTo2D.direction2D = Cartesian3.clone(transitioner._camera2D.direction2D);
    camera3DTo2D.up2D = Cartesian3.clone(transitioner._camera2D.up2D);
    var completeCallback = function () {
        morphPerspectiveToOrthographic(transitioner, duration, complete);
    };
    morphFrom3DToColumbusView(transitioner, duration, camera3DTo2D, completeCallback);
}
function morphOrthographicToPerspective(transitioner, duration, ellipsoid, complete) {
    var scene = transitioner._scene;
    var camera = scene.camera;
    var maxRadii = ellipsoid.maximumRadius;
    var tanPhi = Math.tan(transitioner._cameraCV.frustum.fovy * 0.5);
    var tanTheta = transitioner._cameraCV.frustum.aspectRatio * tanPhi;
    var d = maxRadii * Math.PI / tanTheta;
    var endPos2D = new Cartesian3();
    endPos2D = Cartesian3.multiplyByScalar(Cartesian3.normalize(transitioner._camera2D.position, endPos2D), d, endPos2D);
    var top = camera.frustum.top;
    var bottom = camera.frustum.bottom;
    var right = camera.frustum.right;
    var left = camera.frustum.left;
    var frustum2D = transitioner._camera2D.frustum;
    var frustumCV = transitioner._cameraCV.frustum;
    var startPos = Cartesian3.clone(camera.position);
    var update2D = function (value) {
        camera.position = columbusViewMorph(startPos, endPos2D, value.time);
        camera.frustum.top = CesiumMath.lerp(top, frustum2D.top, value.time);
        camera.frustum.bottom = CesiumMath.lerp(bottom, frustum2D.bottom, value.time);
        camera.frustum.right = CesiumMath.lerp(right, frustum2D.right, value.time);
        camera.frustum.left = CesiumMath.lerp(left, frustum2D.left, value.time);
    };
    var startTime = (right - left) / (2 * maxRadii * Math.PI);
    var endTime = 1;
    if (startTime > endTime) {
        startTime = 0;
    }
    var partialDuration = (endTime - startTime) * duration;
    if (partialDuration < CesiumMath.EPSILON6) {
        if (!Cartesian3.equalsEpsilon(startPos, endPos2D, CesiumMath.EPSILON6)) {
            partialDuration = duration;
            startTime = 0;
            endTime = 1;
        } else {
            camera.position = endPos2D;
            camera.frustum = frustumCV.clone();
            complete(transitioner);
            return;
        }
    }
    var tween = scene.tweens.add({
            easingFunction: EasingFunction.QUARTIC_OUT,
            duration: partialDuration,
            startObject: { time: startTime },
            stopObject: { time: endTime },
            update: update2D,
            complete: function () {
                camera.frustum = frustumCV.clone();
                complete(transitioner);
            }
        });
    transitioner._currentTweens.push(tween);
}
function morphFrom2DToColumbusView(transitioner, duration, ellipsoid, complete) {
    var scene = transitioner._scene;
    var camera = scene.camera;
    camera.setTransform(Matrix4.IDENTITY);
    duration *= 0.5;
    var completeFrustumChange = function () {
        var startPos = Cartesian3.clone(camera.position);
        var startDir = Cartesian3.clone(camera.direction);
        var startUp = Cartesian3.clone(camera.up);
        var endPos = Cartesian3.clone(transitioner._cameraCV.position);
        var endDir = Cartesian3.clone(transitioner._cameraCV.direction);
        var endUp = Cartesian3.clone(transitioner._cameraCV.up);
        var updateCV = function (value) {
            camera.position = columbusViewMorph(startPos, endPos, value.time);
            camera.direction = columbusViewMorph(startDir, endDir, value.time);
            camera.up = columbusViewMorph(startUp, endUp, value.time);
            camera.right = Cartesian3.cross(camera.direction, camera.up, camera.right);
            Cartesian3.normalize(camera.right, camera.right);
        };
        var tween = scene.tweens.add({
                duration: duration,
                easingFunction: EasingFunction.QUARTIC_OUT,
                startObject: { time: 0 },
                stopObject: { time: 1 },
                update: updateCV,
                complete: function () {
                    complete(transitioner);
                }
            });
        transitioner._currentTweens.push(tween);
    };
    morphOrthographicToPerspective(transitioner, duration, ellipsoid, completeFrustumChange);
}
function morphFrom3DToColumbusView(transitioner, duration, endCamera, complete) {
    var scene = transitioner._scene;
    var camera = scene.camera;
    camera.setTransform(Matrix4.IDENTITY);
    var startPos = Cartesian3.clone(camera.position);
    var startDir = Cartesian3.clone(camera.direction);
    var startUp = Cartesian3.clone(camera.up);
    var endPos = Cartesian3.clone(endCamera.position2D);
    var endDir = Cartesian3.clone(endCamera.direction2D);
    var endUp = Cartesian3.clone(endCamera.up2D);
    var update = function (value) {
        camera.position = columbusViewMorph(startPos, endPos, value.time);
        camera.direction = columbusViewMorph(startDir, endDir, value.time);
        camera.up = columbusViewMorph(startUp, endUp, value.time);
        camera.right = Cartesian3.cross(camera.direction, camera.up, camera.right);
        Cartesian3.normalize(camera.right, camera.right);
    };
    var tween = scene.tweens.add({
            duration: duration,
            easingFunction: EasingFunction.QUARTIC_OUT,
            startObject: { time: 0 },
            stopObject: { time: 1 },
            update: update,
            complete: function () {
                camera.position = endPos;
                camera.direction = endDir;
                camera.up = endUp;
                camera.right = Cartesian3.cross(endDir, endUp, camera.right);
                Cartesian3.normalize(camera.right, camera.right);
            }
        });
    transitioner._currentTweens.push(tween);
    addMorphTimeAnimations(transitioner, scene, 1, 0, duration, complete);
}
function addMorphTimeAnimations(transitioner, scene, start, stop, duration, complete) {
    var options = {
            object: scene,
            property: 'morphTime',
            startValue: start,
            stopValue: stop,
            duration: duration,
            easingFunction: EasingFunction.QUARTIC_OUT
        };
    if (defined(complete)) {
        options.complete = function () {
            complete(transitioner);
        };
    }
    var tween = scene.tweens.addProperty(options);
    transitioner._currentTweens.push(tween);
}
function updateFrustums(transitioner) {
    var scene = transitioner._scene;
    var ratio = scene.drawingBufferHeight / scene.drawingBufferWidth;
    var frustum = transitioner._camera2D.frustum;
    frustum.top = frustum.right * ratio;
    frustum.bottom = -frustum.top;
    ratio = 1 / ratio;
    frustum = transitioner._cameraCV.frustum;
    frustum.aspectRatio = ratio;
    frustum = transitioner._camera3D.frustum;
    frustum.aspectRatio = ratio;
    var camera = scene.camera;
    switch (scene.mode) {
    case SceneMode.SCENE3D:
        camera.frustum = transitioner._camera3D.frustum.clone();
        break;
    case SceneMode.COLUMBUS_VIEW:
        camera.frustum = transitioner._cameraCV.frustum.clone();
        break;
    case SceneMode.SCENE2D:
        camera.frustum = transitioner._camera2D.frustum.clone();
        break;
    }
}
function complete3DCallback(transitioner) {
    var scene = transitioner._scene;
    scene.mode = SceneMode.SCENE3D;
    scene.morphTime = SceneMode.getMorphTime(SceneMode.SCENE3D);
    destroyMorphHandler(transitioner);
    updateFrustums(transitioner);
    if (transitioner._previousMode !== SceneMode.MORPHING || transitioner._morphCancelled) {
        transitioner._morphCancelled = false;
        var camera = scene.camera;
        camera.position = Cartesian3.clone(transitioner._camera3D.position);
        camera.direction = Cartesian3.clone(transitioner._camera3D.direction);
        camera.up = Cartesian3.clone(transitioner._camera3D.up);
        camera.right = Cartesian3.cross(camera.direction, camera.up, camera.right);
        Cartesian3.normalize(camera.right, camera.right);
    }
    var wasMorphing = defined(transitioner._completeMorph);
    transitioner._completeMorph = undefined;
    transitioner._scene.morphComplete.raiseEvent(transitioner, transitioner._previousMode, SceneMode.SCENE3D, wasMorphing);
}
function complete2DCallback(transitioner) {
    var scene = transitioner._scene;
    scene.mode = SceneMode.SCENE2D;
    scene.morphTime = SceneMode.getMorphTime(SceneMode.SCENE2D);
    destroyMorphHandler(transitioner);
    updateFrustums(transitioner);
    var camera = scene.camera;
    Cartesian3.clone(transitioner._camera2D.position, camera.position);
    Cartesian3.clone(transitioner._camera2D.direction, camera.direction);
    Cartesian3.clone(transitioner._camera2D.up, camera.up);
    Cartesian3.cross(camera.direction, camera.up, camera.right);
    Cartesian3.normalize(camera.right, camera.right);
    var wasMorphing = defined(transitioner._completeMorph);
    transitioner._completeMorph = undefined;
    transitioner._scene.morphComplete.raiseEvent(transitioner, transitioner._previousMode, SceneMode.SCENE2D, wasMorphing);
}
function completeColumbusViewCallback(transitioner) {
    var scene = transitioner._scene;
    scene.mode = SceneMode.COLUMBUS_VIEW;
    scene.morphTime = SceneMode.getMorphTime(SceneMode.COLUMBUS_VIEW);
    destroyMorphHandler(transitioner);
    updateFrustums(transitioner);
    if (transitioner._previousModeMode !== SceneMode.MORPHING || transitioner._morphCancelled) {
        transitioner._morphCancelled = false;
        var camera = scene.camera;
        Cartesian3.clone(transitioner._cameraCV.position, camera.position);
        Cartesian3.clone(transitioner._cameraCV.direction, camera.direction);
        Cartesian3.clone(transitioner._cameraCV.up, camera.up);
        Cartesian3.cross(camera.direction, camera.up, camera.right);
        Cartesian3.normalize(camera.right, camera.right);
    }
    var wasMorphing = defined(transitioner._completeMorph);
    transitioner._completeMorph = undefined;
    transitioner._scene.morphComplete.raiseEvent(transitioner, transitioner._previousMode, SceneMode.COLUMBUS_VIEW, wasMorphing);
}
module.exports = SceneTransitioner;
},{"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/EasingFunction":126,"../Core/Ellipsoid":130,"../Core/Math":174,"../Core/Matrix4":177,"../Core/ScreenSpaceEventHandler":208,"../Core/ScreenSpaceEventType":209,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"./Camera":375,"./OrthographicFrustum":418,"./PerspectiveFrustum":422,"./SceneMode":438}],441:[function(require,module,exports){
var Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Cartographic = require('../Core/Cartographic'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), Ellipsoid = require('../Core/Ellipsoid'), IntersectionTests = require('../Core/IntersectionTests'), isArray = require('../Core/isArray'), KeyboardEventModifier = require('../Core/KeyboardEventModifier'), CesiumMath = require('../Core/Math'), Matrix3 = require('../Core/Matrix3'), Matrix4 = require('../Core/Matrix4'), Plane = require('../Core/Plane'), Quaternion = require('../Core/Quaternion'), Ray = require('../Core/Ray'), Transforms = require('../Core/Transforms'), CameraEventAggregator = require('./CameraEventAggregator'), CameraEventType = require('./CameraEventType'), SceneMode = require('./SceneMode'), TweenCollection = require('./TweenCollection');
'use strict';
var ScreenSpaceCameraController = function (scene) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    this.enableInputs = true;
    this.enableTranslate = true;
    this.enableZoom = true;
    this.enableRotate = true;
    this.enableTilt = true;
    this.enableLook = true;
    this.inertiaSpin = 0.9;
    this.inertiaTranslate = 0.9;
    this.inertiaZoom = 0.8;
    this.maximumMovementRatio = 0.1;
    this.bounceAnimationTime = 3;
    this.minimumZoomDistance = 20;
    this.maximumZoomDistance = Number.POSITIVE_INFINITY;
    this.translateEventTypes = CameraEventType.LEFT_DRAG;
    this.zoomEventTypes = [
        CameraEventType.RIGHT_DRAG,
        CameraEventType.WHEEL,
        CameraEventType.PINCH
    ];
    this.rotateEventTypes = CameraEventType.LEFT_DRAG;
    this.tiltEventTypes = [
        CameraEventType.MIDDLE_DRAG,
        CameraEventType.PINCH,
        {
            eventType: CameraEventType.LEFT_DRAG,
            modifier: KeyboardEventModifier.CTRL
        }
    ];
    this.lookEventTypes = {
        eventType: CameraEventType.LEFT_DRAG,
        modifier: KeyboardEventModifier.SHIFT
    };
    this.minimumPickingTerrainHeight = 150000;
    this.minimumCollisionTerrainHeight = 10000;
    this.minimumTrackBallHeight = 7500000;
    this._scene = scene;
    this._globe = undefined;
    this._ellipsoid = undefined;
    this._aggregator = new CameraEventAggregator(scene.canvas);
    this._lastInertiaSpinMovement = undefined;
    this._lastInertiaZoomMovement = undefined;
    this._lastInertiaTranslateMovement = undefined;
    this._lastInertiaWheelZoomMovement = undefined;
    this._lastInertiaTiltMovement = undefined;
    this._tweens = new TweenCollection();
    this._tween = undefined;
    this._horizontalRotationAxis = undefined;
    this._tiltCenterMousePosition = new Cartesian2(-1, -1);
    this._tiltCenter = new Cartesian3();
    this._rotateMousePosition = new Cartesian2(-1, -1);
    this._rotateStartPosition = new Cartesian3();
    this._tiltCVOffMap = false;
    this._looking = false;
    this._rotating = false;
    var projection = scene.mapProjection;
    this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO));
    this._zoomFactor = 5;
    this._rotateFactor = undefined;
    this._rotateRateRangeAdjustment = undefined;
    this._maximumRotateRate = 1.77;
    this._minimumRotateRate = 1 / 5000;
    this._translateFactor = 1;
    this._minimumZoomRate = 20;
    this._maximumZoomRate = 5906376272000;
};
function decay(time, coefficient) {
    if (time < 0) {
        return 0;
    }
    var tau = (1 - coefficient) * 25;
    return Math.exp(-tau * time);
}
function sameMousePosition(movement) {
    return Cartesian2.equalsEpsilon(movement.startPosition, movement.endPosition, CesiumMath.EPSILON14);
}
var inertiaMaxClickTimeThreshold = 0.4;
function maintainInertia(aggregator, type, modifier, decayCoef, action, object, lastMovementName) {
    var movementState = object[lastMovementName];
    if (!defined(movementState)) {
        movementState = object[lastMovementName] = {
            startPosition: new Cartesian2(),
            endPosition: new Cartesian2(),
            motion: new Cartesian2(),
            active: false
        };
    }
    var ts = aggregator.getButtonPressTime(type, modifier);
    var tr = aggregator.getButtonReleaseTime(type, modifier);
    var threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000;
    var now = new Date();
    var fromNow = tr && (now.getTime() - tr.getTime()) / 1000;
    if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {
        var d = decay(fromNow, decayCoef);
        if (!movementState.active) {
            var lastMovement = aggregator.getLastMovement(type, modifier);
            if (!defined(lastMovement) || sameMousePosition(lastMovement)) {
                return;
            }
            movementState.motion.x = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;
            movementState.motion.y = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;
            movementState.startPosition = Cartesian2.clone(lastMovement.startPosition, movementState.startPosition);
            movementState.endPosition = Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);
            movementState.endPosition = Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition);
            movementState.active = true;
        } else {
            movementState.startPosition = Cartesian2.clone(movementState.endPosition, movementState.startPosition);
            movementState.endPosition = Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);
            movementState.endPosition = Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition);
            movementState.motion = Cartesian2.clone(Cartesian2.ZERO, movementState.motion);
        }
        if (isNaN(movementState.endPosition.x) || isNaN(movementState.endPosition.y) || sameMousePosition(movementState)) {
            movementState.active = false;
            return;
        }
        if (!aggregator.isButtonDown(type, modifier)) {
            var startPosition = aggregator.getStartMousePosition(type, modifier);
            action(object, startPosition, movementState);
        }
    } else {
        movementState.active = false;
    }
}
var scratchEventTypeArray = [];
function reactToInput(controller, enabled, eventTypes, action, inertiaConstant, inertiaStateName) {
    if (!defined(eventTypes)) {
        return;
    }
    var aggregator = controller._aggregator;
    if (!isArray(eventTypes)) {
        scratchEventTypeArray[0] = eventTypes;
        eventTypes = scratchEventTypeArray;
    }
    var length = eventTypes.length;
    for (var i = 0; i < length; ++i) {
        var eventType = eventTypes[i];
        var type = defined(eventType.eventType) ? eventType.eventType : eventType;
        var modifier = eventType.modifier;
        var movement = aggregator.isMoving(type, modifier) && aggregator.getMovement(type, modifier);
        var startPosition = aggregator.getStartMousePosition(type, modifier);
        if (controller.enableInputs && enabled) {
            if (movement) {
                action(controller, startPosition, movement);
            } else if (inertiaConstant < 1) {
                maintainInertia(aggregator, type, modifier, inertiaConstant, action, controller, inertiaStateName);
            }
        }
    }
}
function handleZoom(object, startPosition, movement, zoomFactor, distanceMeasure, unitPositionDotDirection) {
    var percentage = 1;
    if (defined(unitPositionDotDirection)) {
        percentage = CesiumMath.clamp(Math.abs(unitPositionDotDirection), 0.25, 1);
    }
    var minHeight = object.minimumZoomDistance * percentage;
    var maxHeight = object.maximumZoomDistance;
    var minDistance = distanceMeasure - minHeight;
    var zoomRate = zoomFactor * minDistance;
    zoomRate = CesiumMath.clamp(zoomRate, object._minimumZoomRate, object._maximumZoomRate);
    var diff = movement.endPosition.y - movement.startPosition.y;
    var rangeWindowRatio = diff / object._scene.canvas.clientHeight;
    rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);
    var distance = zoomRate * rangeWindowRatio;
    if (distance > 0 && Math.abs(distanceMeasure - minHeight) < 1) {
        return;
    }
    if (distance < 0 && Math.abs(distanceMeasure - maxHeight) < 1) {
        return;
    }
    if (distanceMeasure - distance < minHeight) {
        distance = distanceMeasure - minHeight - 1;
    } else if (distanceMeasure - distance > maxHeight) {
        distance = distanceMeasure - maxHeight;
    }
    object._scene.camera.zoomIn(distance);
}
var translate2DStart = new Ray();
var translate2DEnd = new Ray();
var scratchTranslateP0 = new Cartesian3();
var scratchTranslateP1 = new Cartesian3();
function translate2D(controller, startPosition, movement) {
    var scene = controller._scene;
    var camera = scene.camera;
    var start = camera.getPickRay(movement.startPosition, translate2DStart).origin;
    var end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;
    var position = camera.position;
    var p0 = Cartesian3.subtract(start, position, scratchTranslateP0);
    var p1 = Cartesian3.subtract(end, position, scratchTranslateP1);
    var direction = Cartesian3.subtract(p0, p1, scratchTranslateP0);
    var distance = Cartesian3.magnitude(direction);
    if (distance > 0) {
        Cartesian3.normalize(direction, direction);
        camera.move(direction, distance);
    }
}
function zoom2D(controller, startPosition, movement) {
    if (defined(movement.distance)) {
        movement = movement.distance;
    }
    var scene = controller._scene;
    var camera = scene.camera;
    handleZoom(controller, startPosition, movement, controller._zoomFactor, camera.getMagnitude());
}
var twist2DStart = new Cartesian2();
var twist2DEnd = new Cartesian2();
function twist2D(controller, startPosition, movement) {
    if (defined(movement.angleAndHeight)) {
        singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);
        return;
    }
    var scene = controller._scene;
    var camera = scene.camera;
    var canvas = scene.canvas;
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;
    var start = twist2DStart;
    start.x = 2 / width * movement.startPosition.x - 1;
    start.y = 2 / height * (height - movement.startPosition.y) - 1;
    start = Cartesian2.normalize(start, start);
    var end = twist2DEnd;
    end.x = 2 / width * movement.endPosition.x - 1;
    end.y = 2 / height * (height - movement.endPosition.y) - 1;
    end = Cartesian2.normalize(end, end);
    var startTheta = CesiumMath.acosClamped(start.x);
    if (start.y < 0) {
        startTheta = CesiumMath.TWO_PI - startTheta;
    }
    var endTheta = CesiumMath.acosClamped(end.x);
    if (end.y < 0) {
        endTheta = CesiumMath.TWO_PI - endTheta;
    }
    var theta = endTheta - startTheta;
    camera.twistRight(theta);
}
function singleAxisTwist2D(controller, startPosition, movement) {
    var rotateRate = controller._rotateFactor * controller._rotateRateRangeAdjustment;
    if (rotateRate > controller._maximumRotateRate) {
        rotateRate = controller._maximumRotateRate;
    }
    if (rotateRate < controller._minimumRotateRate) {
        rotateRate = controller._minimumRotateRate;
    }
    var scene = controller._scene;
    var camera = scene.camera;
    var canvas = scene.canvas;
    var phiWindowRatio = (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;
    phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);
    var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4;
    camera.twistRight(deltaPhi);
}
function update2D(controller) {
    var tweens = controller._tweens;
    if (controller._aggregator.anyButtonDown) {
        tweens.removeAll();
    }
    var scene = controller._scene;
    var camera = scene.camera;
    if (!tweens.contains(controller._tween)) {
        if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {
            reactToInput(controller, controller.enableRotate, controller.translateEventTypes, twist2D, controller.inertiaSpin, '_lastInertiaSpinMovement');
            reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, '_lastInertiaZoomMovement');
        } else {
            reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translate2D, controller.inertiaTranslate, '_lastInertiaTranslateMovement');
            reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, '_lastInertiaZoomMovement');
            reactToInput(controller, controller.enableRotate, controller.tiltEventTypes, twist2D, controller.inertiaSpin, '_lastInertiaTiltMovement');
        }
    }
    if (!controller._aggregator.anyButtonDown && (!defined(controller._lastInertiaZoomMovement) || !controller._lastInertiaZoomMovement.active) && (!defined(controller._lastInertiaTranslateMovement) || !controller._lastInertiaTranslateMovement.active) && !tweens.contains(controller._tween)) {
        var tween = camera.createCorrectPositionTween(controller.bounceAnimationTime);
        if (defined(tween)) {
            controller._tween = tweens.add(tween);
        }
    }
    tweens.update();
}
var translateCVStartRay = new Ray();
var translateCVEndRay = new Ray();
var translateCVStartPos = new Cartesian3();
var translateCVEndPos = new Cartesian3();
var translatCVDifference = new Cartesian3();
var translateCVOrigin = new Cartesian3();
var translateCVPlane = new Plane(Cartesian3.ZERO, 0);
var translateCVStartMouse = new Cartesian2();
var translateCVEndMouse = new Cartesian2();
function translateCV(controller, startPosition, movement) {
    if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {
        controller._looking = false;
    }
    if (controller._looking) {
        look3D(controller, startPosition, movement);
        return;
    }
    var scene = controller._scene;
    var camera = scene.camera;
    var startMouse = Cartesian2.clone(movement.startPosition, translateCVStartMouse);
    var endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);
    var startRay = camera.getPickRay(startMouse, translateCVStartRay);
    var origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);
    var normal = Cartesian3.UNIT_X;
    if (defined(controller._globe) && camera.position.z < controller.minimumPickingTerrainHeight) {
        var intersection = controller._globe.pick(startRay, scene, translateCVStartPos);
        if (defined(intersection)) {
            origin.x = intersection.x;
        }
    }
    if (origin.x > camera.position.z) {
        var tempY = startMouse.y;
        startMouse.y = endMouse.y;
        endMouse.y = tempY;
    }
    var plane = Plane.fromPointNormal(origin, normal, translateCVPlane);
    startRay = camera.getPickRay(startMouse, translateCVStartRay);
    var startPlanePos = IntersectionTests.rayPlane(startRay, plane, translateCVStartPos);
    var endRay = camera.getPickRay(endMouse, translateCVEndRay);
    var endPlanePos = IntersectionTests.rayPlane(endRay, plane, translateCVEndPos);
    if (!defined(startPlanePos) || !defined(endPlanePos)) {
        controller._looking = true;
        look3D(controller, startPosition, movement);
        Cartesian2.clone(startPosition, controller._translateMousePosition);
        return;
    }
    var diff = Cartesian3.subtract(startPlanePos, endPlanePos, translatCVDifference);
    var temp = diff.x;
    diff.x = diff.y;
    diff.y = diff.z;
    diff.z = temp;
    var mag = Cartesian3.magnitude(diff);
    if (mag > CesiumMath.EPSILON6) {
        Cartesian3.normalize(diff, diff);
        camera.move(diff, mag);
    }
}
var rotateCVWindowPos = new Cartesian2();
var rotateCVWindowRay = new Ray();
var rotateCVCenter = new Cartesian3();
var rotateCVVerticalCenter = new Cartesian3();
var rotateCVTransform = new Matrix4();
var rotateCVVerticalTransform = new Matrix4();
var rotateCVOrigin = new Cartesian3();
var rotateCVPlane = new Plane(Cartesian3.ZERO, 0);
var rotateCVCartesian3 = new Cartesian3();
var rotateCVCart = new Cartographic();
var rotateCVOldTransform = new Matrix4();
var rotateCVQuaternion = new Quaternion();
var rotateCVMatrix = new Matrix3();
function rotateCV(controller, startPosition, movement) {
    if (defined(movement.angleAndHeight)) {
        movement = movement.angleAndHeight;
    }
    if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {
        controller._tiltCVOffMap = false;
        controller._looking = false;
    }
    if (controller._looking) {
        look3D(controller, startPosition, movement);
        return;
    }
    var scene = controller._scene;
    var camera = scene.camera;
    var maxCoord = controller._maxCoord;
    var onMap = Math.abs(camera.position.x) - maxCoord.x < 0 && Math.abs(camera.position.y) - maxCoord.y < 0;
    if (controller._tiltCVOffMap || !onMap || camera.position.z > controller.minimumPickingTerrainHeight) {
        controller._tiltCVOffMap = true;
        rotateCVOnPlane(controller, startPosition, movement);
    } else {
        rotateCVOnTerrain(controller, startPosition, movement);
    }
}
function rotateCVOnPlane(controller, startPosition, movement) {
    var scene = controller._scene;
    var camera = scene.camera;
    var canvas = scene.canvas;
    var windowPosition = rotateCVWindowPos;
    windowPosition.x = canvas.clientWidth / 2;
    windowPosition.y = canvas.clientHeight / 2;
    var ray = camera.getPickRay(windowPosition, rotateCVWindowRay);
    var normal = Cartesian3.UNIT_X;
    var position = ray.origin;
    var direction = ray.direction;
    var scalar;
    var normalDotDirection = Cartesian3.dot(normal, direction);
    if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {
        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;
    }
    if (!defined(scalar) || scalar <= 0) {
        controller._looking = true;
        look3D(controller, startPosition, movement);
        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);
        return;
    }
    var center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);
    Cartesian3.add(position, center, center);
    var projection = scene.mapProjection;
    var ellipsoid = projection.ellipsoid;
    Cartesian3.fromElements(center.y, center.z, center.x, center);
    var cart = projection.unproject(center, rotateCVCart);
    ellipsoid.cartographicToCartesian(cart, center);
    var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);
    var oldGlobe = controller._globe;
    var oldEllipsoid = controller._ellipsoid;
    controller._globe = undefined;
    controller._ellipsoid = Ellipsoid.UNIT_SPHERE;
    controller._rotateFactor = 1;
    controller._rotateRateRangeAdjustment = 1;
    var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);
    camera.setTransform(transform);
    rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);
    camera.setTransform(oldTransform);
    controller._globe = oldGlobe;
    controller._ellipsoid = oldEllipsoid;
    var radius = oldEllipsoid.maximumRadius;
    controller._rotateFactor = 1 / radius;
    controller._rotateRateRangeAdjustment = radius;
}
function rotateCVOnTerrain(controller, startPosition, movement) {
    var ellipsoid = controller._ellipsoid;
    var scene = controller._scene;
    var camera = scene.camera;
    var center;
    var ray;
    var normal = Cartesian3.UNIT_X;
    if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {
        center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);
    } else {
        ray = camera.getPickRay(startPosition, rotateCVWindowRay);
        if (defined(controller._globe) && camera.position.z < controller.minimumPickingTerrainHeight) {
            center = controller._globe.pick(ray, scene, rotateCVCenter);
        }
        if (!defined(center)) {
            var position = ray.origin;
            var direction = ray.direction;
            var scalar;
            var normalDotDirection = Cartesian3.dot(normal, direction);
            if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {
                scalar = -Cartesian3.dot(normal, position) / normalDotDirection;
            }
            if (!defined(scalar) || scalar <= 0) {
                controller._looking = true;
                look3D(controller, startPosition, movement);
                Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);
                return;
            }
            center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);
            Cartesian3.add(position, center, center);
        }
        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);
        Cartesian3.clone(center, controller._tiltCenter);
    }
    var canvas = scene.canvas;
    var windowPosition = rotateCVWindowPos;
    windowPosition.x = canvas.clientWidth / 2;
    windowPosition.y = controller._tiltCenterMousePosition.y;
    ray = camera.getPickRay(windowPosition, rotateCVWindowRay);
    var origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);
    origin.x = center.x;
    var plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);
    var verticalCenter = IntersectionTests.rayPlane(ray, plane, rotateCVVerticalCenter);
    var projection = camera._projection;
    ellipsoid = projection.ellipsoid;
    Cartesian3.fromElements(center.y, center.z, center.x, center);
    var cart = projection.unproject(center, rotateCVCart);
    ellipsoid.cartographicToCartesian(cart, center);
    var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);
    var verticalTransform;
    if (defined(verticalCenter)) {
        Cartesian3.fromElements(verticalCenter.y, verticalCenter.z, verticalCenter.x, verticalCenter);
        cart = projection.unproject(verticalCenter, rotateCVCart);
        ellipsoid.cartographicToCartesian(cart, verticalCenter);
        verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, ellipsoid, rotateCVVerticalTransform);
    } else {
        verticalTransform = transform;
    }
    var oldGlobe = controller._globe;
    var oldEllipsoid = controller._ellipsoid;
    controller._globe = undefined;
    controller._ellipsoid = Ellipsoid.UNIT_SPHERE;
    controller._rotateFactor = 1;
    controller._rotateRateRangeAdjustment = 1;
    var constrainedAxis = Cartesian3.UNIT_Z;
    var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);
    camera.setTransform(transform);
    var tangent = Cartesian3.cross(Cartesian3.UNIT_Z, Cartesian3.normalize(camera.position, rotateCVCartesian3), rotateCVCartesian3);
    var dot = Cartesian3.dot(camera.right, tangent);
    rotate3D(controller, startPosition, movement, constrainedAxis, false, true);
    camera.setTransform(verticalTransform);
    if (dot < 0) {
        if (movement.startPosition.y > movement.endPosition.y) {
            constrainedAxis = undefined;
        }
        var oldConstrainedAxis = camera.constrainedAxis;
        camera.constrainedAxis = undefined;
        rotate3D(controller, startPosition, movement, constrainedAxis, true, false);
        camera.constrainedAxis = oldConstrainedAxis;
    } else {
        rotate3D(controller, startPosition, movement, constrainedAxis, true, false);
    }
    if (defined(camera.constrainedAxis)) {
        var right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);
        if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
            if (Cartesian3.dot(right, camera.right) < 0) {
                Cartesian3.negate(right, right);
            }
            Cartesian3.cross(right, camera.direction, camera.up);
            Cartesian3.cross(camera.direction, camera.up, camera.right);
            Cartesian3.normalize(camera.up, camera.up);
            Cartesian3.normalize(camera.right, camera.right);
        }
    }
    camera.setTransform(oldTransform);
    controller._globe = oldGlobe;
    controller._ellipsoid = oldEllipsoid;
    var radius = oldEllipsoid.maximumRadius;
    controller._rotateFactor = 1 / radius;
    controller._rotateRateRangeAdjustment = radius;
    var originalPosition = Cartesian3.clone(camera.positionWC, rotateCVCartesian3);
    adjustHeightForTerrain(controller);
    if (!Cartesian3.equals(camera.positionWC, originalPosition)) {
        camera.setTransform(verticalTransform);
        camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);
        var magSqrd = Cartesian3.magnitudeSquared(originalPosition);
        if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {
            Cartesian3.normalize(camera.position, camera.position);
            Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);
        }
        var angle = Cartesian3.angleBetween(originalPosition, camera.position);
        var axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);
        Cartesian3.normalize(axis, axis);
        var quaternion = Quaternion.fromAxisAngle(axis, angle, rotateCVQuaternion);
        var rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);
        Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);
        Matrix3.multiplyByVector(rotation, camera.up, camera.up);
        Cartesian3.cross(camera.direction, camera.up, camera.right);
        Cartesian3.cross(camera.right, camera.direction, camera.up);
        camera.setTransform(oldTransform);
    }
}
var zoomCVWindowPos = new Cartesian2();
var zoomCVWindowRay = new Ray();
var zoomCVIntersection = new Cartesian3();
function zoomCV(controller, startPosition, movement) {
    if (defined(movement.distance)) {
        movement = movement.distance;
    }
    var scene = controller._scene;
    var camera = scene.camera;
    var canvas = scene.canvas;
    var windowPosition = zoomCVWindowPos;
    windowPosition.x = canvas.clientWidth / 2;
    windowPosition.y = canvas.clientHeight / 2;
    var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);
    var intersection;
    if (defined(controller._globe) && camera.position.z < controller.minimumPickingTerrainHeight) {
        intersection = controller._globe.pick(ray, scene, zoomCVIntersection);
    }
    var distance;
    if (defined(intersection)) {
        distance = Cartesian3.distance(ray.origin, intersection);
    } else {
        var normal = Cartesian3.UNIT_X;
        var position = ray.origin;
        var direction = ray.direction;
        distance = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);
    }
    handleZoom(controller, startPosition, movement, controller._zoomFactor, distance);
}
function updateCV(controller) {
    var scene = controller._scene;
    var camera = scene.camera;
    if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {
        reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, rotate3D, controller.inertiaSpin, '_lastInertiaSpinMovement');
        reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, '_lastInertiaZoomMovement');
    } else {
        var tweens = controller._tweens;
        if (controller._aggregator.anyButtonDown) {
            tweens.removeAll();
        }
        reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, rotateCV, controller.inertiaSpin, '_lastInertiaTiltMovement');
        reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translateCV, controller.inertiaTranslate, '_lastInertiaTranslateMovement');
        reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoomCV, controller.inertiaZoom, '_lastInertiaZoomMovement');
        reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);
        if (!controller._aggregator.anyButtonDown && (!defined(controller._lastInertiaZoomMovement) || !controller._lastInertiaZoomMovement.active) && (!defined(controller._lastInertiaTranslateMovement) || !controller._lastInertiaTranslateMovement.active) && !tweens.contains(controller._tween)) {
            var tween = camera.createCorrectPositionTween(controller.bounceAnimationTime);
            if (defined(tween)) {
                controller._tween = tweens.add(tween);
            }
        }
        tweens.update();
    }
}
var spin3DPick = new Cartesian3();
var scratchStartRay = new Ray();
var scratchCartographic = new Cartographic();
var scratchMousePos = new Cartesian3();
var scratchRadii = new Cartesian3();
var scratchEllipsoid = new Ellipsoid();
var scratchLookUp = new Cartesian3();
function spin3D(controller, startPosition, movement) {
    var scene = controller._scene;
    var camera = scene.camera;
    if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {
        rotate3D(controller, startPosition, movement);
        return;
    }
    var magnitude;
    var radii;
    var ellipsoid;
    var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);
    if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {
        if (controller._looking) {
            look3D(controller, startPosition, movement, up);
        } else if (controller._rotating) {
            rotate3D(controller, startPosition, movement);
        } else {
            magnitude = Cartesian3.magnitude(controller._rotateStartPosition);
            radii = scratchRadii;
            radii.x = radii.y = radii.z = magnitude;
            ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);
            pan3D(controller, startPosition, movement, ellipsoid);
        }
        return;
    } else {
        controller._looking = false;
        controller._rotating = false;
    }
    var height = controller._ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic).height;
    if (defined(controller._globe) && height < controller.minimumPickingTerrainHeight) {
        var startRay = camera.getPickRay(movement.startPosition, scratchStartRay);
        var mousePos = controller._globe.pick(startRay, scene, scratchMousePos);
        if (defined(mousePos)) {
            magnitude = Cartesian3.magnitude(mousePos);
            radii = scratchRadii;
            radii.x = radii.y = radii.z = magnitude;
            ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);
            pan3D(controller, startPosition, movement, ellipsoid);
            Cartesian3.clone(mousePos, controller._rotateStartPosition);
        } else {
            controller._looking = true;
            look3D(controller, startPosition, movement, up);
        }
    } else if (defined(camera.pickEllipsoid(movement.startPosition, controller._ellipsoid, spin3DPick))) {
        pan3D(controller, startPosition, movement, controller._ellipsoid);
        Cartesian3.clone(spin3DPick, controller._rotateStartPosition);
    } else if (height > controller.minimumTrackBallHeight) {
        controller._rotating = true;
        rotate3D(controller, startPosition, movement);
    } else {
        controller._looking = true;
        look3D(controller, startPosition, movement, up);
    }
    Cartesian2.clone(startPosition, controller._rotateMousePosition);
}
function rotate3D(controller, startPosition, movement, constrainedAxis, rotateOnlyVertical, rotateOnlyHorizontal) {
    rotateOnlyVertical = defaultValue(rotateOnlyVertical, false);
    rotateOnlyHorizontal = defaultValue(rotateOnlyHorizontal, false);
    var scene = controller._scene;
    var camera = scene.camera;
    var canvas = scene.canvas;
    var oldAxis = camera.constrainedAxis;
    if (defined(constrainedAxis)) {
        camera.constrainedAxis = constrainedAxis;
    }
    var rho = Cartesian3.magnitude(camera.position);
    var rotateRate = controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);
    if (rotateRate > controller._maximumRotateRate) {
        rotateRate = controller._maximumRotateRate;
    }
    if (rotateRate < controller._minimumRotateRate) {
        rotateRate = controller._minimumRotateRate;
    }
    var phiWindowRatio = (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;
    var thetaWindowRatio = (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;
    phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);
    thetaWindowRatio = Math.min(thetaWindowRatio, controller.maximumMovementRatio);
    var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2;
    var deltaTheta = rotateRate * thetaWindowRatio * Math.PI;
    if (!rotateOnlyVertical) {
        camera.rotateRight(deltaPhi);
    }
    if (!rotateOnlyHorizontal) {
        camera.rotateUp(deltaTheta);
    }
    camera.constrainedAxis = oldAxis;
}
var pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);
var pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);
var pan3DTemp0 = new Cartesian3();
var pan3DTemp1 = new Cartesian3();
var pan3DTemp2 = new Cartesian3();
var pan3DTemp3 = new Cartesian3();
var pan3DStartMousePosition = new Cartesian2();
var pan3DEndMousePosition = new Cartesian2();
function pan3D(controller, startPosition, movement, ellipsoid) {
    var scene = controller._scene;
    var camera = scene.camera;
    var cameraPosMag = Cartesian3.magnitude(camera.position);
    var startMousePosition = Cartesian2.clone(movement.startPosition, pan3DStartMousePosition);
    var endMousePosition = Cartesian2.clone(movement.endPosition, pan3DEndMousePosition);
    if (cameraPosMag < ellipsoid.maximumRadius) {
        startMousePosition.y = endMousePosition.y;
        endMousePosition.y = movement.startPosition.y;
        var magnitude = cameraPosMag + (ellipsoid.maximumRadius - cameraPosMag) * 2;
        var radii = scratchRadii;
        radii.x = radii.y = radii.z = magnitude;
        ellipsoid = Ellipsoid.fromCartesian3(radii, ellipsoid);
    }
    var p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);
    var p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);
    if (!defined(p0) || !defined(p1)) {
        controller._rotating = true;
        rotate3D(controller, startPosition, movement);
        return;
    }
    p0 = camera.worldToCameraCoordinates(p0, p0);
    p1 = camera.worldToCameraCoordinates(p1, p1);
    if (!defined(camera.constrainedAxis)) {
        Cartesian3.normalize(p0, p0);
        Cartesian3.normalize(p1, p1);
        var dot = Cartesian3.dot(p0, p1);
        var axis = Cartesian3.cross(p0, p1, pan3DTemp0);
        if (dot < 1 && !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)) {
            var angle = Math.acos(dot);
            camera.rotate(axis, angle);
        }
    } else {
        var basis0 = camera.constrainedAxis;
        var basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);
        Cartesian3.cross(basis1, basis0, basis1);
        Cartesian3.normalize(basis1, basis1);
        var basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);
        var startRho = Cartesian3.magnitude(p0);
        var startDot = Cartesian3.dot(basis0, p0);
        var startTheta = Math.acos(startDot / startRho);
        var startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);
        Cartesian3.subtract(p0, startRej, startRej);
        Cartesian3.normalize(startRej, startRej);
        var endRho = Cartesian3.magnitude(p1);
        var endDot = Cartesian3.dot(basis0, p1);
        var endTheta = Math.acos(endDot / endRho);
        var endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);
        Cartesian3.subtract(p1, endRej, endRej);
        Cartesian3.normalize(endRej, endRej);
        var startPhi = Math.acos(Cartesian3.dot(startRej, basis1));
        if (Cartesian3.dot(startRej, basis2) < 0) {
            startPhi = CesiumMath.TWO_PI - startPhi;
        }
        var endPhi = Math.acos(Cartesian3.dot(endRej, basis1));
        if (Cartesian3.dot(endRej, basis2) < 0) {
            endPhi = CesiumMath.TWO_PI - endPhi;
        }
        var deltaPhi = startPhi - endPhi;
        var east;
        if (Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)) {
            east = camera.right;
        } else {
            east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);
        }
        var planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);
        var side0 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p0, basis0, pan3DTemp1));
        var side1 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p1, basis0, pan3DTemp1));
        var deltaTheta;
        if (side0 > 0 && side1 > 0) {
            deltaTheta = endTheta - startTheta;
        } else if (side0 > 0 && side1 <= 0) {
            if (Cartesian3.dot(camera.position, basis0) > 0) {
                deltaTheta = -startTheta - endTheta;
            } else {
                deltaTheta = startTheta + endTheta;
            }
        } else {
            deltaTheta = startTheta - endTheta;
        }
        camera.rotateRight(deltaPhi);
        camera.rotateUp(deltaTheta);
    }
}
var zoom3DUnitPosition = new Cartesian3();
var zoom3DCartographic = new Cartographic();
function zoom3D(controller, startPosition, movement) {
    if (defined(movement.distance)) {
        movement = movement.distance;
    }
    var ellipsoid = controller._ellipsoid;
    var scene = controller._scene;
    var camera = scene.camera;
    var canvas = scene.canvas;
    var windowPosition = zoomCVWindowPos;
    windowPosition.x = canvas.clientWidth / 2;
    windowPosition.y = canvas.clientHeight / 2;
    var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);
    var intersection;
    var height = ellipsoid.cartesianToCartographic(camera.position, zoom3DCartographic).height;
    if (defined(controller._globe) && height < controller.minimumPickingTerrainHeight) {
        intersection = controller._globe.pick(ray, scene, zoomCVIntersection);
    }
    var distance;
    if (defined(intersection)) {
        distance = Cartesian3.distance(ray.origin, intersection);
    } else {
        distance = height;
    }
    var unitPosition = Cartesian3.normalize(camera.position, zoom3DUnitPosition);
    handleZoom(controller, startPosition, movement, controller._zoomFactor, distance, Cartesian3.dot(unitPosition, camera.direction));
}
var tilt3DWindowPos = new Cartesian2();
var tilt3DRay = new Ray();
var tilt3DCenter = new Cartesian3();
var tilt3DVerticalCenter = new Cartesian3();
var tilt3DTransform = new Matrix4();
var tilt3DVerticalTransform = new Matrix4();
var tilt3DCartesian3 = new Cartesian3();
var tilt3DOldTransform = new Matrix4();
var tilt3DQuaternion = new Quaternion();
var tilt3DMatrix = new Matrix3();
var tilt3DCart = new Cartographic();
var tilt3DLookUp = new Cartesian3();
function tilt3D(controller, startPosition, movement) {
    var scene = controller._scene;
    var camera = scene.camera;
    if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {
        return;
    }
    if (defined(movement.angleAndHeight)) {
        movement = movement.angleAndHeight;
    }
    if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {
        controller._tiltOnEllipsoid = false;
        controller._looking = false;
    }
    if (controller._looking) {
        var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);
        look3D(controller, startPosition, movement, up);
        return;
    }
    var ellipsoid = controller._ellipsoid;
    var cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);
    if (controller._tiltOnEllipsoid || cartographic.height > controller.minimumCollisionTerrainHeight) {
        controller._tiltOnEllipsoid = true;
        tilt3DOnEllipsoid(controller, startPosition, movement);
    } else {
        tilt3DOnTerrain(controller, startPosition, movement);
    }
}
var tilt3DOnEllipsoidCartographic = new Cartographic();
function tilt3DOnEllipsoid(controller, startPosition, movement) {
    var ellipsoid = controller._ellipsoid;
    var scene = controller._scene;
    var camera = scene.camera;
    var minHeight = controller.minimumZoomDistance * 0.25;
    var height = ellipsoid.cartesianToCartographic(camera.positionWC, tilt3DOnEllipsoidCartographic).height;
    if (height - minHeight - 1 < CesiumMath.EPSILON3 && movement.endPosition.y - movement.startPosition.y < 0) {
        return;
    }
    var canvas = scene.canvas;
    var windowPosition = tilt3DWindowPos;
    windowPosition.x = canvas.clientWidth / 2;
    windowPosition.y = canvas.clientHeight / 2;
    var ray = camera.getPickRay(windowPosition, tilt3DRay);
    var center;
    var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);
    if (defined(intersection)) {
        center = Ray.getPoint(ray, intersection.start, tilt3DCenter);
    } else if (height > controller.minimumTrackBallHeight) {
        var grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(ray, ellipsoid);
        if (!defined(grazingAltitudeLocation)) {
            return;
        }
        var grazingAltitudeCart = ellipsoid.cartesianToCartographic(grazingAltitudeLocation, tilt3DCart);
        grazingAltitudeCart.height = 0;
        center = ellipsoid.cartographicToCartesian(grazingAltitudeCart, tilt3DCenter);
    } else {
        controller._looking = true;
        var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);
        look3D(controller, startPosition, movement, up);
        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);
        return;
    }
    var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);
    var oldGlobe = controller._globe;
    var oldEllipsoid = controller._ellipsoid;
    controller._globe = undefined;
    controller._ellipsoid = Ellipsoid.UNIT_SPHERE;
    controller._rotateFactor = 1;
    controller._rotateRateRangeAdjustment = 1;
    var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);
    camera.setTransform(transform);
    rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);
    camera.setTransform(oldTransform);
    controller._globe = oldGlobe;
    controller._ellipsoid = oldEllipsoid;
    var radius = oldEllipsoid.maximumRadius;
    controller._rotateFactor = 1 / radius;
    controller._rotateRateRangeAdjustment = radius;
}
function tilt3DOnTerrain(controller, startPosition, movement) {
    var ellipsoid = controller._ellipsoid;
    var scene = controller._scene;
    var camera = scene.camera;
    var center;
    var ray;
    var intersection;
    if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {
        center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);
    } else {
        ray = camera.getPickRay(startPosition, tilt3DRay);
        if (defined(controller._globe)) {
            center = controller._globe.pick(ray, scene, tilt3DCenter);
        }
        if (!defined(center)) {
            intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);
            if (!defined(intersection)) {
                var cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);
                if (cartographic.height <= controller.minimumTrackBallHeight) {
                    controller._looking = true;
                    var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);
                    look3D(controller, startPosition, movement, up);
                    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);
                }
                return;
            }
            center = Ray.getPoint(ray, intersection.start, tilt3DCenter);
        }
        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);
        Cartesian3.clone(center, controller._tiltCenter);
    }
    var canvas = scene.canvas;
    var windowPosition = tilt3DWindowPos;
    windowPosition.x = canvas.clientWidth / 2;
    windowPosition.y = controller._tiltCenterMousePosition.y;
    ray = camera.getPickRay(windowPosition, tilt3DRay);
    var mag = Cartesian3.magnitude(center);
    var radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);
    var newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);
    intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);
    if (!defined(intersection)) {
        return;
    }
    var t = Cartesian3.magnitude(ray.origin) > mag ? intersection.start : intersection.stop;
    var verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);
    var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);
    var verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, newEllipsoid, tilt3DVerticalTransform);
    var oldGlobe = controller._globe;
    var oldEllipsoid = controller._ellipsoid;
    controller._globe = undefined;
    controller._ellipsoid = Ellipsoid.UNIT_SPHERE;
    controller._rotateFactor = 1;
    controller._rotateRateRangeAdjustment = 1;
    var constrainedAxis = Cartesian3.UNIT_Z;
    var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);
    camera.setTransform(transform);
    var tangent = Cartesian3.cross(verticalCenter, camera.positionWC, tilt3DCartesian3);
    var dot = Cartesian3.dot(camera.rightWC, tangent);
    rotate3D(controller, startPosition, movement, constrainedAxis, false, true);
    camera.setTransform(verticalTransform);
    if (dot < 0) {
        if (movement.startPosition.y > movement.endPosition.y) {
            constrainedAxis = undefined;
        }
        var oldConstrainedAxis = camera.constrainedAxis;
        camera.constrainedAxis = undefined;
        rotate3D(controller, startPosition, movement, constrainedAxis, true, false);
        camera.constrainedAxis = oldConstrainedAxis;
    } else {
        rotate3D(controller, startPosition, movement, constrainedAxis, true, false);
    }
    if (defined(camera.constrainedAxis)) {
        var right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);
        if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
            if (Cartesian3.dot(right, camera.right) < 0) {
                Cartesian3.negate(right, right);
            }
            Cartesian3.cross(right, camera.direction, camera.up);
            Cartesian3.cross(camera.direction, camera.up, camera.right);
            Cartesian3.normalize(camera.up, camera.up);
            Cartesian3.normalize(camera.right, camera.right);
        }
    }
    camera.setTransform(oldTransform);
    controller._globe = oldGlobe;
    controller._ellipsoid = oldEllipsoid;
    var radius = oldEllipsoid.maximumRadius;
    controller._rotateFactor = 1 / radius;
    controller._rotateRateRangeAdjustment = radius;
    var originalPosition = Cartesian3.clone(camera.positionWC, tilt3DCartesian3);
    adjustHeightForTerrain(controller);
    if (!Cartesian3.equals(camera.positionWC, originalPosition)) {
        camera.setTransform(verticalTransform);
        camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);
        var magSqrd = Cartesian3.magnitudeSquared(originalPosition);
        if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {
            Cartesian3.normalize(camera.position, camera.position);
            Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);
        }
        var angle = Cartesian3.angleBetween(originalPosition, camera.position);
        var axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);
        Cartesian3.normalize(axis, axis);
        var quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);
        var rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);
        Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);
        Matrix3.multiplyByVector(rotation, camera.up, camera.up);
        Cartesian3.cross(camera.direction, camera.up, camera.right);
        Cartesian3.cross(camera.right, camera.direction, camera.up);
        camera.setTransform(oldTransform);
    }
}
var look3DStartPos = new Cartesian2();
var look3DEndPos = new Cartesian2();
var look3DStartRay = new Ray();
var look3DEndRay = new Ray();
var look3DNegativeRot = new Cartesian3();
var look3DTan = new Cartesian3();
function look3D(controller, startPosition, movement, rotationAxis) {
    var scene = controller._scene;
    var camera = scene.camera;
    var startPos = look3DStartPos;
    startPos.x = movement.startPosition.x;
    startPos.y = 0;
    var endPos = look3DEndPos;
    endPos.x = movement.endPosition.x;
    endPos.y = 0;
    var start = camera.getPickRay(startPos, look3DStartRay).direction;
    var end = camera.getPickRay(endPos, look3DEndRay).direction;
    var angle = 0;
    var dot = Cartesian3.dot(start, end);
    if (dot < 1) {
        angle = Math.acos(dot);
    }
    angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;
    var horizontalRotationAxis = controller._horizontalRotationAxis;
    if (defined(rotationAxis)) {
        camera.look(rotationAxis, -angle);
    } else if (defined(horizontalRotationAxis)) {
        camera.look(horizontalRotationAxis, -angle);
    } else {
        camera.lookLeft(angle);
    }
    startPos.x = 0;
    startPos.y = movement.startPosition.y;
    endPos.x = 0;
    endPos.y = movement.endPosition.y;
    start = camera.getPickRay(startPos, look3DStartRay).direction;
    end = camera.getPickRay(endPos, look3DEndRay).direction;
    angle = 0;
    dot = Cartesian3.dot(start, end);
    if (dot < 1) {
        angle = Math.acos(dot);
    }
    angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;
    rotationAxis = defaultValue(rotationAxis, horizontalRotationAxis);
    if (defined(rotationAxis)) {
        var direction = camera.direction;
        var negativeRotationAxis = Cartesian3.negate(rotationAxis, look3DNegativeRot);
        var northParallel = Cartesian3.equalsEpsilon(direction, rotationAxis, CesiumMath.EPSILON2);
        var southParallel = Cartesian3.equalsEpsilon(direction, negativeRotationAxis, CesiumMath.EPSILON2);
        if (!northParallel && !southParallel) {
            dot = Cartesian3.dot(direction, rotationAxis);
            var angleToAxis = CesiumMath.acosClamped(dot);
            if (angle > 0 && angle > angleToAxis) {
                angle = angleToAxis - CesiumMath.EPSILON4;
            }
            dot = Cartesian3.dot(direction, negativeRotationAxis);
            angleToAxis = CesiumMath.acosClamped(dot);
            if (angle < 0 && -angle > angleToAxis) {
                angle = -angleToAxis + CesiumMath.EPSILON4;
            }
            var tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);
            camera.look(tangent, angle);
        } else if (northParallel && angle < 0 || southParallel && angle > 0) {
            camera.look(camera.right, -angle);
        }
    } else {
        camera.lookUp(angle);
    }
}
function update3D(controller) {
    reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, spin3D, controller.inertiaSpin, '_lastInertiaSpinMovement');
    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, '_lastInertiaZoomMovement');
    reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, tilt3D, controller.inertiaSpin, '_lastInertiaTiltMovement');
    reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);
}
var scratchAdjustHeightCartographic = new Cartographic();
function adjustHeightForTerrain(controller) {
    var scene = controller._scene;
    var mode = scene.mode;
    var globe = controller._globe;
    if (!defined(globe) || mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {
        return;
    }
    var camera = scene.camera;
    var ellipsoid = controller._ellipsoid;
    var projection = scene.mapProjection;
    var cartographic = scratchAdjustHeightCartographic;
    if (mode === SceneMode.SCENE3D) {
        ellipsoid.cartesianToCartographic(camera.position, cartographic);
    } else {
        projection.unproject(camera.position, cartographic);
    }
    if (cartographic.height > controller.minimumCollisionTerrainHeight) {
        return;
    }
    var height = globe.getHeight(cartographic);
    if (!defined(height)) {
        return;
    }
    height += controller.minimumZoomDistance;
    if (cartographic.height >= height) {
        return;
    }
    cartographic.height = height;
    if (mode === SceneMode.SCENE3D) {
        ellipsoid.cartographicToCartesian(cartographic, camera.position);
    } else {
        projection.project(cartographic, camera.position);
    }
}
ScreenSpaceCameraController.prototype.update = function () {
    if (!Matrix4.equals(this._scene.camera.transform, Matrix4.IDENTITY)) {
        this._globe = undefined;
        this._ellipsoid = Ellipsoid.UNIT_SPHERE;
    } else {
        this._globe = this._scene.globe;
        this._ellipsoid = defined(this._globe) ? this._globe.ellipsoid : this._scene.mapProjection.ellipsoid;
    }
    var radius = this._ellipsoid.maximumRadius;
    this._rotateFactor = 1 / radius;
    this._rotateRateRangeAdjustment = radius;
    var scene = this._scene;
    var mode = scene.mode;
    if (mode === SceneMode.SCENE2D) {
        update2D(this);
    } else if (mode === SceneMode.COLUMBUS_VIEW) {
        this._horizontalRotationAxis = Cartesian3.UNIT_Z;
        updateCV(this);
    } else if (mode === SceneMode.SCENE3D) {
        this._horizontalRotationAxis = undefined;
        update3D(this);
    }
    adjustHeightForTerrain(this);
    this._aggregator.reset();
};
ScreenSpaceCameraController.prototype.isDestroyed = function () {
    return false;
};
ScreenSpaceCameraController.prototype.destroy = function () {
    this._tweens.removeAll();
    this._spinHandler = this._spinHandler && this._spinHandler.destroy();
    this._translateHandler = this._translateHandler && this._translateHandler.destroy();
    this._lookHandler = this._lookHandler && this._lookHandler.destroy();
    this._rotateHandler = this._rotateHandler && this._rotateHandler.destroy();
    this._zoomHandler = this._zoomHandler && this._zoomHandler.destroy();
    this._zoomWheelHandler = this._zoomWheelHandler && this._zoomWheelHandler.destroy();
    this._pinchHandler = this._pinchHandler && this._pinchHandler.destroy();
    return destroyObject(this);
};
module.exports = ScreenSpaceCameraController;
},{"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Cartographic":104,"../Core/DeveloperError":123,"../Core/Ellipsoid":130,"../Core/IntersectionTests":164,"../Core/KeyboardEventModifier":169,"../Core/Math":174,"../Core/Matrix3":176,"../Core/Matrix4":177,"../Core/Plane":182,"../Core/Quaternion":197,"../Core/Ray":200,"../Core/Transforms":226,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"../Core/isArray":253,"./CameraEventAggregator":376,"./CameraEventType":377,"./SceneMode":438,"./TweenCollection":453}],442:[function(require,module,exports){
var Credit = require('../Core/Credit'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeographicTilingScheme = require('../Core/GeographicTilingScheme'), loadImage = require('../Core/loadImage'), Rectangle = require('../Core/Rectangle'), TileProviderError = require('../Core/TileProviderError'), when = require('../ThirdParty/when');
'use strict';
var SingleTileImageryProvider = function (options) {
    options = defaultValue(options, {});
    var url = options.url;
    if (!defined(url)) {
        throw new DeveloperError('url is required.');
    }
    this._url = url;
    var proxy = options.proxy;
    this._proxy = proxy;
    var rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);
    var tilingScheme = new GeographicTilingScheme({
            rectangle: rectangle,
            numberOfLevelZeroTilesX: 1,
            numberOfLevelZeroTilesY: 1
        });
    this._tilingScheme = tilingScheme;
    this._image = undefined;
    this._texture = undefined;
    this._tileWidth = 0;
    this._tileHeight = 0;
    this._errorEvent = new Event();
    this._ready = false;
    var imageUrl = url;
    if (defined(proxy)) {
        imageUrl = proxy.getURL(imageUrl);
    }
    var credit = options.credit;
    if (typeof credit === 'string') {
        credit = new Credit(credit);
    }
    this._credit = credit;
    var that = this;
    var error;
    function success(image) {
        that._image = image;
        that._tileWidth = image.width;
        that._tileHeight = image.height;
        that._ready = true;
        TileProviderError.handleSuccess(that._errorEvent);
    }
    function failure(e) {
        var message = 'Failed to load image ' + imageUrl + '.';
        error = TileProviderError.handleError(error, that, that._errorEvent, message, 0, 0, 0, doRequest);
    }
    function doRequest() {
        when(loadImage(imageUrl), success, failure);
    }
    doRequest();
};
defineProperties(SingleTileImageryProvider.prototype, {
    url: {
        get: function () {
            return this._url;
        }
    },
    proxy: {
        get: function () {
            return this._proxy;
        }
    },
    tileWidth: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            return this._tileWidth;
        }
    },
    tileHeight: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            return this._tileHeight;
        }
    },
    maximumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            return 0;
        }
    },
    minimumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            return 0;
        }
    },
    tilingScheme: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            return this._tilingScheme;
        }
    },
    rectangle: {
        get: function () {
            return this._tilingScheme.rectangle;
        }
    },
    tileDiscardPolicy: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            return undefined;
        }
    },
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    credit: {
        get: function () {
            return this._credit;
        }
    },
    hasAlphaChannel: {
        get: function () {
            return true;
        }
    }
});
SingleTileImageryProvider.prototype.getTileCredits = function (x, y, level) {
    return undefined;
};
SingleTileImageryProvider.prototype.requestImage = function (x, y, level) {
    if (!this._ready) {
        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }
    return this._image;
};
SingleTileImageryProvider.prototype.pickFeatures = function () {
    return undefined;
};
module.exports = SingleTileImageryProvider;
},{"../Core/Credit":118,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeographicTilingScheme":144,"../Core/Rectangle":201,"../Core/TileProviderError":220,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/loadImage":259,"../ThirdParty/when":596}],443:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), Ellipsoid = require('../Core/Ellipsoid'), EllipsoidGeometry = require('../Core/EllipsoidGeometry'), GeometryPipeline = require('../Core/GeometryPipeline'), VertexFormat = require('../Core/VertexFormat'), BufferUsage = require('../Renderer/BufferUsage'), DrawCommand = require('../Renderer/DrawCommand'), ShaderSource = require('../Renderer/ShaderSource'), SkyAtmosphereFS = require('../Shaders/SkyAtmosphereFS'), SkyAtmosphereVS = require('../Shaders/SkyAtmosphereVS'), BlendingState = require('./BlendingState'), CullFace = require('./CullFace'), SceneMode = require('./SceneMode');
'use strict';
var SkyAtmosphere = function (ellipsoid) {
    ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
    this.show = true;
    this._ellipsoid = ellipsoid;
    this._command = new DrawCommand({ owner: this });
    this._spSkyFromSpace = undefined;
    this._spSkyFromAtmosphere = undefined;
    this._fCameraHeight = undefined;
    this._fCameraHeight2 = undefined;
    this._outerRadius = Cartesian3.maximumComponent(Cartesian3.multiplyByScalar(ellipsoid.radii, 1.025, new Cartesian3()));
    var innerRadius = ellipsoid.maximumRadius;
    var rayleighScaleDepth = 0.25;
    var that = this;
    this._command.uniformMap = {
        fCameraHeight: function () {
            return that._fCameraHeight;
        },
        fCameraHeight2: function () {
            return that._fCameraHeight2;
        },
        fOuterRadius: function () {
            return that._outerRadius;
        },
        fOuterRadius2: function () {
            return that._outerRadius * that._outerRadius;
        },
        fInnerRadius: function () {
            return innerRadius;
        },
        fScale: function () {
            return 1 / (that._outerRadius - innerRadius);
        },
        fScaleDepth: function () {
            return rayleighScaleDepth;
        },
        fScaleOverScaleDepth: function () {
            return 1 / (that._outerRadius - innerRadius) / rayleighScaleDepth;
        }
    };
};
defineProperties(SkyAtmosphere.prototype, {
    ellipsoid: {
        get: function () {
            return this._ellipsoid;
        }
    }
});
SkyAtmosphere.prototype.update = function (context, frameState) {
    if (!this.show) {
        return undefined;
    }
    if (frameState.mode !== SceneMode.SCENE3D && frameState.mode !== SceneMode.MORPHING) {
        return undefined;
    }
    if (!frameState.passes.render) {
        return undefined;
    }
    var command = this._command;
    if (!defined(command.vertexArray)) {
        var geometry = EllipsoidGeometry.createGeometry(new EllipsoidGeometry({
                radii: Cartesian3.multiplyByScalar(this._ellipsoid.radii, 1.025, new Cartesian3()),
                slicePartitions: 256,
                stackPartitions: 256,
                vertexFormat: VertexFormat.POSITION_ONLY
            }));
        command.vertexArray = context.createVertexArrayFromGeometry({
            geometry: geometry,
            attributeLocations: GeometryPipeline.createAttributeLocations(geometry),
            bufferUsage: BufferUsage.STATIC_DRAW
        });
        command.renderState = context.createRenderState({
            cull: {
                enabled: true,
                face: CullFace.FRONT
            },
            blending: BlendingState.ALPHA_BLEND
        });
        var vs = new ShaderSource({
                defines: ['SKY_FROM_SPACE'],
                sources: [SkyAtmosphereVS]
            });
        this._spSkyFromSpace = context.createShaderProgram(vs, SkyAtmosphereFS);
        vs = new ShaderSource({
            defines: ['SKY_FROM_ATMOSPHERE'],
            sources: [SkyAtmosphereVS]
        });
        this._spSkyFromAtmosphere = context.createShaderProgram(vs, SkyAtmosphereFS);
    }
    var cameraPosition = frameState.camera.positionWC;
    this._fCameraHeight2 = Cartesian3.magnitudeSquared(cameraPosition);
    this._fCameraHeight = Math.sqrt(this._fCameraHeight2);
    if (this._fCameraHeight > this._outerRadius) {
        command.shaderProgram = this._spSkyFromSpace;
    } else {
        command.shaderProgram = this._spSkyFromAtmosphere;
    }
    return command;
};
SkyAtmosphere.prototype.isDestroyed = function () {
    return false;
};
SkyAtmosphere.prototype.destroy = function () {
    var command = this._command;
    command.vertexArray = command.vertexArray && command.vertexArray.destroy();
    this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.destroy();
    this._spSkyFromAtmosphere = this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.destroy();
    return destroyObject(this);
};
module.exports = SkyAtmosphere;
},{"../Core/Cartesian3":102,"../Core/Ellipsoid":130,"../Core/EllipsoidGeometry":132,"../Core/GeometryPipeline":150,"../Core/VertexFormat":228,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/BufferUsage":339,"../Renderer/DrawCommand":344,"../Renderer/ShaderSource":355,"../Shaders/SkyAtmosphereFS":578,"../Shaders/SkyAtmosphereVS":579,"./BlendingState":374,"./CullFace":380,"./SceneMode":438}],444:[function(require,module,exports){
var BoxGeometry = require('../Core/BoxGeometry'), Cartesian3 = require('../Core/Cartesian3'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), GeometryPipeline = require('../Core/GeometryPipeline'), Matrix4 = require('../Core/Matrix4'), VertexFormat = require('../Core/VertexFormat'), BufferUsage = require('../Renderer/BufferUsage'), DrawCommand = require('../Renderer/DrawCommand'), loadCubeMap = require('../Renderer/loadCubeMap'), SkyBoxFS = require('../Shaders/SkyBoxFS'), SkyBoxVS = require('../Shaders/SkyBoxVS'), BlendingState = require('./BlendingState'), SceneMode = require('./SceneMode');
'use strict';
var SkyBox = function (options) {
    this.sources = options.sources;
    this._sources = undefined;
    this.show = defaultValue(options.show, true);
    this._command = new DrawCommand({
        modelMatrix: Matrix4.clone(Matrix4.IDENTITY),
        owner: this
    });
    this._cubeMap = undefined;
};
SkyBox.prototype.update = function (context, frameState) {
    if (!this.show) {
        return undefined;
    }
    if (frameState.mode !== SceneMode.SCENE3D && frameState.mode !== SceneMode.MORPHING) {
        return undefined;
    }
    if (!frameState.passes.render) {
        return undefined;
    }
    if (this._sources !== this.sources) {
        this._sources = this.sources;
        var sources = this.sources;
        if (!defined(sources.positiveX) || !defined(sources.negativeX) || !defined(sources.positiveY) || !defined(sources.negativeY) || !defined(sources.positiveZ) || !defined(sources.negativeZ)) {
            throw new DeveloperError('this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.');
        }
        if (typeof sources.positiveX !== typeof sources.negativeX || typeof sources.positiveX !== typeof sources.positiveY || typeof sources.positiveX !== typeof sources.negativeY || typeof sources.positiveX !== typeof sources.positiveZ || typeof sources.positiveX !== typeof sources.negativeZ) {
            throw new DeveloperError('this.sources properties must all be the same type.');
        }
        if (typeof sources.positiveX === 'string') {
            loadCubeMap(context, this._sources).then(function (cubeMap) {
                that._cubeMap = that._cubeMap && that._cubeMap.destroy();
                that._cubeMap = cubeMap;
            });
        } else {
            this._cubeMap = this._cubeMap && this._cubeMap.destroy();
            this._cubeMap = context.createCubeMap({ source: sources });
        }
    }
    var command = this._command;
    if (!defined(command.vertexArray)) {
        var that = this;
        command.uniformMap = {
            u_cubeMap: function () {
                return that._cubeMap;
            }
        };
        var geometry = BoxGeometry.createGeometry(BoxGeometry.fromDimensions({
                dimensions: new Cartesian3(2, 2, 2),
                vertexFormat: VertexFormat.POSITION_ONLY
            }));
        var attributeLocations = GeometryPipeline.createAttributeLocations(geometry);
        command.vertexArray = context.createVertexArrayFromGeometry({
            geometry: geometry,
            attributeLocations: attributeLocations,
            bufferUsage: BufferUsage.STATIC_DRAW
        });
        command.shaderProgram = context.createShaderProgram(SkyBoxVS, SkyBoxFS, attributeLocations);
        command.renderState = context.createRenderState({ blending: BlendingState.ALPHA_BLEND });
    }
    if (!defined(this._cubeMap)) {
        return undefined;
    }
    return command;
};
SkyBox.prototype.isDestroyed = function () {
    return false;
};
SkyBox.prototype.destroy = function () {
    var command = this._command;
    command.vertexArray = command.vertexArray && command.vertexArray.destroy();
    command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();
    this._cubeMap = this._cubeMap && this._cubeMap.destroy();
    return destroyObject(this);
};
module.exports = SkyBox;
},{"../Core/BoxGeometry":99,"../Core/Cartesian3":102,"../Core/DeveloperError":123,"../Core/GeometryPipeline":150,"../Core/Matrix4":177,"../Core/VertexFormat":228,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/BufferUsage":339,"../Renderer/DrawCommand":344,"../Renderer/loadCubeMap":365,"../Shaders/SkyBoxFS":580,"../Shaders/SkyBoxVS":581,"./BlendingState":374,"./SceneMode":438}],445:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), BoundingSphere = require('../Core/BoundingSphere'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartesian4 = require('../Core/Cartesian4'), Color = require('../Core/Color'), ComponentDatatype = require('../Core/ComponentDatatype'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), IndexDatatype = require('../Core/IndexDatatype'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), PixelFormat = require('../Core/PixelFormat'), PrimitiveType = require('../Core/PrimitiveType'), BufferUsage = require('../Renderer/BufferUsage'), ClearCommand = require('../Renderer/ClearCommand'), DrawCommand = require('../Renderer/DrawCommand'), SunFS = require('../Shaders/SunFS'), SunTextureFS = require('../Shaders/SunTextureFS'), SunVS = require('../Shaders/SunVS'), BlendingState = require('./BlendingState'), SceneMode = require('./SceneMode'), SceneTransforms = require('./SceneTransforms');
'use strict';
var Sun = function () {
    this.show = true;
    this._command = new DrawCommand({
        primitiveType: PrimitiveType.TRIANGLES,
        boundingVolume: new BoundingSphere(),
        owner: this
    });
    this._boundingVolume = new BoundingSphere();
    this._boundingVolume2D = new BoundingSphere();
    this._texture = undefined;
    this._drawingBufferWidth = undefined;
    this._drawingBufferHeight = undefined;
    this._radiusTS = undefined;
    this._size = undefined;
    this.glowFactor = 1;
    this._glowFactorDirty = false;
    var that = this;
    this._uniformMap = {
        u_texture: function () {
            return that._texture;
        },
        u_size: function () {
            return that._size;
        }
    };
};
defineProperties(Sun.prototype, {
    glowFactor: {
        get: function () {
            return this._glowFactor;
        },
        set: function (glowFactor) {
            glowFactor = Math.max(glowFactor, 0);
            this._glowFactor = glowFactor;
            this._glowFactorDirty = true;
        }
    }
});
var scratchPositionWC = new Cartesian2();
var scratchLimbWC = new Cartesian2();
var scratchPositionEC = new Cartesian4();
var scratchCartesian4 = new Cartesian4();
Sun.prototype.update = function (scene) {
    var frameState = scene.frameState;
    var context = scene.context;
    if (!this.show) {
        return undefined;
    }
    var mode = frameState.mode;
    if (mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {
        return undefined;
    }
    if (!frameState.passes.render) {
        return undefined;
    }
    var drawingBufferWidth = scene.drawingBufferWidth;
    var drawingBufferHeight = scene.drawingBufferHeight;
    if (!defined(this._texture) || drawingBufferWidth !== this._drawingBufferWidth || drawingBufferHeight !== this._drawingBufferHeight || this._glowFactorDirty) {
        this._texture = this._texture && this._texture.destroy();
        this._drawingBufferWidth = drawingBufferWidth;
        this._drawingBufferHeight = drawingBufferHeight;
        this._glowFactorDirty = false;
        var size = Math.max(drawingBufferWidth, drawingBufferHeight);
        size = Math.pow(2, Math.ceil(Math.log(size) / Math.log(2)) - 2);
        this._texture = context.createTexture2D({
            width: size,
            height: size,
            pixelFormat: PixelFormat.RGBA
        });
        var fbo = context.createFramebuffer({ colorTextures: [this._texture] });
        fbo.destroyAttachments = false;
        var clearCommand = new ClearCommand({
                color: new Color(0, 0, 0, 0),
                framebuffer: fbo
            });
        var rs = context.createRenderState({ viewport: new BoundingRectangle(0, 0, size, size) });
        this._glowLengthTS = this._glowFactor * 5;
        this._radiusTS = 1 / (1 + 2 * this._glowLengthTS) * 0.5;
        var that = this;
        var uniformMap = {
                u_glowLengthTS: function () {
                    return that._glowLengthTS;
                },
                u_radiusTS: function () {
                    return that._radiusTS;
                }
            };
        var drawCommand = context.createViewportQuadCommand(SunTextureFS, {
                renderState: rs,
                uniformMap: uniformMap,
                framebuffer: fbo,
                owner: this
            });
        clearCommand.execute(context);
        drawCommand.execute(context);
        drawCommand.shaderProgram.destroy();
        fbo.destroy();
    }
    var command = this._command;
    if (!defined(command.vertexArray)) {
        var attributeLocations = { direction: 0 };
        var directions = new Uint8Array(4 * 2);
        directions[0] = 0;
        directions[1] = 0;
        directions[2] = 255;
        directions[3] = 0;
        directions[4] = 255;
        directions[5] = 255;
        directions[6] = 0;
        directions[7] = 255;
        var vertexBuffer = context.createVertexBuffer(directions, BufferUsage.STATIC_DRAW);
        var attributes = [{
                    index: attributeLocations.direction,
                    vertexBuffer: vertexBuffer,
                    componentsPerAttribute: 2,
                    normalize: true,
                    componentDatatype: ComponentDatatype.UNSIGNED_BYTE
                }];
        var indexBuffer = context.createIndexBuffer(new Uint16Array([
                0,
                1,
                2,
                0,
                2,
                3
            ]), BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
        command.vertexArray = context.createVertexArray(attributes, indexBuffer);
        command.shaderProgram = context.createShaderProgram(SunVS, SunFS, attributeLocations);
        command.renderState = context.createRenderState({ blending: BlendingState.ALPHA_BLEND });
        command.uniformMap = this._uniformMap;
    }
    var sunPosition = context.uniformState.sunPositionWC;
    var sunPositionCV = context.uniformState.sunPositionColumbusView;
    var boundingVolume = this._boundingVolume;
    var boundingVolume2D = this._boundingVolume2D;
    Cartesian3.clone(sunPosition, boundingVolume.center);
    boundingVolume2D.center.x = sunPositionCV.z;
    boundingVolume2D.center.y = sunPositionCV.x;
    boundingVolume2D.center.z = sunPositionCV.y;
    boundingVolume.radius = CesiumMath.SOLAR_RADIUS + CesiumMath.SOLAR_RADIUS * this._glowLengthTS;
    boundingVolume2D.radius = boundingVolume.radius;
    if (mode === SceneMode.SCENE3D) {
        BoundingSphere.clone(boundingVolume, command.boundingVolume);
    } else if (mode === SceneMode.COLUMBUS_VIEW) {
        BoundingSphere.clone(boundingVolume2D, command.boundingVolume);
    }
    var position = SceneTransforms.computeActualWgs84Position(frameState, sunPosition, scratchCartesian4);
    var dist = Cartesian3.magnitude(Cartesian3.subtract(position, scene.camera.position, scratchCartesian4));
    var projMatrix = context.uniformState.projection;
    var positionEC = scratchPositionEC;
    positionEC.x = 0;
    positionEC.y = 0;
    positionEC.z = -dist;
    positionEC.w = 1;
    var positionCC = Matrix4.multiplyByVector(projMatrix, positionEC, scratchCartesian4);
    var positionWC = SceneTransforms.clipToDrawingBufferCoordinates(scene, positionCC, scratchPositionWC);
    positionEC.x = CesiumMath.SOLAR_RADIUS;
    var limbCC = Matrix4.multiplyByVector(projMatrix, positionEC, scratchCartesian4);
    var limbWC = SceneTransforms.clipToDrawingBufferCoordinates(scene, limbCC, scratchLimbWC);
    this._size = Math.ceil(Cartesian2.magnitude(Cartesian2.subtract(limbWC, positionWC, scratchCartesian4)));
    this._size = 2 * this._size * (1 + 2 * this._glowLengthTS);
    return command;
};
Sun.prototype.isDestroyed = function () {
    return false;
};
Sun.prototype.destroy = function () {
    var command = this._command;
    command.vertexArray = command.vertexArray && command.vertexArray.destroy();
    command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();
    this._texture = this._texture && this._texture.destroy();
    return destroyObject(this);
};
module.exports = Sun;
},{"../Core/BoundingRectangle":97,"../Core/BoundingSphere":98,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartesian4":103,"../Core/Color":111,"../Core/ComponentDatatype":113,"../Core/IndexDatatype":162,"../Core/Math":174,"../Core/Matrix4":177,"../Core/PixelFormat":181,"../Core/PrimitiveType":193,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/BufferUsage":339,"../Renderer/ClearCommand":340,"../Renderer/DrawCommand":344,"../Shaders/SunFS":582,"../Shaders/SunTextureFS":583,"../Shaders/SunVS":584,"./BlendingState":374,"./SceneMode":438,"./SceneTransforms":439}],446:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), Cartesian2 = require('../Core/Cartesian2'), Cartesian4 = require('../Core/Cartesian4'), Color = require('../Core/Color'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), destroyObject = require('../Core/destroyObject'), CesiumMath = require('../Core/Math'), Matrix4 = require('../Core/Matrix4'), PixelFormat = require('../Core/PixelFormat'), Transforms = require('../Core/Transforms'), ClearCommand = require('../Renderer/ClearCommand'), PassState = require('../Renderer/PassState'), PixelDatatype = require('../Renderer/PixelDatatype'), RenderbufferFormat = require('../Renderer/RenderbufferFormat'), AdditiveBlend = require('../Shaders/PostProcessFilters/AdditiveBlend'), BrightPass = require('../Shaders/PostProcessFilters/BrightPass'), GaussianBlur1D = require('../Shaders/PostProcessFilters/GaussianBlur1D'), PassThrough = require('../Shaders/PostProcessFilters/PassThrough');
'use strict';
var SunPostProcess = function () {
    this._fbo = undefined;
    this._downSampleFBO1 = undefined;
    this._downSampleFBO2 = undefined;
    this._clearFBO1Command = undefined;
    this._clearFBO2Command = undefined;
    this._downSampleCommand = undefined;
    this._brightPassCommand = undefined;
    this._blurXCommand = undefined;
    this._blurYCommand = undefined;
    this._blendCommand = undefined;
    this._fullScreenCommand = undefined;
    this._downSamplePassState = new PassState();
    this._downSamplePassState.scissorTest = {
        enable: true,
        rectangle: new BoundingRectangle()
    };
    this._upSamplePassState = new PassState();
    this._upSamplePassState.scissorTest = {
        enabled: true,
        rectangle: new BoundingRectangle()
    };
    this._uCenter = new Cartesian2();
    this._uRadius = undefined;
    this._blurStep = new Cartesian2();
};
SunPostProcess.prototype.clear = function (context, color) {
    var clear = this._clearFBO1Command;
    Color.clone(defaultValue(color, Color.BLACK), clear.color);
    clear.execute(context);
    clear = this._clearFBO2Command;
    Color.clone(defaultValue(color, Color.BLACK), clear.color);
    clear.execute(context);
};
SunPostProcess.prototype.execute = function (context, framebuffer) {
    this._downSampleCommand.execute(context, this._downSamplePassState);
    this._brightPassCommand.execute(context, this._downSamplePassState);
    this._blurXCommand.execute(context, this._downSamplePassState);
    this._blurYCommand.execute(context, this._downSamplePassState);
    this._fullScreenCommand.framebuffer = framebuffer;
    this._blendCommand.framebuffer = framebuffer;
    this._fullScreenCommand.execute(context);
    this._blendCommand.execute(context, this._upSamplePassState);
};
var viewportBoundingRectangle = new BoundingRectangle();
var downSampleViewportBoundingRectangle = new BoundingRectangle();
var sunPositionECScratch = new Cartesian4();
var sunPositionWCScratch = new Cartesian2();
var sizeScratch = new Cartesian2();
var postProcessMatrix4Scratch = new Matrix4();
SunPostProcess.prototype.update = function (context) {
    var width = context.drawingBufferWidth;
    var height = context.drawingBufferHeight;
    var that = this;
    if (!defined(this._downSampleCommand)) {
        this._clearFBO1Command = new ClearCommand({ color: new Color() });
        this._clearFBO2Command = new ClearCommand({ color: new Color() });
        var rs;
        var uniformMap = {};
        this._downSampleCommand = context.createViewportQuadCommand(PassThrough, {
            renderState: rs,
            uniformMap: uniformMap,
            owner: this
        });
        uniformMap = {
            u_avgLuminance: function () {
                return 0.5;
            },
            u_threshold: function () {
                return 0.25;
            },
            u_offset: function () {
                return 0.1;
            }
        };
        this._brightPassCommand = context.createViewportQuadCommand(BrightPass, {
            renderState: rs,
            uniformMap: uniformMap,
            owner: this
        });
        var delta = 1;
        var sigma = 2;
        uniformMap = {
            delta: function () {
                return delta;
            },
            sigma: function () {
                return sigma;
            },
            direction: function () {
                return 0;
            }
        };
        this._blurXCommand = context.createViewportQuadCommand(GaussianBlur1D, {
            renderState: rs,
            uniformMap: uniformMap,
            owner: this
        });
        uniformMap = {
            delta: function () {
                return delta;
            },
            sigma: function () {
                return sigma;
            },
            direction: function () {
                return 1;
            }
        };
        this._blurYCommand = context.createViewportQuadCommand(GaussianBlur1D, {
            renderState: rs,
            uniformMap: uniformMap,
            owner: this
        });
        uniformMap = {
            u_center: function () {
                return that._uCenter;
            },
            u_radius: function () {
                return that._uRadius;
            }
        };
        this._blendCommand = context.createViewportQuadCommand(AdditiveBlend, {
            renderState: rs,
            uniformMap: uniformMap,
            owner: this
        });
        uniformMap = {};
        this._fullScreenCommand = context.createViewportQuadCommand(PassThrough, {
            renderState: rs,
            uniformMap: uniformMap,
            owner: this
        });
    }
    var downSampleWidth = Math.pow(2, Math.ceil(Math.log(width) / Math.log(2)) - 2);
    var downSampleHeight = Math.pow(2, Math.ceil(Math.log(height) / Math.log(2)) - 2);
    var downSampleSize = Math.max(downSampleWidth, downSampleHeight);
    var viewport = viewportBoundingRectangle;
    viewport.width = width;
    viewport.height = height;
    var downSampleViewport = downSampleViewportBoundingRectangle;
    downSampleViewport.width = downSampleSize;
    downSampleViewport.height = downSampleSize;
    var fbo = this._fbo;
    var colorTexture = defined(fbo) && fbo.getColorTexture(0) || undefined;
    if (!defined(colorTexture) || colorTexture.width !== width || colorTexture.height !== height) {
        fbo = fbo && fbo.destroy();
        this._downSampleFBO1 = this._downSampleFBO1 && this._downSampleFBO1.destroy();
        this._downSampleFBO2 = this._downSampleFBO2 && this._downSampleFBO2.destroy();
        this._blurStep.x = this._blurStep.y = 1 / downSampleSize;
        var colorTextures = [context.createTexture2D({
                    width: width,
                    height: height
                })];
        if (context.depthTexture) {
            fbo = this._fbo = context.createFramebuffer({
                colorTextures: colorTextures,
                depthTexture: context.createTexture2D({
                    width: width,
                    height: height,
                    pixelFormat: PixelFormat.DEPTH_COMPONENT,
                    pixelDatatype: PixelDatatype.UNSIGNED_SHORT
                })
            });
        } else {
            fbo = this._fbo = context.createFramebuffer({
                colorTextures: colorTextures,
                depthRenderbuffer: context.createRenderbuffer({ format: RenderbufferFormat.DEPTH_COMPONENT16 })
            });
        }
        this._downSampleFBO1 = context.createFramebuffer({
            colorTextures: [context.createTexture2D({
                    width: downSampleSize,
                    height: downSampleSize
                })]
        });
        this._downSampleFBO2 = context.createFramebuffer({
            colorTextures: [context.createTexture2D({
                    width: downSampleSize,
                    height: downSampleSize
                })]
        });
        this._clearFBO1Command.framebuffer = this._downSampleFBO1;
        this._clearFBO2Command.framebuffer = this._downSampleFBO2;
        this._downSampleCommand.framebuffer = this._downSampleFBO1;
        this._brightPassCommand.framebuffer = this._downSampleFBO2;
        this._blurXCommand.framebuffer = this._downSampleFBO1;
        this._blurYCommand.framebuffer = this._downSampleFBO2;
        var downSampleRenderState = context.createRenderState({ viewport: downSampleViewport });
        var upSampleRenderState = context.createRenderState();
        this._downSampleCommand.uniformMap.u_texture = function () {
            return fbo.getColorTexture(0);
        };
        this._downSampleCommand.renderState = downSampleRenderState;
        this._brightPassCommand.uniformMap.u_texture = function () {
            return that._downSampleFBO1.getColorTexture(0);
        };
        this._brightPassCommand.renderState = downSampleRenderState;
        this._blurXCommand.uniformMap.u_texture = function () {
            return that._downSampleFBO2.getColorTexture(0);
        };
        this._blurXCommand.uniformMap.u_step = function () {
            return that._blurStep;
        };
        this._blurXCommand.renderState = downSampleRenderState;
        this._blurYCommand.uniformMap.u_texture = function () {
            return that._downSampleFBO1.getColorTexture(0);
        };
        this._blurYCommand.uniformMap.u_step = function () {
            return that._blurStep;
        };
        this._blurYCommand.renderState = downSampleRenderState;
        this._blendCommand.uniformMap.u_texture0 = function () {
            return fbo.getColorTexture(0);
        };
        this._blendCommand.uniformMap.u_texture1 = function () {
            return that._downSampleFBO2.getColorTexture(0);
        };
        this._blendCommand.renderState = upSampleRenderState;
        this._fullScreenCommand.uniformMap.u_texture = function () {
            return fbo.getColorTexture(0);
        };
        this._fullScreenCommand.renderState = upSampleRenderState;
    }
    var us = context.uniformState;
    var sunPosition = us.sunPositionWC;
    var viewMatrix = us.view;
    var viewProjectionMatrix = us.viewProjection;
    var projectionMatrix = us.projection;
    var viewportTransformation = Matrix4.computeViewportTransformation(viewport, 0, 1, postProcessMatrix4Scratch);
    var sunPositionEC = Matrix4.multiplyByPoint(viewMatrix, sunPosition, sunPositionECScratch);
    var sunPositionWC = Transforms.pointToGLWindowCoordinates(viewProjectionMatrix, viewportTransformation, sunPosition, sunPositionWCScratch);
    sunPositionEC.x += CesiumMath.SOLAR_RADIUS;
    var limbWC = Transforms.pointToGLWindowCoordinates(projectionMatrix, viewportTransformation, sunPositionEC, sunPositionEC);
    var sunSize = Cartesian2.magnitude(Cartesian2.subtract(limbWC, sunPositionWC, limbWC)) * 30 * 2;
    var size = sizeScratch;
    size.x = sunSize;
    size.y = sunSize;
    var scissorRectangle = this._upSamplePassState.scissorTest.rectangle;
    scissorRectangle.x = Math.max(sunPositionWC.x - size.x * 0.5, 0);
    scissorRectangle.y = Math.max(sunPositionWC.y - size.y * 0.5, 0);
    scissorRectangle.width = Math.min(size.x, width);
    scissorRectangle.height = Math.min(size.y, height);
    this._uCenter = Cartesian2.clone(sunPositionWC, this._uCenter);
    this._uRadius = Math.max(size.x, size.y) * 0.5;
    viewportTransformation = Matrix4.computeViewportTransformation(downSampleViewport, 0, 1, postProcessMatrix4Scratch);
    sunPositionWC = Transforms.pointToGLWindowCoordinates(viewProjectionMatrix, viewportTransformation, sunPosition, sunPositionWCScratch);
    size.x *= downSampleWidth / width;
    size.y *= downSampleHeight / height;
    scissorRectangle = this._downSamplePassState.scissorTest.rectangle;
    scissorRectangle.x = Math.max(sunPositionWC.x - size.x * 0.5, 0);
    scissorRectangle.y = Math.max(sunPositionWC.y - size.y * 0.5, 0);
    scissorRectangle.width = Math.min(size.x, width);
    scissorRectangle.height = Math.min(size.y, height);
    this._downSamplePassState.context = context;
    this._upSamplePassState.context = context;
    return this._fbo;
};
SunPostProcess.prototype.isDestroyed = function () {
    return false;
};
SunPostProcess.prototype.destroy = function () {
    this._fbo = this._fbo && this._fbo.destroy();
    this._downSampleFBO1 = this._downSampleFBO1 && this._downSampleFBO1.destroy();
    this._downSampleFBO2 = this._downSampleFBO2 && this._downSampleFBO2.destroy();
    this._downSampleCommand = this._downSampleCommand && this._downSampleCommand.shaderProgram && this._downSampleCommand.shaderProgram.destroy();
    this._brightPassCommand = this._brightPassCommand && this._brightPassCommand.shaderProgram && this._brightPassCommand.shaderProgram.destroy();
    this._blurXCommand = this._blurXCommand && this._blurXCommand.shaderProgram && this._blurXCommand.shaderProgram.destroy();
    this._blurYCommand = this._blurYCommand && this._blurYCommand.shaderProgram && this._blurYCommand.shaderProgram.destroy();
    this._blendCommand = this._blendCommand && this._blendCommand.shaderProgram && this._blendCommand.shaderProgram.destroy();
    this._fullScreenCommand = this._fullScreenCommand && this._fullScreenCommand.shaderProgram && this._fullScreenCommand.shaderProgram.destroy();
    return destroyObject(this);
};
module.exports = SunPostProcess;
},{"../Core/BoundingRectangle":97,"../Core/Cartesian2":101,"../Core/Cartesian4":103,"../Core/Color":111,"../Core/Math":174,"../Core/Matrix4":177,"../Core/PixelFormat":181,"../Core/Transforms":226,"../Core/defaultValue":243,"../Core/defined":245,"../Core/destroyObject":247,"../Renderer/ClearCommand":340,"../Renderer/PassState":347,"../Renderer/PixelDatatype":349,"../Renderer/RenderbufferFormat":352,"../Shaders/PostProcessFilters/AdditiveBlend":571,"../Shaders/PostProcessFilters/BrightPass":572,"../Shaders/PostProcessFilters/GaussianBlur1D":574,"../Shaders/PostProcessFilters/PassThrough":575}],447:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var TerrainState = {
        FAILED: 0,
        UNLOADED: 1,
        RECEIVING: 2,
        RECEIVED: 3,
        TRANSFORMING: 4,
        TRANSFORMED: 5,
        READY: 6
    };
module.exports = freezeObject(TerrainState);
},{"../Core/freezeObject":249}],448:[function(require,module,exports){
var BoundingRectangle = require('../Core/BoundingRectangle'), Cartesian2 = require('../Core/Cartesian2'), createGuid = require('../Core/createGuid'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), DeveloperError = require('../Core/DeveloperError'), loadImage = require('../Core/loadImage'), PixelFormat = require('../Core/PixelFormat'), RuntimeError = require('../Core/RuntimeError'), when = require('../ThirdParty/when');
'use strict';
function TextureAtlasNode(bottomLeft, topRight, childNode1, childNode2, imageIndex) {
    this.bottomLeft = defaultValue(bottomLeft, Cartesian2.ZERO);
    this.topRight = defaultValue(topRight, Cartesian2.ZERO);
    this.childNode1 = childNode1;
    this.childNode2 = childNode2;
    this.imageIndex = imageIndex;
}
var defaultInitialSize = new Cartesian2(16, 16);
var TextureAtlas = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var borderWidthInPixels = defaultValue(options.borderWidthInPixels, 1);
    var initialSize = defaultValue(options.initialSize, defaultInitialSize);
    if (!defined(options.context)) {
        throw new DeveloperError('context is required.');
    }
    if (borderWidthInPixels < 0) {
        throw new DeveloperError('borderWidthInPixels must be greater than or equal to zero.');
    }
    if (initialSize.x < 1 || initialSize.y < 1) {
        throw new DeveloperError('initialSize must be greater than zero.');
    }
    this._context = options.context;
    this._pixelFormat = defaultValue(options.pixelFormat, PixelFormat.RGBA);
    this._borderWidthInPixels = borderWidthInPixels;
    this._textureCoordinates = [];
    this._guid = createGuid();
    this._idHash = {};
    this._texture = this._context.createTexture2D({
        width: initialSize.x,
        height: initialSize.y,
        pixelFormat: this._pixelFormat
    });
    this._root = new TextureAtlasNode(new Cartesian2(), new Cartesian2(initialSize.x, initialSize.y));
};
defineProperties(TextureAtlas.prototype, {
    borderWidthInPixels: {
        get: function () {
            return this._borderWidthInPixels;
        }
    },
    textureCoordinates: {
        get: function () {
            return this._textureCoordinates;
        }
    },
    texture: {
        get: function () {
            return this._texture;
        }
    },
    numberOfImages: {
        get: function () {
            return this._textureCoordinates.length;
        }
    },
    guid: {
        get: function () {
            return this._guid;
        }
    }
});
function resizeAtlas(textureAtlas, image) {
    var numImages = textureAtlas.numberOfImages;
    var scalingFactor = 2;
    if (numImages > 0) {
        var oldAtlasWidth = textureAtlas._texture.width;
        var oldAtlasHeight = textureAtlas._texture.height;
        var atlasWidth = scalingFactor * (oldAtlasWidth + image.width + textureAtlas._borderWidthInPixels);
        var atlasHeight = scalingFactor * (oldAtlasHeight + image.height + textureAtlas._borderWidthInPixels);
        var widthRatio = oldAtlasWidth / atlasWidth;
        var heightRatio = oldAtlasHeight / atlasHeight;
        var nodeBottomRight = new TextureAtlasNode(new Cartesian2(oldAtlasWidth + textureAtlas._borderWidthInPixels, 0), new Cartesian2(atlasWidth, oldAtlasHeight));
        var nodeBottomHalf = new TextureAtlasNode(new Cartesian2(), new Cartesian2(atlasWidth, oldAtlasHeight), textureAtlas._root, nodeBottomRight);
        var nodeTopHalf = new TextureAtlasNode(new Cartesian2(0, oldAtlasHeight + textureAtlas._borderWidthInPixels), new Cartesian2(atlasWidth, atlasHeight));
        var nodeMain = new TextureAtlasNode(new Cartesian2(), new Cartesian2(atlasWidth, atlasHeight), nodeBottomHalf, nodeTopHalf);
        textureAtlas._root = nodeMain;
        for (var i = 0; i < textureAtlas._textureCoordinates.length; i++) {
            var texCoord = textureAtlas._textureCoordinates[i];
            if (defined(texCoord)) {
                texCoord.x *= widthRatio;
                texCoord.y *= heightRatio;
                texCoord.width *= widthRatio;
                texCoord.height *= heightRatio;
            }
        }
        var newTexture = textureAtlas._context.createTexture2D({
                width: atlasWidth,
                height: atlasHeight,
                pixelFormat: textureAtlas._pixelFormat
            });
        var framebuffer = textureAtlas._context.createFramebuffer({ colorTextures: [textureAtlas._texture] });
        framebuffer._bind();
        newTexture.copyFromFramebuffer(0, 0, 0, 0, oldAtlasWidth, oldAtlasHeight);
        framebuffer._unBind();
        framebuffer.destroy();
        textureAtlas._texture = newTexture;
    } else {
        var initialWidth = scalingFactor * (image.width + textureAtlas._borderWidthInPixels);
        var initialHeight = scalingFactor * (image.height + textureAtlas._borderWidthInPixels);
        textureAtlas._texture = textureAtlas._texture && textureAtlas._texture.destroy();
        textureAtlas._texture = textureAtlas._context.createTexture2D({
            width: initialWidth,
            height: initialHeight,
            pixelFormat: textureAtlas._pixelFormat
        });
        textureAtlas._root = new TextureAtlasNode(new Cartesian2(), new Cartesian2(initialWidth, initialHeight));
    }
}
function findNode(textureAtlas, node, image) {
    if (!defined(node)) {
        return undefined;
    }
    if (!defined(node.childNode1) && !defined(node.childNode2)) {
        if (defined(node.imageIndex)) {
            return undefined;
        }
        var nodeWidth = node.topRight.x - node.bottomLeft.x;
        var nodeHeight = node.topRight.y - node.bottomLeft.y;
        var widthDifference = nodeWidth - image.width;
        var heightDifference = nodeHeight - image.height;
        if (widthDifference < 0 || heightDifference < 0) {
            return undefined;
        }
        if (widthDifference === 0 && heightDifference === 0) {
            return node;
        }
        if (widthDifference > heightDifference) {
            node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.bottomLeft.x + image.width, node.topRight.y));
            var childNode2BottomLeftX = node.bottomLeft.x + image.width + textureAtlas._borderWidthInPixels;
            if (childNode2BottomLeftX < node.topRight.x) {
                node.childNode2 = new TextureAtlasNode(new Cartesian2(childNode2BottomLeftX, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.topRight.y));
            }
        } else {
            node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.bottomLeft.y + image.height));
            var childNode2BottomLeftY = node.bottomLeft.y + image.height + textureAtlas._borderWidthInPixels;
            if (childNode2BottomLeftY < node.topRight.y) {
                node.childNode2 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, childNode2BottomLeftY), new Cartesian2(node.topRight.x, node.topRight.y));
            }
        }
        return findNode(textureAtlas, node.childNode1, image);
    }
    return findNode(textureAtlas, node.childNode1, image) || findNode(textureAtlas, node.childNode2, image);
}
function addImage(textureAtlas, image, index) {
    var node = findNode(textureAtlas, textureAtlas._root, image);
    if (defined(node)) {
        node.imageIndex = index;
        var atlasWidth = textureAtlas._texture.width;
        var atlasHeight = textureAtlas._texture.height;
        var nodeWidth = node.topRight.x - node.bottomLeft.x;
        var nodeHeight = node.topRight.y - node.bottomLeft.y;
        var x = node.bottomLeft.x / atlasWidth;
        var y = node.bottomLeft.y / atlasHeight;
        var w = nodeWidth / atlasWidth;
        var h = nodeHeight / atlasHeight;
        textureAtlas._textureCoordinates[index] = new BoundingRectangle(x, y, w, h);
        textureAtlas._texture.copyFrom(image, node.bottomLeft.x, node.bottomLeft.y);
    } else {
        resizeAtlas(textureAtlas, image);
        addImage(textureAtlas, image, index);
    }
    textureAtlas._guid = createGuid();
}
TextureAtlas.prototype.addImage = function (id, image) {
    if (!defined(id)) {
        throw new DeveloperError('id is required.');
    }
    if (!defined(image)) {
        throw new DeveloperError('image is required.');
    }
    var indexPromise = this._idHash[id];
    if (defined(indexPromise)) {
        return indexPromise;
    }
    if (typeof image === 'function') {
        image = image(id);
        if (!defined(image)) {
            throw new DeveloperError('image is required.');
        }
    } else if (typeof image === 'string') {
        image = loadImage(image);
    }
    var that = this;
    indexPromise = when(image, function (image) {
        if (that.isDestroyed()) {
            return -1;
        }
        var index = that.numberOfImages;
        addImage(that, image, index);
        return index;
    });
    this._idHash[id] = indexPromise;
    return indexPromise;
};
TextureAtlas.prototype.addSubRegion = function (id, subRegion) {
    if (!defined(id)) {
        throw new DeveloperError('id is required.');
    }
    if (!defined(subRegion)) {
        throw new DeveloperError('subRegion is required.');
    }
    var indexPromise = this._idHash[id];
    if (!defined(indexPromise)) {
        throw new RuntimeError('image with id "' + id + '" not found in the atlas.');
    }
    var that = this;
    return when(indexPromise, function (index) {
        if (index === -1) {
            return -1;
        }
        var atlasWidth = that._texture.width;
        var atlasHeight = that._texture.height;
        var numImages = that.numberOfImages;
        var baseRegion = that._textureCoordinates[index];
        var x = baseRegion.x + subRegion.x / atlasWidth;
        var y = baseRegion.y + subRegion.y / atlasHeight;
        var w = subRegion.width / atlasWidth;
        var h = subRegion.height / atlasHeight;
        that._textureCoordinates.push(new BoundingRectangle(x, y, w, h));
        that._guid = createGuid();
        return numImages;
    });
};
TextureAtlas.prototype.isDestroyed = function () {
    return false;
};
TextureAtlas.prototype.destroy = function () {
    this._texture = this._texture && this._texture.destroy();
    return destroyObject(this);
};
module.exports = TextureAtlas;
},{"../Core/BoundingRectangle":97,"../Core/Cartesian2":101,"../Core/DeveloperError":123,"../Core/PixelFormat":181,"../Core/RuntimeError":207,"../Core/createGuid":242,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../Core/loadImage":259,"../ThirdParty/when":596}],449:[function(require,module,exports){
var defined = require('../Core/defined'), ImageryState = require('./ImageryState');
'use strict';
var TileImagery = function (imagery, textureCoordinateRectangle) {
    this.readyImagery = undefined;
    this.loadingImagery = imagery;
    this.textureCoordinateRectangle = textureCoordinateRectangle;
    this.textureTranslationAndScale = undefined;
};
TileImagery.prototype.freeResources = function () {
    if (defined(this.readyImagery)) {
        this.readyImagery.releaseReference();
    }
    if (defined(this.loadingImagery)) {
        this.loadingImagery.releaseReference();
    }
};
TileImagery.prototype.processStateMachine = function (tile, context) {
    var loadingImagery = this.loadingImagery;
    var imageryLayer = loadingImagery.imageryLayer;
    if (loadingImagery.state === ImageryState.UNLOADED) {
        loadingImagery.state = ImageryState.TRANSITIONING;
        imageryLayer._requestImagery(loadingImagery);
    }
    if (loadingImagery.state === ImageryState.RECEIVED) {
        loadingImagery.state = ImageryState.TRANSITIONING;
        imageryLayer._createTexture(context, loadingImagery);
    }
    if (loadingImagery.state === ImageryState.TEXTURE_LOADED) {
        loadingImagery.state = ImageryState.TRANSITIONING;
        imageryLayer._reprojectTexture(context, loadingImagery);
    }
    if (loadingImagery.state === ImageryState.READY) {
        if (defined(this.readyImagery)) {
            this.readyImagery.releaseReference();
        }
        this.readyImagery = this.loadingImagery;
        this.loadingImagery = undefined;
        this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, this);
        return true;
    }
    var ancestor = loadingImagery.parent;
    var ancestorsAreStillLoading = false;
    while (defined(ancestor) && ancestor.state !== ImageryState.READY) {
        ancestorsAreStillLoading = ancestorsAreStillLoading || ancestor.state !== ImageryState.FAILED && ancestor.state !== ImageryState.INVALID;
        ancestor = ancestor.parent;
    }
    if (this.readyImagery !== ancestor) {
        if (defined(this.readyImagery)) {
            this.readyImagery.releaseReference();
        }
        this.readyImagery = ancestor;
        if (defined(ancestor)) {
            ancestor.addReference();
            this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, this);
        }
    }
    if (!ancestorsAreStillLoading && (loadingImagery.state === ImageryState.FAILED || loadingImagery.state === ImageryState.INVALID)) {
        return true;
    }
    return false;
};
module.exports = TileImagery;
},{"../Core/defined":245,"./ImageryState":400}],450:[function(require,module,exports){
var appendForwardSlash = require('../Core/appendForwardSlash'), Cartesian2 = require('../Core/Cartesian2'), Cartographic = require('../Core/Cartographic'), Credit = require('../Core/Credit'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), GeographicTilingScheme = require('../Core/GeographicTilingScheme'), loadXML = require('../Core/loadXML'), Rectangle = require('../Core/Rectangle'), TileProviderError = require('../Core/TileProviderError'), WebMercatorTilingScheme = require('../Core/WebMercatorTilingScheme'), when = require('../ThirdParty/when'), ImageryProvider = require('./ImageryProvider');
'use strict';
var TileMapServiceImageryProvider = function TileMapServiceImageryProvider(options) {
    options = defaultValue(options, {});
    if (!defined(options.url)) {
        throw new DeveloperError('options.url is required.');
    }
    var url = appendForwardSlash(options.url);
    this._url = url;
    this._ready = false;
    this._proxy = options.proxy;
    this._tileDiscardPolicy = options.tileDiscardPolicy;
    this._errorEvent = new Event();
    this._fileExtension = options.fileExtension;
    this._tileWidth = options.tileWidth;
    this._tileHeight = options.tileHeight;
    this._minimumLevel = options.minimumLevel;
    this._maximumLevel = options.maximumLevel;
    this._rectangle = Rectangle.clone(options.rectangle);
    this._tilingScheme = options.tilingScheme;
    var credit = options.credit;
    if (typeof credit === 'string') {
        credit = new Credit(credit);
    }
    this._credit = credit;
    var that = this;
    var metadataError;
    function metadataSuccess(xml) {
        var tileFormatRegex = /tileformat/i;
        var tileSetRegex = /tileset/i;
        var tileSetsRegex = /tilesets/i;
        var bboxRegex = /boundingbox/i;
        var srsRegex = /srs/i;
        var format, bbox, tilesets, srs;
        var tilesetsList = [];
        var nodeList = xml.childNodes[0].childNodes;
        for (var i = 0; i < nodeList.length; i++) {
            if (tileFormatRegex.test(nodeList.item(i).nodeName)) {
                format = nodeList.item(i);
            } else if (tileSetsRegex.test(nodeList.item(i).nodeName)) {
                tilesets = nodeList.item(i);
                var tileSetNodes = nodeList.item(i).childNodes;
                for (var j = 0; j < tileSetNodes.length; j++) {
                    if (tileSetRegex.test(tileSetNodes.item(j).nodeName)) {
                        tilesetsList.push(tileSetNodes.item(j));
                    }
                }
            } else if (bboxRegex.test(nodeList.item(i).nodeName)) {
                bbox = nodeList.item(i);
            } else if (srsRegex.test(nodeList.item(i).nodeName)) {
                srs = nodeList.item(i).textContent;
            }
        }
        that._fileExtension = defaultValue(that._fileExtension, format.getAttribute('extension'));
        that._tileWidth = defaultValue(that._tileWidth, parseInt(format.getAttribute('width'), 10));
        that._tileHeight = defaultValue(that._tileHeight, parseInt(format.getAttribute('height'), 10));
        that._minimumLevel = defaultValue(that._minimumLevel, parseInt(tilesetsList[0].getAttribute('order'), 10));
        that._maximumLevel = defaultValue(that._maximumLevel, parseInt(tilesetsList[tilesetsList.length - 1].getAttribute('order'), 10));
        var tilingSchemeName = tilesets.getAttribute('profile');
        var flipXY = false;
        if (tilingSchemeName === 'geodetic' || tilingSchemeName === 'mercator') {
            flipXY = true;
        }
        if (!defined(that._tilingScheme)) {
            if (tilingSchemeName === 'geodetic' || tilingSchemeName === 'global-geodetic') {
                that._tilingScheme = new GeographicTilingScheme();
            } else if (tilingSchemeName === 'mercator' || tilingSchemeName === 'global-mercator') {
                that._tilingScheme = new WebMercatorTilingScheme();
            } else {
                var message = url + 'tilemapresource.xml specifies an unsupported profile attribute, ' + tilingSchemeName + '.';
                metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, undefined, undefined, undefined, requestMetadata);
                return;
            }
        }
        var tilingScheme = that._tilingScheme;
        if (!defined(that._rectangle)) {
            var swXY;
            var neXY;
            var sw;
            var ne;
            if (flipXY) {
                swXY = new Cartesian2(parseFloat(bbox.getAttribute('miny')), parseFloat(bbox.getAttribute('minx')));
                neXY = new Cartesian2(parseFloat(bbox.getAttribute('maxy')), parseFloat(bbox.getAttribute('maxx')));
                sw = Cartographic.fromDegrees(swXY.x, swXY.y);
                ne = Cartographic.fromDegrees(neXY.x, neXY.y);
            } else {
                swXY = new Cartesian2(parseFloat(bbox.getAttribute('minx')), parseFloat(bbox.getAttribute('miny')));
                neXY = new Cartesian2(parseFloat(bbox.getAttribute('maxx')), parseFloat(bbox.getAttribute('maxy')));
                if (that._tilingScheme instanceof GeographicTilingScheme) {
                    sw = Cartographic.fromDegrees(swXY.x, swXY.y);
                    ne = Cartographic.fromDegrees(neXY.x, neXY.y);
                } else {
                    var projection = that._tilingScheme.projection;
                    sw = projection.unproject(swXY);
                    ne = projection.unproject(neXY);
                }
            }
            that._rectangle = new Rectangle(sw.longitude, sw.latitude, ne.longitude, ne.latitude);
        }
        if (that._rectangle.west < tilingScheme.rectangle.west) {
            that._rectangle.west = tilingScheme.rectangle.west;
        }
        if (that._rectangle.east > tilingScheme.rectangle.east) {
            that._rectangle.east = tilingScheme.rectangle.east;
        }
        if (that._rectangle.south < tilingScheme.rectangle.south) {
            that._rectangle.south = tilingScheme.rectangle.south;
        }
        if (that._rectangle.north > tilingScheme.rectangle.north) {
            that._rectangle.north = tilingScheme.rectangle.north;
        }
        var swTile = tilingScheme.positionToTileXY(Rectangle.southwest(that._rectangle), that._minimumLevel);
        var neTile = tilingScheme.positionToTileXY(Rectangle.northeast(that._rectangle), that._minimumLevel);
        var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
        if (tileCount > 4) {
            that._minimumLevel = 0;
        }
        that._tilingScheme = tilingScheme;
        that._ready = true;
    }
    function metadataFailure(error) {
        that._fileExtension = defaultValue(options.fileExtension, 'png');
        that._tileWidth = defaultValue(options.tileWidth, 256);
        that._tileHeight = defaultValue(options.tileHeight, 256);
        that._minimumLevel = defaultValue(options.minimumLevel, 0);
        that._maximumLevel = defaultValue(options.maximumLevel, 18);
        that._tilingScheme = defined(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme();
        that._rectangle = defaultValue(options.rectangle, that._tilingScheme.rectangle);
        that._ready = true;
    }
    function requestMetadata() {
        var resourceUrl = url + 'tilemapresource.xml';
        var proxy = that._proxy;
        if (defined(proxy)) {
            resourceUrl = proxy.getURL(resourceUrl);
        }
        when(loadXML(resourceUrl), metadataSuccess, metadataFailure);
    }
    requestMetadata();
};
function buildImageUrl(imageryProvider, x, y, level) {
    var yTiles = imageryProvider._tilingScheme.getNumberOfYTilesAtLevel(level);
    var url = imageryProvider._url + level + '/' + x + '/' + (yTiles - y - 1) + '.' + imageryProvider._fileExtension;
    var proxy = imageryProvider._proxy;
    if (defined(proxy)) {
        url = proxy.getURL(url);
    }
    return url;
}
defineProperties(TileMapServiceImageryProvider.prototype, {
    url: {
        get: function () {
            return this._url;
        }
    },
    proxy: {
        get: function () {
            return this._proxy;
        }
    },
    tileWidth: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            return this._tileWidth;
        }
    },
    tileHeight: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            return this._tileHeight;
        }
    },
    maximumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            return this._maximumLevel;
        }
    },
    minimumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            return this._minimumLevel;
        }
    },
    tilingScheme: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            return this._tilingScheme;
        }
    },
    rectangle: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
            }
            return this._rectangle;
        }
    },
    tileDiscardPolicy: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            return this._tileDiscardPolicy;
        }
    },
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    credit: {
        get: function () {
            return this._credit;
        }
    },
    hasAlphaChannel: {
        get: function () {
            return true;
        }
    }
});
TileMapServiceImageryProvider.prototype.getTileCredits = function (x, y, level) {
    return undefined;
};
TileMapServiceImageryProvider.prototype.requestImage = function (x, y, level) {
    if (!this._ready) {
        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }
    var url = buildImageUrl(this, x, y, level);
    return ImageryProvider.loadImage(this, url);
};
TileMapServiceImageryProvider.prototype.pickFeatures = function () {
    return undefined;
};
module.exports = TileMapServiceImageryProvider;
},{"../Core/Cartesian2":101,"../Core/Cartographic":104,"../Core/Credit":118,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeographicTilingScheme":144,"../Core/Rectangle":201,"../Core/TileProviderError":220,"../Core/WebMercatorTilingScheme":234,"../Core/appendForwardSlash":236,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/loadXML":264,"../ThirdParty/when":596,"./ImageryProvider":399}],451:[function(require,module,exports){
var defined = require('../Core/defined');
'use strict';
var TileReplacementQueue = function TileReplacementQueue() {
    this.head = undefined;
    this.tail = undefined;
    this.count = 0;
    this._lastBeforeStartOfFrame = undefined;
};
TileReplacementQueue.prototype.markStartOfRenderFrame = function () {
    this._lastBeforeStartOfFrame = this.head;
};
TileReplacementQueue.prototype.trimTiles = function (maximumTiles) {
    var tileToTrim = this.tail;
    var keepTrimming = true;
    while (keepTrimming && defined(this._lastBeforeStartOfFrame) && this.count > maximumTiles && defined(tileToTrim)) {
        keepTrimming = tileToTrim !== this._lastBeforeStartOfFrame;
        var previous = tileToTrim.replacementPrevious;
        if (tileToTrim.eligibleForUnloading) {
            tileToTrim.freeResources();
            remove(this, tileToTrim);
        }
        tileToTrim = previous;
    }
};
function remove(tileReplacementQueue, item) {
    var previous = item.replacementPrevious;
    var next = item.replacementNext;
    if (item === tileReplacementQueue._lastBeforeStartOfFrame) {
        tileReplacementQueue._lastBeforeStartOfFrame = next;
    }
    if (item === tileReplacementQueue.head) {
        tileReplacementQueue.head = next;
    } else {
        previous.replacementNext = next;
    }
    if (item === tileReplacementQueue.tail) {
        tileReplacementQueue.tail = previous;
    } else {
        next.replacementPrevious = previous;
    }
    item.replacementPrevious = undefined;
    item.replacementNext = undefined;
    --tileReplacementQueue.count;
}
TileReplacementQueue.prototype.markTileRendered = function (item) {
    var head = this.head;
    if (head === item) {
        if (item === this._lastBeforeStartOfFrame) {
            this._lastBeforeStartOfFrame = item.replacementNext;
        }
        return;
    }
    ++this.count;
    if (!defined(head)) {
        item.replacementPrevious = undefined;
        item.replacementNext = undefined;
        this.head = item;
        this.tail = item;
        return;
    }
    if (defined(item.replacementPrevious) || defined(item.replacementNext)) {
        remove(this, item);
    }
    item.replacementPrevious = undefined;
    item.replacementNext = head;
    head.replacementPrevious = item;
    this.head = item;
};
module.exports = TileReplacementQueue;
},{"../Core/defined":245}],452:[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), Cartesian3 = require('../Core/Cartesian3'), ComponentDatatype = require('../Core/ComponentDatatype'), defined = require('../Core/defined'), DeveloperError = require('../Core/DeveloperError'), IndexDatatype = require('../Core/IndexDatatype'), TileProviderError = require('../Core/TileProviderError'), BufferUsage = require('../Renderer/BufferUsage'), when = require('../ThirdParty/when'), terrainAttributeLocations = require('./terrainAttributeLocations'), TerrainState = require('./TerrainState');
'use strict';
var TileTerrain = function TileTerrain(upsampleDetails) {
    this.state = TerrainState.UNLOADED;
    this.data = undefined;
    this.mesh = undefined;
    this.vertexArray = undefined;
    this.upsampleDetails = upsampleDetails;
};
TileTerrain.prototype.freeResources = function () {
    this.state = TerrainState.UNLOADED;
    this.data = undefined;
    this.mesh = undefined;
    if (defined(this.vertexArray)) {
        var indexBuffer = this.vertexArray.indexBuffer;
        this.vertexArray.destroy();
        this.vertexArray = undefined;
        if (!indexBuffer.isDestroyed() && defined(indexBuffer.referenceCount)) {
            --indexBuffer.referenceCount;
            if (indexBuffer.referenceCount === 0) {
                indexBuffer.destroy();
            }
        }
    }
};
TileTerrain.prototype.publishToTile = function (tile) {
    var surfaceTile = tile.data;
    var mesh = this.mesh;
    Cartesian3.clone(mesh.center, surfaceTile.center);
    surfaceTile.minimumHeight = mesh.minimumHeight;
    surfaceTile.maximumHeight = mesh.maximumHeight;
    surfaceTile.boundingSphere3D = BoundingSphere.clone(mesh.boundingSphere3D, surfaceTile.boundingSphere3D);
    tile.data.occludeePointInScaledSpace = Cartesian3.clone(mesh.occludeePointInScaledSpace, surfaceTile.occludeePointInScaledSpace);
    surfaceTile.freeVertexArray();
    surfaceTile.vertexArray = this.vertexArray;
    this.vertexArray = undefined;
};
TileTerrain.prototype.processLoadStateMachine = function (context, terrainProvider, x, y, level) {
    if (this.state === TerrainState.UNLOADED) {
        requestTileGeometry(this, terrainProvider, x, y, level);
    }
    if (this.state === TerrainState.RECEIVED) {
        transform(this, context, terrainProvider, x, y, level);
    }
    if (this.state === TerrainState.TRANSFORMED) {
        createResources(this, context, terrainProvider, x, y, level);
    }
};
function requestTileGeometry(tileTerrain, terrainProvider, x, y, level) {
    function success(terrainData) {
        tileTerrain.data = terrainData;
        tileTerrain.state = TerrainState.RECEIVED;
    }
    function failure() {
        tileTerrain.state = TerrainState.FAILED;
        var message = 'Failed to obtain terrain tile X: ' + x + ' Y: ' + y + ' Level: ' + level + '.';
        terrainProvider._requestError = TileProviderError.handleError(terrainProvider._requestError, terrainProvider, terrainProvider.errorEvent, message, x, y, level, doRequest);
    }
    function doRequest() {
        tileTerrain.data = terrainProvider.requestTileGeometry(x, y, level);
        if (defined(tileTerrain.data)) {
            tileTerrain.state = TerrainState.RECEIVING;
            when(tileTerrain.data, success, failure);
        } else {
            tileTerrain.state = TerrainState.UNLOADED;
        }
    }
    doRequest();
}
TileTerrain.prototype.processUpsampleStateMachine = function (context, terrainProvider, x, y, level) {
    if (this.state === TerrainState.UNLOADED) {
        var upsampleDetails = this.upsampleDetails;
        if (!defined(upsampleDetails)) {
            throw new DeveloperError('TileTerrain cannot upsample unless provided upsampleDetails.');
        }
        var sourceData = upsampleDetails.data;
        var sourceX = upsampleDetails.x;
        var sourceY = upsampleDetails.y;
        var sourceLevel = upsampleDetails.level;
        this.data = sourceData.upsample(terrainProvider.tilingScheme, sourceX, sourceY, sourceLevel, x, y, level);
        if (!defined(this.data)) {
            return;
        }
        this.state = TerrainState.RECEIVING;
        var that = this;
        when(this.data, function (terrainData) {
            that.data = terrainData;
            that.state = TerrainState.RECEIVED;
        }, function () {
            that.state = TerrainState.FAILED;
        });
    }
    if (this.state === TerrainState.RECEIVED) {
        transform(this, context, terrainProvider, x, y, level);
    }
    if (this.state === TerrainState.TRANSFORMED) {
        createResources(this, context, terrainProvider, x, y, level);
    }
};
function transform(tileTerrain, context, terrainProvider, x, y, level) {
    var tilingScheme = terrainProvider.tilingScheme;
    var terrainData = tileTerrain.data;
    var meshPromise = terrainData.createMesh(tilingScheme, x, y, level);
    if (!defined(meshPromise)) {
        return;
    }
    tileTerrain.state = TerrainState.TRANSFORMING;
    when(meshPromise, function (mesh) {
        tileTerrain.mesh = mesh;
        tileTerrain.state = TerrainState.TRANSFORMED;
    }, function () {
        tileTerrain.state = TerrainState.FAILED;
    });
}
function createResources(tileTerrain, context, terrainProvider, x, y, level) {
    var datatype = ComponentDatatype.FLOAT;
    var stride;
    var numTexCoordComponents;
    var typedArray = tileTerrain.mesh.vertices;
    var buffer = context.createVertexBuffer(typedArray, BufferUsage.STATIC_DRAW);
    if (terrainProvider.hasVertexNormals) {
        stride = 7 * ComponentDatatype.getSizeInBytes(datatype);
        numTexCoordComponents = 3;
    } else {
        stride = 6 * ComponentDatatype.getSizeInBytes(datatype);
        numTexCoordComponents = 2;
    }
    var position3DAndHeightLength = 4;
    var attributes = [
            {
                index: terrainAttributeLocations.position3DAndHeight,
                vertexBuffer: buffer,
                componentDatatype: datatype,
                componentsPerAttribute: position3DAndHeightLength,
                offsetInBytes: 0,
                strideInBytes: stride
            },
            {
                index: terrainAttributeLocations.textureCoordAndEncodedNormals,
                vertexBuffer: buffer,
                componentDatatype: datatype,
                componentsPerAttribute: numTexCoordComponents,
                offsetInBytes: position3DAndHeightLength * ComponentDatatype.getSizeInBytes(datatype),
                strideInBytes: stride
            }
        ];
    var indexBuffers = tileTerrain.mesh.indices.indexBuffers || {};
    var indexBuffer = indexBuffers[context.id];
    if (!defined(indexBuffer) || indexBuffer.isDestroyed()) {
        var indices = tileTerrain.mesh.indices;
        var indexDatatype = indices.BYTES_PER_ELEMENT === 2 ? IndexDatatype.UNSIGNED_SHORT : IndexDatatype.UNSIGNED_INT;
        indexBuffer = context.createIndexBuffer(indices, BufferUsage.STATIC_DRAW, indexDatatype);
        indexBuffer.vertexArrayDestroyable = false;
        indexBuffer.referenceCount = 1;
        indexBuffers[context.id] = indexBuffer;
        tileTerrain.mesh.indices.indexBuffers = indexBuffers;
    } else {
        ++indexBuffer.referenceCount;
    }
    tileTerrain.vertexArray = context.createVertexArray(attributes, indexBuffer);
    tileTerrain.state = TerrainState.READY;
}
module.exports = TileTerrain;
},{"../Core/BoundingSphere":98,"../Core/Cartesian3":102,"../Core/ComponentDatatype":113,"../Core/DeveloperError":123,"../Core/IndexDatatype":162,"../Core/TileProviderError":220,"../Core/defined":245,"../Renderer/BufferUsage":339,"../ThirdParty/when":596,"./TerrainState":447,"./terrainAttributeLocations":457}],453:[function(require,module,exports){
var clone = require('../Core/clone'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), EasingFunction = require('../Core/EasingFunction'), getTimestamp = require('../Core/getTimestamp'), TimeConstants = require('../Core/TimeConstants'), TweenJS = require('../ThirdParty/Tween');
'use strict';
var Tween = function (tweens, tweenjs, startObject, stopObject, duration, delay, easingFunction, update, complete, cancel) {
    this._tweens = tweens;
    this._tweenjs = tweenjs;
    this._startObject = clone(startObject);
    this._stopObject = clone(stopObject);
    this._duration = duration;
    this._delay = delay;
    this._easingFunction = easingFunction;
    this._update = update;
    this._complete = complete;
    this.cancel = cancel;
    this.needsStart = true;
};
defineProperties(Tween.prototype, {
    startObject: {
        get: function () {
            return this._startObject;
        }
    },
    stopObject: {
        get: function () {
            return this._stopObject;
        }
    },
    duration: {
        get: function () {
            return this._duration;
        }
    },
    delay: {
        get: function () {
            return this._delay;
        }
    },
    easingFunction: {
        get: function () {
            return this._easingFunction;
        }
    },
    update: {
        get: function () {
            return this._update;
        }
    },
    complete: {
        get: function () {
            return this._complete;
        }
    },
    tweenjs: {
        get: function () {
            return this._tweenjs;
        }
    }
});
Tween.prototype.cancelTween = function () {
    this._tweens.remove(this);
};
var TweenCollection = function () {
    this._tweens = [];
};
defineProperties(TweenCollection.prototype, {
    length: {
        get: function () {
            return this._tweens.length;
        }
    }
});
TweenCollection.prototype.add = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.startObject) || !defined(options.stopObject)) {
        throw new DeveloperError('options.startObject and options.stopObject are required.');
    }
    if (!defined(options.duration) || options.duration < 0) {
        throw new DeveloperError('options.duration is required and must be positive.');
    }
    if (options.duration === 0) {
        if (defined(options.complete)) {
            options.complete();
        }
        return new Tween(this);
    }
    var duration = options.duration / TimeConstants.SECONDS_PER_MILLISECOND;
    var delayInSeconds = defaultValue(options.delay, 0);
    var delay = delayInSeconds / TimeConstants.SECONDS_PER_MILLISECOND;
    var easingFunction = defaultValue(options.easingFunction, EasingFunction.LINEAR_NONE);
    var value = options.startObject;
    var tweenjs = new TweenJS.Tween(value);
    tweenjs.to(clone(options.stopObject), duration);
    tweenjs.delay(delay);
    tweenjs.easing(easingFunction);
    if (defined(options.update)) {
        tweenjs.onUpdate(function () {
            options.update(value);
        });
    }
    tweenjs.onComplete(defaultValue(options.complete, null));
    tweenjs.repeat(defaultValue(options._repeat, 0));
    var tween = new Tween(this, tweenjs, options.startObject, options.stopObject, options.duration, delayInSeconds, easingFunction, options.update, options.complete, options.cancel);
    this._tweens.push(tween);
    return tween;
};
TweenCollection.prototype.addProperty = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var object = options.object;
    var property = options.property;
    var startValue = options.startValue;
    var stopValue = options.stopValue;
    if (!defined(object) || !defined(options.property)) {
        throw new DeveloperError('options.object and options.property are required.');
    }
    if (!defined(object[property])) {
        throw new DeveloperError('options.object must have the specified property.');
    }
    if (!defined(startValue) || !defined(stopValue)) {
        throw new DeveloperError('options.startValue and options.stopValue are required.');
    }
    function update(value) {
        object[property] = value.value;
    }
    return this.add({
        startObject: { value: startValue },
        stopObject: { value: stopValue },
        duration: defaultValue(options.duration, 3),
        delay: options.delay,
        easingFunction: options.easingFunction,
        update: update,
        complete: options.complete,
        cancel: options.cancel,
        _repeat: options._repeat
    });
};
TweenCollection.prototype.addAlpha = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var material = options.material;
    if (!defined(material)) {
        throw new DeveloperError('options.material is required.');
    }
    var properties = [];
    for (var property in material.uniforms) {
        if (material.uniforms.hasOwnProperty(property) && defined(material.uniforms[property]) && defined(material.uniforms[property].alpha)) {
            properties.push(property);
        }
    }
    if (properties.length === 0) {
        throw new DeveloperError('material has no properties with alpha components.');
    }
    function update(value) {
        var length = properties.length;
        for (var i = 0; i < length; ++i) {
            material.uniforms[properties[i]].alpha = value.alpha;
        }
    }
    return this.add({
        startObject: { alpha: defaultValue(options.startValue, 0) },
        stopObject: { alpha: defaultValue(options.stopValue, 1) },
        duration: defaultValue(options.duration, 3),
        delay: options.delay,
        easingFunction: options.easingFunction,
        update: update,
        complete: options.complete,
        cancel: options.cancel
    });
};
TweenCollection.prototype.addOffsetIncrement = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var material = options.material;
    if (!defined(material)) {
        throw new DeveloperError('material is required.');
    }
    if (!defined(material.uniforms.offset)) {
        throw new DeveloperError('material.uniforms must have an offset property.');
    }
    var uniforms = material.uniforms;
    return this.addProperty({
        object: uniforms,
        property: 'offset',
        startValue: uniforms.offset,
        stopValue: uniforms.offset + 1,
        duration: options.duration,
        delay: options.delay,
        easingFunction: options.easingFunction,
        update: options.update,
        cancel: options.cancel,
        _repeat: Infinity
    });
};
TweenCollection.prototype.remove = function (tween) {
    if (!defined(tween)) {
        return false;
    }
    var index = this._tweens.indexOf(tween);
    if (index !== -1) {
        tween.tweenjs.stop();
        if (defined(tween.cancel)) {
            tween.cancel();
        }
        this._tweens.splice(index, 1);
        return true;
    }
    return false;
};
TweenCollection.prototype.removeAll = function () {
    var tweens = this._tweens;
    for (var i = 0; i < tweens.length; ++i) {
        var tween = tweens[i];
        tween.tweenjs.stop();
        if (defined(tween.cancel)) {
            tween.cancel();
        }
    }
    tweens.length = 0;
};
TweenCollection.prototype.contains = function (tween) {
    return defined(tween) && this._tweens.indexOf(tween) !== -1;
};
TweenCollection.prototype.get = function (index) {
    if (!defined(index)) {
        throw new DeveloperError('index is required.');
    }
    return this._tweens[index];
};
TweenCollection.prototype.update = function (time) {
    var tweens = this._tweens;
    var i = 0;
    time = defined(time) ? time / TimeConstants.SECONDS_PER_MILLISECOND : getTimestamp();
    while (i < tweens.length) {
        var tween = tweens[i];
        var tweenjs = tween.tweenjs;
        if (tween.needsStart) {
            tween.needsStart = false;
            tweenjs.start(time);
        } else {
            if (tweenjs.update(time)) {
                i++;
            } else {
                tweenjs.stop();
                tweens.splice(i, 1);
            }
        }
    }
};
module.exports = TweenCollection;
},{"../Core/DeveloperError":123,"../Core/EasingFunction":126,"../Core/TimeConstants":221,"../Core/clone":240,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/getTimestamp":252,"../ThirdParty/Tween":586}],454:[function(require,module,exports){
var freezeObject = require('../Core/freezeObject');
'use strict';
var VerticalOrigin = {
        CENTER: 0,
        BOTTOM: 1,
        TOP: -1
    };
module.exports = freezeObject(VerticalOrigin);
},{"../Core/freezeObject":249}],455:[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), Cartographic = require('../Core/Cartographic'), combine = require('../Core/combine'), Credit = require('../Core/Credit'), defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), freezeObject = require('../Core/freezeObject'), GeographicTilingScheme = require('../Core/GeographicTilingScheme'), loadJson = require('../Core/loadJson'), loadXML = require('../Core/loadXML'), CesiumMath = require('../Core/Math'), objectToQuery = require('../Core/objectToQuery'), queryToObject = require('../Core/queryToObject'), Rectangle = require('../Core/Rectangle'), WebMercatorTilingScheme = require('../Core/WebMercatorTilingScheme'), Uri = require('../ThirdParty/Uri'), when = require('../ThirdParty/when'), ImageryLayerFeatureInfo = require('./ImageryLayerFeatureInfo'), ImageryProvider = require('./ImageryProvider');
'use strict';
function objectToLowercase(obj) {
    var result = {};
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key.toLowerCase()] = obj[key];
        }
    }
    return result;
}
var WebMapServiceImageryProvider = function WebMapServiceImageryProvider(options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    if (!defined(options.url)) {
        throw new DeveloperError('options.url is required.');
    }
    if (!defined(options.layers)) {
        throw new DeveloperError('options.layers is required.');
    }
    this._url = options.url;
    this._tileDiscardPolicy = options.tileDiscardPolicy;
    this._proxy = options.proxy;
    this._layers = options.layers;
    this._enablePickFeatures = defaultValue(options.enablePickFeatures, true);
    this._getFeatureInfoAsGeoJson = defaultValue(options.getFeatureInfoAsGeoJson, true);
    this._getFeatureInfoAsXml = defaultValue(options.getFeatureInfoAsXml, true);
    this._parameters = combine(objectToLowercase(defaultValue(options.parameters, defaultValue.EMPTY_OBJECT)), WebMapServiceImageryProvider.DefaultParameters);
    this._getFeatureInfoParameters = combine(objectToLowercase(defaultValue(options.getFeatureInfoParameters, defaultValue.EMPTY_OBJECT)), WebMapServiceImageryProvider.GetFeatureInfoDefaultParameters);
    this._tileWidth = defaultValue(options.tileWidth, 256);
    this._tileHeight = defaultValue(options.tileHeight, 256);
    this._minimumLevel = defaultValue(options.minimumLevel, 0);
    this._maximumLevel = options.maximumLevel;
    this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);
    this._tilingScheme = defined(options.tilingScheme) ? options.tilingScheme : new GeographicTilingScheme();
    this._rectangle = Rectangle.intersection(this._rectangle, this._tilingScheme.rectangle);
    var credit = options.credit;
    if (typeof credit === 'string') {
        credit = new Credit(credit);
    }
    this._credit = credit;
    this._errorEvent = new Event();
    this._ready = true;
};
defineProperties(WebMapServiceImageryProvider.prototype, {
    url: {
        get: function () {
            return this._url;
        }
    },
    proxy: {
        get: function () {
            return this._proxy;
        }
    },
    layers: {
        get: function () {
            return this._layers;
        }
    },
    tileWidth: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            return this._tileWidth;
        }
    },
    tileHeight: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            return this._tileHeight;
        }
    },
    maximumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            return this._maximumLevel;
        }
    },
    minimumLevel: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            return this._minimumLevel;
        }
    },
    tilingScheme: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            return this._tilingScheme;
        }
    },
    rectangle: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
            }
            return this._rectangle;
        }
    },
    tileDiscardPolicy: {
        get: function () {
            if (!this._ready) {
                throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            return this._tileDiscardPolicy;
        }
    },
    errorEvent: {
        get: function () {
            return this._errorEvent;
        }
    },
    ready: {
        get: function () {
            return this._ready;
        }
    },
    credit: {
        get: function () {
            return this._credit;
        }
    },
    hasAlphaChannel: {
        get: function () {
            return true;
        }
    }
});
WebMapServiceImageryProvider.prototype.getTileCredits = function (x, y, level) {
    return undefined;
};
WebMapServiceImageryProvider.prototype.requestImage = function (x, y, level) {
    if (!this._ready) {
        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }
    var url = buildImageUrl(this, x, y, level);
    return ImageryProvider.loadImage(this, url);
};
var cartographicScratch = new Cartographic();
var cartesian3Scratch = new Cartesian3();
WebMapServiceImageryProvider.prototype.pickFeatures = function (x, y, level, longitude, latitude) {
    if (!this._ready) {
        throw new DeveloperError('pickFeatures must not be called before the imagery provider is ready.');
    }
    if (!this._enablePickFeatures) {
        return undefined;
    }
    var rectangle = this._tilingScheme.tileXYToNativeRectangle(x, y, level);
    var projected;
    if (this._tilingScheme instanceof GeographicTilingScheme) {
        projected = cartesian3Scratch;
        projected.x = CesiumMath.toDegrees(longitude);
        projected.y = CesiumMath.toDegrees(latitude);
    } else {
        var cartographic = cartographicScratch;
        cartographic.longitude = longitude;
        cartographic.latitude = latitude;
        projected = this._tilingScheme.projection.project(cartographic, cartesian3Scratch);
    }
    var i = this._tileWidth * (projected.x - rectangle.west) / rectangle.width | 0;
    var j = this._tileHeight * (rectangle.north - projected.y) / rectangle.height | 0;
    var url;
    if (this._getFeatureInfoAsGeoJson) {
        url = buildGetFeatureInfoUrl(this, 'application/json', x, y, level, i, j);
        var that = this;
        return when(loadJson(url), function (json) {
            return geoJsonToFeatureInfo(json);
        }, function (e) {
            if (!that._getFeatureInfoAsXml) {
                return when.reject(e);
            }
            url = buildGetFeatureInfoUrl(that, 'text/xml', x, y, level, i, j);
            return when(loadXML(url), function (xml) {
                return xmlToFeatureInfo(xml);
            });
        });
    } else if (this._getFeatureInfoAsXml) {
        url = buildGetFeatureInfoUrl(this, 'text/xml', x, y, level, i, j);
        return when(loadXML(url), function (xml) {
            return xmlToFeatureInfo(xml);
        });
    } else {
        return undefined;
    }
};
WebMapServiceImageryProvider.prototype.pickFeatures = function (x, y, level, longitude, latitude) {
    if (!this._ready) {
        throw new DeveloperError('pickFeatures must not be called before the imagery provider is ready.');
    }
    var rectangle = this._tilingScheme.tileXYToRectangle(x, y, level);
    var i = this._tileWidth * (longitude - rectangle.west) / (rectangle.east - rectangle.west) | 0;
    var j = this._tileHeight * (rectangle.north - latitude) / (rectangle.north - rectangle.south) | 0;
    var url;
    if (this._getFeatureInfoAsGeoJson) {
        url = buildGetFeatureInfoUrl(this, 'application/json', x, y, level, i, j);
        var that = this;
        return when(loadJson(url), function (json) {
            return geoJsonToFeatureInfo(json);
        }, function (e) {
            if (!that._getFeatureInfoAsXml) {
                throw e;
            }
            url = buildGetFeatureInfoUrl(that, 'text/xml', x, y, level, i, j);
            return when(loadXML(url), function (xml) {
                return xmlToFeatureInfo(xml);
            });
        });
    } else if (this._getFeatureInfoAsXml) {
        url = buildGetFeatureInfoUrl(this, 'text/xml', x, y, level, i, j);
        return when(loadXML(url), function (xml) {
            return xmlToFeatureInfo(xml);
        });
    } else {
        return undefined;
    }
};
WebMapServiceImageryProvider.DefaultParameters = freezeObject({
    service: 'WMS',
    version: '1.1.1',
    request: 'GetMap',
    styles: '',
    format: 'image/jpeg'
});
WebMapServiceImageryProvider.GetFeatureInfoDefaultParameters = freezeObject({
    service: 'WMS',
    version: '1.1.1',
    request: 'GetFeatureInfo'
});
function buildImageUrl(imageryProvider, x, y, level) {
    var uri = new Uri(imageryProvider._url);
    var queryOptions = queryToObject(defaultValue(uri.query, ''));
    queryOptions = combine(imageryProvider._parameters, queryOptions);
    if (!defined(queryOptions.layers)) {
        queryOptions.layers = imageryProvider._layers;
    }
    if (!defined(queryOptions.srs)) {
        queryOptions.srs = imageryProvider._tilingScheme instanceof WebMercatorTilingScheme ? 'EPSG:3857' : 'EPSG:4326';
    }
    if (!defined(queryOptions.bbox)) {
        var nativeRectangle = imageryProvider._tilingScheme.tileXYToNativeRectangle(x, y, level);
        queryOptions.bbox = nativeRectangle.west + ',' + nativeRectangle.south + ',' + nativeRectangle.east + ',' + nativeRectangle.north;
    }
    if (!defined(queryOptions.width)) {
        queryOptions.width = imageryProvider._tileWidth;
    }
    if (!defined(queryOptions.height)) {
        queryOptions.height = imageryProvider._tileHeight;
    }
    uri.query = objectToQuery(queryOptions);
    var url = uri.toString();
    var proxy = imageryProvider._proxy;
    if (defined(proxy)) {
        url = proxy.getURL(url);
    }
    return url;
}
function buildGetFeatureInfoUrl(imageryProvider, infoFormat, x, y, level, i, j) {
    var uri = new Uri(imageryProvider._url);
    var queryOptions = queryToObject(defaultValue(uri.query, ''));
    queryOptions = combine(imageryProvider._getFeatureInfoParameters, queryOptions);
    if (!defined(queryOptions.layers)) {
        queryOptions.layers = imageryProvider._layers;
    }
    if (!defined(queryOptions.query_layers)) {
        queryOptions.query_layers = imageryProvider._layers;
    }
    if (!defined(queryOptions.srs)) {
        queryOptions.srs = imageryProvider._tilingScheme instanceof WebMercatorTilingScheme ? 'EPSG:3857' : 'EPSG:4326';
    }
    if (!defined(queryOptions.bbox)) {
        var nativeRectangle = imageryProvider._tilingScheme.tileXYToNativeRectangle(x, y, level);
        queryOptions.bbox = nativeRectangle.west + ',' + nativeRectangle.south + ',' + nativeRectangle.east + ',' + nativeRectangle.north;
    }
    if (!defined(queryOptions.x)) {
        queryOptions.x = i;
    }
    if (!defined(queryOptions.y)) {
        queryOptions.y = j;
    }
    if (!defined(queryOptions.width)) {
        queryOptions.width = imageryProvider._tileWidth;
    }
    if (!defined(queryOptions.height)) {
        queryOptions.height = imageryProvider._tileHeight;
    }
    if (!defined(queryOptions.info_format)) {
        queryOptions.info_format = infoFormat;
    }
    uri.query = objectToQuery(queryOptions);
    var url = uri.toString();
    var proxy = imageryProvider._proxy;
    if (defined(proxy)) {
        url = proxy.getURL(url);
    }
    return url;
}
function geoJsonToFeatureInfo(json) {
    var result = [];
    var features = json.features;
    for (var i = 0; i < features.length; ++i) {
        var feature = features[i];
        var featureInfo = new ImageryLayerFeatureInfo();
        featureInfo.data = feature;
        featureInfo.configureNameFromProperties(feature.properties);
        featureInfo.configureDescriptionFromProperties(feature.properties);
        if (feature.geometry && feature.geometry.type === 'Point') {
            var longitude = feature.geometry.coordinates[0];
            var latitude = feature.geometry.coordinates[1];
            featureInfo.position = Cartographic.fromDegrees(longitude, latitude);
        }
        result.push(featureInfo);
    }
    return result;
}
var mapInfoMxpNamespace = 'http://www.mapinfo.com/mxp';
var esriWmsNamespace = 'http://www.esri.com/wms';
function xmlToFeatureInfo(xml) {
    var documentElement = xml.documentElement;
    if (documentElement.localName === 'MultiFeatureCollection' && documentElement.namespaceURI === mapInfoMxpNamespace) {
        return mapInfoXmlToFeatureInfo(xml);
    } else if (documentElement.localName === 'FeatureInfoResponse' && documentElement.namespaceURI === esriWmsNamespace) {
        return esriXmlToFeatureInfo(xml);
    } else if (documentElement.localName === 'ServiceExceptionReport') {
        return undefined;
    } else {
        return unknownXmlToFeatureInfo(xml);
    }
}
function mapInfoXmlToFeatureInfo(xml) {
    var result = [];
    var multiFeatureCollection = xml.documentElement;
    var features = multiFeatureCollection.getElementsByTagNameNS(mapInfoMxpNamespace, 'Feature');
    for (var featureIndex = 0; featureIndex < features.length; ++featureIndex) {
        var feature = features[featureIndex];
        var properties = {};
        var propertyElements = feature.getElementsByTagNameNS(mapInfoMxpNamespace, 'Val');
        for (var propertyIndex = 0; propertyIndex < propertyElements.length; ++propertyIndex) {
            var propertyElement = propertyElements[propertyIndex];
            if (propertyElement.hasAttribute('ref')) {
                var name = propertyElement.getAttribute('ref');
                var value = propertyElement.textContent.trim();
                properties[name] = value;
            }
        }
        var featureInfo = new ImageryLayerFeatureInfo();
        featureInfo.data = feature;
        featureInfo.configureNameFromProperties(properties);
        featureInfo.configureDescriptionFromProperties(properties);
        result.push(featureInfo);
    }
    return result;
}
function esriXmlToFeatureInfo(xml) {
    var result = [];
    var featureInfoResponse = xml.documentElement;
    var features = featureInfoResponse.getElementsByTagNameNS(esriWmsNamespace, 'FIELDS');
    for (var featureIndex = 0; featureIndex < features.length; ++featureIndex) {
        var feature = features[featureIndex];
        var properties = {};
        var propertyAttributes = feature.attributes;
        for (var attributeIndex = 0; attributeIndex < propertyAttributes.length; ++attributeIndex) {
            var attribute = propertyAttributes[attributeIndex];
            properties[attribute.name] = attribute.value;
        }
        var featureInfo = new ImageryLayerFeatureInfo();
        featureInfo.data = feature;
        featureInfo.configureNameFromProperties(properties);
        featureInfo.configureDescriptionFromProperties(properties);
        result.push(featureInfo);
    }
    return result;
}
function unknownXmlToFeatureInfo(xml) {
    var xmlText = new XMLSerializer().serializeToString(xml);
    var element = document.createElement('div');
    var pre = document.createElement('pre');
    pre.textContent = xmlText;
    element.appendChild(pre);
    var featureInfo = new ImageryLayerFeatureInfo();
    featureInfo.data = xml;
    featureInfo.description = element.innerHTML;
    return [featureInfo];
}
module.exports = WebMapServiceImageryProvider;
},{"../Core/Cartesian3":102,"../Core/Cartographic":104,"../Core/Credit":118,"../Core/DeveloperError":123,"../Core/Event":138,"../Core/GeographicTilingScheme":144,"../Core/Math":174,"../Core/Rectangle":201,"../Core/WebMercatorTilingScheme":234,"../Core/combine":241,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../Core/freezeObject":249,"../Core/loadJson":261,"../Core/loadXML":264,"../Core/objectToQuery":266,"../Core/queryToObject":269,"../ThirdParty/Uri":587,"../ThirdParty/when":596,"./ImageryLayerFeatureInfo":398,"./ImageryProvider":399}],456:[function(require,module,exports){
var ComponentDatatype = require('../Core/ComponentDatatype');
'use strict';
var ComponentsPerAttribute = {
        'SCALAR': 1,
        'VEC2': 2,
        'VEC3': 3,
        'VEC4': 4,
        'MAT2': 4,
        'MAT3': 9,
        'MAT4': 16
    };
var getModelAccessor = function (accessor) {
    var componentDatatype = accessor.componentType;
    var componentsPerAttribute = ComponentsPerAttribute[accessor.type];
    return {
        componentsPerAttribute: componentsPerAttribute,
        createArrayBufferView: function (buffer, byteOffset, length) {
            return ComponentDatatype.createArrayBufferView(componentDatatype, buffer, byteOffset, componentsPerAttribute * length);
        }
    };
};
module.exports = getModelAccessor;
},{"../Core/ComponentDatatype":113}],457:[function(require,module,exports){
'use strict';
module.exports = {
    position3DAndHeight: 0,
    textureCoordAndEncodedNormals: 1
};
},{}],458:[function(require,module,exports){
'use strict';
module.exports = '#ifdef MRT\n#extension GL_EXT_draw_buffers : enable\n#endif\n\nuniform vec4 u_bgColor;\nuniform sampler2D u_depthTexture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    if (texture2D(u_depthTexture, v_textureCoordinates).r < 1.0)\n    {\n#ifdef MRT\n        gl_FragData[0] = u_bgColor;\n        gl_FragData[1] = vec4(u_bgColor.a);\n#else\n        gl_FragColor = u_bgColor;\n#endif\n        return;\n    }\n    \n    discard;\n}';
},{}],459:[function(require,module,exports){
'use strict';
module.exports = 'varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_binormalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC; \n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_binormalEC);\n\n\tvec3 normalEC;\n#ifdef FACE_FORWARD\n    normalEC = normalize(faceforward(v_normalEC, vec3(0.0, 0.0, 1.0), -v_normalEC));\n#else\n    normalEC = normalize(v_normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n    \n#ifdef FLAT    \n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n';
},{}],460:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 binormal;\nattribute vec2 st;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_binormalEC;\nvarying vec2 v_st;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\n    v_binormalEC = czm_normal * binormal;                     // binormal in eye coordinates\n    v_st = st;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n';
},{}],461:[function(require,module,exports){
'use strict';
module.exports = 'varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC; \n\n\tvec3 normalEC;\n#ifdef FACE_FORWARD\n    normalEC = normalize(faceforward(v_normalEC, vec3(0.0, 0.0, 1.0), -v_normalEC));\n#else\n    normalEC = normalize(v_normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getMaterial(materialInput);\n    \n#ifdef FLAT    \n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n';
},{}],462:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n';
},{}],463:[function(require,module,exports){
'use strict';
module.exports = 'varying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n    \n\tvec3 normalEC = czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));\n#ifdef FACE_FORWARD\n    normalEC = normalize(faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC));\n#else\n    normalEC = normalize(normalEC);\n#endif\n    \n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n    \n    // Convert tangent space material normal to eye space\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n    \n    // Convert view vector to world space\n    vec3 positionToEyeEC = -v_positionEC; \n    materialInput.positionToEyeEC = positionToEyeEC;\n\n    czm_material material = czm_getMaterial(materialInput);\n    \n#ifdef FLAT    \n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n';
},{}],464:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec2 st;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_st;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n    v_st = st;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n';
},{}],465:[function(require,module,exports){
'use strict';
module.exports = 'varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n    \n\tvec3 normalEC;\n#ifdef FACE_FORWARD\n    normalEC = normalize(faceforward(v_normalEC, vec3(0.0, 0.0, 1.0), -v_normalEC));\n#else\n    normalEC = normalize(v_normalEC);\n#endif\n    \n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = v_color.rgb;\n    material.alpha = v_color.a;\n    \n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n}\n';
},{}],466:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec4 color;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n';
},{}],467:[function(require,module,exports){
'use strict';
module.exports = 'varying vec4 v_color;\n\nvoid main()\n{\n    gl_FragColor = v_color;\n}\n';
},{}],468:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec4 color;\n\nvarying vec4 v_color;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n';
},{}],469:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec4 color;\n\nvarying vec4 v_color;\n\nvoid main() \n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n    \n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n    \n    v_color = color;\n    \n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev);\n    gl_Position = czm_viewportOrthographic * positionWC;\n}\n';
},{}],470:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec2 st;\n\nvarying float v_width;\nvarying vec2 v_st;\n\nvoid main() \n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n    \n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n    \n    v_width = width;\n    v_st = st;\n    \n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev);\n    gl_Position = czm_viewportOrthographic * positionWC;\n}\n';
},{}],471:[function(require,module,exports){
'use strict';
module.exports = 'varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC; \n\n\tvec3 normalEC;\n#ifdef FACE_FORWARD\n    normalEC = normalize(faceforward(v_normalEC, vec3(0.0, 0.0, 1.0), -v_normalEC));\n#else\n    normalEC = normalize(v_normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n    \n#ifdef FLAT    \n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n';
},{}],472:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main() \n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_st = st;\n    \n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n';
},{}],473:[function(require,module,exports){
'use strict';
module.exports = 'uniform sampler2D u_atlas;\n\nvarying vec2 v_textureCoordinates;\n\n#ifdef RENDER_FOR_PICK\nvarying vec4 v_pickColor;\n#else\nvarying vec4 v_color;\n#endif\n\nvoid main()\n{\n#ifdef RENDER_FOR_PICK\n    vec4 vertexColor = vec4(1.0, 1.0, 1.0, 1.0);\n#else\n    vec4 vertexColor = v_color;\n#endif\n    \n    vec4 color = texture2D(u_atlas, v_textureCoordinates) * vertexColor;\n    if (color.a == 0.0)\n    {\n        discard;\n    }\n    \n#ifdef RENDER_FOR_PICK\n    gl_FragColor = v_pickColor;\n#else\n    gl_FragColor = color;\n#endif\n}';
},{}],474:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec4 positionHighAndScale;\nattribute vec4 positionLowAndRotation;   \nattribute vec4 compressedAttribute0;        // pixel offset, translate, horizontal origin, vertical origin, show, texture coordinates, direction\nattribute vec4 compressedAttribute1;        // aligned axis, translucency by distance, image width\nattribute vec4 compressedAttribute2;        // image height, color, pick color, 2 bytes free\nattribute vec3 eyeOffset;                   // eye offset in meters\nattribute vec4 scaleByDistance;             // near, nearScale, far, farScale\nattribute vec4 pixelOffsetScaleByDistance;  // near, nearScale, far, farScale\n\nvarying vec2 v_textureCoordinates;\n\n#ifdef RENDER_FOR_PICK\nvarying vec4 v_pickColor;\n#else\nvarying vec4 v_color;\n#endif\n\nfloat getNearFarScalar(vec4 nearFarScalar, float cameraDistSq)\n{\n    float valueAtMin = nearFarScalar.y;\n    float valueAtMax = nearFarScalar.w;\n    float nearDistanceSq = nearFarScalar.x * nearFarScalar.x;\n    float farDistanceSq = nearFarScalar.z * nearFarScalar.z;\n\n    float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq);\n\n    t = pow(clamp(t, 0.0, 1.0), 0.2);\n\n    return mix(valueAtMin, valueAtMax, t);\n}\n\nconst float UPPER_BOUND = 32768.0;\n\nconst float SHIFT_LEFT16 = 65536.0;\nconst float SHIFT_LEFT8 = 256.0;\nconst float SHIFT_LEFT7 = 128.0;\nconst float SHIFT_LEFT5 = 32.0;\nconst float SHIFT_LEFT3 = 8.0;\nconst float SHIFT_LEFT2 = 4.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\nconst float SHIFT_RIGHT7 = 1.0 / 128.0;\nconst float SHIFT_RIGHT5 = 1.0 / 32.0;\nconst float SHIFT_RIGHT3 = 1.0 / 8.0;\nconst float SHIFT_RIGHT2 = 1.0 / 4.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nvoid main() \n{\n    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition\n    \n    // unpack attributes\n    vec3 positionHigh = positionHighAndScale.xyz;\n    vec3 positionLow = positionLowAndRotation.xyz;\n    float scale = positionHighAndScale.w;\n    \n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    float rotation = positionLowAndRotation.w;\n#endif\n\n    float compressed = compressedAttribute0.x;\n    \n    vec2 pixelOffset;\n    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);\n    compressed -= pixelOffset.x * SHIFT_LEFT7;\n    pixelOffset.x -= UPPER_BOUND;\n    \n    vec2 origin;\n    origin.x = floor(compressed * SHIFT_RIGHT5);\n    compressed -= origin.x * SHIFT_LEFT5;\n    \n    origin.y = floor(compressed * SHIFT_RIGHT3);\n    compressed -= origin.y * SHIFT_LEFT3;\n    \n    origin -= vec2(1.0);\n    \n    float show = floor(compressed * SHIFT_RIGHT2);\n    compressed -= show * SHIFT_LEFT2;\n    \n    vec2 direction;\n    direction.x = floor(compressed * SHIFT_RIGHT1);\n    direction.y = compressed - direction.x * SHIFT_LEFT1;\n    \n    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;\n    pixelOffset.y = -(floor(temp) - UPPER_BOUND);\n    \n    vec2 translate;\n    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;\n    \n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\n    translate.x = floor(temp) - UPPER_BOUND;\n    \n    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;\n    translate.y -= UPPER_BOUND;\n    \n    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);\n    \n    temp = compressedAttribute1.x * SHIFT_RIGHT8;\n    \n    vec2 imageSize = vec2(floor(temp), compressedAttribute2.w);\n    \n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    vec4 translucencyByDistance;\n    translucencyByDistance.x = compressedAttribute1.z;\n    translucencyByDistance.z = compressedAttribute1.w;\n    \n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n    \n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n#endif\n\n#ifdef ALIGNED_AXIS\n    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));\n#else\n    vec3 alignedAxis = vec3(0.0);\n#endif\n    \n#ifdef RENDER_FOR_PICK\n    temp = compressedAttribute2.y;\n#else\n    temp = compressedAttribute2.x;\n#endif\n\n    vec4 color;\n    temp = temp * SHIFT_RIGHT8;\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    color.r = floor(temp);\n    \n    temp = compressedAttribute2.z * SHIFT_RIGHT8;\n    \n#ifdef RENDER_FOR_PICK\n    color.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    vec4 pickColor = color / 255.0;\n#else\n    color.a = floor(temp);\n    color /= 255.0;\n#endif\n    \n    ///////////////////////////////////////////////////////////////////////////\n    \n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n    positionEC = czm_eyeOffset(positionEC, eyeOffset);\n    positionEC.xyz *= show;\n    \n    ///////////////////////////////////////////////////////////////////////////     \n\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET)\n    float lengthSq;\n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        // 2D camera distance is a special case\n        // treat all billboards as flattened to the z=0.0 plane\n        lengthSq = czm_eyeHeight2D.y;\n    }\n    else\n    {\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_SCALING\n    scale *= getNearFarScalar(scaleByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (scale == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    float translucency = 1.0;\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    translucency = getNearFarScalar(translucencyByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (translucency == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_PIXEL_OFFSET\n    float pixelOffsetScale = getNearFarScalar(pixelOffsetScaleByDistance, lengthSq);\n    pixelOffset *= pixelOffsetScale;\n#endif\n\n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n    \n    vec2 halfSize = imageSize * scale * czm_resolutionScale;\n    halfSize *= ((direction * 2.0) - 1.0);\n    \n    positionWC.xy += (origin * abs(halfSize));\n    \n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    if (!all(equal(alignedAxis, vec3(0.0))) || rotation != 0.0)\n    {\n        float angle = rotation;\n        if (!all(equal(alignedAxis, vec3(0.0))))\n        {\n            vec3 pos = positionEC.xyz + czm_encodedCameraPositionMCHigh + czm_encodedCameraPositionMCLow;\n            vec3 normal = normalize(cross(alignedAxis, pos));\n            vec4 tangent = vec4(normalize(cross(pos, normal)), 0.0);\n            tangent = czm_modelViewProjection * tangent;\n            angle += sign(-tangent.x) * acos(tangent.y / length(tangent.xy));\n        }\n        \n        float cosTheta = cos(angle);\n        float sinTheta = sin(angle);\n        mat2 rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\n        halfSize = rotationMatrix * halfSize;\n    }\n#endif\n    \n    positionWC.xy += halfSize;\n    positionWC.xy += translate;\n    positionWC.xy += (pixelOffset * czm_resolutionScale);\n\n    gl_Position = czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\n    v_textureCoordinates = textureCoordinates;\n\n#ifdef RENDER_FOR_PICK\n    v_pickColor = pickColor;\n#else\n    v_color = color;\n    v_color.a *= translucency;\n#endif\n}\n';
},{}],475:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for converting radians to degrees.\n *\n * @alias czm_degreesPerRadian\n * @glslConstant\n *\n * @see CesiumMath.DEGREES_PER_RADIAN\n *\n * @example\n * // GLSL declaration\n * const float czm_degreesPerRadian = ...;\n *\n * // Example\n * float deg = czm_degreesPerRadian * rad;\n */\nconst float czm_degreesPerRadian = 57.29577951308232;';
},{}],476:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL vec2 constant for defining the depth range.\n * This is a workaround to a bug where IE11 does not implement gl_DepthRange.\n *\n * @alias czm_depthRange\n * @glslConstant\n *\n * @example\n * // GLSL declaration\n * float depthRangeNear = czm_depthRange.near;\n * float depthRangeFar = czm_depthRange.far;\n *\n */\nconst czm_depthRangeStruct czm_depthRange = czm_depthRangeStruct(0.0, 1.0);';
},{}],477:[function(require,module,exports){
'use strict';
module.exports = '/**\n * 0.1\n *\n * @name czm_epsilon1\n * @glslConstant\n */\nconst float czm_epsilon1 = 0.1;';
},{}],478:[function(require,module,exports){
'use strict';
module.exports = '/**\n * 0.01\n *\n * @name czm_epsilon2\n * @glslConstant\n */\nconst float czm_epsilon2 = 0.01;';
},{}],479:[function(require,module,exports){
'use strict';
module.exports = '/**\n * 0.001\n *\n * @name czm_epsilon3\n * @glslConstant\n */\nconst float czm_epsilon3 = 0.001;';
},{}],480:[function(require,module,exports){
'use strict';
module.exports = '/**\n * 0.0001\n *\n * @name czm_epsilon4\n * @glslConstant\n */\nconst float czm_epsilon4 = 0.0001;';
},{}],481:[function(require,module,exports){
'use strict';
module.exports = '/**\n * 0.00001\n *\n * @name czm_epsilon5\n * @glslConstant\n */\nconst float czm_epsilon5 = 0.00001;';
},{}],482:[function(require,module,exports){
'use strict';
module.exports = '/**\n * 0.000001\n *\n * @name czm_epsilon6\n * @glslConstant\n */\nconst float czm_epsilon6 = 0.000001;';
},{}],483:[function(require,module,exports){
'use strict';
module.exports = '/**\n * 0.0000001\n *\n * @name czm_epsilon7\n * @glslConstant\n */\nconst float czm_epsilon7 = 0.0000001;';
},{}],484:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_infinity\n * @glslConstant\n */\nconst float czm_infinity = 5906376272000.0;  // Distance from the Sun to Pluto in meters.  TODO: What is best given lowp, mediump, and highp?';
},{}],485:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>1/pi</code>.\n *\n * @alias czm_oneOverPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverPi = ...;\n *\n * // Example\n * float pi = 1.0 / czm_oneOverPi;\n */\nconst float czm_oneOverPi = 0.3183098861837907;';
},{}],486:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>1/2pi</code>.\n *\n * @alias czm_oneOverTwoPi\n * @glslConstant\n *\n * @see CesiumMath.ONE_OVER_TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_oneOverTwoPi = ...;\n *\n * // Example\n * float pi = 2.0 * czm_oneOverTwoPi;\n */\nconst float czm_oneOverTwoPi = 0.15915494309189535;';
},{}],487:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>Math.PI</code>.\n *\n * @alias czm_pi\n * @glslConstant\n *\n * @see CesiumMath.PI\n *\n * @example\n * // GLSL declaration\n * const float czm_pi = ...;\n *\n * // Example\n * float twoPi = 2.0 * czm_pi;\n */\nconst float czm_pi = 3.141592653589793;';
},{}],488:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>pi/4</code>.\n *\n * @alias czm_piOverFour\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_FOUR\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverFour = ...;\n *\n * // Example\n * float pi = 4.0 * czm_piOverFour;\n */\nconst float czm_piOverFour = 0.7853981633974483;';
},{}],489:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>pi/6</code>.\n *\n * @alias czm_piOverSix\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_SIX\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverSix = ...;\n *\n * // Example\n * float pi = 6.0 * czm_piOverSix;\n */\nconst float czm_piOverSix = 0.5235987755982988;';
},{}],490:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>pi/3</code>.\n *\n * @alias czm_piOverThree\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_THREE\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverThree = ...;\n *\n * // Example\n * float pi = 3.0 * czm_piOverThree;\n */\nconst float czm_piOverThree = 1.0471975511965976;';
},{}],491:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>pi/2</code>.\n *\n * @alias czm_piOverTwo\n * @glslConstant\n *\n * @see CesiumMath.PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_piOverTwo = ...;\n *\n * // Example\n * float pi = 2.0 * czm_piOverTwo;\n */\nconst float czm_piOverTwo = 1.5707963267948966;';
},{}],492:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for converting degrees to radians.\n *\n * @alias czm_radiansPerDegree\n * @glslConstant\n *\n * @see CesiumMath.RADIANS_PER_DEGREE\n *\n * @example\n * // GLSL declaration\n * const float czm_radiansPerDegree = ...;\n *\n * // Example\n * float rad = czm_radiansPerDegree * deg;\n */\nconst float czm_radiansPerDegree = 0.017453292519943295;';
},{}],493:[function(require,module,exports){
'use strict';
module.exports = '/**\n * The constant identifier for the 2D {@link SceneMode}\n *\n * @name czm_sceneMode2D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode2D = 2.0;';
},{}],494:[function(require,module,exports){
'use strict';
module.exports = '/**\n * The constant identifier for the 3D {@link SceneMode}\n *\n * @name czm_sceneMode3D\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneMode3D = 3.0;';
},{}],495:[function(require,module,exports){
'use strict';
module.exports = '/**\n * The constant identifier for the Columbus View {@link SceneMode}\n *\n * @name czm_sceneModeColumbusView\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneMode3D\n * @see czm_sceneModeMorphing\n */\nconst float czm_sceneModeColumbusView = 1.0;';
},{}],496:[function(require,module,exports){
'use strict';
module.exports = '/**\n * The constant identifier for the Morphing {@link SceneMode}\n *\n * @name czm_sceneModeMorphing\n * @glslConstant\n * @see czm_sceneMode\n * @see czm_sceneMode2D\n * @see czm_sceneModeColumbusView\n * @see czm_sceneMode3D\n */\nconst float czm_sceneModeMorphing = 0.0;';
},{}],497:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for one solar radius.\n *\n * @alias czm_solarRadius\n * @glslConstant\n *\n * @see CesiumMath.SOLAR_RADIUS\n *\n * @example\n * // GLSL declaration\n * const float czm_solarRadius = ...;\n */\nconst float czm_solarRadius = 695500000.0;';
},{}],498:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>3pi/2</code>.\n *\n * @alias czm_threePiOver2\n * @glslConstant\n *\n * @see CesiumMath.THREE_PI_OVER_TWO\n *\n * @example\n * // GLSL declaration\n * const float czm_threePiOver2 = ...;\n *\n * // Example\n * float pi = (2.0 / 3.0) * czm_threePiOver2;\n */\nconst float czm_threePiOver2 = 4.71238898038469;';
},{}],499:[function(require,module,exports){
'use strict';
module.exports = '/**\n * A built-in GLSL floating-point constant for <code>2pi</code>.\n *\n * @alias czm_twoPi\n * @glslConstant\n *\n * @see CesiumMath.TWO_PI\n *\n * @example\n * // GLSL declaration\n * const float czm_twoPi = ...;\n *\n * // Example\n * float pi = czm_twoPi / 2.0;\n */\nconst float czm_twoPi = 6.283185307179586;';
},{}],500:[function(require,module,exports){
'use strict';
module.exports = '/**\n * The maximum latitude, in radians, both North and South, supported by a Web Mercator\n * (EPSG:3857) projection.  Technically, the Mercator projection is defined\n * for any latitude up to (but not including) 90 degrees, but it makes sense\n * to cut it off sooner because it grows exponentially with increasing latitude.\n * The logic behind this particular cutoff value, which is the one used by\n * Google Maps, Bing Maps, and Esri, is that it makes the projection\n * square.  That is, the rectangle is equal in the X and Y directions.\n *\n * The constant value is computed as follows:\n *   czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi)))\n *\n * @name czm_webMercatorMaxLatitude\n * @glslConstant\n */\nconst float czm_webMercatorMaxLatitude = 1.4844222297453324;';
},{}],501:[function(require,module,exports){
var czm_degreesPerRadian = require('./Constants/degreesPerRadian'), czm_depthRange = require('./Constants/depthRange'), czm_epsilon1 = require('./Constants/epsilon1'), czm_epsilon2 = require('./Constants/epsilon2'), czm_epsilon3 = require('./Constants/epsilon3'), czm_epsilon4 = require('./Constants/epsilon4'), czm_epsilon5 = require('./Constants/epsilon5'), czm_epsilon6 = require('./Constants/epsilon6'), czm_epsilon7 = require('./Constants/epsilon7'), czm_infinity = require('./Constants/infinity'), czm_oneOverPi = require('./Constants/oneOverPi'), czm_oneOverTwoPi = require('./Constants/oneOverTwoPi'), czm_pi = require('./Constants/pi'), czm_piOverFour = require('./Constants/piOverFour'), czm_piOverSix = require('./Constants/piOverSix'), czm_piOverThree = require('./Constants/piOverThree'), czm_piOverTwo = require('./Constants/piOverTwo'), czm_radiansPerDegree = require('./Constants/radiansPerDegree'), czm_sceneMode2D = require('./Constants/sceneMode2D'), czm_sceneMode3D = require('./Constants/sceneMode3D'), czm_sceneModeColumbusView = require('./Constants/sceneModeColumbusView'), czm_sceneModeMorphing = require('./Constants/sceneModeMorphing'), czm_solarRadius = require('./Constants/solarRadius'), czm_threePiOver2 = require('./Constants/threePiOver2'), czm_twoPi = require('./Constants/twoPi'), czm_webMercatorMaxLatitude = require('./Constants/webMercatorMaxLatitude'), czm_depthRangeStruct = require('./Structs/depthRangeStruct'), czm_ellipsoid = require('./Structs/ellipsoid'), czm_material = require('./Structs/material'), czm_materialInput = require('./Structs/materialInput'), czm_ray = require('./Structs/ray'), czm_raySegment = require('./Structs/raySegment'), czm_RGBToXYZ = require('./Functions/RGBToXYZ'), czm_XYZToRGB = require('./Functions/XYZToRGB'), czm_alphaWeight = require('./Functions/alphaWeight'), czm_antialias = require('./Functions/antialias'), czm_columbusViewMorph = require('./Functions/columbusViewMorph'), czm_computePosition = require('./Functions/computePosition'), czm_cosineAndSine = require('./Functions/cosineAndSine'), czm_decompressTextureCoordinates = require('./Functions/decompressTextureCoordinates'), czm_eastNorthUpToEyeCoordinates = require('./Functions/eastNorthUpToEyeCoordinates'), czm_ellipsoidContainsPoint = require('./Functions/ellipsoidContainsPoint'), czm_ellipsoidNew = require('./Functions/ellipsoidNew'), czm_ellipsoidWgs84TextureCoordinates = require('./Functions/ellipsoidWgs84TextureCoordinates'), czm_equalsEpsilon = require('./Functions/equalsEpsilon'), czm_eyeOffset = require('./Functions/eyeOffset'), czm_eyeToWindowCoordinates = require('./Functions/eyeToWindowCoordinates'), czm_geodeticSurfaceNormal = require('./Functions/geodeticSurfaceNormal'), czm_getDefaultMaterial = require('./Functions/getDefaultMaterial'), czm_getLambertDiffuse = require('./Functions/getLambertDiffuse'), czm_getSpecular = require('./Functions/getSpecular'), czm_getWaterNoise = require('./Functions/getWaterNoise'), czm_getWgs84EllipsoidEC = require('./Functions/getWgs84EllipsoidEC'), czm_hue = require('./Functions/hue'), czm_isEmpty = require('./Functions/isEmpty'), czm_isFull = require('./Functions/isFull'), czm_latitudeToWebMercatorFraction = require('./Functions/latitudeToWebMercatorFraction'), czm_luminance = require('./Functions/luminance'), czm_modelToWindowCoordinates = require('./Functions/modelToWindowCoordinates'), czm_multiplyWithColorBalance = require('./Functions/multiplyWithColorBalance'), czm_octDecode = require('./Functions/octDecode'), czm_phong = require('./Functions/phong'), czm_pointAlongRay = require('./Functions/pointAlongRay'), czm_rayEllipsoidIntersectionInterval = require('./Functions/rayEllipsoidIntersectionInterval'), czm_saturation = require('./Functions/saturation'), czm_signNotZero = require('./Functions/signNotZero'), czm_tangentToEyeSpaceMatrix = require('./Functions/tangentToEyeSpaceMatrix'), czm_translateRelativeToEye = require('./Functions/translateRelativeToEye'), czm_translucentPhong = require('./Functions/translucentPhong'), czm_transpose = require('./Functions/transpose'), czm_windowToEyeCoordinates = require('./Functions/windowToEyeCoordinates');
'use strict';
module.exports = {
    czm_degreesPerRadian: czm_degreesPerRadian,
    czm_depthRange: czm_depthRange,
    czm_epsilon1: czm_epsilon1,
    czm_epsilon2: czm_epsilon2,
    czm_epsilon3: czm_epsilon3,
    czm_epsilon4: czm_epsilon4,
    czm_epsilon5: czm_epsilon5,
    czm_epsilon6: czm_epsilon6,
    czm_epsilon7: czm_epsilon7,
    czm_infinity: czm_infinity,
    czm_oneOverPi: czm_oneOverPi,
    czm_oneOverTwoPi: czm_oneOverTwoPi,
    czm_pi: czm_pi,
    czm_piOverFour: czm_piOverFour,
    czm_piOverSix: czm_piOverSix,
    czm_piOverThree: czm_piOverThree,
    czm_piOverTwo: czm_piOverTwo,
    czm_radiansPerDegree: czm_radiansPerDegree,
    czm_sceneMode2D: czm_sceneMode2D,
    czm_sceneMode3D: czm_sceneMode3D,
    czm_sceneModeColumbusView: czm_sceneModeColumbusView,
    czm_sceneModeMorphing: czm_sceneModeMorphing,
    czm_solarRadius: czm_solarRadius,
    czm_threePiOver2: czm_threePiOver2,
    czm_twoPi: czm_twoPi,
    czm_webMercatorMaxLatitude: czm_webMercatorMaxLatitude,
    czm_depthRangeStruct: czm_depthRangeStruct,
    czm_ellipsoid: czm_ellipsoid,
    czm_material: czm_material,
    czm_materialInput: czm_materialInput,
    czm_ray: czm_ray,
    czm_raySegment: czm_raySegment,
    czm_RGBToXYZ: czm_RGBToXYZ,
    czm_XYZToRGB: czm_XYZToRGB,
    czm_alphaWeight: czm_alphaWeight,
    czm_antialias: czm_antialias,
    czm_columbusViewMorph: czm_columbusViewMorph,
    czm_computePosition: czm_computePosition,
    czm_cosineAndSine: czm_cosineAndSine,
    czm_decompressTextureCoordinates: czm_decompressTextureCoordinates,
    czm_eastNorthUpToEyeCoordinates: czm_eastNorthUpToEyeCoordinates,
    czm_ellipsoidContainsPoint: czm_ellipsoidContainsPoint,
    czm_ellipsoidNew: czm_ellipsoidNew,
    czm_ellipsoidWgs84TextureCoordinates: czm_ellipsoidWgs84TextureCoordinates,
    czm_equalsEpsilon: czm_equalsEpsilon,
    czm_eyeOffset: czm_eyeOffset,
    czm_eyeToWindowCoordinates: czm_eyeToWindowCoordinates,
    czm_geodeticSurfaceNormal: czm_geodeticSurfaceNormal,
    czm_getDefaultMaterial: czm_getDefaultMaterial,
    czm_getLambertDiffuse: czm_getLambertDiffuse,
    czm_getSpecular: czm_getSpecular,
    czm_getWaterNoise: czm_getWaterNoise,
    czm_getWgs84EllipsoidEC: czm_getWgs84EllipsoidEC,
    czm_hue: czm_hue,
    czm_isEmpty: czm_isEmpty,
    czm_isFull: czm_isFull,
    czm_latitudeToWebMercatorFraction: czm_latitudeToWebMercatorFraction,
    czm_luminance: czm_luminance,
    czm_modelToWindowCoordinates: czm_modelToWindowCoordinates,
    czm_multiplyWithColorBalance: czm_multiplyWithColorBalance,
    czm_octDecode: czm_octDecode,
    czm_phong: czm_phong,
    czm_pointAlongRay: czm_pointAlongRay,
    czm_rayEllipsoidIntersectionInterval: czm_rayEllipsoidIntersectionInterval,
    czm_saturation: czm_saturation,
    czm_signNotZero: czm_signNotZero,
    czm_tangentToEyeSpaceMatrix: czm_tangentToEyeSpaceMatrix,
    czm_translateRelativeToEye: czm_translateRelativeToEye,
    czm_translucentPhong: czm_translucentPhong,
    czm_transpose: czm_transpose,
    czm_windowToEyeCoordinates: czm_windowToEyeCoordinates
};
},{"./Constants/degreesPerRadian":475,"./Constants/depthRange":476,"./Constants/epsilon1":477,"./Constants/epsilon2":478,"./Constants/epsilon3":479,"./Constants/epsilon4":480,"./Constants/epsilon5":481,"./Constants/epsilon6":482,"./Constants/epsilon7":483,"./Constants/infinity":484,"./Constants/oneOverPi":485,"./Constants/oneOverTwoPi":486,"./Constants/pi":487,"./Constants/piOverFour":488,"./Constants/piOverSix":489,"./Constants/piOverThree":490,"./Constants/piOverTwo":491,"./Constants/radiansPerDegree":492,"./Constants/sceneMode2D":493,"./Constants/sceneMode3D":494,"./Constants/sceneModeColumbusView":495,"./Constants/sceneModeMorphing":496,"./Constants/solarRadius":497,"./Constants/threePiOver2":498,"./Constants/twoPi":499,"./Constants/webMercatorMaxLatitude":500,"./Functions/RGBToXYZ":502,"./Functions/XYZToRGB":503,"./Functions/alphaWeight":504,"./Functions/antialias":505,"./Functions/columbusViewMorph":506,"./Functions/computePosition":507,"./Functions/cosineAndSine":508,"./Functions/decompressTextureCoordinates":509,"./Functions/eastNorthUpToEyeCoordinates":510,"./Functions/ellipsoidContainsPoint":511,"./Functions/ellipsoidNew":512,"./Functions/ellipsoidWgs84TextureCoordinates":513,"./Functions/equalsEpsilon":514,"./Functions/eyeOffset":515,"./Functions/eyeToWindowCoordinates":516,"./Functions/geodeticSurfaceNormal":517,"./Functions/getDefaultMaterial":518,"./Functions/getLambertDiffuse":519,"./Functions/getSpecular":520,"./Functions/getWaterNoise":521,"./Functions/getWgs84EllipsoidEC":522,"./Functions/hue":523,"./Functions/isEmpty":524,"./Functions/isFull":525,"./Functions/latitudeToWebMercatorFraction":526,"./Functions/luminance":527,"./Functions/modelToWindowCoordinates":528,"./Functions/multiplyWithColorBalance":529,"./Functions/octDecode":530,"./Functions/phong":531,"./Functions/pointAlongRay":532,"./Functions/rayEllipsoidIntersectionInterval":533,"./Functions/saturation":534,"./Functions/signNotZero":535,"./Functions/tangentToEyeSpaceMatrix":536,"./Functions/translateRelativeToEye":537,"./Functions/translucentPhong":538,"./Functions/transpose":539,"./Functions/windowToEyeCoordinates":540,"./Structs/depthRangeStruct":541,"./Structs/ellipsoid":542,"./Structs/material":543,"./Structs/materialInput":544,"./Structs/ray":545,"./Structs/raySegment":546}],502:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Converts an RGB color to CIE Yxy.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_RGBToXYZ\n * @glslFunction\n * \n * @param {vec3} rgb The color in RGB.\n *\n * @returns {vec3} The color in CIE Yxy.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_RGBToXYZ(vec3 rgb)\n{\n    const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193,\n                              0.3576, 0.7152, 0.1192,\n                              0.1805, 0.0722, 0.9505);\n    vec3 xyz = RGB2XYZ * rgb;\n    vec3 Yxy;\n    Yxy.r = xyz.g;\n    float temp = dot(vec3(1.0), xyz);\n    Yxy.gb = xyz.rg / temp;\n    return Yxy;\n}\n';
},{}],503:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Converts a CIE Yxy color to RGB.\n * <p>The conversion is described in\n * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform}\n * </p>\n * \n * @name czm_XYZToRGB\n * @glslFunction\n * \n * @param {vec3} Yxy The color in CIE Yxy.\n *\n * @returns {vec3} The color in RGB.\n *\n * @example\n * vec3 xyz = czm_RGBToXYZ(rgb);\n * xyz.x = max(xyz.x - luminanceThreshold, 0.0);\n * rgb = czm_XYZToRGB(xyz);\n */\nvec3 czm_XYZToRGB(vec3 Yxy)\n{\n    const mat3 XYZ2RGB = mat3( 3.2405, -0.9693,  0.0556,\n                              -1.5371,  1.8760, -0.2040,\n                              -0.4985,  0.0416,  1.0572);\n    vec3 xyz;\n    xyz.r = Yxy.r * Yxy.g / Yxy.b;\n    xyz.g = Yxy.r;\n    xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b;\n    \n    return XYZ2RGB * xyz;\n}\n';
},{}],504:[function(require,module,exports){
'use strict';
module.exports = '/**\n * @private\n */\nfloat czm_alphaWeight(float a)\n{\n    float z;\n    if (czm_sceneMode != czm_sceneMode2D)\n    {\n        float x = 2.0 * (gl_FragCoord.x - czm_viewport.x) / czm_viewport.z - 1.0;\n\t    float y = 2.0 * (gl_FragCoord.y - czm_viewport.y) / czm_viewport.w - 1.0;\n\t    float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n\t    vec4 q = vec4(x, y, z, 1.0);\n\t    q /= gl_FragCoord.w;\n\t    z = (czm_inverseProjectionOIT * q).z;\n    }\n    else\n    {\n        z = gl_FragCoord.z * (czm_currentFrustum.y - czm_currentFrustum.x) + czm_currentFrustum.x;\n    }\n    \n    // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n    // http://jcgt.org/published/0002/02/09/\n    return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 100.0 / (1e-5 + pow(abs(z) / 10.0, 3.0) + pow(abs(z) / 200.0, 6.0))));\n}';
},{}],505:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Procedural anti-aliasing by blurring two colors that meet at a sharp edge.\n *\n * @name czm_antialias\n * @glslFunction\n *\n * @param {vec4} color1 The color on one side of the edge.\n * @param {vec4} color2 The color on the other side of the edge.\n * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>.\n * @param {float} dist The distance to the edge in texture coordinates.\n * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors.\n * @returns {vec4} The anti-aliased color.\n *\n * @example\n * // GLSL declarations\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor);\n * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist);\n *\n * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space\n * float dist = abs(textureCoordinates.t - 0.5);\n * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t));\n * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1);\n */\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor)\n{\n    float val1 = clamp(dist / fuzzFactor, 0.0, 1.0);\n    float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0);\n    val1 = val1 * (1.0 - val2);\n    val1 = val1 * val1 * (3.0 - (2.0 * val1));\n    val1 = pow(val1, 0.5); //makes the transition nicer\n    \n    vec4 midColor = (color1 + color2) * 0.5;\n    return mix(midColor, currentColor, val1);\n}\n\nvec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist)\n{\n    return czm_antialias(color1, color2, currentColor, dist, 0.1);\n}\n';
},{}],506:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_columbusViewMorph\n * @glslFunction\n */\nvec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time)\n{\n    // Just linear for now.\n    vec3 p = mix(position2D.xyz, position3D.xyz, time);\n    return vec4(p, 1.0);\n}\n';
},{}],507:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Returns a position in model coordinates relative to eye taking into\n * account the current scene mode: 3D, 2D, or Columbus view.\n * <p>\n * This uses standard position attributes, <code>position3DHigh</code>, \n * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, \n * and should be used when writing a vertex shader for an {@link Appearance}.\n * </p>\n *\n * @name czm_computePosition\n * @glslFunction\n *\n * @returns {vec4} The position relative to eye.\n *\n * @example\n * vec4 p = czm_computePosition();\n * v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n * gl_Position = czm_modelViewProjectionRelativeToEye * p;\n *\n * @see czm_translateRelativeToEye\n */\nvec4 czm_computePosition();\n';
},{}],508:[function(require,module,exports){
'use strict';
module.exports = '// Firefox 33-34 has a regression that prevents the CORDIC implementation from compiling\n#ifndef DISABLE_CORDIC\n\n/**\n * @private\n */\nvec2 cordic(float angle)\n{\n// Scale the vector by the appropriate factor for the 24 iterations to follow.\n    vec2 vector = vec2(6.0725293500888267e-1, 0.0);\n// Iteration 1\n    float sense = (angle < 0.0) ? -1.0 : 1.0;\n //   float factor = sense * 1.0;  // 2^-0\n    mat2 rotation = mat2(1.0, sense, -sense, 1.0);\n    vector = rotation * vector;\n    angle -= sense * 7.8539816339744828e-1;  // atan(2^-0)\n// Iteration 2\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    float factor = sense * 5.0e-1;  // 2^-1\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.6364760900080609e-1;  // atan(2^-1)\n// Iteration 3\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.5e-1;  // 2^-2\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4497866312686414e-1;  // atan(2^-2)\n// Iteration 4\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.25e-1;  // 2^-3\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2435499454676144e-1;  // atan(2^-3)\n// Iteration 5\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.25e-2;  // 2^-4\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.2418809995957350e-2;  // atan(2^-4)\n// Iteration 6\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.125e-2;  // 2^-5\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.1239833430268277e-2;  // atan(2^-5)\n// Iteration 7\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.5625e-2;  // 2^-6\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5623728620476831e-2;  // atan(2^-6)\n// Iteration 8\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.8125e-3;  // 2^-7\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.8123410601011111e-3;  // atan(2^-7)\n// Iteration 9\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.90625e-3;  // 2^-8\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.9062301319669718e-3;  // atan(2^-8)\n// Iteration 10\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.953125e-3;  // 2^-9\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9531225164788188e-3;  // atan(2^-9)\n// Iteration 11\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.765625e-4;  // 2^-10\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.7656218955931946e-4;  // atan(2^-10)\n// Iteration 12\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.8828125e-4;  // 2^-11\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.8828121119489829e-4;  // atan(2^-11)\n// Iteration 13\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.44140625e-4;  // 2^-12\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.4414062014936177e-4;  // atan(2^-12)\n// Iteration 14\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.220703125e-4;  // 2^-13\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.2207031189367021e-4;  // atan(2^-13)\n// Iteration 15\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 6.103515625e-5;  // 2^-14\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 6.1035156174208773e-5;  // atan(2^-14)\n// Iteration 16\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.0517578125e-5;  // 2^-15\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.0517578115526096e-5;  // atan(2^-15)\n// Iteration 17\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.52587890625e-5;  // 2^-16\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.5258789061315762e-5;  // atan(2^-16)\n// Iteration 18\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 7.62939453125e-6;  // 2^-17\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 7.6293945311019700e-6;  // atan(2^-17)\n// Iteration 19\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 3.814697265625e-6;  // 2^-18\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 3.8146972656064961e-6;  // atan(2^-18)\n// Iteration 20\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.9073486328125e-6;  // 2^-19\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 1.9073486328101870e-6;  // atan(2^-19)\n// Iteration 21\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 9.5367431640625e-7;  // 2^-20\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 9.5367431640596084e-7;  // atan(2^-20)\n// Iteration 22\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 4.76837158203125e-7;  // 2^-21\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 4.7683715820308884e-7;  // atan(2^-21)\n// Iteration 23\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 2.384185791015625e-7;  // 2^-22\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n    angle -= sense * 2.3841857910155797e-7;  // atan(2^-22)\n// Iteration 24\n    sense = (angle < 0.0) ? -1.0 : 1.0;\n    factor = sense * 1.1920928955078125e-7;  // 2^-23\n    rotation[0][1] = factor;\n    rotation[1][0] = -factor;\n    vector = rotation * vector;\n//    angle -= sense * 1.1920928955078068e-7;  // atan(2^-23)\n\n    return vector;\n}\n\n/**\n * Computes the cosine and sine of the provided angle using the CORDIC algorithm.\n *\n * @name czm_cosineAndSine\n * @glslFunction\n *\n * @param {float} angle The angle in radians.\n *\n * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate).\n *\n * @example\n * vec2 v = czm_cosineAndSine(czm_piOverSix);\n * float cosine = v.x;\n * float sine = v.y;\n */\nvec2 czm_cosineAndSine(float angle)\n{\n    if (angle < -czm_piOverTwo || angle > czm_piOverTwo)\n    {\n        if (angle < 0.0)\n        {\n            return -cordic(angle + czm_pi);\n        }\n        else\n        {\n            return -cordic(angle - czm_pi);\n        }\n    }\n    else\n    {\n        return cordic(angle);\n    }\n}\n\n#endif';
},{}],509:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @name czm_decompressTextureCoordinates\n * @glslFunction\n *\n * @param {float} encoded The compressed texture coordinates.\n * @returns {vec2} The decompressed texture coordinates.\n */\n vec2 czm_decompressTextureCoordinates(float encoded)\n {\n    float temp = encoded / 4096.0;\n    float stx = floor(temp) / 4096.0;\n    float sty = temp - floor(temp);\n    return vec2(stx, sty);\n }\n';
},{}],510:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid\'s east-north-up coordinate system \n * to eye coordinates.  In east-north-up coordinates, x points east, y points north, and z points along the \n * surface normal.  East-north-up can be used as an ellipsoid\'s tangent space for operations such as bump mapping.\n * <br /><br />\n * The ellipsoid is assumed to be centered at the model coordinate\'s origin.\n *\n * @name czm_eastNorthUpToEyeCoordinates\n * @glslFunction\n *\n * @param {vec3} positionMC The position on the ellipsoid in model coordinates.\n * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates.\n *\n * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates.\n *\n * @example\n * // Transform a vector defined in the east-north-up coordinate \n * // system, (0, 0, 1) which is the surface normal, to eye \n * // coordinates.\n * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n * vec3 normalEC = m * vec3(0.0, 0.0, 1.0);\n */\nmat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n{\n    vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));  // normalized surface tangent in model coordinates\n    vec3 tangentEC = normalize(czm_normal3D * tangentMC);                // normalized surface tangent in eye coordiantes\n    vec3 bitangentEC = normalize(cross(normalEC, tangentEC));            // normalized surface bitangent in eye coordinates\n\n    return mat3(\n        tangentEC.x,   tangentEC.y,   tangentEC.z,\n        bitangentEC.x, bitangentEC.y, bitangentEC.z,\n        normalEC.x,    normalEC.y,    normalEC.z);\n}\n';
},{}],511:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_ellipsoidContainsPoint\n * @glslFunction\n *\n */\nbool czm_ellipsoidContainsPoint(czm_ellipsoid ellipsoid, vec3 point)\n{\n    vec3 scaled = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz;\n    return (dot(scaled, scaled) <= 1.0);\n}\n';
},{}],512:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_ellipsoidNew\n * @glslFunction\n *\n */\nczm_ellipsoid czm_ellipsoidNew(vec3 center, vec3 radii)\n{\n    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n    czm_ellipsoid temp = czm_ellipsoid(center, radii, inverseRadii, inverseRadiiSquared);\n    return temp;\n}\n';
},{}],513:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_ellipsoidWgs84TextureCoordinates\n * @glslFunction\n */\nvec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal)\n{\n    return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5);\n}\n';
},{}],514:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code>\n * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs\n * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s,\n * <code>vec3</code>s, or <code>vec4</code>s.\n *\n * @name czm_equalsEpsilon\n * @glslFunction\n *\n * @param {} left The first vector.\n * @param {} right The second vector.\n * @param {float} epsilon The epsilon to use for equality testing.\n * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise.\n *\n * @example\n * // GLSL declarations\n * bool czm_equalsEpsilon(float left, float right, float epsilon);\n * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon);\n * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon);\n * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon);\n */\nbool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec4(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec3(epsilon)));\n}\n\nbool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) {\n    return all(lessThanEqual(abs(left - right), vec2(epsilon)));\n}\n\nbool czm_equalsEpsilon(float left, float right, float epsilon) {\n    return (abs(left - right) <= epsilon);\n}\n';
},{}],515:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_eyeOffset\n * @glslFunction\n *\n * @param {vec4} positionEC DOC_TBA.\n * @param {vec3} eyeOffset DOC_TBA.\n *\n * @returns {vec4} DOC_TBA.\n */\nvec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n{\n    // This equation is approximate in x and y.\n    vec4 p = positionEC;\n    vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n    p.xy += eyeOffset.xy + zEyeOffset.xy;\n    p.z += zEyeOffset.z;\n    return p;\n}\n';
},{}],516:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Transforms a position from eye to window coordinates.  The transformation\n * from eye to clip coordinates is done using {@link czm_projection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n *\n * @name czm_eyeToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in eye coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_projection\n * @see czm_viewportTransformation\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n */\nvec4 czm_eyeToWindowCoordinates(vec4 positionEC)\n{\n    vec4 q = czm_projection * positionEC;                        // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n';
},{}],517:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_geodeticSurfaceNormal\n * @glslFunction\n *\n * @param {vec3} positionOnEllipsoid DOC_TBA\n * @param {vec3} ellipsoidCenter DOC_TBA\n * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA\n * \n * @returns {vec3} DOC_TBA.\n */\nvec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n{\n    return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n}\n';
},{}],518:[function(require,module,exports){
'use strict';
module.exports = '/**\n * An czm_material with default values. Every material\'s czm_getMaterial\n * should use this default material as a base for the material it returns.\n * The default normal value is given by materialInput.normalEC.\n *\n * @name czm_getDefaultMaterial\n * @glslFunction \n *\n * @param {czm_materialInput} input The input used to construct the default material.\n * \n * @returns {czm_material} The default material.\n *\n * @see czm_materialInput\n * @see czm_material\n * @see czm_getMaterial\n */\nczm_material czm_getDefaultMaterial(czm_materialInput materialInput)\n{\n    czm_material material;\n    material.diffuse = vec3(0.0);\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal = materialInput.normalEC;\n    material.emission = vec3(0.0);\n    material.alpha = 1.0;\n    return material;\n}\n';
},{}],519:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Calculates the intensity of diffusely reflected light.\n *\n * @name czm_getLambertDiffuse\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n *\n * @returns {float} The intensity of the diffuse reflection.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\n{\n    return max(dot(lightDirectionEC, normalEC), 0.0);\n}';
},{}],520:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Calculates the specular intensity of reflected light.\n *\n * @name czm_getSpecular\n * @glslFunction\n *\n * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates.\n * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates.\n * @param {vec3} normalEC The surface normal in eye coordinates.\n * @param {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n *\n * @returns {float} The intensity of the specular highlight.\n *\n * @see czm_phong\n *\n * @example\n * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC);\n * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200);\n * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity);\n */\nfloat czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess)\n{\n    vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC);\n    float specular = max(dot(toReflectedLight, toEyeEC), 0.0);\n    return pow(specular, shininess);\n}';
},{}],521:[function(require,module,exports){
'use strict';
module.exports = '/**\n * @private\n */\nvec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians)\n{\n    float cosAngle = cos(angleInRadians);\n    float sinAngle = sin(angleInRadians);\n\n    // time dependent sampling directions\n    vec2 s0 = vec2(1.0/17.0, 0.0);\n    vec2 s1 = vec2(-1.0/29.0, 0.0);\n    vec2 s2 = vec2(1.0/101.0, 1.0/59.0);\n    vec2 s3 = vec2(-1.0/109.0, -1.0/57.0);\n\n    // rotate sampling direction by specified angle\n    s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y));\n    s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y));\n    s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y));\n    s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y));\n\n    vec2 uv0 = (uv/103.0) + (time * s0);\n    vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23);\n    vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51);\n    vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71);\n\n    uv0 = fract(uv0);\n    uv1 = fract(uv1);\n    uv2 = fract(uv2);\n    uv3 = fract(uv3);\n    vec4 noise = (texture2D(normalMap, uv0)) +\n                 (texture2D(normalMap, uv1)) +\n                 (texture2D(normalMap, uv2)) +\n                 (texture2D(normalMap, uv3));\n\n    // average and scale to between -1 and 1\n    return ((noise / 4.0) - 0.5) * 2.0;\n}\n';
},{}],522:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Returns the WGS84 ellipsoid, with its center at the origin of world coordinates, in eye coordinates.\n *\n * @name czm_getWgs84EllipsoidEC\n * @glslFunction\n *\n * @returns {czm_ellipsoid} The WGS84 ellipsoid, with its center at the origin of world coordinates, in eye coordinates.\n *\n * @see Ellipsoid.WGS84\n *\n * @example\n * czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n */\nczm_ellipsoid czm_getWgs84EllipsoidEC()\n{\n    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\n    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n    czm_ellipsoid temp = czm_ellipsoid(czm_view[3].xyz, radii, inverseRadii, inverseRadiiSquared);\n    return temp;\n}\n';
},{}],523:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Adjusts the hue of a color.\n * \n * @name czm_hue\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the hue of the color in radians.\n *\n * @returns {float} The color with the hue adjusted.\n *\n * @example\n * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi)\n */\nvec3 czm_hue(vec3 rgb, float adjustment)\n{\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\n                            0.595716, -0.274453, -0.321263,\n                            0.211456, -0.522591,  0.311135);\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\n                            1.0, -0.2721, -0.6474,\n                            1.0, -1.107,   1.7046);\n    \n    vec3 yiq = toYIQ * rgb;\n    float hue = atan(yiq.z, yiq.y) + adjustment;\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\n    \n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\n    return toRGB * color;\n}\n';
},{}],524:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Determines if a time interval is empty.\n *\n * @name czm_isEmpty\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isEmpty(czm_raySegment interval)\n{\n    return (interval.stop < 0.0);\n}\n';
},{}],525:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Determines if a time interval is empty.\n *\n * @name czm_isFull\n * @glslFunction \n * \n * @param {czm_raySegment} interval The interval to test.\n * \n * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>.\n *\n * @example\n * bool b0 = czm_isEmpty(czm_emptyRaySegment);      // true\n * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false\n * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0.\n */\nbool czm_isFull(czm_raySegment interval)\n{\n    return (interval.start == 0.0 && interval.stop == czm_infinity);\n}\n';
},{}],526:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located.\n *\n * @name czm_latitudeToWebMercatorFraction\n * @glslFunction\n *\n * @param {float} latitude The geodetic latitude, in radians.\n * @param {float} southMercatorYLow The low portion of the Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} southMercatorYHigh The high portion of the Web Mercator coordinate of the southern boundary of the rectangle.\n * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates.\n *\n * @returns {float} The fraction of the rectangle at which the latitude occurs.  If the latitude is the southern\n *          boundary of the rectangle, the return value will be zero.  If it is the northern boundary, the return\n *          value will be 1.0.  Latitudes in between are mapped according to the Web Mercator projection.\n */ \nfloat czm_latitudeToWebMercatorFraction(float latitude, float southMercatorYLow, float southMercatorYHigh, float oneOverMercatorHeight)\n{\n    float sinLatitude = sin(latitude);\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n    \n    // mercatorY - southMercatorY in simulated double precision.\n    float t1 = 0.0 - southMercatorYLow;\n    float e = t1 - 0.0;\n    float t2 = ((-southMercatorYLow - e) + (0.0 - (t1 - e))) + mercatorY - southMercatorYHigh;\n    float highDifference = t1 + t2;\n    float lowDifference = t2 - (highDifference - t1);\n    \n    return highDifference * oneOverMercatorHeight + lowDifference * oneOverMercatorHeight;\n}\n';
},{}],527:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n';
},{}],528:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Transforms a position from model to window coordinates.  The transformation\n * from model to clip coordinates is done using {@link czm_modelViewProjection}.\n * The transform from normalized device coordinates to window coordinates is\n * done using {@link czm_viewportTransformation}, which assumes a depth range\n * of <code>near = 0</code> and <code>far = 1</code>.\n * <br /><br />\n * This transform is useful when there is a need to manipulate window coordinates\n * in a vertex shader as done by {@link BillboardCollection}.\n * <br /><br />\n * This function should not be confused with {@link czm_viewportOrthographic},\n * which is an orthographic projection matrix that transforms from window \n * coordinates to clip coordinates.\n *\n * @name czm_modelToWindowCoordinates\n * @glslFunction\n *\n * @param {vec4} position The position in model coordinates to transform.\n *\n * @returns {vec4} The transformed position in window coordinates.\n *\n * @see czm_eyeToWindowCoordinates\n * @see czm_modelViewProjection\n * @see czm_viewportTransformation\n * @see czm_viewportOrthographic\n * @see BillboardCollection\n *\n * @example\n * vec4 positionWC = czm_modelToWindowCoordinates(positionMC);\n */\nvec4 czm_modelToWindowCoordinates(vec4 position)\n{\n    vec4 q = czm_modelViewProjection * position;                // clip coordinates\n    q.xyz /= q.w;                                                // normalized device coordinates\n    q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates\n    return q;\n}\n';
},{}],529:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_multiplyWithColorBalance\n * @glslFunction\n */\nvec3 czm_multiplyWithColorBalance(vec3 left, vec3 right)\n{\n    // Algorithm from Chapter 10 of Graphics Shaders.\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    \n    vec3 target = left * right;\n    float leftLuminance = dot(left, W);\n    float rightLuminance = dot(right, W);\n    float targetLuminance = dot(target, W);\n    \n    return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target;\n}\n';
},{}],530:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Decodes a unit-length vector in \'oct\' encoding to a normalized 3-component Cartesian vector.\n * The \'oct\' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n * \n * @name czm_octDecode\n * @param {vec2} encoded The oct-encoded, unit-length vector\n * @returns {vec3} The decoded and normalized vector\n */\n vec3 czm_octDecode(vec2 encoded)\n {\n    encoded = encoded / 255.0 * 2.0 - 1.0;\n    vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\n    if (v.z < 0.0)\n    {\n        v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\n    }\n    \n    return normalize(v);\n }\n\n /**\n * Decodes a unit-length vector in \'oct\' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.\n * The \'oct\' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n * \n * @name czm_octDecode\n * @param {float} encoded The oct-encoded, unit-length vector\n * @returns {vec3} The decoded and normalized vector\n */\n vec3 czm_octDecode(float encoded)\n {\n    float temp = encoded / 256.0;\n    float x = floor(temp);\n    float y = (temp - x) * 256.0;\n    return czm_octDecode(vec2(x, y));\n }\n \n/**\n * Decodes three unit-length vectors in \'oct\' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors.\n * The \'oct\' encoding is described in "A Survey of Efficient Representations of Independent Unit Vectors",\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\n * \n * @name czm_octDecode\n * @param {vec2} encoded The packed oct-encoded, unit-length vectors.\n * @param {vec3} vector1 One decoded and normalized vector.\n * @param {vec3} vector2 One decoded and normalized vector.\n * @param {vec3} vector3 One decoded and normalized vector.\n */\n  void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3)\n {\n    float temp = encoded.x / 65536.0;\n    float x = floor(temp);\n    float encodedFloat1 = (temp - x) * 65536.0;\n\n    temp = encoded.y / 65536.0;\n    float y = floor(temp);\n    float encodedFloat2 = (temp - y) * 65536.0;\n\n    vector1 = czm_octDecode(encodedFloat1);\n    vector2 = czm_octDecode(encodedFloat2);\n    vector3 = czm_octDecode(vec2(x, y));\n }\n ';
},{}],531:[function(require,module,exports){
'use strict';
module.exports = 'float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material)\n{\n    return czm_getLambertDiffuse(lightDirectionEC, material.normal);\n}\n\nfloat czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material)\n{\n    return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess);\n}\n\n/**\n * Computes a color using the Phong lighting model.\n *\n * @name czm_phong\n * @glslFunction\n *\n * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates.\n * @param {czm_material} material The fragment\'s material.\n * \n * @returns {vec4} The computed color.\n * \n * @example\n * vec3 positionToEyeEC = // ...\n * czm_material material = // ...\n * gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n *\n * @see czm_getMaterial\n */\nvec4 czm_phong(vec3 toEye, czm_material material)\n{\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material) + czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material);\n\n    // Specular from sun and pseudo-moon\n    float specular = czm_private_getSpecularOfMaterial(czm_sunDirectionEC, toEye, material) + czm_private_getSpecularOfMaterial(czm_moonDirectionEC, toEye, material);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n    \n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse;\n    color += material.specular * specular;\n\n    return vec4(color, material.alpha);\n}\n\nvec4 czm_private_phong(vec3 toEye, czm_material material)\n{\n    float diffuse = czm_private_getLambertDiffuseOfMaterial(czm_sunDirectionEC, material);\n    float specular = czm_private_getSpecularOfMaterial(czm_sunDirectionEC, toEye, material);\n\n    vec3 ambient = vec3(0.0);\n    vec3 color = ambient + material.emission;\n    color += material.diffuse * diffuse;\n    color += material.specular * specular;\n\n    return vec4(color, material.alpha);\n}';
},{}],532:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Computes the point along a ray at the given time.  <code>time</code> can be positive, negative, or zero.\n *\n * @name czm_pointAlongRay\n * @glslFunction\n *\n * @param {czm_ray} ray The ray to compute the point along.\n * @param {float} time The time along the ray.\n * \n * @returns {vec3} The point along the ray at the given time.\n * \n * @example\n * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction\n * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0)\n */\nvec3 czm_pointAlongRay(czm_ray ray, float time)\n{\n    return ray.origin + (time * ray.direction);\n}\n';
},{}],533:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_rayEllipsoidIntersectionInterval\n * @glslFunction\n */\nczm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, czm_ellipsoid ellipsoid)\n{\n   // ray and ellipsoid center in eye coordinates.  radii in model coordinates.\n    vec3 q = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz;\n    vec3 w = ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz;\n   \n    q = q - ellipsoid.inverseRadii * (czm_inverseModelView * vec4(ellipsoid.center, 1.0)).xyz;\n    \n    float q2 = dot(q, q);\n    float qw = dot(q, w);\n    \n    if (q2 > 1.0) // Outside ellipsoid.\n    {\n        if (qw >= 0.0) // Looking outward or tangent (0 intersections).\n        {\n            return czm_emptyRaySegment;\n        }\n        else // qw < 0.0.\n        {\n            float qw2 = qw * qw;\n            float difference = q2 - 1.0; // Positively valued.\n            float w2 = dot(w, w);\n            float product = w2 * difference;\n            \n            if (qw2 < product) // Imaginary roots (0 intersections).\n            {\n                return czm_emptyRaySegment;     \n            }   \n            else if (qw2 > product) // Distinct roots (2 intersections).\n            {\n                float discriminant = qw * qw - product;\n                float temp = -qw + sqrt(discriminant); // Avoid cancellation.\n                float root0 = temp / w2;\n                float root1 = difference / temp;\n                if (root0 < root1)\n                {\n                    czm_raySegment i = czm_raySegment(root0, root1);\n                    return i;\n                }\n                else\n                {\n                    czm_raySegment i = czm_raySegment(root1, root0);\n                    return i;\n                }\n            }\n            else // qw2 == product.  Repeated roots (2 intersections).\n            {\n                float root = sqrt(difference / w2);\n                czm_raySegment i = czm_raySegment(root, root);\n                return i;\n            }\n        }\n    }\n    else if (q2 < 1.0) // Inside ellipsoid (2 intersections).\n    {\n        float difference = q2 - 1.0; // Negatively valued.\n        float w2 = dot(w, w);\n        float product = w2 * difference; // Negatively valued.\n        float discriminant = qw * qw - product;\n        float temp = -qw + sqrt(discriminant); // Positively valued.\n        czm_raySegment i = czm_raySegment(0.0, temp / w2);\n        return i;\n    }\n    else // q2 == 1.0. On ellipsoid.\n    {\n        if (qw < 0.0) // Looking inward.\n        {\n            float w2 = dot(w, w);\n            czm_raySegment i = czm_raySegment(0.0, -qw / w2);\n            return i;\n        }\n        else // qw >= 0.0.  Looking outward or tangent.\n        {\n            return czm_emptyRaySegment;\n        }\n    }\n}\n';
},{}],534:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Adjusts the saturation of a color.\n * \n * @name czm_saturation\n * @glslFunction\n * \n * @param {vec3} rgb The color.\n * @param {float} adjustment The amount to adjust the saturation of the color.\n *\n * @returns {float} The color with the saturation adjusted.\n *\n * @example\n * vec3 greyScale = czm_saturation(color, 0.0);\n * vec3 doubleSaturation = czm_saturation(color, 2.0);\n */\nvec3 czm_saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n';
},{}],535:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.  This is similar to the GLSL\n * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0.\n * \n * @name czm_signNotZero\n * @glslFunction\n *\n * @param {} value The value for which to determine the sign.\n * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative.\n */\nfloat czm_signNotZero(float value)\n{\n    return value >= 0.0 ? 1.0 : -1.0;\n}\n\nvec2 czm_signNotZero(vec2 value)\n{\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n}\n\nvec3 czm_signNotZero(vec3 value)\n{\n    return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z));\n}\n\nvec4 czm_signNotZero(vec4 value)\n{\n    return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w));\n}';
},{}],536:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Creates a matrix that transforms vectors from tangent space to eye space.\n *\n * @name czm_tangentToEyeSpaceMatrix\n * @glslFunction\n * \n * @param {vec3} normalEC The normal vector in eye coordinates.\n * @param {vec3} tangentEC The tangent vector in eye coordinates.\n * @param {vec3} binormalEC The binormal vector in eye coordinates.\n *\n * @returns {mat3} The matrix that transforms from tangent space to eye space.\n *\n * @example\n * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, binormalEC);\n * vec3 normal = tangentToEye * texture2D(normalMap, st).xyz;\n */\nmat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 binormalEC)\n{\n    vec3 normal = normalize(normalEC);\n    vec3 tangent = normalize(tangentEC);\n    vec3 binormal = normalize(binormalEC);\n    return mat3(tangent.x,  tangent.y,  tangent.z,\n                binormal.x, binormal.y, binormal.z,\n                normal.x,   normal.y,   normal.z);\n}\n';
},{}],537:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3},\n * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to\n * be relative to the eye.  As shown in the example, the position can then be transformed in eye\n * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye},\n * respectively.\n * <p>\n * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as\n * described in {@link http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/|Precisions, Precisions}.\n * </p>\n *\n * @name czm_translateRelativeToEye\n * @glslFunction\n *\n * @param {vec3} high The position\'s high bits.\n * @param {vec3} low The position\'s low bits.\n * @returns {vec3} The position translated to be relative to the camera\'s position.\n *\n * @example\n * attribute vec3 positionHigh;\n * attribute vec3 positionLow;\n * \n * void main() \n * {\n *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n *   gl_Position = czm_modelViewProjectionRelativeToEye * p;\n * }\n *\n * @see czm_modelViewRelativeToEye\n * @see czm_modelViewProjectionRelativeToEye\n * @see czm_computePosition\n * @see EncodedCartesian3\n */\nvec4 czm_translateRelativeToEye(vec3 high, vec3 low)\n{\n    vec3 highDifference = high - czm_encodedCameraPositionMCHigh;\n    vec3 lowDifference = low - czm_encodedCameraPositionMCLow;\n\n    return vec4(highDifference + lowDifference, 1.0);\n}\n';
},{}],538:[function(require,module,exports){
'use strict';
module.exports = '/**\n * @private\n */\nvec4 czm_translucentPhong(vec3 toEye, czm_material material)\n{\n    // Diffuse from directional light sources at eye (for top-down and horizon views)\n    float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal);\n    diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal);\n    diffuse = clamp(diffuse, 0.0, 1.0);\n\n    // Specular from sun and pseudo-moon\n    float specular = czm_getSpecular(czm_sunDirectionEC, toEye, material.normal, material.shininess);\n    specular += czm_getSpecular(czm_moonDirectionEC, toEye, material.normal, material.shininess);\n\n    // Temporary workaround for adding ambient.\n    vec3 materialDiffuse = material.diffuse * 0.5;\n\n    vec3 ambient = materialDiffuse;\n    vec3 color = ambient + material.emission;\n    color += materialDiffuse * diffuse;\n    color += material.specular * specular;\n\n    return vec4(color, material.alpha);\n}';
},{}],539:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Returns the transpose of the matrix.  The input <code>matrix</code> can be \n * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>.\n *\n * @name czm_transpose\n * @glslFunction\n *\n * @param {} matrix The matrix to transpose.\n *\n * @returns {} The transposed matrix.\n *\n * @example\n * // GLSL declarations\n * mat2 czm_transpose(mat2 matrix);\n * mat3 czm_transpose(mat3 matrix);\n * mat4 czm_transpose(mat4 matrix);\n *\n * // Tranpose a 3x3 rotation matrix to find its inverse.\n * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates(\n *     positionMC, normalEC);\n * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye);\n */\nmat2 czm_transpose(mat2 matrix)\n{\n    return mat2(\n        matrix[0][0], matrix[1][0],\n        matrix[0][1], matrix[1][1]);\n}\n\nmat3 czm_transpose(mat3 matrix)\n{\n    return mat3(\n        matrix[0][0], matrix[1][0], matrix[2][0],\n        matrix[0][1], matrix[1][1], matrix[2][1],\n        matrix[0][2], matrix[1][2], matrix[2][2]);\n}\n\nmat4 czm_transpose(mat4 matrix)\n{\n    return mat4(\n        matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n        matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n        matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n        matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n}\n';
},{}],540:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Transforms a position from window to eye coordinates.\n * The transform from window to normalized device coordinates is done using components\n * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating\n * the inverse of <code>czm_viewportTransformation</code>. The transformation from \n * normalized device coordinates to clip coordinates is done using <code>positionWC.w</code>,\n * which is expected to be the scalar used in the perspective divide. The transformation\n * from clip to eye coordinates is done using {@link czm_inverseProjection}.\n *\n * @name czm_windowToEyeCoordinates\n * @glslFunction\n *\n * @param {vec4} fragmentCoordinate The position in window coordinates to transform.\n *\n * @returns {vec4} The transformed position in eye coordinates.\n *\n * @see czm_modelToWindowCoordinates\n * @see czm_eyeToWindowCoordinates\n * @see czm_inverseProjection\n * @see czm_viewport\n * @see czm_viewportTransformation\n *\n * @example\n * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord);\n */\nvec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate)\n{\n    float x = 2.0 * (fragmentCoordinate.x - czm_viewport.x) / czm_viewport.z - 1.0;\n    float y = 2.0 * (fragmentCoordinate.y - czm_viewport.y) / czm_viewport.w - 1.0;\n    float z = (fragmentCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];\n    vec4 q = vec4(x, y, z, 1.0);\n    q /= fragmentCoordinate.w;\n    q = czm_inverseProjection * q;\n    return q;\n}\n';
},{}],541:[function(require,module,exports){
'use strict';
module.exports = '/**\n * @name czm_depthRangeStruct\n * @glslStruct\n */\nstruct czm_depthRangeStruct\n{\n    float near;\n    float far;\n};';
},{}],542:[function(require,module,exports){
'use strict';
module.exports = '/** DOC_TBA\n *\n * @name czm_ellipsoid\n * @glslStruct\n */\nstruct czm_ellipsoid\n{\n    vec3 center;\n    vec3 radii;\n    vec3 inverseRadii;\n    vec3 inverseRadiiSquared;\n};';
},{}],543:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions.\n *\n * @name czm_material\n * @glslStruct\n *\n * @property {vec3} diffuse Incoming light that scatters evenly in all directions.\n * @property {float} specular Intensity of incoming light reflecting in a single direction.\n * @property {float} shininess The sharpness of the specular reflection.  Higher values create a smaller, more focused specular highlight.\n * @property {vec3} normal Surface\'s normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface\'s unmodified normal.\n * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light.\n * @property {float} alpha Opacity of this material. 0.0 is completely transparent; 1.0 is completely opaque.\n */\nstruct czm_material\n{\n    vec3 diffuse;\n    float specular;\n    float shininess;\n    vec3 normal;\n    vec3 emission;\n    float alpha;\n};';
},{}],544:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Used as input to every material\'s czm_getMaterial function.\n *\n * @name czm_materialInput\n * @glslStruct\n *\n * @property {float} s 1D texture coordinates.\n * @property {vec2} st 2D texture coordinates.\n * @property {vec3} str 3D texture coordinates.\n * @property {vec3} normalEC Unperturbed surface normal in eye coordinates.\n * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space.\n * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates.  The magnitude is the distance in meters from the fragment to the eye.\n */\nstruct czm_materialInput\n{\n    float s;\n    vec2 st;\n    vec3 str;\n    vec3 normalEC;\n    mat3 tangentToEyeMatrix;\n    vec3 positionToEyeEC;\n};';
},{}],545:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_ray\n * @glslStruct\n */\nstruct czm_ray\n{\n    vec3 origin;\n    vec3 direction;\n};';
},{}],546:[function(require,module,exports){
'use strict';
module.exports = '/**\n * DOC_TBA\n *\n * @name czm_raySegment\n * @glslStruct\n */\nstruct czm_raySegment\n{\n    float start;\n    float stop;\n};\n\n/**\n * DOC_TBA\n *\n * @name czm_emptyRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity);\n\n/**\n * DOC_TBA\n *\n * @name czm_fullRaySegment\n * @glslConstant \n */\nconst czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity);\n';
},{}],547:[function(require,module,exports){
'use strict';
module.exports = '/**\n * Compositing for Weighted Blended Order-Independent Transparency. See:\n * - http://jcgt.org/published/0002/02/09/\n * - http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html\n */\n \nuniform sampler2D u_opaque;\nuniform sampler2D u_accumulation;\nuniform sampler2D u_revealage;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    vec4 opaque = texture2D(u_opaque, v_textureCoordinates);\n    vec4 accum = texture2D(u_accumulation, v_textureCoordinates);\n    float r = texture2D(u_revealage, v_textureCoordinates).r;\n    \n#ifdef MRT\n    vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);\n#else\n    vec4 transparent = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);\n#endif\n    \n    gl_FragColor = (1.0 - transparent.a) * transparent + transparent.a * opaque;\n}\n';
},{}],548:[function(require,module,exports){
'use strict';
module.exports = '#ifdef WRITE_DEPTH\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n#endif\n#endif\n\nuniform vec3 u_radii;\nuniform vec3 u_oneOverEllipsoidRadiiSquared;\n\nvarying vec3 v_positionEC;\n\nvec4 computeEllipsoidColor(czm_ray ray, float intersection, float side)\n{\n    vec3 positionEC = czm_pointAlongRay(ray, intersection);\n    vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\n    vec3 geodeticNormal = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), u_oneOverEllipsoidRadiiSquared));\n    vec3 sphericalNormal = normalize(positionMC / u_radii);\n    vec3 normalMC = geodeticNormal * side;              // normalized surface normal (always facing the viewer) in model coordinates\n    vec3 normalEC = normalize(czm_normal * normalMC);   // normalized surface normal in eye coordiantes\n\n    vec2 st = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\n    vec3 positionToEyeEC = -positionEC;\n\n    czm_materialInput materialInput;\n    materialInput.s = st.s;\n    materialInput.st = st;\n    materialInput.str = (positionMC + u_radii) / u_radii;\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef ONLY_SUN_LIGHTING\n    return czm_private_phong(normalize(positionToEyeEC), material);\n#else\n    return czm_phong(normalize(positionToEyeEC), material);\n#endif\n}\n\nvoid main()\n{\n    // PERFORMANCE_TODO: When dynamic branching is available, compute ratio of maximum and minimum radii\n    // in the vertex shader. Only when it is larger than some constant, march along the ray.\n    // Otherwise perform one intersection test which will be the common case.\n    \n    // Test if the ray intersects a sphere with the ellipsoid\'s maximum radius.\n    // For very oblate ellipsoids, using the ellipsoid\'s radii for an intersection test\n    // may cause false negatives. This will discard fragments before marching the ray forward.\n    float maxRadius = max(u_radii.x, max(u_radii.y, u_radii.z)) * 1.5;\n    vec3 direction = normalize(v_positionEC);\n    vec3 ellipsoidCenter = czm_modelView[3].xyz;\n    \n    float t1 = -1.0;\n    float t2 = -1.0;\n    \n    float b = -2.0 * dot(direction, ellipsoidCenter);\n    float c = dot(ellipsoidCenter, ellipsoidCenter) - maxRadius * maxRadius;\n\n    float discriminant = b * b - 4.0 * c;\n    if (discriminant >= 0.0) {\n        t1 = (-b - sqrt(discriminant)) * 0.5;\n        t2 = (-b + sqrt(discriminant)) * 0.5;\n    }\n    \n    if (t1 < 0.0 && t2 < 0.0) {\n        discard;\n    }\n    \n    float t = min(t1, t2);\n    if (t < 0.0) {\n        t = 0.0;\n    }\n    \n    // March ray forward to intersection with larger sphere and find\n    // actual intersection point with ellipsoid.\n    czm_ellipsoid ellipsoid = czm_ellipsoidNew(ellipsoidCenter, u_radii);\n    czm_ray ray = czm_ray(t * direction, direction);\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n    \n    if (czm_isEmpty(intersection))\n    {\n        discard;\n    }\n\n    // If the viewer is outside, compute outsideFaceColor, with normals facing outward.\n    vec4 outsideFaceColor = (intersection.start != 0.0) ? computeEllipsoidColor(ray, intersection.start, 1.0) : vec4(0.0);\n\n    // If the viewer either is inside or can see inside, compute insideFaceColor, with normals facing inward.\n    vec4 insideFaceColor = (outsideFaceColor.a < 1.0) ? computeEllipsoidColor(ray, intersection.stop, -1.0) : vec4(0.0);\n\n    gl_FragColor = mix(insideFaceColor, outsideFaceColor, outsideFaceColor.a);\n    gl_FragColor.a = 1.0 - (1.0 - insideFaceColor.a) * (1.0 - outsideFaceColor.a);\n    \n#ifdef WRITE_DEPTH\n#ifdef GL_EXT_frag_depth\n    t = (intersection.start != 0.0) ? intersection.start : intersection.stop;\n    vec3 positionEC = czm_pointAlongRay(ray, t);\n    vec4 positionCC = czm_projection * vec4(positionEC, 1.0);\n    float z = positionCC.z / positionCC.w;\n    \n    float n = czm_depthRange.near;\n    float f = czm_depthRange.far;\n    \n    gl_FragDepthEXT = (z * (f - n) + f + n) * 0.5;\n#endif\n#endif\n}\n';
},{}],549:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position;\n\nuniform vec3 u_radii;\n\nvarying vec3 v_positionEC;\n\nvoid main() \n{\n    // In the vertex data, the cube goes from (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0) in model coordinates.\n    // Scale to consider the radii.  We could also do this once on the CPU when using the BoxGeometry,\n    // but doing it here allows us to change the radii without rewriting the vertex data, and\n    // allows all ellipsoids to reuse the same vertex data.\n    vec4 p = vec4(u_radii * position, 1.0);\n\n    v_positionEC = (czm_modelView * p).xyz;     // position in eye coordinates\n    gl_Position = czm_modelViewProjection * p;  // position in clip coordinates\n\n    // With multi-frustum, when the ellipsoid primitive is positioned on the intersection of two frustums \n    // and close to terrain, the terrain (writes depth) in the closest frustum can overwrite part of the \n    // ellipsoid (does not write depth) that was rendered in the farther frustum.\n    //\n    // Here, we clamp the depth in the vertex shader to avoid being overwritten; however, this creates\n    // artifacts since some fragments can be alpha blended twice.  This is solved by only rendering\n    // the ellipsoid in the closest frustum to the viewer.\n    gl_Position.z = clamp(gl_Position.z, czm_depthRange.near, czm_depthRange.far);\n}\n';
},{}],550:[function(require,module,exports){
'use strict';
module.exports = '//#define SHOW_TILE_BOUNDARIES\n\nuniform vec4 u_initialColor;\n\n#if TEXTURE_UNITS > 0\nuniform sampler2D u_dayTextures[TEXTURE_UNITS];\nuniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];\n\n#ifdef APPLY_ALPHA\nuniform float u_dayTextureAlpha[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_BRIGHTNESS\nuniform float u_dayTextureBrightness[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_CONTRAST\nuniform float u_dayTextureContrast[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_HUE\nuniform float u_dayTextureHue[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_SATURATION\nuniform float u_dayTextureSaturation[TEXTURE_UNITS];\n#endif\n\n#ifdef APPLY_GAMMA\nuniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];\n#endif\n\nuniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];\n#endif\n\n#ifdef SHOW_REFLECTIVE_OCEAN\nuniform sampler2D u_waterMask;\nuniform vec4 u_waterMaskTranslationAndScale;\nuniform float u_zoomedOutOceanSpecularIntensity;\n#endif\n\n#ifdef SHOW_OCEAN_WAVES\nuniform sampler2D u_oceanNormalMap;\n#endif\n\n#ifdef ENABLE_DAYNIGHT_SHADING\nuniform vec2 u_lightingFadeDistance;\n#endif\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\nvarying vec2 v_textureCoordinates;\nvarying vec3 v_normalMC;\nvarying vec3 v_normalEC;\n\nvec4 sampleAndBlend(\n    vec4 previousColor,\n    sampler2D texture,\n    vec2 tileTextureCoordinates,\n    vec4 textureCoordinateRectangle,\n    vec4 textureCoordinateTranslationAndScale,\n    float textureAlpha,\n    float textureBrightness,\n    float textureContrast,\n    float textureHue,\n    float textureSaturation,\n    float textureOneOverGamma)\n{\n    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:\n    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||\n    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||\n    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||\n    //    tileTextureCoordinates.t > textureCoordinateRectangle.q\n    // In other words, the alpha is zero if the fragment is outside the rectangle\n    // covered by this texture.  Would an actual \'if\' yield better performance?\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates); \n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n    \n    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\n    \n    vec2 translation = textureCoordinateTranslationAndScale.xy;\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\n    vec4 sample = texture2D(texture, textureCoordinates);\n    vec3 color = sample.rgb;\n    float alpha = sample.a;\n    \n#ifdef APPLY_BRIGHTNESS\n    color = mix(vec3(0.0), color, textureBrightness);\n#endif\n\n#ifdef APPLY_CONTRAST\n    color = mix(vec3(0.5), color, textureContrast);\n#endif\n\n#ifdef APPLY_HUE\n    color = czm_hue(color, textureHue);\n#endif\n\n#ifdef APPLY_SATURATION\n    color = czm_saturation(color, textureSaturation);\n#endif\n\n#ifdef APPLY_GAMMA\n    color = pow(color, vec3(textureOneOverGamma));\n#endif\n\n    float sourceAlpha = alpha * textureAlpha;\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\n    return vec4(outColor, outAlpha);\n}\n\nvec4 computeDayColor(vec4 initialColor, vec2 textureCoordinates);\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue);\n\nvoid main()\n{\n    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0\n    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the\n    // fragments on the edges of tiles even though the vertex shader is outputting\n    // coordinates strictly in the 0-1 range.\n    vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0));\n\n#ifdef SHOW_TILE_BOUNDARIES\n    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||\n        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))\n    {\n        color = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING)\n    vec3 normalMC = normalize(czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));   // normalized surface normal in model coordinates\n    vec3 normalEC = normalize(czm_normal3D * normalMC);                                         // normalized surface normal in eye coordiantes\n#elif defined(ENABLE_VERTEX_LIGHTING)\n    vec3 normalMC = normalize(v_normalMC);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// normalized surface normal in model coordinates\n    vec3 normalEC = normalize(v_normalEC);                                                      // normalized surface normal in eye coordiantes\n#endif\n\n#ifdef SHOW_REFLECTIVE_OCEAN\n    vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;\n    vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;\n    vec2 waterMaskTextureCoordinates = v_textureCoordinates * waterMaskScale + waterMaskTranslation;\n\n    float mask = texture2D(u_waterMask, waterMaskTextureCoordinates).r;\n\n    if (mask > 0.0)\n    {\n        mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);\n        \n        vec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC);\n        vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx);\n\n        vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));\n\n        color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask);\n    }\n#endif\n\n#ifdef ENABLE_VERTEX_LIGHTING\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 0.9 + 0.3, 0.0, 1.0);\n    gl_FragColor = vec4(color.rgb * diffuseIntensity, color.a);\n#elif defined(ENABLE_DAYNIGHT_SHADING)\n    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\n    float cameraDist = length(czm_view[3]);\n    float fadeOutDist = u_lightingFadeDistance.x;\n    float fadeInDist = u_lightingFadeDistance.y;\n    float t = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\n    diffuseIntensity = mix(1.0, diffuseIntensity, t);\n    gl_FragColor = vec4(color.rgb * diffuseIntensity, color.a);\n#else\n    gl_FragColor = color;\n#endif\n}\n\n#ifdef SHOW_REFLECTIVE_OCEAN\n\nfloat waveFade(float edge0, float edge1, float x)\n{\n    float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return pow(1.0 - y, 5.0);\n}\n\nfloat linearFade(float edge0, float edge1, float x)\n{\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\n// Based on water rendering by Jonas Wagner:\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\n// low altitude wave settings\nconst float oceanFrequencyLowAltitude = 825000.0;\nconst float oceanAnimationSpeedLowAltitude = 0.004;\nconst float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;\nconst float oceanSpecularIntensity = 0.5;\n \n// high altitude wave settings\nconst float oceanFrequencyHighAltitude = 125000.0;\nconst float oceanAnimationSpeedHighAltitude = 0.008;\nconst float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;\n\nvec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue)\n{\n    vec3 positionToEyeEC = -positionEyeCoordinates;\n    float positionToEyeECLength = length(positionToEyeEC);\n\n    // The double normalize below works around a bug in Firefox on Android devices.\n    vec3 normalizedpositionToEyeEC = normalize(normalize(positionToEyeEC));\n    \n    // Fade out the waves as the camera moves far from the surface.\n    float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);\n\n#ifdef SHOW_OCEAN_WAVES\n    // high altitude waves\n    float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;\n    vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);\n    vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);\n    \n    // low altitude waves\n    time = czm_frameNumber * oceanAnimationSpeedLowAltitude;\n    noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);\n    vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);\n    \n    // blend the 2 wave layers based on distance to surface\n    float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);\n    float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);\n    vec3 normalTangentSpace = \n    \t(highAltitudeFade * normalTangentSpaceHighAltitude) + \n    \t(lowAltitudeFade * normalTangentSpaceLowAltitude);\n    normalTangentSpace = normalize(normalTangentSpace);\n    \n    // fade out the normal perturbation as we move farther from the water surface\n    normalTangentSpace.xy *= waveIntensity;\n    normalTangentSpace = normalize(normalTangentSpace);\n#else\n    vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);\n#endif\n\n    vec3 normalEC = enuToEye * normalTangentSpace;\n    \n    const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);\n    \n    // Use diffuse light to highlight the waves\n    float diffuseIntensity = czm_getLambertDiffuse(czm_sunDirectionEC, normalEC);\n    vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity;\n    \n#ifdef SHOW_OCEAN_WAVES\n    // Where diffuse light is low or non-existent, use wave highlights based solely on\n    // the wave bumpiness and no particular light direction.\n    float tsPerturbationRatio = normalTangentSpace.z;\n    vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);\n#else\n    vec3 nonDiffuseHighlight = vec3(0.0);\n#endif\n\n    // Add specular highlights in 3D, and in all modes when zoomed in.\n    float specularIntensity = czm_getSpecular(czm_sunDirectionEC, normalizedpositionToEyeEC, normalEC, 10.0) + 0.25 * czm_getSpecular(czm_moonDirectionEC, normalizedpositionToEyeEC, normalEC, 10.0);\n    float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), specularMapValue);\n    float specular = specularIntensity * surfaceReflectance;\n    \n    return vec4(imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular, imageryColor.a); \n}\n\n#endif // #ifdef SHOW_REFLECTIVE_OCEAN\n';
},{}],551:[function(require,module,exports){
'use strict';
module.exports = 'varying vec4 positionEC;\n\nvoid main()\n{\n    // TODO: make arbitrary ellipsoid\n    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n    \n    vec3 direction = normalize(positionEC.xyz);\n    czm_ray ray = czm_ray(vec3(0.0), direction);\n    \n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n    if (!czm_isEmpty(intersection))\n    {\n        gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    else\n    {\n        discard;\n    }\n}';
},{}],552:[function(require,module,exports){
'use strict';
module.exports = 'uniform vec3 u_color;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    // TODO: make arbitrary ellipsoid\n    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n    vec3 direction = normalize(czm_windowToEyeCoordinates(gl_FragCoord).xyz);\n    czm_ray ray = czm_ray(vec3(0.0), direction);\n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n    \n    if (!czm_isEmpty(intersection))\n    {\n        vec3 positionEC = czm_pointAlongRay(ray, intersection.start);\n        vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;\n\t    \n\t    vec3 normalMC = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), vec3(1.0)));\n\t    vec3 normalEC = normalize(czm_normal * normalMC);\n\t    \n        vec3 startDayColor = u_color;\n\t\t\n        gl_FragColor = vec4(startDayColor, 1.0);\n    }\n    else\n    {\n        discard;\n    }\n}';
},{}],553:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec4 position3DAndHeight;\nattribute vec4 textureCoordAndEncodedNormals;\n\nuniform vec3 u_center3D;\nuniform mat4 u_modifiedModelView;\nuniform vec4 u_tileRectangle;\n\n// Uniforms for 2D Mercator projection\nuniform vec2 u_southAndNorthLatitude;\nuniform vec3 u_southMercatorYLowAndHighAndOneOverHeight;\n\nvarying vec3 v_positionMC;\nvarying vec3 v_positionEC;\n\nvarying vec2 v_textureCoordinates;\nvarying vec3 v_normalMC;\nvarying vec3 v_normalEC;\n\n// These functions are generated at runtime.\nvec4 getPosition(vec3 position3DWC);\nfloat get2DYPositionFraction();\n\nvec4 getPosition3DMode(vec3 position3DWC)\n{\n    return czm_projection * (u_modifiedModelView * vec4(position3DAndHeight.xyz, 1.0));\n}\n\nfloat get2DMercatorYPositionFraction()\n{\n    // The width of a tile at level 11, in radians and assuming a single root tile, is\n    //   2.0 * czm_pi / pow(2.0, 11.0)\n    // We want to just linearly interpolate the 2D position from the texture coordinates\n    // when we\'re at this level or higher.  The constant below is the expression\n    // above evaluated and then rounded up at the 4th significant digit.\n    const float maxTileWidth = 0.003068;\n    float positionFraction = textureCoordAndEncodedNormals.y;\n    float southLatitude = u_southAndNorthLatitude.x;\n    float northLatitude = u_southAndNorthLatitude.y;\n    if (northLatitude - southLatitude > maxTileWidth)\n    {\n        float southMercatorYLow = u_southMercatorYLowAndHighAndOneOverHeight.x;\n        float southMercatorYHigh = u_southMercatorYLowAndHighAndOneOverHeight.y;\n        float oneOverMercatorHeight = u_southMercatorYLowAndHighAndOneOverHeight.z;\n\n        float currentLatitude = mix(southLatitude, northLatitude, textureCoordAndEncodedNormals.y);\n        currentLatitude = clamp(currentLatitude, -czm_webMercatorMaxLatitude, czm_webMercatorMaxLatitude);\n        positionFraction = czm_latitudeToWebMercatorFraction(currentLatitude, southMercatorYLow, southMercatorYHigh, oneOverMercatorHeight);\n    }    \n    return positionFraction;\n}\n\nfloat get2DGeographicYPositionFraction()\n{\n    return textureCoordAndEncodedNormals.y;\n}\n\nvec4 getPositionPlanarEarth(vec3 position3DWC, float height2D)\n{\n    float yPositionFraction = get2DYPositionFraction();\n    vec4 rtcPosition2D = vec4(height2D, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordAndEncodedNormals.x, yPositionFraction)), 1.0);  \n    return czm_projection * (u_modifiedModelView * rtcPosition2D);\n}\n\nvec4 getPosition2DMode(vec3 position3DWC)\n{\n    return getPositionPlanarEarth(position3DWC, 0.0);\n}\n\nvec4 getPositionColumbusViewMode(vec3 position3DWC)\n{\n    return getPositionPlanarEarth(position3DWC, position3DAndHeight.w);\n}\n\nvec4 getPositionMorphingMode(vec3 position3DWC)\n{\n    // We do not do RTC while morphing, so there is potential for jitter.\n    // This is unlikely to be noticeable, though.\n    float yPositionFraction = get2DYPositionFraction();\n    vec4 position2DWC = vec4(0.0, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordAndEncodedNormals.x, yPositionFraction)), 1.0);\n    vec4 morphPosition = czm_columbusViewMorph(position2DWC, vec4(position3DWC, 1.0), czm_morphTime);\n    return czm_modelViewProjection * morphPosition;\n}\n\nvoid main() \n{\n    vec3 position3DWC = position3DAndHeight.xyz + u_center3D;\n\n    gl_Position = getPosition(position3DWC);\n\n#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING)\n    v_positionEC = (czm_modelView3D * vec4(position3DWC, 1.0)).xyz;\n    v_positionMC = position3DWC;                                 // position in model coordinates\n#elif defined(ENABLE_VERTEX_LIGHTING)\n    v_positionEC = (czm_modelView3D * vec4(position3DWC, 1.0)).xyz;\n    v_positionMC = position3DWC;                                 // position in model coordinates\n    float encodedNormal = textureCoordAndEncodedNormals.z;\n    v_normalMC = czm_octDecode(encodedNormal);\n    v_normalEC = czm_normal3D * v_normalMC;\n#endif\n\n    v_textureCoordinates = textureCoordAndEncodedNormals.xy;\n}\n';
},{}],554:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec4 position;\n\nvarying vec4 positionEC;\n\nvoid main()\n{\n    positionEC = czm_modelView * position;\n    gl_Position = czm_projection * positionEC;\n}';
},{}],555:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec4 position;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() \n{\n    float x = (position.x - czm_viewport.x) / czm_viewport.z;\n    float y = (position.y - czm_viewport.y) / czm_viewport.w;\n    v_textureCoordinates = vec2(x, y);\n    \n    gl_Position = czm_viewportOrthographic * position;\n}';
},{}],556:[function(require,module,exports){
'use strict';
module.exports = 'uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    \n    vec2 centerPixel = fract(repeat * st);\n    float centerBump = texture2D(image, centerPixel).channel;\n    \n    float imageWidth = float(imageDimensions.x);\n    vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\n    float rightBump = texture2D(image, rightPixel).channel;\n    \n    float imageHeight = float(imageDimensions.y);\n    vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\n    float topBump = texture2D(image, leftPixel).channel;\n    \n    vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n \n    material.normal = normalEC;\n    material.diffuse = vec3(0.01);\n    \n    return material;\n}';
},{}],557:[function(require,module,exports){
'use strict';
module.exports = 'uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    \n    // From Stefan Gustavson\'s Procedural Textures in GLSL in OpenGL Insights\n    float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);  // 0.0 or 1.0\n    \n    // Find the distance from the closest separator (region between two colors)\n    float scaledWidth = fract(repeat.s * st.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(repeat.t * st.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n    float value = min(scaledWidth, scaledHeight);\n    \n    vec4 currentColor = mix(lightColor, darkColor, b);\n    vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03);\n    \n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    \n    return material;\n}\n';
},{}],558:[function(require,module,exports){
'use strict';
module.exports = 'uniform vec4 lightColor;\nuniform vec4 darkColor;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    // From Stefan Gustavson\'s Procedural Textures in GLSL in OpenGL Insights\n    float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));  // 0.0 or 1.0\n\n    vec4 color = mix(lightColor, darkColor, b);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    \n    return material;\n}\n';
},{}],559:[function(require,module,exports){
'use strict';
module.exports = 'uniform vec4 fadeInColor;\nuniform vec4 fadeOutColor;\nuniform float maximumDistance;\nuniform bool repeat;\nuniform vec2 fadeDirection;\nuniform vec2 time;\n\nfloat getTime(float t, float coord)\n{\n    float scalar = 1.0 / maximumDistance;\n    float q  = distance(t, coord) * scalar;\n    if (repeat)\n    {\n        float r = distance(t, coord + 1.0) * scalar;\n        float s = distance(t, coord - 1.0) * scalar;\n        q = min(min(r, s), q);\n    }\n    return clamp(q, 0.0, 1.0);\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 st = materialInput.st;\n    float s = getTime(time.x, st.s) * fadeDirection.s;\n    float t = getTime(time.y, st.t) * fadeDirection.t;\n    \n    float u = length(vec2(s, t));\n    vec4 color = mix(fadeInColor, fadeOutColor, u);\n    \n    material.emission = color.rgb;\n    material.alpha = color.a;\n    \n    return material;\n}\n';
},{}],560:[function(require,module,exports){
'use strict';
module.exports = '#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform vec4 color;\nuniform float cellAlpha;\nuniform vec2 lineCount;\nuniform vec2 lineThickness;\nuniform vec2 lineOffset;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n\n    float scaledWidth = fract(lineCount.s * st.s - lineOffset.s);\n    scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n    float scaledHeight = fract(lineCount.t * st.t - lineOffset.t);\n    scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n\n    float value;\n#ifdef GL_OES_standard_derivatives\n    // Fuzz Factor - Controls blurriness of lines\n    const float fuzz = 1.2;\n    vec2 thickness = (lineThickness * czm_resolutionScale) - 1.0;\n\n    // From "3D Engine Design for Virtual Globes" by Cozzi and Ring, Listing 4.13.\n    vec2 dx = abs(dFdx(st));\n    vec2 dy = abs(dFdy(st));\n    vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount;\n    value = min(\n        smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth),\n        smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight));\n#else\n    // Fuzz Factor - Controls blurriness of lines\n    const float fuzz = 0.05;\n\n    vec2 range = 0.5 - (lineThickness * 0.05);\n    value = min(\n        1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth),\n        1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight));\n#endif\n\n    // Edges taken from RimLightingMaterial.glsl\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)));\n    float sRim = smoothstep(0.8, 1.0, dRim);\n    value *= (1.0 - sRim);\n\n    vec3 halfColor = color.rgb * 0.5;\n    material.diffuse = halfColor;\n    material.emission = halfColor;\n    material.alpha = color.a * (1.0 - ((1.0 - cellAlpha) * value));\n\n    return material;\n}\n';
},{}],561:[function(require,module,exports){
'use strict';
module.exports = 'uniform sampler2D image;\nuniform float strength;\nuniform vec2 repeat;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec4 textureValue = texture2D(image, fract(repeat * materialInput.st));\n    vec3 normalTangentSpace = textureValue.channels;\n    normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\n    normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\n    normalTangentSpace = normalize(normalTangentSpace);\n    vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n    \n    material.normal = normalEC;\n    \n    return material;\n}';
},{}],562:[function(require,module,exports){
'use strict';
module.exports = '#extension GL_OES_standard_derivatives : enable\n\nuniform vec4 color;\n\nvarying float v_width;\n\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\n{\n    float slope = (p0.y - p1.y) / (p0.x - p1.x);\n    return slope * (x - p0.x) + p0.y;\n}\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 st = materialInput.st;\n    \n    float base = 1.0 - abs(fwidth(st.s)) * 10.0;\n    vec2 center = vec2(1.0, 0.5);\n    float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s);\n    float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s);\n    \n    float halfWidth = 0.15;\n    float s = step(0.5 - halfWidth, st.t);\n    s *= 1.0 - step(0.5 + halfWidth, st.t);\n    s *= 1.0 - step(base, st.s);\n    \n    float t = step(base, materialInput.st.s);\n    t *= 1.0 - step(ptOnUpperLine, st.t);\n    t *= step(ptOnLowerLine, st.t);\n    \n    // Find the distance from the closest separator (region between two colors)\n    float dist;\n    if (st.s < base)\n    {\n        float d1 = abs(st.t - (0.5 - halfWidth));\n        float d2 = abs(st.t - (0.5 + halfWidth));\n        dist = min(d1, d2);\n    }\n    else\n    {\n        float d1 = czm_infinity;\n        if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\n        {\n            d1 = abs(st.s - base);\n        }\n        float d2 = abs(st.t - ptOnUpperLine);\n        float d3 = abs(st.t - ptOnLowerLine);\n        dist = min(min(d1, d2), d3);\n    }\n    \n    vec4 outsideColor = vec4(0.0);\n    vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0));\n    vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist);\n    \n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n    return material;\n}\n';
},{}],563:[function(require,module,exports){
'use strict';
module.exports = 'uniform vec4 color;\nuniform float glowPower;\n\nvarying float v_width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    vec2 st = materialInput.st;\n    float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5);\n\n    material.emission = max(vec3(glow - 1.0 + color.rgb), color.rgb);\n    material.alpha = clamp(0.0, 1.0, glow) * color.a;\n\n    return material;\n}\n';
},{}],564:[function(require,module,exports){
'use strict';
module.exports = 'uniform vec4 color;\nuniform vec4 outlineColor;\nuniform float outlineWidth;\n\nvarying float v_width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    \n    vec2 st = materialInput.st;\n    float halfInteriorWidth =  0.5 * (v_width - outlineWidth) / v_width;\n    float b = step(0.5 - halfInteriorWidth, st.t);\n    b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\n    \n    // Find the distance from the closest separator (region between two colors)\n    float d1 = abs(st.t - (0.5 - halfInteriorWidth));\n    float d2 = abs(st.t - (0.5 + halfInteriorWidth));\n    float dist = min(d1, d2);\n    \n    vec4 currentColor = mix(outlineColor, color, b);\n    vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\n    \n    material.diffuse = outColor.rgb;\n    material.alpha = outColor.a;\n    \n    return material;\n}\n';
},{}],565:[function(require,module,exports){
'use strict';
module.exports = 'uniform vec4 color;\nuniform vec4 rimColor;\nuniform float width;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html\n    float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC));\n    float s = smoothstep(1.0 - width, 1.0, d);\n\n    material.diffuse = color.rgb;\n    material.emission = rimColor.rgb * s; \n    material.alpha = mix(color.a, rimColor.a, s);\n\n    return material;\n}\n';
},{}],566:[function(require,module,exports){
'use strict';
module.exports = 'uniform vec4 evenColor;\nuniform vec4 oddColor;\nuniform float offset;\nuniform float repeat;\nuniform bool horizontal;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    // Based on the Stripes Fragment Shader in the Orange Book (11.1.2)\n    float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\n    float value = fract((coord - offset) * (repeat * 0.5));\n    float dist = min(value, min(abs(value - 0.5), 1.0 - value));\n    \n    vec4 currentColor = mix(evenColor, oddColor, step(0.5, value));\n    vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist);\n    \n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    \n    return material;\n}\n';
},{}],567:[function(require,module,exports){
'use strict';
module.exports = '// Thanks for the contribution Jonas\n// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog\n\nuniform sampler2D specularMap;\nuniform sampler2D normalMap;\nuniform vec4 baseWaterColor;\nuniform vec4 blendColor;\nuniform float frequency;\nuniform float animationSpeed;\nuniform float amplitude;\nuniform float specularIntensity;\nuniform float fadeFactor;\n\nczm_material czm_getMaterial(czm_materialInput materialInput)\n{\n    czm_material material = czm_getDefaultMaterial(materialInput);\n\n    float time = czm_frameNumber * animationSpeed;\n    \n    // fade is a function of the distance from the fragment and the frequency of the waves\n    float fade = max(1.0, (length(materialInput.positionToEyeEC) / 10000000000.0) * frequency * fadeFactor);\n            \n    float specularMapValue = texture2D(specularMap, materialInput.st).r;\n    \n    // note: not using directional motion at this time, just set the angle to 0.0;\n    vec4 noise = czm_getWaterNoise(normalMap, materialInput.st * frequency, time, 0.0);\n    vec3 normalTangentSpace = noise.xyz * vec3(1.0, 1.0, (1.0 / amplitude));\n    \n    // fade out the normal perturbation as we move further from the water surface\n    normalTangentSpace.xy /= fade;\n        \n    // attempt to fade out the normal perturbation as we approach non water areas (low specular map value)\n    normalTangentSpace = mix(vec3(0.0, 0.0, 50.0), normalTangentSpace, specularMapValue);\n    \n    normalTangentSpace = normalize(normalTangentSpace);\n    \n    // get ratios for alignment of the new normal vector with a vector perpendicular to the tangent plane\n    float tsPerturbationRatio = clamp(dot(normalTangentSpace, vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n    \n    // fade out water effect as specular map value decreases\n    material.alpha = specularMapValue;\n    \n    // base color is a blend of the water and non-water color based on the value from the specular map\n    // may need a uniform blend factor to better control this\n    material.diffuse = mix(blendColor.rgb, baseWaterColor.rgb, specularMapValue);\n    \n    // diffuse highlights are based on how perturbed the normal is\n    material.diffuse += (0.1 * tsPerturbationRatio);\n    \n    material.normal = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\n    \n    material.specular = specularIntensity;\n    material.shininess = 10.0;\n    \n    return material;\n}';
},{}],568:[function(require,module,exports){
'use strict';
module.exports = 'void clipLineSegmentToNearPlane(\n    vec3 p0,\n    vec3 p1,\n    out vec4 positionWC,\n    out bool clipped,\n    out bool culledByNearPlane)\n{\n    culledByNearPlane = false;\n    clipped = false;\n    \n    vec3 p1ToP0 = p1 - p0;\n    float magnitude = length(p1ToP0);\n    vec3 direction = normalize(p1ToP0);\n    float endPoint0Distance =  -(czm_currentFrustum.x + p0.z);\n    float denominator = -direction.z;\n    \n    if (endPoint0Distance < 0.0 && abs(denominator) < czm_epsilon7)\n    {\n        culledByNearPlane = true;\n    }\n    else if (endPoint0Distance < 0.0 && abs(denominator) > czm_epsilon7)\n    {\n        // t = (-plane distance - dot(plane normal, ray origin)) / dot(plane normal, ray direction)\n        float t = (czm_currentFrustum.x + p0.z) / denominator;\n        if (t < 0.0 || t > magnitude)\n        {\n            culledByNearPlane = true;\n        }\n        else\n        {\n            p0 = p0 + t * direction;\n            clipped = true;\n        }\n    }\n    \n    positionWC = czm_eyeToWindowCoordinates(vec4(p0, 1.0));\n}\n\nvec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious) {\n    vec4 endPointWC, p0, p1;\n    bool culledByNearPlane, clipped;\n    \n    vec4 positionEC = czm_modelViewRelativeToEye * position;\n    vec4 prevEC = czm_modelViewRelativeToEye * previous;\n    vec4 nextEC = czm_modelViewRelativeToEye * next;\n    \n    clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, p0, clipped, culledByNearPlane);\n    clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, p1, clipped, culledByNearPlane);\n    clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, endPointWC, clipped, culledByNearPlane);\n    \n    if (culledByNearPlane)\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    vec2 prevWC = normalize(p0.xy - endPointWC.xy);\n    vec2 nextWC = normalize(p1.xy - endPointWC.xy);\n    \n    float expandWidth = width * 0.5;\n    vec2 direction;\n\n    if (czm_equalsEpsilon(normalize(previous.xyz - position.xyz), vec3(0.0), czm_epsilon1) || czm_equalsEpsilon(prevWC, -nextWC, czm_epsilon1))\n    {\n        direction = vec2(-nextWC.y, nextWC.x);\n    }\n    else if (czm_equalsEpsilon(normalize(next.xyz - position.xyz), vec3(0.0), czm_epsilon1) || clipped)\n    {\n        direction = vec2(prevWC.y, -prevWC.x);\n    }\n    else\n    {\n        vec2 normal = vec2(-nextWC.y, nextWC.x);\n        direction = normalize((nextWC + prevWC) * 0.5);\n        if (dot(direction, normal) < 0.0)\n        {\n            direction = -direction;\n        }\n\n        // The sine of the angle between the two vectors is given by the formula\n        //         |a x b| = |a||b|sin(theta)\n        // which is\n        //     float sinAngle = length(cross(vec3(direction, 0.0), vec3(nextWC, 0.0)));\n        // Because the z components of both vectors are zero, the x and y coordinate will be zero.\n        // Therefore, the sine of the angle is just the z component of the cross product.\n        float sinAngle = abs(direction.x * nextWC.y - direction.y * nextWC.x);\n        expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0);\n    }\n\n    vec2 offset = direction * expandDirection * expandWidth * czm_resolutionScale;\n    return vec4(endPointWC.xy + offset, -endPointWC.z, 1.0);\n}\n';
},{}],569:[function(require,module,exports){
'use strict';
module.exports = 'varying vec2 v_st;\n\nvoid main()\n{\n    czm_materialInput materialInput;\n    \n    materialInput.s = v_st.s;\n    materialInput.st = v_st;\n    materialInput.str = vec3(v_st, 0.0);\n    \n    czm_material material = czm_getMaterial(materialInput);\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n}';
},{}],570:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 position2DHigh;\nattribute vec3 position2DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 prevPosition2DHigh;\nattribute vec3 prevPosition2DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec3 nextPosition2DHigh;\nattribute vec3 nextPosition2DLow;\nattribute vec4 texCoordExpandWidthAndShow;\nattribute vec4 pickColor;\n\nvarying vec2  v_st;\nvarying float v_width;\nvarying vec4  czm_pickColor;\n\nvoid main() \n{\n    float texCoord = texCoordExpandWidthAndShow.x;\n    float expandDir = texCoordExpandWidthAndShow.y;\n    float width = abs(texCoordExpandWidthAndShow.z) + 0.5;\n    bool usePrev = texCoordExpandWidthAndShow.z < 0.0;\n    float show = texCoordExpandWidthAndShow.w;\n    \n    vec4 p, prev, next;\n    if (czm_morphTime == 1.0)\n    {\n        p = czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz);\n        prev = czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz);\n        next = czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        p = czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy);\n        prev = czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy);\n        next = czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy);\n    }\n    else\n    {\n        p = czm_columbusViewMorph(\n                czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy),\n                czm_translateRelativeToEye(position3DHigh.xyz, position3DLow.xyz),\n                czm_morphTime);\n        prev = czm_columbusViewMorph(\n                czm_translateRelativeToEye(prevPosition2DHigh.zxy, prevPosition2DLow.zxy),\n                czm_translateRelativeToEye(prevPosition3DHigh.xyz, prevPosition3DLow.xyz),\n                czm_morphTime);\n        next = czm_columbusViewMorph(\n                czm_translateRelativeToEye(nextPosition2DHigh.zxy, nextPosition2DLow.zxy),\n                czm_translateRelativeToEye(nextPosition3DHigh.xyz, nextPosition3DLow.xyz),\n                czm_morphTime);\n    }\n    \n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev);\n    gl_Position = czm_viewportOrthographic * positionWC * show;\n    \n    v_st = vec2(texCoord, clamp(expandDir, 0.0, 1.0));\n    v_width = width;\n    czm_pickColor = pickColor;\n}\n';
},{}],571:[function(require,module,exports){
'use strict';
module.exports = 'uniform sampler2D u_texture0;\nuniform sampler2D u_texture1;\n\nuniform vec2 u_center;\nuniform float u_radius;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    vec4 color0 = texture2D(u_texture0, v_textureCoordinates);\n    vec4 color1 = texture2D(u_texture1, v_textureCoordinates);\n    \n    float x = length(gl_FragCoord.xy - u_center) / u_radius;\n    float t = smoothstep(0.5, 0.8, x);\n    gl_FragColor = mix(color0 + color1, color0, t);\n}\n';
},{}],572:[function(require,module,exports){
'use strict';
module.exports = 'uniform sampler2D u_texture;\n\nuniform float u_avgLuminance;\nuniform float u_threshold;\nuniform float u_offset;\n\nvarying vec2 v_textureCoordinates;\n\nfloat key(float avg)\n{\n    float guess = 1.5 - (1.5 / (avg * 0.1 + 1.0));\n    return max(0.0, guess) + 0.1;\n}\n\n// See section 9. "The bright-pass filter" of Realtime HDR Rendering\n// http://www.cg.tuwien.ac.at/research/publications/2007/Luksch_2007_RHR/Luksch_2007_RHR-RealtimeHDR%20.pdf\n\nvoid main()\n{\n    vec4 color = texture2D(u_texture, v_textureCoordinates);\n    vec3 xyz = czm_RGBToXYZ(color.rgb);\n    float luminance = xyz.r;\n    \n    float scaledLum = key(u_avgLuminance) * luminance / u_avgLuminance;\n    float brightLum = max(scaledLum - u_threshold, 0.0);\n    float brightness = brightLum / (u_offset + brightLum);\n    \n    xyz.r = brightness;\n    gl_FragColor = vec4(czm_XYZToRGB(xyz), 1.0);\n}\n';
},{}],573:[function(require,module,exports){
'use strict';
module.exports = '/**\n * @license\n * Copyright (c) 2011 NVIDIA Corporation. All rights reserved.\n *\n * TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED\n * *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS\n * OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, NONINFRINGEMENT,IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA \n * OR ITS SUPPLIERS BE  LIABLE  FOR  ANY  DIRECT, SPECIAL,  INCIDENTAL,  INDIRECT,  OR  \n * CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS \n * OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY \n * OTHER PECUNIARY LOSS) ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, \n * EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n */\n\n/*\nFXAA_PRESET - Choose compile-in knob preset 0-5.\n------------------------------------------------------------------------------\nFXAA_EDGE_THRESHOLD - The minimum amount of local contrast required \n                      to apply algorithm.\n                      1.0/3.0  - too little\n                      1.0/4.0  - good start\n                      1.0/8.0  - applies to more edges\n                      1.0/16.0 - overkill\n------------------------------------------------------------------------------\nFXAA_EDGE_THRESHOLD_MIN - Trims the algorithm from processing darks.\n                          Perf optimization.\n                          1.0/32.0 - visible limit (smaller isn\'t visible)\n                          1.0/16.0 - good compromise\n                          1.0/12.0 - upper limit (seeing artifacts)\n------------------------------------------------------------------------------\nFXAA_SEARCH_STEPS - Maximum number of search steps for end of span.\n------------------------------------------------------------------------------\nFXAA_SEARCH_THRESHOLD - Controls when to stop searching.\n                        1.0/4.0 - seems to be the best quality wise\n------------------------------------------------------------------------------\nFXAA_SUBPIX_TRIM - Controls sub-pixel aliasing removal.\n                   1.0/2.0 - low removal\n                   1.0/3.0 - medium removal\n                   1.0/4.0 - default removal\n                   1.0/8.0 - high removal\n                   0.0 - complete removal\n------------------------------------------------------------------------------\nFXAA_SUBPIX_CAP - Insures fine detail is not completely removed.\n                  This is important for the transition of sub-pixel detail,\n                  like fences and wires.\n                  3.0/4.0 - default (medium amount of filtering)\n                  7.0/8.0 - high amount of filtering\n                  1.0 - no capping of sub-pixel aliasing removal\n*/\n\n#ifndef FXAA_PRESET\n    #define FXAA_PRESET 3\n#endif\n#if (FXAA_PRESET == 3)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        16\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n#if (FXAA_PRESET == 4)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        24\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n#if (FXAA_PRESET == 5)\n    #define FXAA_EDGE_THRESHOLD      (1.0/8.0)\n    #define FXAA_EDGE_THRESHOLD_MIN  (1.0/24.0)\n    #define FXAA_SEARCH_STEPS        32\n    #define FXAA_SEARCH_THRESHOLD    (1.0/4.0)\n    #define FXAA_SUBPIX_CAP          (3.0/4.0)\n    #define FXAA_SUBPIX_TRIM         (1.0/4.0)\n#endif\n\n#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))\n\n// Return the luma, the estimation of luminance from rgb inputs.\n// This approximates luma using one FMA instruction,\n// skipping normalization and tossing out blue.\n// FxaaLuma() will range 0.0 to 2.963210702.\nfloat FxaaLuma(vec3 rgb) {\n    return rgb.y * (0.587/0.299) + rgb.x;\n}\n\nvec3 FxaaLerp3(vec3 a, vec3 b, float amountOfA) {\n    return (vec3(-amountOfA) * b) + ((a * vec3(amountOfA)) + b);\n}\n\nvec4 FxaaTexOff(sampler2D tex, vec2 pos, ivec2 off, vec2 rcpFrame) {\n    float x = pos.x + float(off.x) * rcpFrame.x;\n    float y = pos.y + float(off.y) * rcpFrame.y;\n    return texture2D(tex, vec2(x, y));\n}\n\n// pos is the output of FxaaVertexShader interpolated across screen.\n// xy -> actual texture position {0.0 to 1.0}\n// rcpFrame should be a uniform equal to  {1.0/frameWidth, 1.0/frameHeight}\nvec3 FxaaPixelShader(vec2 pos, sampler2D tex, vec2 rcpFrame)\n{\n    vec3 rgbN = FxaaTexOff(tex, pos.xy, ivec2( 0,-1), rcpFrame).xyz;\n    vec3 rgbW = FxaaTexOff(tex, pos.xy, ivec2(-1, 0), rcpFrame).xyz;\n    vec3 rgbM = FxaaTexOff(tex, pos.xy, ivec2( 0, 0), rcpFrame).xyz;\n    vec3 rgbE = FxaaTexOff(tex, pos.xy, ivec2( 1, 0), rcpFrame).xyz;\n    vec3 rgbS = FxaaTexOff(tex, pos.xy, ivec2( 0, 1), rcpFrame).xyz;\n    \n    float lumaN = FxaaLuma(rgbN);\n    float lumaW = FxaaLuma(rgbW);\n    float lumaM = FxaaLuma(rgbM);\n    float lumaE = FxaaLuma(rgbE);\n    float lumaS = FxaaLuma(rgbS);\n    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));\n    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));\n    \n    float range = rangeMax - rangeMin;\n    if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD))\n    {\n        return rgbM;\n    }\n    \n    vec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\n    \n    float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;\n    float rangeL = abs(lumaL - lumaM);\n    float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE; \n    blendL = min(FXAA_SUBPIX_CAP, blendL);\n    \n    vec3 rgbNW = FxaaTexOff(tex, pos.xy, ivec2(-1,-1), rcpFrame).xyz;\n    vec3 rgbNE = FxaaTexOff(tex, pos.xy, ivec2( 1,-1), rcpFrame).xyz;\n    vec3 rgbSW = FxaaTexOff(tex, pos.xy, ivec2(-1, 1), rcpFrame).xyz;\n    vec3 rgbSE = FxaaTexOff(tex, pos.xy, ivec2( 1, 1), rcpFrame).xyz;\n    rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\n    rgbL *= vec3(1.0/9.0);\n    \n    float lumaNW = FxaaLuma(rgbNW);\n    float lumaNE = FxaaLuma(rgbNE);\n    float lumaSW = FxaaLuma(rgbSW);\n    float lumaSE = FxaaLuma(rgbSE);\n    \n    float edgeVert = \n        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\n        abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\n        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\n    float edgeHorz = \n        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\n        abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\n        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\n        \n    bool horzSpan = edgeHorz >= edgeVert;\n    float lengthSign = horzSpan ? -rcpFrame.y : -rcpFrame.x;\n    \n    if(!horzSpan)\n    {\n        lumaN = lumaW;\n        lumaS = lumaE;\n    }\n    \n    float gradientN = abs(lumaN - lumaM);\n    float gradientS = abs(lumaS - lumaM);\n    lumaN = (lumaN + lumaM) * 0.5;\n    lumaS = (lumaS + lumaM) * 0.5;\n    \n    if (gradientN < gradientS)\n    {\n        lumaN = lumaS;\n        lumaN = lumaS;\n        gradientN = gradientS;\n        lengthSign *= -1.0;\n    }\n    \n    vec2 posN;\n    posN.x = pos.x + (horzSpan ? 0.0 : lengthSign * 0.5);\n    posN.y = pos.y + (horzSpan ? lengthSign * 0.5 : 0.0);\n    \n    gradientN *= FXAA_SEARCH_THRESHOLD;\n    \n    vec2 posP = posN;\n    vec2 offNP = horzSpan ? vec2(rcpFrame.x, 0.0) : vec2(0.0, rcpFrame.y); \n    float lumaEndN = lumaN;\n    float lumaEndP = lumaN;\n    bool doneN = false;\n    bool doneP = false;\n    posN += offNP * vec2(-1.0, -1.0);\n    posP += offNP * vec2( 1.0,  1.0);\n    \n    for(int i = 0; i < FXAA_SEARCH_STEPS; i++) {\n        if(!doneN)\n        {\n            lumaEndN = FxaaLuma(texture2D(tex, posN.xy).xyz);\n        }\n        if(!doneP)\n        {\n            lumaEndP = FxaaLuma(texture2D(tex, posP.xy).xyz);\n        }\n        \n        doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\n        doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\n        \n        if(doneN && doneP)\n        {\n            break;\n        }\n        if(!doneN)\n        {\n            posN -= offNP;\n        }\n        if(!doneP)\n        {\n            posP += offNP;\n        }\n    }\n    \n    float dstN = horzSpan ? pos.x - posN.x : pos.y - posN.y;\n    float dstP = horzSpan ? posP.x - pos.x : posP.y - pos.y;\n    bool directionN = dstN < dstP;\n    lumaEndN = directionN ? lumaEndN : lumaEndP;\n    \n    if(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0))\n    {\n        lengthSign = 0.0;\n    }\n \n\n    float spanLength = (dstP + dstN);\n    dstN = directionN ? dstN : dstP;\n    float subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;\n    vec3 rgbF = texture2D(tex, vec2(\n        pos.x + (horzSpan ? 0.0 : subPixelOffset),\n        pos.y + (horzSpan ? subPixelOffset : 0.0))).xyz;\n    return FxaaLerp3(rgbL, rgbF, blendL); \n}\n\nuniform sampler2D u_texture;\nuniform vec2 u_step;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    gl_FragColor = vec4(FxaaPixelShader(v_textureCoordinates, u_texture, u_step), 1.0);\n}\n';
},{}],574:[function(require,module,exports){
'use strict';
module.exports = '#define SAMPLES 8\n\nuniform float delta;\nuniform float sigma;\nuniform float direction; // 0.0 for x direction, 1.0 for y direction\n\nuniform sampler2D u_texture;\nuniform vec2 u_step;\n\nvarying vec2 v_textureCoordinates;\n\n//  Incremental Computation of the Gaussian:\n//  http://http.developer.nvidia.com/GPUGems3/gpugems3_ch40.html\n\nvoid main()\n{\n    vec2 st = v_textureCoordinates;\n    \n    vec2 dir = vec2(1.0 - direction, direction);\n    \n    vec3 g;\n    g.x = 1.0 / (sqrt(czm_twoPi) * sigma);\n    g.y = exp((-0.5 * delta * delta) / (sigma * sigma));\n    g.z = g.y * g.y;\n    \n    vec4 result = texture2D(u_texture, st) * g.x;\n    for (int i = 1; i < SAMPLES; ++i)\n    {\n        g.xy *= g.yz;\n        \n        vec2 offset = float(i) * dir * u_step;\n        result += texture2D(u_texture, st - offset) * g.x;\n        result += texture2D(u_texture, st + offset) * g.x;\n    }\n    \n    gl_FragColor = result;\n}\n';
},{}],575:[function(require,module,exports){
'use strict';
module.exports = 'uniform sampler2D u_texture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() \n{\n    gl_FragColor = texture2D(u_texture, v_textureCoordinates);\n}\n';
},{}],576:[function(require,module,exports){
'use strict';
module.exports = 'uniform sampler2D u_texture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    gl_FragColor = texture2D(u_texture, v_textureCoordinates);\n}\n';
},{}],577:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec4 position;\nattribute float webMercatorT;\n\nuniform vec2 u_textureDimensions;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    v_textureCoordinates = vec2(position.x, webMercatorT);\n    gl_Position = czm_viewportOrthographic * (position * vec4(u_textureDimensions, 1.0, 1.0));\n}\n';
},{}],578:[function(require,module,exports){
'use strict';
module.exports = '/**\n * @license\n * Copyright (c) 2000-2005, Sean O\'Neil (s_p_oneil@hotmail.com)\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * \n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the project nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Modifications made by Analytical Graphics, Inc.\n */\n \n // Code:  http://sponeil.net/\n // GPU Gems 2 Article:  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n \nconst float g = -0.95;\nconst float g2 = g * g;\n\nvarying vec3 v_rayleighColor;\nvarying vec3 v_mieColor;\nvarying vec3 v_toCamera;\nvarying vec3 v_positionEC;\n\nvoid main (void)\n{\n    // TODO: make arbitrary ellipsoid\n    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\n    \n    vec3 direction = normalize(v_positionEC);\n    czm_ray ray = czm_ray(vec3(0.0), direction);\n    \n    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n    if (!czm_isEmpty(intersection)) {\n        discard;\n    }\n    \n    // Extra normalize added for Android\n    float fCos = dot(czm_sunDirectionWC, normalize(v_toCamera)) / length(v_toCamera);\n    float fRayleighPhase = 0.75 * (1.0 + fCos*fCos);\n    float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);\n    \n    const float fExposure = 2.0;\n    \n    vec3 rgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n    rgb = vec3(1.0) - exp(-fExposure * rgb);\n    float l = czm_luminance(rgb);\n    gl_FragColor = vec4(rgb, min(smoothstep(0.0, 0.1, l), 1.0) * smoothstep(0.0, 1.0, czm_morphTime));\n}\n';
},{}],579:[function(require,module,exports){
'use strict';
module.exports = '/**\n * @license\n * Copyright (c) 2000-2005, Sean O\'Neil (s_p_oneil@hotmail.com)\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * \n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n * * Neither the name of the project nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Modifications made by Analytical Graphics, Inc.\n */\n \n // Code:  http://sponeil.net/\n // GPU Gems 2 Article:  http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n  \nattribute vec4 position;\n\nuniform float fCameraHeight;\nuniform float fCameraHeight2;\nuniform float fOuterRadius;     // The outer (atmosphere) radius\nuniform float fOuterRadius2;    // fOuterRadius^2\nuniform float fInnerRadius;     // The inner (planetary) radius\nuniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere\'s average density is found)\nuniform float fScaleOverScaleDepth; // fScale / fScaleDepth\n\nconst float Kr = 0.0025;\nconst float fKr4PI = Kr * 4.0 * czm_pi;\nconst float Km = 0.0015;\nconst float fKm4PI = Km * 4.0 * czm_pi;\nconst float ESun = 15.0;\nconst float fKmESun = Km * ESun;\nconst float fKrESun = Kr * ESun;\nconst vec3 v3InvWavelength = vec3(\n    5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\n    9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\n    19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\nconst float rayleighScaleDepth = 0.25;\n          \nconst int nSamples = 2;\nconst float fSamples = 2.0;\n\nvarying vec3 v_rayleighColor;\nvarying vec3 v_mieColor;\nvarying vec3 v_toCamera;\nvarying vec3 v_positionEC;\n\nfloat scale(float fCos)\n{\n    float x = 1.0 - fCos;\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n    vec3 v3Pos = position.xyz;\n    vec3 v3Ray = v3Pos - czm_viewerPositionWC;\n    float fFar = length(v3Ray);\n    v3Ray /= fFar;\n\n#ifdef SKY_FROM_SPACE\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n    float B = 2.0 * dot(czm_viewerPositionWC, v3Ray);\n    float C = fCameraHeight2 - fOuterRadius2;\n    float fDet = max(0.0, B*B - 4.0 * C);\n    float fNear = 0.5 * (-B - sqrt(fDet));\n\n    // Calculate the ray\'s starting position, then calculate its scattering offset\n    vec3 v3Start = czm_viewerPositionWC + v3Ray * fNear;\n    fFar -= fNear;\n    float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n    float fStartDepth = exp(-1.0 / fScaleDepth);\n    float fStartOffset = fStartDepth*scale(fStartAngle);\n#else // SKY_FROM_ATMOSPHERE\n    // Calculate the ray\'s starting position, then calculate its scattering offset\n    vec3 v3Start = czm_viewerPositionWC;\n    float fHeight = length(v3Start);\n    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n    float fStartAngle = dot(v3Ray, v3Start) / fHeight;\n    float fStartOffset = fDepth*scale(fStartAngle);\n#endif\n\n    // Initialize the scattering loop variables\n    float fSampleLength = fFar / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = v3Ray * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n    // Now loop through the sample rays\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<nSamples; i++)\n    {\n        float fHeight = length(v3SamplePoint);\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n        vec3 lightPosition = normalize(czm_viewerPositionWC); // czm_sunDirectionWC\n        float fLightAngle = dot(lightPosition, v3SamplePoint) / fHeight;\n        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n        float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));\n        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n        v3SamplePoint += v3SampleRay;\n    }\n\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n    v_mieColor = v3FrontColor * fKmESun;\n    v_rayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);\n    v_toCamera = czm_viewerPositionWC - v3Pos;\n    v_positionEC = (czm_modelView * position).xyz;\n    gl_Position = czm_modelViewProjection * position;\n}\n';
},{}],580:[function(require,module,exports){
'use strict';
module.exports = 'uniform samplerCube u_cubeMap;\n\nvarying vec3 v_texCoord;\n\nvoid main()\n{\n    vec3 rgb = textureCube(u_cubeMap, normalize(v_texCoord)).rgb;\n    gl_FragColor = vec4(rgb, czm_morphTime);\n}\n';
},{}],581:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec3 position;\n\nvarying vec3 v_texCoord;\n\nvoid main()\n{\n    vec3 p = czm_viewRotation * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));\n    gl_Position = czm_projection * vec4(p, 1.0);\n    v_texCoord = position.xyz;\n}\n';
},{}],582:[function(require,module,exports){
module.exports=require(576)
},{}],583:[function(require,module,exports){
'use strict';
module.exports = 'uniform float u_glowLengthTS;\nuniform float u_radiusTS;\n\nvarying vec2 v_textureCoordinates;\n\nvec2 rotate(vec2 p, vec2 direction)\n{\n    return vec2(p.x * direction.x - p.y * direction.y, p.x * direction.y + p.y * direction.x);\n}\n\nvec4 addBurst(vec2 position, vec2 direction)\n{\n    vec2 rotatedPosition = rotate(position, direction) * vec2(25.0, 0.75);\n    float radius = length(rotatedPosition);\n    float burst = 1.0 - smoothstep(0.0, 0.55, radius);\n\n    return vec4(burst);\n}\n\nvoid main()\n{\n    vec2 position = v_textureCoordinates - vec2(0.5);\n    float radius = length(position);\n    float surface = step(radius, u_radiusTS);\n    vec4 color = vec4(1.0, 1.0, surface + 0.2, surface);\n\n    float glow = 1.0 - smoothstep(0.0, 0.55, radius);\n    color.ba += mix(vec2(0.0), vec2(1.0), glow) * 0.75;\n\n    vec4 burst = vec4(0.0);\n\n    // The following loop has been manually unrolled for speed, to\n    // avoid sin() and cos().\n    //\n    //for (float i = 0.4; i < 3.2; i += 1.047) {\n    //    vec2 direction = vec2(sin(i), cos(i));\n    //    burst += 0.4 * addBurst(position, direction);\n    //\n    //    direction = vec2(sin(i - 0.08), cos(i - 0.08));\n    //    burst += 0.3 * addBurst(position, direction);\n    //}\n\n    burst += 0.4 * addBurst(position, vec2(0.38942,  0.92106));  // angle == 0.4\n    burst += 0.4 * addBurst(position, vec2(0.99235,  0.12348));  // angle == 0.4 + 1.047\n    burst += 0.4 * addBurst(position, vec2(0.60327, -0.79754));  // angle == 0.4 + 1.047 * 2.0\n\n    burst += 0.3 * addBurst(position, vec2(0.31457,  0.94924));  // angle == 0.4 - 0.08\n    burst += 0.3 * addBurst(position, vec2(0.97931,  0.20239));  // angle == 0.4 + 1.047 - 0.08\n    burst += 0.3 * addBurst(position, vec2(0.66507, -0.74678));  // angle == 0.4 + 1.047 * 2.0 - 0.08\n\n    // End of manual loop unrolling.\n\n    color += clamp(burst, vec4(0.0), vec4(1.0)) * 0.15;\n    \n    gl_FragColor = clamp(color, vec4(0.0), vec4(1.0));\n}\n';
},{}],584:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec2 direction;\n\nuniform float u_size;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() \n{\n    vec4 position;\n    if (czm_morphTime == 1.0)\n    {\n        position = vec4(czm_sunPositionWC, 1.0);\n    }\n    else\n    {\n        position = vec4(czm_sunPositionColumbusView.zxy, 1.0);\n    }\n    \n    vec4 positionEC = czm_view * position;\n    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);\n    \n    vec2 halfSize = vec2(u_size * 0.5);\n    halfSize *= ((direction * 2.0) - 1.0);\n    \n    gl_Position = czm_viewportOrthographic * vec4(positionWC.xy + halfSize, -positionWC.z, 1.0);\n    \n    v_textureCoordinates = direction;\n}\n';
},{}],585:[function(require,module,exports){
'use strict';
module.exports = 'attribute vec4 position;\nattribute vec2 textureCoordinates;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main() \n{\n    gl_Position = position;\n    v_textureCoordinates = textureCoordinates;\n}';
},{}],586:[function(require,module,exports){
if (Date.now === undefined) {
    Date.now = function () {
        return new Date().valueOf();
    };
}
var TWEEN = TWEEN || function () {
        var _tweens = [];
        return {
            REVISION: '13',
            getAll: function () {
                return _tweens;
            },
            removeAll: function () {
                _tweens = [];
            },
            add: function (tween) {
                _tweens.push(tween);
            },
            remove: function (tween) {
                var i = _tweens.indexOf(tween);
                if (i !== -1) {
                    _tweens.splice(i, 1);
                }
            },
            update: function (time) {
                if (_tweens.length === 0)
                    return false;
                var i = 0;
                time = time !== undefined ? time : typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now();
                while (i < _tweens.length) {
                    if (_tweens[i].update(time)) {
                        i++;
                    } else {
                        _tweens.splice(i, 1);
                    }
                }
                return true;
            }
        };
    }();
TWEEN.Tween = function (object) {
    var _object = object;
    var _valuesStart = {};
    var _valuesEnd = {};
    var _valuesStartRepeat = {};
    var _duration = 1000;
    var _repeat = 0;
    var _yoyo = false;
    var _isPlaying = false;
    var _reversed = false;
    var _delayTime = 0;
    var _startTime = null;
    var _easingFunction = TWEEN.Easing.Linear.None;
    var _interpolationFunction = TWEEN.Interpolation.Linear;
    var _chainedTweens = [];
    var _onStartCallback = null;
    var _onStartCallbackFired = false;
    var _onUpdateCallback = null;
    var _onCompleteCallback = null;
    var _onStopCallback = null;
    for (var field in object) {
        _valuesStart[field] = parseFloat(object[field], 10);
    }
    this.to = function (properties, duration) {
        if (duration !== undefined) {
            _duration = duration;
        }
        _valuesEnd = properties;
        return this;
    };
    this.start = function (time) {
        TWEEN.add(this);
        _isPlaying = true;
        _onStartCallbackFired = false;
        _startTime = time !== undefined ? time : typeof window !== 'undefined' && window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now();
        _startTime += _delayTime;
        for (var property in _valuesEnd) {
            if (_valuesEnd[property] instanceof Array) {
                if (_valuesEnd[property].length === 0) {
                    continue;
                }
                _valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);
            }
            _valuesStart[property] = _object[property];
            if (_valuesStart[property] instanceof Array === false) {
                _valuesStart[property] *= 1;
            }
            _valuesStartRepeat[property] = _valuesStart[property] || 0;
        }
        return this;
    };
    this.stop = function () {
        if (!_isPlaying) {
            return this;
        }
        TWEEN.remove(this);
        _isPlaying = false;
        if (_onStopCallback !== null) {
            _onStopCallback.call(_object);
        }
        this.stopChainedTweens();
        return this;
    };
    this.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
            _chainedTweens[i].stop();
        }
    };
    this.delay = function (amount) {
        _delayTime = amount;
        return this;
    };
    this.repeat = function (times) {
        _repeat = times;
        return this;
    };
    this.yoyo = function (yoyo) {
        _yoyo = yoyo;
        return this;
    };
    this.easing = function (easing) {
        _easingFunction = easing;
        return this;
    };
    this.interpolation = function (interpolation) {
        _interpolationFunction = interpolation;
        return this;
    };
    this.chain = function () {
        _chainedTweens = arguments;
        return this;
    };
    this.onStart = function (callback) {
        _onStartCallback = callback;
        return this;
    };
    this.onUpdate = function (callback) {
        _onUpdateCallback = callback;
        return this;
    };
    this.onComplete = function (callback) {
        _onCompleteCallback = callback;
        return this;
    };
    this.onStop = function (callback) {
        _onStopCallback = callback;
        return this;
    };
    this.update = function (time) {
        var property;
        if (time < _startTime) {
            return true;
        }
        if (_onStartCallbackFired === false) {
            if (_onStartCallback !== null) {
                _onStartCallback.call(_object);
            }
            _onStartCallbackFired = true;
        }
        var elapsed = (time - _startTime) / _duration;
        elapsed = elapsed > 1 ? 1 : elapsed;
        var value = _easingFunction(elapsed);
        for (property in _valuesEnd) {
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            if (end instanceof Array) {
                _object[property] = _interpolationFunction(end, value);
            } else {
                if (typeof end === 'string') {
                    end = start + parseFloat(end, 10);
                }
                if (typeof end === 'number') {
                    _object[property] = start + (end - start) * value;
                }
            }
        }
        if (_onUpdateCallback !== null) {
            _onUpdateCallback.call(_object, value);
        }
        if (elapsed == 1) {
            if (_repeat > 0) {
                if (isFinite(_repeat)) {
                    _repeat--;
                }
                for (property in _valuesStartRepeat) {
                    if (typeof _valuesEnd[property] === 'string') {
                        _valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10);
                    }
                    if (_yoyo) {
                        var tmp = _valuesStartRepeat[property];
                        _valuesStartRepeat[property] = _valuesEnd[property];
                        _valuesEnd[property] = tmp;
                    }
                    _valuesStart[property] = _valuesStartRepeat[property];
                }
                if (_yoyo) {
                    _reversed = !_reversed;
                }
                _startTime = time + _delayTime;
                return true;
            } else {
                if (_onCompleteCallback !== null) {
                    _onCompleteCallback.call(_object);
                }
                for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
                    _chainedTweens[i].start(time);
                }
                return false;
            }
        }
        return true;
    };
};
TWEEN.Easing = {
    Linear: {
        None: function (k) {
            return k;
        }
    },
    Quadratic: {
        In: function (k) {
            return k * k;
        },
        Out: function (k) {
            return k * (2 - k);
        },
        InOut: function (k) {
            if ((k *= 2) < 1)
                return 0.5 * k * k;
            return -0.5 * (--k * (k - 2) - 1);
        }
    },
    Cubic: {
        In: function (k) {
            return k * k * k;
        },
        Out: function (k) {
            return --k * k * k + 1;
        },
        InOut: function (k) {
            if ((k *= 2) < 1)
                return 0.5 * k * k * k;
            return 0.5 * ((k -= 2) * k * k + 2);
        }
    },
    Quartic: {
        In: function (k) {
            return k * k * k * k;
        },
        Out: function (k) {
            return 1 - --k * k * k * k;
        },
        InOut: function (k) {
            if ((k *= 2) < 1)
                return 0.5 * k * k * k * k;
            return -0.5 * ((k -= 2) * k * k * k - 2);
        }
    },
    Quintic: {
        In: function (k) {
            return k * k * k * k * k;
        },
        Out: function (k) {
            return --k * k * k * k * k + 1;
        },
        InOut: function (k) {
            if ((k *= 2) < 1)
                return 0.5 * k * k * k * k * k;
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        }
    },
    Sinusoidal: {
        In: function (k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        Out: function (k) {
            return Math.sin(k * Math.PI / 2);
        },
        InOut: function (k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        }
    },
    Exponential: {
        In: function (k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        Out: function (k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function (k) {
            if (k === 0)
                return 0;
            if (k === 1)
                return 1;
            if ((k *= 2) < 1)
                return 0.5 * Math.pow(1024, k - 1);
            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        }
    },
    Circular: {
        In: function (k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        Out: function (k) {
            return Math.sqrt(1 - --k * k);
        },
        InOut: function (k) {
            if ((k *= 2) < 1)
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        }
    },
    Elastic: {
        In: function (k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0)
                return 0;
            if (k === 1)
                return 1;
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        },
        Out: function (k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0)
                return 0;
            if (k === 1)
                return 1;
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
        },
        InOut: function (k) {
            var s, a = 0.1, p = 0.4;
            if (k === 0)
                return 0;
            if (k === 1)
                return 1;
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            if ((k *= 2) < 1)
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
        }
    },
    Back: {
        In: function (k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        Out: function (k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        InOut: function (k) {
            var s = 1.70158 * 1.525;
            if ((k *= 2) < 1)
                return 0.5 * (k * k * ((s + 1) * k - s));
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        }
    },
    Bounce: {
        In: function (k) {
            return 1 - TWEEN.Easing.Bounce.Out(1 - k);
        },
        Out: function (k) {
            if (k < 1 / 2.75) {
                return 7.5625 * k * k;
            } else if (k < 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
            } else if (k < 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
            } else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
            }
        },
        InOut: function (k) {
            if (k < 0.5)
                return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
            return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
        }
    }
};
TWEEN.Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.Linear;
        if (k < 0)
            return fn(v[0], v[1], f);
        if (k > 1)
            return fn(v[m], v[m - 1], m - f);
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;
        for (i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0)
                i = Math.floor(f = m * (1 + k));
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        } else {
            if (k < 0)
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            if (k > 1)
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = TWEEN.Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: function () {
            var a = [1];
            return function (n) {
                var s = 1, i;
                if (a[n])
                    return a[n];
                for (i = n; i > 1; i--)
                    s *= i;
                return a[n] = s;
            };
        }(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
    }
};
module.exports = TWEEN;
},{}],587:[function(require,module,exports){
function URI(uri) {
    if (uri instanceof URI) {
        this.scheme = uri.scheme;
        this.authority = uri.authority;
        this.path = uri.path;
        this.query = uri.query;
        this.fragment = uri.fragment;
    } else if (uri) {
        var c = parseRegex.exec(uri);
        this.scheme = c[1];
        this.authority = c[2];
        this.path = c[3];
        this.query = c[4];
        this.fragment = c[5];
    }
}
;
URI.prototype.scheme = null;
URI.prototype.authority = null;
URI.prototype.path = '';
URI.prototype.query = null;
URI.prototype.fragment = null;
var parseRegex = new RegExp('^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$');
URI.prototype.getScheme = function () {
    return this.scheme;
};
URI.prototype.getAuthority = function () {
    return this.authority;
};
URI.prototype.getPath = function () {
    return this.path;
};
URI.prototype.getQuery = function () {
    return this.query;
};
URI.prototype.getFragment = function () {
    return this.fragment;
};
URI.prototype.isAbsolute = function () {
    return !!this.scheme && !this.fragment;
};
URI.prototype.isSameDocumentAs = function (uri) {
    return uri.scheme == this.scheme && uri.authority == this.authority && uri.path == this.path && uri.query == this.query;
};
URI.prototype.equals = function (uri) {
    return this.isSameDocumentAs(uri) && uri.fragment == this.fragment;
};
URI.prototype.normalize = function () {
    this.removeDotSegments();
    if (this.scheme)
        this.scheme = this.scheme.toLowerCase();
    if (this.authority)
        this.authority = this.authority.replace(authorityRegex, replaceAuthority).replace(caseRegex, replaceCase);
    if (this.path)
        this.path = this.path.replace(caseRegex, replaceCase);
    if (this.query)
        this.query = this.query.replace(caseRegex, replaceCase);
    if (this.fragment)
        this.fragment = this.fragment.replace(caseRegex, replaceCase);
};
var caseRegex = /%[0-9a-z]{2}/gi;
var percentRegex = /[a-zA-Z0-9\-\._~]/;
var authorityRegex = /(.*@)?([^@:]*)(:.*)?/;
function replaceCase(str) {
    var dec = unescape(str);
    return percentRegex.test(dec) ? dec : str.toUpperCase();
}
function replaceAuthority(str, p1, p2, p3) {
    return (p1 || '') + p2.toLowerCase() + (p3 || '');
}
URI.prototype.resolve = function (baseURI) {
    var uri = new URI();
    if (this.scheme) {
        uri.scheme = this.scheme;
        uri.authority = this.authority;
        uri.path = this.path;
        uri.query = this.query;
    } else {
        uri.scheme = baseURI.scheme;
        if (this.authority) {
            uri.authority = this.authority;
            uri.path = this.path;
            uri.query = this.query;
        } else {
            uri.authority = baseURI.authority;
            if (this.path == '') {
                uri.path = baseURI.path;
                uri.query = this.query || baseURI.query;
            } else {
                if (this.path.charAt(0) == '/') {
                    uri.path = this.path;
                    uri.removeDotSegments();
                } else {
                    if (baseURI.authority && baseURI.path == '') {
                        uri.path = '/' + this.path;
                    } else {
                        uri.path = baseURI.path.substring(0, baseURI.path.lastIndexOf('/') + 1) + this.path;
                    }
                    uri.removeDotSegments();
                }
                uri.query = this.query;
            }
        }
    }
    uri.fragment = this.fragment;
    return uri;
};
URI.prototype.removeDotSegments = function () {
    var input = this.path.split('/'), output = [], segment, absPath = input[0] == '';
    if (absPath)
        input.shift();
    var sFirst = input[0] == '' ? input.shift() : null;
    while (input.length) {
        segment = input.shift();
        if (segment == '..') {
            output.pop();
        } else if (segment != '.') {
            output.push(segment);
        }
    }
    if (segment == '.' || segment == '..')
        output.push('');
    if (absPath)
        output.unshift('');
    this.path = output.join('/');
};
URI.prototype.toString = function () {
    var result = '';
    if (this.scheme)
        result += this.scheme + ':';
    if (this.authority)
        result += '//' + this.authority;
    result += this.path;
    if (this.query)
        result += '?' + this.query;
    if (this.fragment)
        result += '#' + this.fragment;
    return result;
};
module.exports = URI;
},{}],588:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined');
'use strict';
function accessorDefaults(gltf) {
    if (!defined(gltf.accessors)) {
        gltf.accessors = {};
    }
    var accessors = gltf.accessors;
    for (var name in accessors) {
        if (accessors.hasOwnProperty(name)) {
            var accessor = accessors[name];
            accessor.byteStride = defaultValue(accessor.byteStride, 0);
        }
    }
}
function animationDefaults(gltf) {
    if (!defined(gltf.animations)) {
        gltf.animations = {};
    }
    var animations = gltf.animations;
    for (var name in animations) {
        if (animations.hasOwnProperty(name)) {
            var animation = animations[name];
            if (!defined(animation.channels)) {
                animation.channels = [];
            }
            if (!defined(animation.parameters)) {
                animation.parameters = {};
            }
            if (!defined(animation.samplers)) {
                animation.samplers = {};
            }
            var samplers = animations.samplers;
            for (var samplerName in samplers) {
                if (samplers.hasOwnProperty(samplerName)) {
                    var sampler = samplers[samplerName];
                    sampler.interpolation = defaultValue(sampler.interpolation, 'LINEAR');
                }
            }
        }
    }
}
function assetDefaults(gltf) {
    if (!defined(gltf.asset)) {
        gltf.asset = {};
    }
    gltf.asset.premultipliedAlpha = defaultValue(gltf.asset.premultipliedAlpha, false);
}
function bufferDefaults(gltf) {
    if (!defined(gltf.buffers)) {
        gltf.buffers = {};
    }
    var buffers = gltf.buffers;
    for (var name in buffers) {
        if (buffers.hasOwnProperty(name)) {
            var buffer = buffers[name];
            buffer.type = defaultValue(buffer.type, 'arraybuffer');
        }
    }
}
function bufferViewDefaults(gltf) {
    if (!defined(gltf.bufferViews)) {
        gltf.bufferViews = {};
    }
}
function cameraDefaults(gltf) {
    if (!defined(gltf.cameras)) {
        gltf.cameras = {};
    }
}
function imageDefaults(gltf) {
    if (!defined(gltf.images)) {
        gltf.images = {};
    }
}
function lightDefaults(gltf) {
    if (!defined(gltf.lights)) {
        gltf.lights = {};
    }
    var lights = gltf.lights;
    for (var name in lights) {
        if (lights.hasOwnProperty(name)) {
            var light = lights[name];
            if (light.type === 'ambient') {
                if (!defined(light.ambient)) {
                    light.ambient = {};
                }
                var ambientLight = light.ambient;
                if (!defined(ambientLight.color)) {
                    ambientLight.color = [
                        1,
                        1,
                        1
                    ];
                }
            } else if (light.type === 'directional') {
                if (!defined(light.directional)) {
                    light.directional = {};
                }
                var directionalLight = light.directional;
                if (!defined(directionalLight.color)) {
                    directionalLight.color = [
                        1,
                        1,
                        1
                    ];
                }
            } else if (light.type === 'point') {
                if (!defined(light.point)) {
                    light.point = {};
                }
                var pointLight = light.point;
                if (!defined(pointLight.color)) {
                    pointLight.color = [
                        1,
                        1,
                        1
                    ];
                }
                pointLight.constantAttenuation = defaultValue(pointLight.constantAttenuation, 1);
                pointLight.linearAttenuation = defaultValue(pointLight.linearAttenuation, 0);
                pointLight.quadraticAttenuation = defaultValue(pointLight.quadraticAttenuation, 0);
            } else if (light.type === 'spot') {
                if (!defined(light.spot)) {
                    light.spot = {};
                }
                var spotLight = light.spot;
                if (!defined(spotLight.color)) {
                    spotLight.color = [
                        1,
                        1,
                        1
                    ];
                }
                spotLight.constantAttenuation = defaultValue(spotLight.constantAttenuation, 1);
                spotLight.fallOffAngle = defaultValue(spotLight.fallOffAngle, 3.14159265);
                spotLight.fallOffExponent = defaultValue(spotLight.fallOffExponent, 0);
                spotLight.linearAttenuation = defaultValue(spotLight.linearAttenuation, 0);
                spotLight.quadraticAttenuation = defaultValue(spotLight.quadraticAttenuation, 0);
            }
        }
    }
}
function materialDefaults(gltf) {
    if (!defined(gltf.materials)) {
        gltf.materials = {};
    }
    var materials = gltf.materials;
    for (var name in materials) {
        if (materials.hasOwnProperty(name)) {
            var instanceTechnique = materials[name].instanceTechnique;
            if (!defined(instanceTechnique.values)) {
                instanceTechnique.values = {};
            }
        }
    }
}
function meshDefaults(gltf) {
    if (!defined(gltf.meshes)) {
        gltf.meshes = {};
    }
    var meshes = gltf.meshes;
    for (var name in meshes) {
        if (meshes.hasOwnProperty(name)) {
            var mesh = meshes[name];
            if (!defined(mesh.primitives)) {
                mesh.primitives = [];
            }
            var primitives = mesh.primitives.length;
            var length = primitives.length;
            for (var i = 0; i < length; ++i) {
                var primitive = primitives[i];
                if (!defined(primitive.attributes)) {
                    primitive.attributes = {};
                }
                primitive.primitive = defaultValue(primitive.primitive, WebGLRenderingContext.TRIANGLES);
            }
        }
    }
}
function nodeDefaults(gltf) {
    if (!defined(gltf.nodes)) {
        gltf.nodes = {};
    }
    var nodes = gltf.nodes;
    for (var name in nodes) {
        if (nodes.hasOwnProperty(name)) {
            var node = nodes[name];
            if (!defined(node.children)) {
                node.children = [];
            }
            if (!defined(node.matrix)) {
                if (!(defined(node.translation) && defined(node.rotation) && defined(node.scale))) {
                    node.matrix = [
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        0,
                        1
                    ];
                } else {
                    if (!defined(node.translation)) {
                        node.translation = [
                            0,
                            0,
                            0
                        ];
                    }
                    if (!defined(node.rotation)) {
                        node.rotation = [
                            1,
                            0,
                            0,
                            0
                        ];
                    }
                    if (!defined(node.scale)) {
                        node.scale = [
                            1,
                            1,
                            1
                        ];
                    }
                }
            }
        }
    }
}
function programDefaults(gltf) {
    if (!defined(gltf.programs)) {
        gltf.programs = {};
    }
    var programs = gltf.programs;
    for (var name in programs) {
        if (programs.hasOwnProperty(name)) {
            var program = programs[name];
            if (!defined(program.attributes)) {
                program.attributes = [];
            }
        }
    }
}
function samplerDefaults(gltf) {
    if (!defined(gltf.samplers)) {
        gltf.samplers = {};
    }
    var samplers = gltf.samplers;
    for (var name in samplers) {
        if (samplers.hasOwnProperty(name)) {
            var sampler = samplers[name];
            sampler.magFilter = defaultValue(sampler.magFilter, WebGLRenderingContext.LINEAR);
            sampler.minFilter = defaultValue(sampler.minFilter, WebGLRenderingContext.NEAREST_MIPMAP_LINEAR);
            sampler.wrapS = defaultValue(sampler.wrapS, WebGLRenderingContext.REPEAT);
            sampler.wrapT = defaultValue(sampler.wrapT, WebGLRenderingContext.REPEAT);
        }
    }
}
function sceneDefaults(gltf) {
    if (!defined(gltf.scenes)) {
        gltf.scenes = {};
    }
    var scenes = gltf.scenes;
    for (var name in scenes) {
        if (scenes.hasOwnProperty(name)) {
            var scene = scenes[name];
            if (!defined(scene.node)) {
                scene.node = [];
            }
        }
    }
}
function shaderDefaults(gltf) {
    if (!defined(gltf.shaders)) {
        gltf.shaders = {};
    }
}
function skinDefaults(gltf) {
    if (!defined(gltf.skins)) {
        gltf.skins = {};
    }
    var skins = gltf.skins;
    for (var name in skins) {
        if (skins.hasOwnProperty(name)) {
            var skin = skins[name];
            if (defined(skin.bindShapeMatrix)) {
                skin.bindShapeMatrix = [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1
                ];
            }
        }
    }
}
function statesDefaults(states) {
    if (!defined(states.enable)) {
        states.enable = [];
    }
    if (!defined(states.disable)) {
        states.disable = [];
    }
}
function techniqueDefaults(gltf) {
    if (!defined(gltf.techniques)) {
        gltf.techniques = {};
    }
    var techniques = gltf.techniques;
    for (var name in techniques) {
        if (techniques.hasOwnProperty(name)) {
            var technique = techniques[name];
            if (!defined(technique.parameters)) {
                technique.parameters = {};
            }
            var passes = technique.passes;
            for (var passName in passes) {
                if (passes.hasOwnProperty(passName)) {
                    var pass = passes[passName];
                    var instanceProgram = pass.instanceProgram;
                    if (!defined(instanceProgram.attributes)) {
                        instanceProgram.attributes = {};
                    }
                    if (!defined(instanceProgram.uniforms)) {
                        instanceProgram.uniforms = {};
                    }
                    if (!defined(pass.states)) {
                        pass.states = {};
                    }
                    statesDefaults(pass.states);
                }
            }
        }
    }
}
function textureDefaults(gltf) {
    if (!defined(gltf.textures)) {
        gltf.textures = {};
    }
    var textures = gltf.textures;
    for (var name in textures) {
        if (textures.hasOwnProperty(name)) {
            var texture = textures[name];
            texture.format = defaultValue(texture.format, WebGLRenderingContext.RGBA);
            texture.internalFormat = defaultValue(texture.internalFormat, texture.format);
            texture.target = defaultValue(texture.target, WebGLRenderingContext.TEXTURE_2D);
            texture.type = defaultValue(texture.type, WebGLRenderingContext.UNSIGNED_BYTE);
        }
    }
}
var gltfDefaults = function (gltf) {
    if (!defined(gltf)) {
        return undefined;
    }
    if (!defined(gltf.allExtensions)) {
        gltf.allExtensions = [];
    }
    accessorDefaults(gltf);
    animationDefaults(gltf);
    assetDefaults(gltf);
    bufferDefaults(gltf);
    bufferViewDefaults(gltf);
    cameraDefaults(gltf);
    imageDefaults(gltf);
    lightDefaults(gltf);
    materialDefaults(gltf);
    meshDefaults(gltf);
    nodeDefaults(gltf);
    programDefaults(gltf);
    samplerDefaults(gltf);
    sceneDefaults(gltf);
    shaderDefaults(gltf);
    skinDefaults(gltf);
    techniqueDefaults(gltf);
    gltf.profile = defaultValue(gltf.profile, 'WebGL 1.0.2');
    gltf.version = defaultValue(gltf.version, '1.0');
    textureDefaults(gltf);
    return gltf;
};
module.exports = gltfDefaults;
},{"../Core/defaultValue":243,"../Core/defined":245}],589:[function(require,module,exports){
/**
 * @license
 * Knockout JavaScript library v3.2.0
 * (c) Steven Sanderson - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(p){var s=this||(0,eval)("this"),v=s.document,L=s.navigator,w=s.jQuery,D=s.JSON;(function(p){"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?p(module.exports||exports,require):"function"===typeof define&&define.amd?define(["exports","require"],p):p(s.ko={})})(function(M,N){function H(a,d){return null===a||typeof a in R?a===d:!1}function S(a,d){var c;return function(){c||(c=setTimeout(function(){c=p;a()},d))}}function T(a,d){var c;return function(){clearTimeout(c);
c=setTimeout(a,d)}}function I(b,d,c,e){a.d[b]={init:function(b,h,k,f,m){var l,q;a.s(function(){var f=a.a.c(h()),k=!c!==!f,z=!q;if(z||d||k!==l)z&&a.Y.la()&&(q=a.a.ia(a.f.childNodes(b),!0)),k?(z||a.f.T(b,a.a.ia(q)),a.Ca(e?e(m,f):m,b)):a.f.ja(b),l=k},null,{o:b});return{controlsDescendantBindings:!0}}};a.h.ha[b]=!1;a.f.Q[b]=!0}var a="undefined"!==typeof M?M:{};a.b=function(b,d){for(var c=b.split("."),e=a,g=0;g<c.length-1;g++)e=e[c[g]];e[c[c.length-1]]=d};a.A=function(a,d,c){a[d]=c};a.version="3.2.0";
a.b("version",a.version);a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function d(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function c(a,b){a.__proto__=b;return a}var e={__proto__:[]}instanceof Array,g={},h={};g[L&&/Firefox\/2/i.test(L.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];g.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(g,function(a,b){if(b.length)for(var c=
0,d=b.length;c<d;c++)h[b[c]]=a});var k={propertychange:!0},f=v&&function(){for(var a=3,b=v.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:p}();return{vb:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],u:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},m:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===
b)return c;return-1},qb:function(a,b,c){for(var d=0,f=a.length;d<f;d++)if(b.call(c,a[d],d))return a[d];return null},ua:function(m,b){var c=a.a.m(m,b);0<c?m.splice(c,1):0===c&&m.shift()},rb:function(m){m=m||[];for(var b=[],c=0,d=m.length;c<d;c++)0>a.a.m(b,m[c])&&b.push(m[c]);return b},Da:function(a,b){a=a||[];for(var c=[],d=0,f=a.length;d<f;d++)c.push(b(a[d],d));return c},ta:function(a,b){a=a||[];for(var c=[],d=0,f=a.length;d<f;d++)b(a[d],d)&&c.push(a[d]);return c},ga:function(a,b){if(b instanceof
Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},ea:function(b,c,d){var f=a.a.m(a.a.Xa(b),c);0>f?d&&b.push(c):d||b.splice(f,1)},xa:e,extend:d,za:c,Aa:e?c:d,G:b,na:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},Ka:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},oc:function(b){b=a.a.S(b);for(var c=v.createElement("div"),d=0,f=b.length;d<f;d++)c.appendChild(a.R(b[d]));return c},ia:function(b,c){for(var d=
0,f=b.length,e=[];d<f;d++){var k=b[d].cloneNode(!0);e.push(c?a.R(k):k)}return e},T:function(b,c){a.a.Ka(b);if(c)for(var d=0,f=c.length;d<f;d++)b.appendChild(c[d])},Lb:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var f=d[0],e=f.parentNode,k=0,g=c.length;k<g;k++)e.insertBefore(c[k],f);k=0;for(g=d.length;k<g;k++)a.removeNode(d[k])}},ka:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.shift();if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=
0;c!==d;)if(a.push(c),c=c.nextSibling,!c)return;a.push(d)}}return a},Nb:function(a,b){7>f?a.setAttribute("selected",b):a.selected=b},cb:function(a){return null===a||a===p?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},vc:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},cc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&
16);for(;a&&a!=b;)a=a.parentNode;return!!a},Ja:function(b){return a.a.cc(b,b.ownerDocument.documentElement)},ob:function(b){return!!a.a.qb(b,a.a.Ja)},t:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},n:function(b,c,d){var e=f&&k[c];if(!e&&w)w(b).bind(c,d);else if(e||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var g=function(a){d.call(b,a)},h="on"+c;b.attachEvent(h,g);a.a.w.da(b,function(){b.detachEvent(h,g)})}else throw Error("Browser doesn't support addEventListener or attachEvent");
else b.addEventListener(c,d,!1)},oa:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.t(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(w&&!d)w(b).trigger(c);else if("function"==typeof v.createEvent)if("function"==typeof b.dispatchEvent)d=v.createEvent(h[c]||"HTMLEvents"),d.initEvent(c,!0,!0,s,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");
else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");},c:function(b){return a.C(b)?b():b},Xa:function(b){return a.C(b)?b.v():b},Ba:function(b,c,d){if(c){var f=/\S+/g,e=b.className.match(f)||[];a.a.u(c.match(f),function(b){a.a.ea(e,b,d)});b.className=e.join(" ")}},bb:function(b,c){var d=a.a.c(c);if(null===d||d===p)d="";var f=a.f.firstChild(b);!f||3!=f.nodeType||a.f.nextSibling(f)?a.f.T(b,[b.ownerDocument.createTextNode(d)]):
f.data=d;a.a.fc(b)},Mb:function(a,b){a.name=b;if(7>=f)try{a.mergeAttributes(v.createElement("<input name='"+a.name+"'/>"),!1)}catch(c){}},fc:function(a){9<=f&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},dc:function(a){if(f){var b=a.style.width;a.style.width=0;a.style.width=b}},sc:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],f=b;f<=c;f++)d.push(f);return d},S:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},yc:6===f,zc:7===f,L:f,xb:function(b,c){for(var d=
a.a.S(b.getElementsByTagName("input")).concat(a.a.S(b.getElementsByTagName("textarea"))),f="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},e=[],k=d.length-1;0<=k;k--)f(d[k])&&e.push(d[k]);return e},pc:function(b){return"string"==typeof b&&(b=a.a.cb(b))?D&&D.parse?D.parse(b):(new Function("return "+b))():null},eb:function(b,c,d){if(!D||!D.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return D.stringify(a.a.c(b),c,d)},qc:function(c,d,f){f=f||{};var e=f.params||{},k=f.includeFields||this.vb,g=c;if("object"==typeof c&&"form"===a.a.t(c))for(var g=c.action,h=k.length-1;0<=h;h--)for(var r=a.a.xb(c,k[h]),E=r.length-1;0<=E;E--)e[r[E].name]=r[E].value;d=a.a.c(d);var y=v.createElement("form");y.style.display="none";y.action=g;y.method="post";for(var p in d)c=v.createElement("input"),c.type="hidden",c.name=p,c.value=a.a.eb(a.a.c(d[p])),y.appendChild(c);b(e,function(a,b){var c=v.createElement("input");
c.type="hidden";c.name=a;c.value=b;y.appendChild(c)});v.body.appendChild(y);f.submitter?f.submitter(y):y.submit();setTimeout(function(){y.parentNode.removeChild(y)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.u);a.b("utils.arrayFirst",a.a.qb);a.b("utils.arrayFilter",a.a.ta);a.b("utils.arrayGetDistinctValues",a.a.rb);a.b("utils.arrayIndexOf",a.a.m);a.b("utils.arrayMap",a.a.Da);a.b("utils.arrayPushAll",a.a.ga);a.b("utils.arrayRemoveItem",a.a.ua);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
a.a.vb);a.b("utils.getFormFields",a.a.xb);a.b("utils.peekObservable",a.a.Xa);a.b("utils.postJson",a.a.qc);a.b("utils.parseJson",a.a.pc);a.b("utils.registerEventHandler",a.a.n);a.b("utils.stringifyJson",a.a.eb);a.b("utils.range",a.a.sc);a.b("utils.toggleDomNodeCssClass",a.a.Ba);a.b("utils.triggerEvent",a.a.oa);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.G);a.b("utils.addOrRemoveItem",a.a.ea);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=function(a){var d=
this,c=Array.prototype.slice.call(arguments);a=c.shift();return function(){return d.apply(a,c.concat(Array.prototype.slice.call(arguments)))}});a.a.e=new function(){function a(b,h){var k=b[c];if(!k||"null"===k||!e[k]){if(!h)return p;k=b[c]="ko"+d++;e[k]={}}return e[k]}var d=0,c="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===p?p:e[d]},set:function(c,d,e){if(e!==p||a(c,!1)!==p)a(c,!0)[d]=e},clear:function(a){var b=a[c];return b?(delete e[b],a[c]=null,!0):!1},F:function(){return d++ +
c}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.w=new function(){function b(b,d){var f=a.a.e.get(b,c);f===p&&d&&(f=[],a.a.e.set(b,c,f));return f}function d(c){var e=b(c,!1);if(e)for(var e=e.slice(0),f=0;f<e.length;f++)e[f](c);a.a.e.clear(c);a.a.w.cleanExternalData(c);if(g[c.nodeType])for(e=c.firstChild;c=e;)e=c.nextSibling,8===c.nodeType&&d(c)}var c=a.a.e.F(),e={1:!0,8:!0,9:!0},g={1:!0,9:!0};return{da:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");
b(a,!0).push(c)},Kb:function(d,e){var f=b(d,!1);f&&(a.a.ua(f,e),0==f.length&&a.a.e.set(d,c,p))},R:function(b){if(e[b.nodeType]&&(d(b),g[b.nodeType])){var c=[];a.a.ga(c,b.getElementsByTagName("*"));for(var f=0,m=c.length;f<m;f++)d(c[f])}return b},removeNode:function(b){a.R(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){w&&"function"==typeof w.cleanData&&w.cleanData([a])}}};a.R=a.a.w.R;a.removeNode=a.a.w.removeNode;a.b("cleanNode",a.R);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",
a.a.w);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.w.da);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.w.Kb);(function(){a.a.ba=function(b){var d;if(w)if(w.parseHTML)d=w.parseHTML(b)||[];else{if((d=w.clean([b]))&&d[0]){for(b=d[0];b.parentNode&&11!==b.parentNode.nodeType;)b=b.parentNode;b.parentNode&&b.parentNode.removeChild(b)}}else{var c=a.a.cb(b).toLowerCase();d=v.createElement("div");c=c.match(/^<(thead|tbody|tfoot)/)&&[1,"<table>","</table>"]||!c.indexOf("<tr")&&[2,"<table><tbody>",
"</tbody></table>"]||(!c.indexOf("<td")||!c.indexOf("<th"))&&[3,"<table><tbody><tr>","</tr></tbody></table>"]||[0,"",""];b="ignored<div>"+c[1]+b+c[2]+"</div>";for("function"==typeof s.innerShiv?d.appendChild(s.innerShiv(b)):d.innerHTML=b;c[0]--;)d=d.lastChild;d=a.a.S(d.lastChild.childNodes)}return d};a.a.$a=function(b,d){a.a.Ka(b);d=a.a.c(d);if(null!==d&&d!==p)if("string"!=typeof d&&(d=d.toString()),w)w(b).html(d);else for(var c=a.a.ba(d),e=0;e<c.length;e++)b.appendChild(c[e])}})();a.b("utils.parseHtmlFragment",
a.a.ba);a.b("utils.setHtml",a.a.$a);a.D=function(){function b(c,d){if(c)if(8==c.nodeType){var g=a.D.Gb(c.nodeValue);null!=g&&d.push({bc:c,mc:g})}else if(1==c.nodeType)for(var g=0,h=c.childNodes,k=h.length;g<k;g++)b(h[g],d)}var d={};return{Ua:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);d[b]=a;return"\x3c!--[ko_memo:"+
b+"]--\x3e"},Rb:function(a,b){var g=d[a];if(g===p)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return g.apply(null,b||[]),!0}finally{delete d[a]}},Sb:function(c,d){var g=[];b(c,g);for(var h=0,k=g.length;h<k;h++){var f=g[h].bc,m=[f];d&&a.a.ga(m,d);a.D.Rb(g[h].mc,m);f.nodeValue="";f.parentNode&&f.parentNode.removeChild(f)}},Gb:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.D);a.b("memoization.memoize",a.D.Ua);
a.b("memoization.unmemoize",a.D.Rb);a.b("memoization.parseMemoText",a.D.Gb);a.b("memoization.unmemoizeDomNodeAndDescendants",a.D.Sb);a.La={throttle:function(b,d){b.throttleEvaluation=d;var c=null;return a.j({read:b,write:function(a){clearTimeout(c);c=setTimeout(function(){b(a)},d)}})},rateLimit:function(a,d){var c,e,g;"number"==typeof d?c=d:(c=d.timeout,e=d.method);g="notifyWhenChangesStop"==e?T:S;a.Ta(function(a){return g(a,c)})},notify:function(a,d){a.equalityComparer="always"==d?null:H}};var R=
{undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.La);a.Pb=function(b,d,c){this.target=b;this.wa=d;this.ac=c;this.Cb=!1;a.A(this,"dispose",this.K)};a.Pb.prototype.K=function(){this.Cb=!0;this.ac()};a.P=function(){a.a.Aa(this,a.P.fn);this.M={}};var G="change",A={U:function(b,d,c){var e=this;c=c||G;var g=new a.Pb(e,d?b.bind(d):b,function(){a.a.ua(e.M[c],g);e.nb&&e.nb()});e.va&&e.va(c);e.M[c]||(e.M[c]=[]);e.M[c].push(g);return g},notifySubscribers:function(b,d){d=d||G;if(this.Ab(d))try{a.k.Ea();
for(var c=this.M[d].slice(0),e=0,g;g=c[e];++e)g.Cb||g.wa(b)}finally{a.k.end()}},Ta:function(b){var d=this,c=a.C(d),e,g,h;d.qa||(d.qa=d.notifySubscribers,d.notifySubscribers=function(a,b){b&&b!==G?"beforeChange"===b?d.kb(a):d.qa(a,b):d.lb(a)});var k=b(function(){c&&h===d&&(h=d());e=!1;d.Pa(g,h)&&d.qa(g=h)});d.lb=function(a){e=!0;h=a;k()};d.kb=function(a){e||(g=a,d.qa(a,"beforeChange"))}},Ab:function(a){return this.M[a]&&this.M[a].length},yb:function(){var b=0;a.a.G(this.M,function(a,c){b+=c.length});
return b},Pa:function(a,d){return!this.equalityComparer||!this.equalityComparer(a,d)},extend:function(b){var d=this;b&&a.a.G(b,function(b,e){var g=a.La[b];"function"==typeof g&&(d=g(d,e)||d)});return d}};a.A(A,"subscribe",A.U);a.A(A,"extend",A.extend);a.A(A,"getSubscriptionsCount",A.yb);a.a.xa&&a.a.za(A,Function.prototype);a.P.fn=A;a.Db=function(a){return null!=a&&"function"==typeof a.U&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.P);a.b("isSubscribable",a.Db);a.Y=a.k=function(){function b(a){c.push(e);
e=a}function d(){e=c.pop()}var c=[],e,g=0;return{Ea:b,end:d,Jb:function(b){if(e){if(!a.Db(b))throw Error("Only subscribable things can act as dependencies");e.wa(b,b.Vb||(b.Vb=++g))}},B:function(a,c,f){try{return b(),a.apply(c,f||[])}finally{d()}},la:function(){if(e)return e.s.la()},ma:function(){if(e)return e.ma}}}();a.b("computedContext",a.Y);a.b("computedContext.getDependenciesCount",a.Y.la);a.b("computedContext.isInitial",a.Y.ma);a.b("computedContext.isSleeping",a.Y.Ac);a.p=function(b){function d(){if(0<
arguments.length)return d.Pa(c,arguments[0])&&(d.X(),c=arguments[0],d.W()),this;a.k.Jb(d);return c}var c=b;a.P.call(d);a.a.Aa(d,a.p.fn);d.v=function(){return c};d.W=function(){d.notifySubscribers(c)};d.X=function(){d.notifySubscribers(c,"beforeChange")};a.A(d,"peek",d.v);a.A(d,"valueHasMutated",d.W);a.A(d,"valueWillMutate",d.X);return d};a.p.fn={equalityComparer:H};var F=a.p.rc="__ko_proto__";a.p.fn[F]=a.p;a.a.xa&&a.a.za(a.p.fn,a.P.fn);a.Ma=function(b,d){return null===b||b===p||b[F]===p?!1:b[F]===
d?!0:a.Ma(b[F],d)};a.C=function(b){return a.Ma(b,a.p)};a.Ra=function(b){return"function"==typeof b&&b[F]===a.p||"function"==typeof b&&b[F]===a.j&&b.hc?!0:!1};a.b("observable",a.p);a.b("isObservable",a.C);a.b("isWriteableObservable",a.Ra);a.b("isWritableObservable",a.Ra);a.aa=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.p(b);a.a.Aa(b,a.aa.fn);return b.extend({trackArrayChanges:!0})};
a.aa.fn={remove:function(b){for(var d=this.v(),c=[],e="function"!=typeof b||a.C(b)?function(a){return a===b}:b,g=0;g<d.length;g++){var h=d[g];e(h)&&(0===c.length&&this.X(),c.push(h),d.splice(g,1),g--)}c.length&&this.W();return c},removeAll:function(b){if(b===p){var d=this.v(),c=d.slice(0);this.X();d.splice(0,d.length);this.W();return c}return b?this.remove(function(c){return 0<=a.a.m(b,c)}):[]},destroy:function(b){var d=this.v(),c="function"!=typeof b||a.C(b)?function(a){return a===b}:b;this.X();
for(var e=d.length-1;0<=e;e--)c(d[e])&&(d[e]._destroy=!0);this.W()},destroyAll:function(b){return b===p?this.destroy(function(){return!0}):b?this.destroy(function(d){return 0<=a.a.m(b,d)}):[]},indexOf:function(b){var d=this();return a.a.m(d,b)},replace:function(a,d){var c=this.indexOf(a);0<=c&&(this.X(),this.v()[c]=d,this.W())}};a.a.u("pop push reverse shift sort splice unshift".split(" "),function(b){a.aa.fn[b]=function(){var a=this.v();this.X();this.sb(a,b,arguments);a=a[b].apply(a,arguments);this.W();
return a}});a.a.u(["slice"],function(b){a.aa.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.a.xa&&a.a.za(a.aa.fn,a.p.fn);a.b("observableArray",a.aa);var J="arrayChange";a.La.trackArrayChanges=function(b){function d(){if(!c){c=!0;var d=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&b!==G||++g;return d.apply(this,arguments)};var f=[].concat(b.v()||[]);e=null;b.U(function(c){c=[].concat(c||[]);if(b.Ab(J)){var d;if(!e||1<g)e=a.a.Fa(f,c,{sparse:!0});d=e;d.length&&b.notifySubscribers(d,
J)}f=c;e=null;g=0})}}if(!b.sb){var c=!1,e=null,g=0,h=b.U;b.U=b.subscribe=function(a,b,c){c===J&&d();return h.apply(this,arguments)};b.sb=function(b,d,m){function l(a,b,c){return q[q.length]={status:a,value:b,index:c}}if(c&&!g){var q=[],h=b.length,t=m.length,z=0;switch(d){case "push":z=h;case "unshift":for(d=0;d<t;d++)l("added",m[d],z+d);break;case "pop":z=h-1;case "shift":h&&l("deleted",b[z],z);break;case "splice":d=Math.min(Math.max(0,0>m[0]?h+m[0]:m[0]),h);for(var h=1===t?h:Math.min(d+(m[1]||0),
h),t=d+t-2,z=Math.max(h,t),u=[],r=[],E=2;d<z;++d,++E)d<h&&r.push(l("deleted",b[d],d)),d<t&&u.push(l("added",m[E],d));a.a.wb(r,u);break;default:return}e=q}}}};a.s=a.j=function(b,d,c){function e(){a.a.G(v,function(a,b){b.K()});v={}}function g(){e();C=0;u=!0;n=!1}function h(){var a=f.throttleEvaluation;a&&0<=a?(clearTimeout(P),P=setTimeout(k,a)):f.ib?f.ib():k()}function k(b){if(t){if(E)throw Error("A 'pure' computed must not be called recursively");}else if(!u){if(w&&w()){if(!z){s();return}}else z=!1;
t=!0;if(y)try{var c={};a.k.Ea({wa:function(a,b){c[b]||(c[b]=1,++C)},s:f,ma:p});C=0;q=r.call(d)}finally{a.k.end(),t=!1}else try{var e=v,m=C;a.k.Ea({wa:function(a,b){u||(m&&e[b]?(v[b]=e[b],++C,delete e[b],--m):v[b]||(v[b]=a.U(h),++C))},s:f,ma:E?p:!C});v={};C=0;try{var l=d?r.call(d):r()}finally{a.k.end(),m&&a.a.G(e,function(a,b){b.K()}),n=!1}f.Pa(q,l)&&(f.notifySubscribers(q,"beforeChange"),q=l,!0!==b&&f.notifySubscribers(q))}finally{t=!1}C||s()}}function f(){if(0<arguments.length){if("function"===typeof O)O.apply(d,
arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}a.k.Jb(f);n&&k(!0);return q}function m(){n&&!C&&k(!0);return q}function l(){return n||0<C}var q,n=!0,t=!1,z=!1,u=!1,r=b,E=!1,y=!1;r&&"object"==typeof r?(c=r,r=c.read):(c=c||{},r||(r=c.read));if("function"!=typeof r)throw Error("Pass a function that returns the value of the ko.computed");var O=c.write,x=c.disposeWhenNodeIsRemoved||
c.o||null,B=c.disposeWhen||c.Ia,w=B,s=g,v={},C=0,P=null;d||(d=c.owner);a.P.call(f);a.a.Aa(f,a.j.fn);f.v=m;f.la=function(){return C};f.hc="function"===typeof c.write;f.K=function(){s()};f.Z=l;var A=f.Ta;f.Ta=function(a){A.call(f,a);f.ib=function(){f.kb(q);n=!0;f.lb(f)}};c.pure?(y=E=!0,f.va=function(){y&&(y=!1,k(!0))},f.nb=function(){f.yb()||(e(),y=n=!0)}):c.deferEvaluation&&(f.va=function(){m();delete f.va});a.A(f,"peek",f.v);a.A(f,"dispose",f.K);a.A(f,"isActive",f.Z);a.A(f,"getDependenciesCount",
f.la);x&&(z=!0,x.nodeType&&(w=function(){return!a.a.Ja(x)||B&&B()}));y||c.deferEvaluation||k();x&&l()&&x.nodeType&&(s=function(){a.a.w.Kb(x,s);g()},a.a.w.da(x,s));return f};a.jc=function(b){return a.Ma(b,a.j)};A=a.p.rc;a.j[A]=a.p;a.j.fn={equalityComparer:H};a.j.fn[A]=a.j;a.a.xa&&a.a.za(a.j.fn,a.P.fn);a.b("dependentObservable",a.j);a.b("computed",a.j);a.b("isComputed",a.jc);a.Ib=function(b,d){if("function"===typeof b)return a.s(b,d,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.s(b,d)};a.b("pureComputed",
a.Ib);(function(){function b(a,g,h){h=h||new c;a=g(a);if("object"!=typeof a||null===a||a===p||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var k=a instanceof Array?[]:{};h.save(a,k);d(a,function(c){var d=g(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":k[c]=d;break;case "object":case "undefined":var l=h.get(d);k[c]=l!==p?l:b(d,g,h)}});return k}function d(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==
typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function c(){this.keys=[];this.hb=[]}a.Qb=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.C(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.Qb(b);return a.a.eb(b,c,d)};c.prototype={save:function(b,c){var d=a.a.m(this.keys,b);0<=d?this.hb[d]=c:(this.keys.push(b),this.hb.push(c))},get:function(b){b=a.a.m(this.keys,b);return 0<=b?this.hb[b]:p}}})();
a.b("toJS",a.Qb);a.b("toJSON",a.toJSON);(function(){a.i={q:function(b){switch(a.a.t(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.Va):7>=a.a.L?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.i.q(b.options[b.selectedIndex]):p;default:return b.value}},ca:function(b,d,c){switch(a.a.t(b)){case "option":switch(typeof d){case "string":a.a.e.set(b,a.d.options.Va,p);"__ko__hasDomDataOptionValue__"in
b&&delete b.__ko__hasDomDataOptionValue__;b.value=d;break;default:a.a.e.set(b,a.d.options.Va,d),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof d?d:""}break;case "select":if(""===d||null===d)d=p;for(var e=-1,g=0,h=b.options.length,k;g<h;++g)if(k=a.i.q(b.options[g]),k==d||""==k&&d===p){e=g;break}if(c||0<=e||d===p&&1<b.size)b.selectedIndex=e;break;default:if(null===d||d===p)d="";b.value=d}}}})();a.b("selectExtensions",a.i);a.b("selectExtensions.readValue",a.i.q);a.b("selectExtensions.writeValue",
a.i.ca);a.h=function(){function b(b){b=a.a.cb(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),k,n,t=0;if(d){d.push(",");for(var z=0,u;u=d[z];++z){var r=u.charCodeAt(0);if(44===r){if(0>=t){k&&c.push(n?{key:k,value:n.join("")}:{unknown:k});k=n=t=0;continue}}else if(58===r){if(!n)continue}else if(47===r&&z&&1<u.length)(r=d[z-1].match(g))&&!h[r[0]]&&(b=b.substr(b.indexOf(u)+1),d=b.match(e),d.push(","),z=-1,u="/");else if(40===r||123===r||91===r)++t;else if(41===r||125===r||93===r)--t;
else if(!k&&!n){k=34===r||39===r?u.slice(1,-1):u;continue}n?n.push(u):n=[u]}}return c}var d=["true","false","null","undefined"],c=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),g=/[\])"'A-Za-z0-9_$]+$/,h={"in":1,"return":1,"typeof":1},k={};return{ha:[],V:k,Wa:b,ya:function(f,m){function e(b,m){var f;if(!z){var u=a.getBindingHandler(b);if(u&&u.preprocess&&
!(m=u.preprocess(m,b,e)))return;if(u=k[b])f=m,0<=a.a.m(d,f)?f=!1:(u=f.match(c),f=null===u?!1:u[1]?"Object("+u[1]+")"+u[2]:f),u=f;u&&h.push("'"+b+"':function(_z){"+f+"=_z}")}t&&(m="function(){return "+m+" }");g.push("'"+b+"':"+m)}m=m||{};var g=[],h=[],t=m.valueAccessors,z=m.bindingParams,u="string"===typeof f?b(f):f;a.a.u(u,function(a){e(a.key||a.unknown,a.value)});h.length&&e("_ko_property_writers","{"+h.join(",")+" }");return g.join(",")},lc:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==
b)return!0;return!1},pa:function(b,c,d,e,k){if(b&&a.C(b))!a.Ra(b)||k&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",a.h.ha);a.b("expressionRewriting.parseObjectLiteral",a.h.Wa);a.b("expressionRewriting.preProcessBindings",a.h.ya);a.b("expressionRewriting._twoWayBindings",a.h.V);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.h.ya);(function(){function b(a){return 8==
a.nodeType&&h.test(g?a.text:a.nodeValue)}function d(a){return 8==a.nodeType&&k.test(g?a.text:a.nodeValue)}function c(a,c){for(var f=a,e=1,k=[];f=f.nextSibling;){if(d(f)&&(e--,0===e))return k;k.push(f);b(f)&&e++}if(!c)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var d=c(a,b);return d?0<d.length?d[d.length-1].nextSibling:a.nextSibling:null}var g=v&&"\x3c!--test--\x3e"===v.createComment("test").text,h=g?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,
k=g?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,f={ul:!0,ol:!0};a.f={Q:{},childNodes:function(a){return b(a)?c(a):a.childNodes},ja:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=0,f=c.length;d<f;d++)a.removeNode(c[d])}else a.a.Ka(c)},T:function(c,d){if(b(c)){a.f.ja(c);for(var f=c.nextSibling,e=0,k=d.length;e<k;e++)f.parentNode.insertBefore(d[e],f)}else a.a.T(c,d)},Hb:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},Bb:function(c,
d,f){f?b(c)?c.parentNode.insertBefore(d,f.nextSibling):f.nextSibling?c.insertBefore(d,f.nextSibling):c.appendChild(d):a.f.Hb(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||d(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&d(a.nextSibling)?null:a.nextSibling},gc:b,xc:function(a){return(a=(g?a.text:a.nodeValue).match(h))?a[1]:null},Fb:function(c){if(f[a.a.t(c)]){var k=c.firstChild;if(k){do if(1===k.nodeType){var g;g=k.firstChild;
var h=null;if(g){do if(h)h.push(g);else if(b(g)){var t=e(g,!0);t?g=t:h=[g]}else d(g)&&(h=[g]);while(g=g.nextSibling)}if(g=h)for(h=k.nextSibling,t=0;t<g.length;t++)h?c.insertBefore(g[t],h):c.appendChild(g[t])}while(k=k.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.Q);a.b("virtualElements.emptyNode",a.f.ja);a.b("virtualElements.insertAfter",a.f.Bb);a.b("virtualElements.prepend",a.f.Hb);a.b("virtualElements.setDomNodeChildren",a.f.T);(function(){a.J=function(){this.Yb=
{}};a.a.extend(a.J.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.gc(b);default:return!1}},getBindings:function(b,d){var c=this.getBindingsString(b,d),c=c?this.parseBindingsString(c,d,b):null;return a.g.mb(c,b,d,!1)},getBindingAccessors:function(b,d){var c=this.getBindingsString(b,d),c=c?this.parseBindingsString(c,d,b,{valueAccessors:!0}):null;return a.g.mb(c,b,d,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");
case 8:return a.f.xc(b);default:return null}},parseBindingsString:function(b,d,c,e){try{var g=this.Yb,h=b+(e&&e.valueAccessors||""),k;if(!(k=g[h])){var f,m="with($context){with($data||{}){return{"+a.h.ya(b,e)+"}}}";f=new Function("$context","$element",m);k=g[h]=f}return k(d,c)}catch(l){throw l.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+l.message,l;}}});a.J.instance=new a.J})();a.b("bindingProvider",a.J);(function(){function b(a){return function(){return a}}function d(a){return a()}
function c(b){return a.a.na(a.k.B(b),function(a,c){return function(){return b()[c]}})}function e(a,b){return c(this.getBindings.bind(this,a,b))}function g(b,c,d){var f,e=a.f.firstChild(c),k=a.J.instance,g=k.preprocessNode;if(g){for(;f=e;)e=a.f.nextSibling(f),g.call(k,f);e=a.f.firstChild(c)}for(;f=e;)e=a.f.nextSibling(f),h(b,f,d)}function h(b,c,d){var e=!0,k=1===c.nodeType;k&&a.f.Fb(c);if(k&&d||a.J.instance.nodeHasBindings(c))e=f(c,null,b,d).shouldBindDescendants;e&&!l[a.a.t(c)]&&g(b,c,!k)}function k(b){var c=
[],d={},f=[];a.a.G(b,function y(e){if(!d[e]){var k=a.getBindingHandler(e);k&&(k.after&&(f.push(e),a.a.u(k.after,function(c){if(b[c]){if(-1!==a.a.m(f,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+f.join(", "));y(c)}}),f.length--),c.push({key:e,zb:k}));d[e]=!0}});return c}function f(b,c,f,g){var m=a.a.e.get(b,q);if(!c){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&g&&a.Ob(b,f);var l;if(c&&"function"!==
typeof c)l=c;else{var h=a.J.instance,n=h.getBindingAccessors||e,s=a.j(function(){(l=c?c(f,b):n.call(h,b,f))&&f.I&&f.I();return l},null,{o:b});l&&s.Z()||(s=null)}var v;if(l){var w=s?function(a){return function(){return d(s()[a])}}:function(a){return l[a]},A=function(){return a.a.na(s?s():l,d)};A.get=function(a){return l[a]&&d(w(a))};A.has=function(a){return a in l};g=k(l);a.a.u(g,function(c){var d=c.zb.init,e=c.zb.update,k=c.key;if(8===b.nodeType&&!a.f.Q[k])throw Error("The binding '"+k+"' cannot be used with virtual elements");
try{"function"==typeof d&&a.k.B(function(){var a=d(b,w(k),A,f.$data,f);if(a&&a.controlsDescendantBindings){if(v!==p)throw Error("Multiple bindings ("+v+" and "+k+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");v=k}}),"function"==typeof e&&a.j(function(){e(b,w(k),A,f.$data,f)},null,{o:b})}catch(g){throw g.message='Unable to process binding "'+k+": "+l[k]+'"\nMessage: '+g.message,g;}})}return{shouldBindDescendants:v===p}}
function m(b){return b&&b instanceof a.N?b:new a.N(b)}a.d={};var l={script:!0};a.getBindingHandler=function(b){return a.d[b]};a.N=function(b,c,d,f){var e=this,k="function"==typeof b&&!a.C(b),g,m=a.j(function(){var g=k?b():b,l=a.a.c(g);c?(c.I&&c.I(),a.a.extend(e,c),m&&(e.I=m)):(e.$parents=[],e.$root=l,e.ko=a);e.$rawData=g;e.$data=l;d&&(e[d]=l);f&&f(e,c,l);return e.$data},null,{Ia:function(){return g&&!a.a.ob(g)},o:!0});m.Z()&&(e.I=m,m.equalityComparer=null,g=[],m.Tb=function(b){g.push(b);a.a.w.da(b,
function(b){a.a.ua(g,b);g.length||(m.K(),e.I=m=p)})})};a.N.prototype.createChildContext=function(b,c,d){return new a.N(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)})};a.N.prototype.extend=function(b){return new a.N(this.I||this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};var q=a.a.e.F(),n=a.a.e.F();a.Ob=function(b,c){if(2==arguments.length)a.a.e.set(b,n,c),
c.I&&c.I.Tb(b);else return a.a.e.get(b,n)};a.ra=function(b,c,d){1===b.nodeType&&a.f.Fb(b);return f(b,c,m(d),!0)};a.Wb=function(d,f,e){e=m(e);return a.ra(d,"function"===typeof f?c(f.bind(null,e,d)):a.a.na(f,b),e)};a.Ca=function(a,b){1!==b.nodeType&&8!==b.nodeType||g(m(a),b,!0)};a.pb=function(a,b){!w&&s.jQuery&&(w=s.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");b=b||s.document.body;h(m(a),
b,!0)};a.Ha=function(b){switch(b.nodeType){case 1:case 8:var c=a.Ob(b);if(c)return c;if(b.parentNode)return a.Ha(b.parentNode)}return p};a.$b=function(b){return(b=a.Ha(b))?b.$data:p};a.b("bindingHandlers",a.d);a.b("applyBindings",a.pb);a.b("applyBindingsToDescendants",a.Ca);a.b("applyBindingAccessorsToNode",a.ra);a.b("applyBindingsToNode",a.Wb);a.b("contextFor",a.Ha);a.b("dataFor",a.$b)})();(function(b){function d(d,f){var e=g.hasOwnProperty(d)?g[d]:b,l;e||(e=g[d]=new a.P,c(d,function(a){h[d]=a;delete g[d];
l?e.notifySubscribers(a):setTimeout(function(){e.notifySubscribers(a)},0)}),l=!0);e.U(f)}function c(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a)}):b(null)})}function e(c,d,g,l){l||(l=a.g.loaders.slice(0));var h=l.shift();if(h){var n=h[c];if(n){var t=!1;if(n.apply(h,d.concat(function(a){t?g(null):null!==a?g(a):e(c,d,g,l)}))!==b&&(t=!0,!h.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");
}else e(c,d,g,l)}else g(null)}var g={},h={};a.g={get:function(a,c){var e=h.hasOwnProperty(a)?h[a]:b;e?setTimeout(function(){c(e)},0):d(a,c)},tb:function(a){delete h[a]},jb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.tb)})();(function(){function b(b,c,d,e){function k(){0===--u&&e(h)}var h={},u=2,r=d.template;d=d.viewModel;r?g(c,r,function(c){a.g.jb("loadTemplate",[b,c],function(a){h.template=a;k()})}):k();d?g(c,d,function(c){a.g.jb("loadViewModel",
[b,c],function(a){h[f]=a;k()})}):k()}function d(a,b,c){if("function"===typeof b)c(function(a){return new b(a)});else if("function"===typeof b[f])c(b[f]);else if("instance"in b){var e=b.instance;c(function(){return e})}else"viewModel"in b?d(a,b.viewModel,c):a("Unknown viewModel value: "+b)}function c(b){switch(a.a.t(b)){case "script":return a.a.ba(b.text);case "textarea":return a.a.ba(b.value);case "template":if(e(b.content))return a.a.ia(b.content.childNodes)}return a.a.ia(b.childNodes)}function e(a){return s.DocumentFragment?
a instanceof DocumentFragment:a&&11===a.nodeType}function g(a,b,c){"string"===typeof b.require?N||s.require?(N||s.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function h(a){return function(b){throw Error("Component '"+a+"': "+b);}}var k={};a.g.tc=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.Qa(b))throw Error("Component "+b+" is already registered");k[b]=c};a.g.Qa=function(a){return a in k};a.g.wc=function(b){delete k[b];a.g.tb(b)};a.g.ub={getConfig:function(a,
b){b(k.hasOwnProperty(a)?k[a]:null)},loadComponent:function(a,c,d){var e=h(a);g(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,d,f){b=h(b);if("string"===typeof d)f(a.a.ba(d));else if(d instanceof Array)f(d);else if(e(d))f(a.a.S(d.childNodes));else if(d.element)if(d=d.element,s.HTMLElement?d instanceof HTMLElement:d&&d.tagName&&1===d.nodeType)f(c(d));else if("string"===typeof d){var k=v.getElementById(d);k?f(c(k)):b("Cannot find element with ID "+d)}else b("Unknown element type: "+d);else b("Unknown template value: "+
d)},loadViewModel:function(a,b,c){d(h(a),b,c)}};var f="createViewModel";a.b("components.register",a.g.tc);a.b("components.isRegistered",a.g.Qa);a.b("components.unregister",a.g.wc);a.b("components.defaultLoader",a.g.ub);a.g.loaders.push(a.g.ub);a.g.Ub=k})();(function(){function b(b,e){var g=b.getAttribute("params");if(g){var g=d.parseBindingsString(g,e,b,{valueAccessors:!0,bindingParams:!0}),g=a.a.na(g,function(d){return a.s(d,null,{o:b})}),h=a.a.na(g,function(d){return d.Z()?a.s(function(){return a.a.c(d())},
null,{o:b}):d.v()});h.hasOwnProperty("$raw")||(h.$raw=g);return h}return{$raw:{}}}a.g.getComponentNameForNode=function(b){b=a.a.t(b);return a.g.Qa(b)&&b};a.g.mb=function(c,d,g,h){if(1===d.nodeType){var k=a.g.getComponentNameForNode(d);if(k){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');var f={name:k,params:b(d,g)};c.component=h?function(){return f}:f}}return c};var d=new a.J;9>a.a.L&&(a.g.register=function(a){return function(b){v.createElement(b);
return a.apply(this,arguments)}}(a.g.register),v.createDocumentFragment=function(b){return function(){var d=b(),g=a.g.Ub,h;for(h in g)g.hasOwnProperty(h)&&d.createElement(h);return d}}(v.createDocumentFragment))})();(function(){var b=0;a.d.component={init:function(d,c,e,g,h){function k(){var a=f&&f.dispose;"function"===typeof a&&a.call(f);m=null}var f,m;a.a.w.da(d,k);a.s(function(){var e=a.a.c(c()),g,n;"string"===typeof e?g=e:(g=a.a.c(e.name),n=a.a.c(e.params));if(!g)throw Error("No component name specified");
var t=m=++b;a.g.get(g,function(b){if(m===t){k();if(!b)throw Error("Unknown component '"+g+"'");var c=b.template;if(!c)throw Error("Component '"+g+"' has no template");c=a.a.ia(c);a.f.T(d,c);var c=n,e=b.createViewModel;b=e?e.call(b,c,{element:d}):c;c=h.createChildContext(b);f=b;a.Ca(c,d)}})},null,{o:d});return{controlsDescendantBindings:!0}}};a.f.Q.component=!0})();var Q={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,d){var c=a.a.c(d())||{};a.a.G(c,function(c,d){d=a.a.c(d);var h=
!1===d||null===d||d===p;h&&b.removeAttribute(c);8>=a.a.L&&c in Q?(c=Q[c],h?b.removeAttribute(c):b[c]=d):h||b.setAttribute(c,d.toString());"name"===c&&a.a.Mb(b,h?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,d,c){function e(){var e=b.checked,k=q?h():e;if(!a.Y.ma()&&(!f||e)){var g=a.k.B(d);m?l!==k?(e&&(a.a.ea(g,k,!0),a.a.ea(g,l,!1)),l=k):a.a.ea(g,k,e):a.h.pa(g,c,"checked",k,!0)}}function g(){var c=a.a.c(d());b.checked=m?0<=a.a.m(c,h()):k?c:h()===c}var h=a.Ib(function(){return c.has("checkedValue")?
a.a.c(c.get("checkedValue")):c.has("value")?a.a.c(c.get("value")):b.value}),k="checkbox"==b.type,f="radio"==b.type;if(k||f){var m=k&&a.a.c(d())instanceof Array,l=m?h():p,q=f||m;f&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.s(e,null,{o:b});a.a.n(b,"click",e);a.s(g,null,{o:b})}}};a.h.V.checked=!0;a.d.checkedValue={update:function(b,d){b.value=a.a.c(d())}}})();a.d.css={update:function(b,d){var c=a.a.c(d());"object"==typeof c?a.a.G(c,function(c,d){d=a.a.c(d);a.a.Ba(b,c,d)}):(c=String(c||""),
a.a.Ba(b,b.__ko__cssValue,!1),b.__ko__cssValue=c,a.a.Ba(b,c,!0))}};a.d.enable={update:function(b,d){var c=a.a.c(d());c&&b.disabled?b.removeAttribute("disabled"):c||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,d){a.d.enable.update(b,function(){return!a.a.c(d())})}};a.d.event={init:function(b,d,c,e,g){var h=d()||{};a.a.G(h,function(k){"string"==typeof k&&a.a.n(b,k,function(b){var h,l=d()[k];if(l){try{var q=a.a.S(arguments);e=g.$data;q.unshift(e);h=l.apply(e,q)}finally{!0!==h&&(b.preventDefault?
b.preventDefault():b.returnValue=!1)}!1===c.get(k+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.d.foreach={Eb:function(b){return function(){var d=b(),c=a.a.Xa(d);if(!c||"number"==typeof c.length)return{foreach:d,templateEngine:a.O.Oa};a.a.c(d);return{foreach:c.data,as:c.as,includeDestroyed:c.includeDestroyed,afterAdd:c.afterAdd,beforeRemove:c.beforeRemove,afterRender:c.afterRender,beforeMove:c.beforeMove,afterMove:c.afterMove,templateEngine:a.O.Oa}}},init:function(b,
d){return a.d.template.init(b,a.d.foreach.Eb(d))},update:function(b,d,c,e,g){return a.d.template.update(b,a.d.foreach.Eb(d),c,e,g)}};a.h.ha.foreach=!1;a.f.Q.foreach=!0;a.d.hasfocus={init:function(b,d,c){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(h){g=f.body}e=g===b}f=d();a.h.pa(f,c,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var g=e.bind(null,!0),h=e.bind(null,!1);a.a.n(b,"focus",g);a.a.n(b,"focusin",
g);a.a.n(b,"blur",h);a.a.n(b,"focusout",h)},update:function(b,d){var c=!!a.a.c(d());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===c||(c?b.focus():b.blur(),a.k.B(a.a.oa,null,[b,c?"focusin":"focusout"]))}};a.h.V.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.V.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,d){a.a.$a(b,d())}};I("if");I("ifnot",!1,!0);I("with",!0,!1,function(a,d){return a.createChildContext(d)});var K={};a.d.options={init:function(b){if("select"!==
a.a.t(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,d,c){function e(){return a.a.ta(b.options,function(a){return a.selected})}function g(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function h(c,d){if(q.length){var e=0<=a.a.m(q,a.i.q(d[0]));a.a.Nb(d[0],e);n&&!e&&a.k.B(a.a.oa,null,[b,"change"])}}var k=0!=b.length&&b.multiple?b.scrollTop:null,f=a.a.c(d()),m=c.get("optionsIncludeDestroyed");
d={};var l,q;q=b.multiple?a.a.Da(e(),a.i.q):0<=b.selectedIndex?[a.i.q(b.options[b.selectedIndex])]:[];f&&("undefined"==typeof f.length&&(f=[f]),l=a.a.ta(f,function(b){return m||b===p||null===b||!a.a.c(b._destroy)}),c.has("optionsCaption")&&(f=a.a.c(c.get("optionsCaption")),null!==f&&f!==p&&l.unshift(K)));var n=!1;d.beforeRemove=function(a){b.removeChild(a)};f=h;c.has("optionsAfterRender")&&(f=function(b,d){h(0,d);a.k.B(c.get("optionsAfterRender"),null,[d[0],b!==K?b:p])});a.a.Za(b,l,function(d,e,f){f.length&&
(q=f[0].selected?[a.i.q(f[0])]:[],n=!0);e=b.ownerDocument.createElement("option");d===K?(a.a.bb(e,c.get("optionsCaption")),a.i.ca(e,p)):(f=g(d,c.get("optionsValue"),d),a.i.ca(e,a.a.c(f)),d=g(d,c.get("optionsText"),f),a.a.bb(e,d));return[e]},d,f);a.k.B(function(){c.get("valueAllowUnset")&&c.has("value")?a.i.ca(b,a.a.c(c.get("value")),!0):(b.multiple?q.length&&e().length<q.length:q.length&&0<=b.selectedIndex?a.i.q(b.options[b.selectedIndex])!==q[0]:q.length||0<=b.selectedIndex)&&a.a.oa(b,"change")});
a.a.dc(b);k&&20<Math.abs(k-b.scrollTop)&&(b.scrollTop=k)}};a.d.options.Va=a.a.e.F();a.d.selectedOptions={after:["options","foreach"],init:function(b,d,c){a.a.n(b,"change",function(){var e=d(),g=[];a.a.u(b.getElementsByTagName("option"),function(b){b.selected&&g.push(a.i.q(b))});a.h.pa(e,c,"selectedOptions",g)})},update:function(b,d){if("select"!=a.a.t(b))throw Error("values binding applies only to SELECT elements");var c=a.a.c(d());c&&"number"==typeof c.length&&a.a.u(b.getElementsByTagName("option"),
function(b){var d=0<=a.a.m(c,a.i.q(b));a.a.Nb(b,d)})}};a.h.V.selectedOptions=!0;a.d.style={update:function(b,d){var c=a.a.c(d()||{});a.a.G(c,function(c,d){d=a.a.c(d);if(null===d||d===p||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,d,c,e,g){if("function"!=typeof d())throw Error("The value for a submit binding must be a function");a.a.n(b,"submit",function(a){var c,e=d();try{c=e.call(g.$data,b)}finally{!0!==c&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},
update:function(b,d){a.a.bb(b,d())}};a.f.Q.text=!0;(function(){if(s&&s.navigator)var b=function(a){if(a)return parseFloat(a[1])},d=s.opera&&s.opera.version&&parseInt(s.opera.version()),c=s.navigator.userAgent,e=b(c.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),g=b(c.match(/Firefox\/([^ ]*)/));if(10>a.a.L)var h=a.a.e.F(),k=a.a.e.F(),f=function(b){var c=this.activeElement;(c=c&&a.a.e.get(c,k))&&c(b)},m=function(b,c){var d=b.ownerDocument;a.a.e.get(d,h)||(a.a.e.set(d,h,!0),a.a.n(d,"selectionchange",
f));a.a.e.set(b,k,c)};a.d.textInput={init:function(b,c,f){function k(c,d){a.a.n(b,c,d)}function h(){var d=a.a.c(c());if(null===d||d===p)d="";v!==p&&d===v?setTimeout(h,4):b.value!==d&&(s=d,b.value=d)}function u(){y||(v=b.value,y=setTimeout(r,4))}function r(){clearTimeout(y);v=y=p;var d=b.value;s!==d&&(s=d,a.h.pa(c(),f,"textInput",d))}var s=b.value,y,v;10>a.a.L?(k("propertychange",function(a){"value"===a.propertyName&&r()}),8==a.a.L&&(k("keyup",r),k("keydown",r)),8<=a.a.L&&(m(b,r),k("dragend",u))):
(k("input",r),5>e&&"textarea"===a.a.t(b)?(k("keydown",u),k("paste",u),k("cut",u)):11>d?k("keydown",u):4>g&&(k("DOMAutoComplete",r),k("dragdrop",r),k("drop",r)));k("change",r);a.s(h,null,{o:b})}};a.h.V.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.d.uniqueName={init:function(b,d){if(d()){var c="ko_unique_"+ ++a.d.uniqueName.Zb;a.a.Mb(b,c)}}};a.d.uniqueName.Zb=0;a.d.value={after:["options","foreach"],init:function(b,d,c){if("input"!=b.tagName.toLowerCase()||"checkbox"!=
b.type&&"radio"!=b.type){var e=["change"],g=c.get("valueUpdate"),h=!1,k=null;g&&("string"==typeof g&&(g=[g]),a.a.ga(e,g),e=a.a.rb(e));var f=function(){k=null;h=!1;var e=d(),f=a.i.q(b);a.h.pa(e,c,"value",f)};!a.a.L||"input"!=b.tagName.toLowerCase()||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.m(e,"propertychange")||(a.a.n(b,"propertychange",function(){h=!0}),a.a.n(b,"focus",function(){h=!1}),a.a.n(b,"blur",function(){h&&f()}));a.a.u(e,function(c){var d=f;a.a.vc(c,
"after")&&(d=function(){k=a.i.q(b);setTimeout(f,0)},c=c.substring(5));a.a.n(b,c,d)});var m=function(){var e=a.a.c(d()),f=a.i.q(b);if(null!==k&&e===k)setTimeout(m,0);else if(e!==f)if("select"===a.a.t(b)){var g=c.get("valueAllowUnset"),f=function(){a.i.ca(b,e,g)};f();g||e===a.i.q(b)?setTimeout(f,0):a.k.B(a.a.oa,null,[b,"change"])}else a.i.ca(b,e)};a.s(m,null,{o:b})}else a.ra(b,{checkedValue:d})},update:function(){}};a.h.V.value=!0;a.d.visible={update:function(b,d){var c=a.a.c(d()),e="none"!=b.style.display;
c&&!e?b.style.display="":!c&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(d,c,e,g,h){return a.d.event.init.call(this,d,function(){var a={};a[b]=c();return a},e,g,h)}}})("click");a.H=function(){};a.H.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.H.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.H.prototype.makeTemplateSource=function(b,d){if("string"==typeof b){d=d||v;var c=
d.getElementById(b);if(!c)throw Error("Cannot find template with ID "+b);return new a.r.l(c)}if(1==b.nodeType||8==b.nodeType)return new a.r.fa(b);throw Error("Unknown template type: "+b);};a.H.prototype.renderTemplate=function(a,d,c,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,d,c)};a.H.prototype.isTemplateRewritten=function(a,d){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,d).data("isRewritten")};a.H.prototype.rewriteTemplate=function(a,d,c){a=this.makeTemplateSource(a,
c);d=d(a.text());a.text(d);a.data("isRewritten",!0)};a.b("templateEngine",a.H);a.fb=function(){function b(b,c,d,k){b=a.h.Wa(b);for(var f=a.h.ha,m=0;m<b.length;m++){var l=b[m].key;if(f.hasOwnProperty(l)){var q=f[l];if("function"===typeof q){if(l=q(b[m].value))throw Error(l);}else if(!q)throw Error("This template engine does not support the '"+l+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.h.ya(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+
"')";return k.createJavaScriptEvaluatorBlock(d)+c}var d=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,c=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{ec:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.fb.nc(b,c)},d)},nc:function(a,g){return a.replace(d,function(a,c,d,e,l){return b(l,c,d,g)}).replace(c,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",g)})},Xb:function(b,c){return a.D.Ua(function(d,
k){var f=d.nextSibling;f&&f.nodeName.toLowerCase()===c&&a.ra(f,b,k)})}}}();a.b("__tr_ambtns",a.fb.Xb);(function(){a.r={};a.r.l=function(a){this.l=a};a.r.l.prototype.text=function(){var b=a.a.t(this.l),b="script"===b?"text":"textarea"===b?"value":"innerHTML";if(0==arguments.length)return this.l[b];var d=arguments[0];"innerHTML"===b?a.a.$a(this.l,d):this.l[b]=d};var b=a.a.e.F()+"_";a.r.l.prototype.data=function(c){if(1===arguments.length)return a.a.e.get(this.l,b+c);a.a.e.set(this.l,b+c,arguments[1])};
var d=a.a.e.F();a.r.fa=function(a){this.l=a};a.r.fa.prototype=new a.r.l;a.r.fa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.l,d)||{};b.gb===p&&b.Ga&&(b.gb=b.Ga.innerHTML);return b.gb}a.a.e.set(this.l,d,{gb:arguments[0]})};a.r.l.prototype.nodes=function(){if(0==arguments.length)return(a.a.e.get(this.l,d)||{}).Ga;a.a.e.set(this.l,d,{Ga:arguments[0]})};a.b("templateSources",a.r);a.b("templateSources.domElement",a.r.l);a.b("templateSources.anonymousTemplate",a.r.fa)})();(function(){function b(b,
c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),d(e,b)}function d(c,d){if(c.length){var e=c[0],g=c[c.length-1],h=e.parentNode,n=a.J.instance,t=n.preprocessNode;if(t){b(e,g,function(a,b){var c=a.previousSibling,d=t.call(n,a);d&&(a===e&&(e=d[0]||b),a===g&&(g=d[d.length-1]||c))});c.length=0;if(!e)return;e===g?c.push(e):(c.push(e,g),a.a.ka(c,h))}b(e,g,function(b){1!==b.nodeType&&8!==b.nodeType||a.pb(d,b)});b(e,g,function(b){1!==b.nodeType&&8!==b.nodeType||a.D.Sb(b,[d])});a.a.ka(c,
h)}}function c(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,h,l,q){q=q||{};var n=b&&c(b),n=n&&n.ownerDocument,t=q.templateEngine||g;a.fb.ec(h,t,n);h=t.renderTemplate(h,l,q,n);if("number"!=typeof h.length||0<h.length&&"number"!=typeof h[0].nodeType)throw Error("Template engine must return an array of DOM nodes");n=!1;switch(e){case "replaceChildren":a.f.T(b,h);n=!0;break;case "replaceNode":a.a.Lb(b,h);n=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+
e);}n&&(d(h,l),q.afterRender&&a.k.B(q.afterRender,null,[h,l.$data]));return h}var g;a.ab=function(b){if(b!=p&&!(b instanceof a.H))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.Ya=function(b,d,h,l,q){h=h||{};if((h.templateEngine||g)==p)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";if(l){var n=c(l);return a.j(function(){var g=d&&d instanceof a.N?d:new a.N(a.a.c(d)),p=a.C(b)?b():"function"===typeof b?b(g.$data,g):b,g=e(l,q,p,g,h);
"replaceNode"==q&&(l=g,n=c(l))},null,{Ia:function(){return!n||!a.a.Ja(n)},o:n&&"replaceNode"==q?n.parentNode:n})}return a.D.Ua(function(c){a.Ya(b,d,h,c,"replaceNode")})};a.uc=function(b,c,g,h,q){function n(a,b){d(b,s);g.afterRender&&g.afterRender(b,a)}function t(c,d){s=q.createChildContext(c,g.as,function(a){a.$index=d});var f=a.C(b)?b():"function"===typeof b?b(c,s):b;return e(null,"ignoreTargetNode",f,s,g)}var s;return a.j(function(){var b=a.a.c(c)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.ta(b,
function(b){return g.includeDestroyed||b===p||null===b||!a.a.c(b._destroy)});a.k.B(a.a.Za,null,[h,b,t,g,n])},null,{o:h})};var h=a.a.e.F();a.d.template={init:function(b,c){var d=a.a.c(c());"string"==typeof d||d.name?a.f.ja(b):(d=a.f.childNodes(b),d=a.a.oc(d),(new a.r.fa(b)).nodes(d));return{controlsDescendantBindings:!0}},update:function(b,c,d,e,g){var n=c(),t;c=a.a.c(n);d=!0;e=null;"string"==typeof c?c={}:(n=c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in c&&(d=!a.a.c(c.ifnot)),t=a.a.c(c.data));
"foreach"in c?e=a.uc(n||b,d&&c.foreach||[],c,b,g):d?(g="data"in c?g.createChildContext(t,c.as):g,e=a.Ya(n||b,g,c,b)):a.f.ja(b);g=e;(t=a.a.e.get(b,h))&&"function"==typeof t.K&&t.K();a.a.e.set(b,h,g&&g.Z()?g:p)}};a.h.ha.template=function(b){b=a.h.Wa(b);return 1==b.length&&b[0].unknown||a.h.lc(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.Q.template=!0})();a.b("setTemplateEngine",a.ab);a.b("renderTemplate",a.Ya);a.a.wb=function(a,d,c){if(a.length&&
d.length){var e,g,h,k,f;for(e=g=0;(!c||e<c)&&(k=a[g]);++g){for(h=0;f=d[h];++h)if(k.value===f.value){k.moved=f.index;f.moved=k.index;d.splice(h,1);e=h=0;break}e+=h}}};a.a.Fa=function(){function b(b,c,e,g,h){var k=Math.min,f=Math.max,m=[],l,q=b.length,n,p=c.length,s=p-q||1,u=q+p+1,r,v,w;for(l=0;l<=q;l++)for(v=r,m.push(r=[]),w=k(p,l+s),n=f(0,l-1);n<=w;n++)r[n]=n?l?b[l-1]===c[n-1]?v[n-1]:k(v[n]||u,r[n-1]||u)+1:n+1:l+1;k=[];f=[];s=[];l=q;for(n=p;l||n;)p=m[l][n]-1,n&&p===m[l][n-1]?f.push(k[k.length]={status:e,
value:c[--n],index:n}):l&&p===m[l-1][n]?s.push(k[k.length]={status:g,value:b[--l],index:l}):(--n,--l,h.sparse||k.push({status:"retained",value:c[n]}));a.a.wb(f,s,10*q);return k.reverse()}return function(a,c,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];c=c||[];return a.length<=c.length?b(a,c,"added","deleted",e):b(c,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Fa);(function(){function b(b,d,g,h,k){var f=[],m=a.j(function(){var l=d(g,k,a.a.ka(f,b))||[];0<f.length&&(a.a.Lb(f,
l),h&&a.k.B(h,null,[g,l,k]));f.length=0;a.a.ga(f,l)},null,{o:b,Ia:function(){return!a.a.ob(f)}});return{$:f,j:m.Z()?m:p}}var d=a.a.e.F();a.a.Za=function(c,e,g,h,k){function f(b,d){x=q[d];r!==d&&(A[b]=x);x.Na(r++);a.a.ka(x.$,c);s.push(x);w.push(x)}function m(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.u(c[d].$,function(a){b(a,d,c[d].sa)})}e=e||[];h=h||{};var l=a.a.e.get(c,d)===p,q=a.a.e.get(c,d)||[],n=a.a.Da(q,function(a){return a.sa}),t=a.a.Fa(n,e,h.dontLimitMoves),s=[],u=0,r=0,v=[],w=[];e=
[];for(var A=[],n=[],x,B=0,D,F;D=t[B];B++)switch(F=D.moved,D.status){case "deleted":F===p&&(x=q[u],x.j&&x.j.K(),v.push.apply(v,a.a.ka(x.$,c)),h.beforeRemove&&(e[B]=x,w.push(x)));u++;break;case "retained":f(B,u++);break;case "added":F!==p?f(B,F):(x={sa:D.value,Na:a.p(r++)},s.push(x),w.push(x),l||(n[B]=x))}m(h.beforeMove,A);a.a.u(v,h.beforeRemove?a.R:a.removeNode);for(var B=0,l=a.f.firstChild(c),G;x=w[B];B++){x.$||a.a.extend(x,b(c,g,x.sa,k,x.Na));for(u=0;t=x.$[u];l=t.nextSibling,G=t,u++)t!==l&&a.f.Bb(c,
t,G);!x.ic&&k&&(k(x.sa,x.$,x.Na),x.ic=!0)}m(h.beforeRemove,e);m(h.afterMove,A);m(h.afterAdd,n);a.a.e.set(c,d,s)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Za);a.O=function(){this.allowTemplateRewriting=!1};a.O.prototype=new a.H;a.O.prototype.renderTemplateSource=function(b){var d=(9>a.a.L?0:b.nodes)?b.nodes():null;if(d)return a.a.S(d.cloneNode(!0).childNodes);b=b.text();return a.a.ba(b)};a.O.Oa=new a.O;a.ab(a.O.Oa);a.b("nativeTemplateEngine",a.O);(function(){a.Sa=function(){var a=this.kc=
function(){if(!w||!w.tmpl)return 0;try{if(0<=w.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,g){g=g||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=w.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=w.extend({koBindingContext:e},g.templateOptions);e=w.tmpl(h,
b,e);e.appendTo(v.createElement("div"));w.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){v.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(w.tmpl.tag.ko_code={open:"__.push($1 || '');"},w.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.Sa.prototype=new a.H;var b=new a.Sa;0<b.kc&&a.ab(b);a.b("jqueryTmplTemplateEngine",a.Sa)})()})})();})();

},{}],590:[function(require,module,exports){
'use strict';
var OBSERVABLES_PROPERTY = '__knockoutObservables';
var SUBSCRIBABLE_PROPERTY = '__knockoutSubscribable';
function track(obj, propertyNames) {
    if (!obj) {
        throw new Error('When calling ko.track, you must pass an object as the first parameter.');
    }
    var ko = this, allObservablesForObject = getAllObservablesForObject(obj, true);
    propertyNames = propertyNames || Object.getOwnPropertyNames(obj);
    propertyNames.forEach(function (propertyName) {
        if (propertyName === OBSERVABLES_PROPERTY || propertyName === SUBSCRIBABLE_PROPERTY) {
            return;
        }
        if (propertyName in allObservablesForObject) {
            return;
        }
        var origValue = obj[propertyName], isArray = origValue instanceof Array, observable = ko.isObservable(origValue) ? origValue : isArray ? ko.observableArray(origValue) : ko.observable(origValue);
        Object.defineProperty(obj, propertyName, {
            configurable: true,
            enumerable: true,
            get: observable,
            set: ko.isWriteableObservable(observable) ? observable : undefined
        });
        allObservablesForObject[propertyName] = observable;
        if (isArray) {
            notifyWhenPresentOrFutureArrayValuesMutate(ko, observable);
        }
    });
    return obj;
}
function getAllObservablesForObject(obj, createIfNotDefined) {
    var result = obj[OBSERVABLES_PROPERTY];
    if (!result && createIfNotDefined) {
        result = {};
        Object.defineProperty(obj, OBSERVABLES_PROPERTY, { value: result });
    }
    return result;
}
function defineComputedProperty(obj, propertyName, evaluatorOrOptions) {
    var ko = this, computedOptions = {
            owner: obj,
            deferEvaluation: true
        };
    if (typeof evaluatorOrOptions === 'function') {
        computedOptions.read = evaluatorOrOptions;
    } else {
        if ('value' in evaluatorOrOptions) {
            throw new Error('For ko.defineProperty, you must not specify a "value" for the property. You must provide a "get" function.');
        }
        if (typeof evaluatorOrOptions.get !== 'function') {
            throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called "get".');
        }
        computedOptions.read = evaluatorOrOptions.get;
        computedOptions.write = evaluatorOrOptions.set;
    }
    obj[propertyName] = ko.computed(computedOptions);
    track.call(ko, obj, [propertyName]);
    return obj;
}
function notifyWhenPresentOrFutureArrayValuesMutate(ko, observable) {
    var watchingArraySubscription = null;
    ko.computed(function () {
        if (watchingArraySubscription) {
            watchingArraySubscription.dispose();
            watchingArraySubscription = null;
        }
        var newArrayInstance = observable();
        if (newArrayInstance instanceof Array) {
            watchingArraySubscription = startWatchingArrayInstance(ko, observable, newArrayInstance);
        }
    });
}
function startWatchingArrayInstance(ko, observable, arrayInstance) {
    var subscribable = getSubscribableForArray(ko, arrayInstance);
    return subscribable.subscribe(observable);
}
function getSubscribableForArray(ko, arrayInstance) {
    var subscribable = arrayInstance[SUBSCRIBABLE_PROPERTY];
    if (!subscribable) {
        subscribable = new ko.subscribable();
        Object.defineProperty(arrayInstance, SUBSCRIBABLE_PROPERTY, { value: subscribable });
        var notificationPauseSignal = {};
        wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal);
        addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal);
    }
    return subscribable;
}
function wrapStandardArrayMutators(arrayInstance, subscribable, notificationPauseSignal) {
    [
        'pop',
        'push',
        'reverse',
        'shift',
        'sort',
        'splice',
        'unshift'
    ].forEach(function (fnName) {
        var origMutator = arrayInstance[fnName];
        arrayInstance[fnName] = function () {
            var result = origMutator.apply(this, arguments);
            if (notificationPauseSignal.pause !== true) {
                subscribable.notifySubscribers(this);
            }
            return result;
        };
    });
}
function addKnockoutArrayMutators(ko, arrayInstance, subscribable, notificationPauseSignal) {
    [
        'remove',
        'removeAll',
        'destroy',
        'destroyAll',
        'replace'
    ].forEach(function (fnName) {
        Object.defineProperty(arrayInstance, fnName, {
            enumerable: false,
            value: function () {
                var result;
                notificationPauseSignal.pause = true;
                try {
                    result = ko.observableArray.fn[fnName].apply(ko.observableArray(arrayInstance), arguments);
                } finally {
                    notificationPauseSignal.pause = false;
                }
                subscribable.notifySubscribers(arrayInstance);
                return result;
            }
        });
    });
}
function getObservable(obj, propertyName) {
    if (!obj) {
        return null;
    }
    var allObservablesForObject = getAllObservablesForObject(obj, false);
    return allObservablesForObject && allObservablesForObject[propertyName] || null;
}
function valueHasMutated(obj, propertyName) {
    var observable = getObservable(obj, propertyName);
    if (observable) {
        observable.valueHasMutated();
    }
}
function attachToKo(ko) {
    ko.track = track;
    ko.getObservable = getObservable;
    ko.valueHasMutated = valueHasMutated;
    ko.defineProperty = defineComputedProperty;
}
module.exports = { attachToKo: attachToKo };
},{}],591:[function(require,module,exports){
var knockout = require('./knockout-3.2.0'), knockout_es5 = require('./knockout-es5'), SvgPathBindingHandler = require('../Widgets/SvgPathBindingHandler');
'use strict';
knockout_es5.attachToKo(knockout);
SvgPathBindingHandler.register(knockout);
module.exports = knockout;
},{"../Widgets/SvgPathBindingHandler":621,"./knockout-3.2.0":589,"./knockout-es5":590}],592:[function(require,module,exports){
var getCSSValue = function (element, property) {
    return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
};
var measureText = function (context2D, textstring, stroke, fill) {
    var metrics = context2D.measureText(textstring), fontFamily = getCSSValue(context2D.canvas, 'font-family'), fontSize = getCSSValue(context2D.canvas, 'font-size').replace('px', ''), isSpace = !/\S/.test(textstring);
    metrics.fontsize = fontSize;
    var leadDiv = document.createElement('div');
    leadDiv.style.position = 'absolute';
    leadDiv.style.opacity = 0;
    leadDiv.style.font = fontSize + 'px ' + fontFamily;
    leadDiv.innerHTML = textstring + '<br/>' + textstring;
    document.body.appendChild(leadDiv);
    metrics.leading = 1.2 * fontSize;
    var leadDivHeight = getCSSValue(leadDiv, 'height');
    leadDivHeight = leadDivHeight.replace('px', '');
    if (leadDivHeight >= fontSize * 2) {
        metrics.leading = leadDivHeight / 2 | 0;
    }
    document.body.removeChild(leadDiv);
    if (!isSpace) {
        var canvas = document.createElement('canvas');
        var padding = 100;
        canvas.width = metrics.width + padding;
        canvas.height = 3 * fontSize;
        canvas.style.opacity = 1;
        canvas.style.fontFamily = fontFamily;
        canvas.style.fontSize = fontSize;
        var ctx = canvas.getContext('2d');
        ctx.font = fontSize + 'px ' + fontFamily;
        var w = canvas.width, h = canvas.height, baseline = h / 2;
        ctx.fillStyle = 'white';
        ctx.fillRect(-1, -1, w + 2, h + 2);
        if (stroke) {
            ctx.strokeStyle = 'black';
            ctx.lineWidth = context2D.lineWidth;
            ctx.strokeText(textstring, padding / 2, baseline);
        }
        if (fill) {
            ctx.fillStyle = 'black';
            ctx.fillText(textstring, padding / 2, baseline);
        }
        var pixelData = ctx.getImageData(0, 0, w, h).data;
        var i = 0, w4 = w * 4, len = pixelData.length;
        while (++i < len && pixelData[i] === 255) {
        }
        var ascent = i / w4 | 0;
        i = len - 1;
        while (--i > 0 && pixelData[i] === 255) {
        }
        var descent = i / w4 | 0;
        for (i = 0; i < len && pixelData[i] === 255;) {
            i += w4;
            if (i >= len) {
                i = i - len + 4;
            }
        }
        var minx = i % w4 / 4 | 0;
        var step = 1;
        for (i = len - 3; i >= 0 && pixelData[i] === 255;) {
            i -= w4;
            if (i < 0) {
                i = len - 3 - step++ * 4;
            }
        }
        var maxx = i % w4 / 4 + 1 | 0;
        metrics.ascent = baseline - ascent;
        metrics.descent = descent - baseline;
        metrics.bounds = {
            minx: minx - padding / 2,
            maxx: maxx - padding / 2,
            miny: 0,
            maxy: descent - ascent
        };
        metrics.height = 1 + (descent - ascent);
    } else {
        metrics.ascent = 0;
        metrics.descent = 0;
        metrics.bounds = {
            minx: 0,
            maxx: metrics.width,
            miny: 0,
            maxy: 0
        };
        metrics.height = 0;
    }
    return metrics;
};
module.exports = measureText;
},{}],593:[function(require,module,exports){
var MersenneTwister = function (seed) {
    if (seed == undefined) {
        seed = new Date().getTime();
    }
    this.N = 624;
    this.M = 397;
    this.MATRIX_A = 2567483615;
    this.UPPER_MASK = 2147483648;
    this.LOWER_MASK = 2147483647;
    this.mt = new Array(this.N);
    this.mti = this.N + 1;
    this.init_genrand(seed);
};
MersenneTwister.prototype.init_genrand = function (s) {
    this.mt[0] = s >>> 0;
    for (this.mti = 1; this.mti < this.N; this.mti++) {
        var s = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (((s & 4294901760) >>> 16) * 1812433253 << 16) + (s & 65535) * 1812433253 + this.mti;
        this.mt[this.mti] >>>= 0;
    }
};
MersenneTwister.prototype.genrand_int32 = function () {
    var y;
    var mag01 = new Array(0, this.MATRIX_A);
    if (this.mti >= this.N) {
        var kk;
        if (this.mti == this.N + 1)
            this.init_genrand(5489);
        for (kk = 0; kk < this.N - this.M; kk++) {
            y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
            this.mt[kk] = this.mt[kk + this.M] ^ y >>> 1 ^ mag01[y & 1];
        }
        for (; kk < this.N - 1; kk++) {
            y = this.mt[kk] & this.UPPER_MASK | this.mt[kk + 1] & this.LOWER_MASK;
            this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ y >>> 1 ^ mag01[y & 1];
        }
        y = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK;
        this.mt[this.N - 1] = this.mt[this.M - 1] ^ y >>> 1 ^ mag01[y & 1];
        this.mti = 0;
    }
    y = this.mt[this.mti++];
    y ^= y >>> 11;
    y ^= y << 7 & 2636928640;
    y ^= y << 15 & 4022730752;
    y ^= y >>> 18;
    return y >>> 0;
};
MersenneTwister.prototype.random = function () {
    return this.genrand_int32() * (1 / 4294967296);
};
module.exports = MersenneTwister;
},{}],594:[function(require,module,exports){
function sprintf() {
    var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
    var a = arguments, i = 0, format = a[i++];
    var pad = function (str, len, chr, leftJustify) {
        if (!chr) {
            chr = ' ';
        }
        var padding = str.length >= len ? '' : Array(1 + len - str.length >>> 0).join(chr);
        return leftJustify ? str + padding : padding + str;
    };
    var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
        var diff = minWidth - value.length;
        if (diff > 0) {
            if (leftJustify || !zeroPad) {
                value = pad(value, minWidth, customPadChar, leftJustify);
            } else {
                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
            }
        }
        return value;
    };
    var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
        var number = value >>> 0;
        prefix = prefix && number && {
            '2': '0b',
            '8': '0',
            '16': '0x'
        }[base] || '';
        value = prefix + pad(number.toString(base), precision || 0, '0', false);
        return justify(value, prefix, leftJustify, minWidth, zeroPad);
    };
    var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
        if (precision != null) {
            value = value.slice(0, precision);
        }
        return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
    };
    var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
        var number;
        var prefix;
        var method;
        var textTransform;
        var value;
        if (substring == '%%') {
            return '%';
        }
        var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false, customPadChar = ' ';
        var flagsl = flags.length;
        for (var j = 0; flags && j < flagsl; j++) {
            switch (flags.charAt(j)) {
            case ' ':
                positivePrefix = ' ';
                break;
            case '+':
                positivePrefix = '+';
                break;
            case '-':
                leftJustify = true;
                break;
            case '\'':
                customPadChar = flags.charAt(j + 1);
                break;
            case '0':
                zeroPad = true;
                break;
            case '#':
                prefixBaseX = true;
                break;
            }
        }
        if (!minWidth) {
            minWidth = 0;
        } else if (minWidth == '*') {
            minWidth = +a[i++];
        } else if (minWidth.charAt(0) == '*') {
            minWidth = +a[minWidth.slice(1, -1)];
        } else {
            minWidth = +minWidth;
        }
        if (minWidth < 0) {
            minWidth = -minWidth;
            leftJustify = true;
        }
        if (!isFinite(minWidth)) {
            throw new Error('sprintf: (minimum-)width must be finite');
        }
        if (!precision) {
            precision = 'fFeE'.indexOf(type) > -1 ? 6 : type == 'd' ? 0 : undefined;
        } else if (precision == '*') {
            precision = +a[i++];
        } else if (precision.charAt(0) == '*') {
            precision = +a[precision.slice(1, -1)];
        } else {
            precision = +precision;
        }
        value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];
        switch (type) {
        case 's':
            return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
        case 'c':
            return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
        case 'b':
            return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'o':
            return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'x':
            return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'X':
            return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
        case 'u':
            return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
        case 'i':
        case 'd':
            number = +value || 0;
            number = Math.round(number - number % 1);
            prefix = number < 0 ? '-' : positivePrefix;
            value = prefix + pad(String(Math.abs(number)), precision, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        case 'e':
        case 'E':
        case 'f':
        case 'F':
        case 'g':
        case 'G':
            number = +value;
            prefix = number < 0 ? '-' : positivePrefix;
            method = [
                'toExponential',
                'toFixed',
                'toPrecision'
            ]['efg'.indexOf(type.toLowerCase())];
            textTransform = [
                'toString',
                'toUpperCase'
            ]['eEfFgG'.indexOf(type) % 2];
            value = prefix + Math.abs(number)[method](precision);
            return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
        default:
            return substring;
        }
    };
    return format.replace(regex, doFormat);
}
module.exports = sprintf;
},{}],595:[function(require,module,exports){
/**
@license
topojson - https://github.com/mbostock/topojson

Copyright (c) 2012, Michael Bostock
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* The name Michael Bostock may not be used to endorse or promote products
  derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

!function() {
  var topojson = {
    version: "1.6.18",
    mesh: function(topology) { return object(topology, meshArcs.apply(this, arguments)); },
    meshArcs: meshArcs,
    merge: function(topology) { return object(topology, mergeArcs.apply(this, arguments)); },
    mergeArcs: mergeArcs,
    feature: featureOrCollection,
    neighbors: neighbors,
    presimplify: presimplify
  };

  function stitchArcs(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i], t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function(i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
      else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

    return fragments;
  }

  function meshArcs(topology, o, filter) {
    var arcs = [];

    if (arguments.length > 1) {
      var geomsByArc = [],
          geom;

      function arc(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
      }

      function line(arcs) {
        arcs.forEach(arc);
      }

      function polygon(arcs) {
        arcs.forEach(line);
      }

      function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs) { arcs.forEach(polygon); }
      };

      geometry(o);

      geomsByArc.forEach(arguments.length < 3
          ? function(geoms) { arcs.push(geoms[0].i); }
          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
    } else {
      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
    }

    return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        components = [];

    objects.forEach(function(o) {
      if (o.type === "Polygon") register(o.arcs);
      else if (o.type === "MultiPolygon") o.arcs.forEach(register);
    });

    function register(polygon) {
      polygon.forEach(function(ring) {
        ring.forEach(function(arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function exterior(ring) {
      return cartesianRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]) > 0; // TODO allow spherical?
    }

    polygons.forEach(function(polygon) {
      if (!polygon._) {
        var component = [],
            neighbors = [polygon];
        polygon._ = 1;
        components.push(component);
        while (polygon = neighbors.pop()) {
          component.push(polygon);
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function(polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: components.map(function(polygons) {
        var arcs = [];

        // Extract the exterior (unique) arcs.
        polygons.forEach(function(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitchArcs(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // this exterior ring has the same winding order
        // as any exterior ring in the original polygons.
        if ((n = arcs.length) > 1) {
          var sgn = exterior(polygons[0][0]);
          for (var i = 0, t; i < n; ++i) {
            if (sgn === exterior(arcs[i])) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
              break;
            }
          }
        }

        return arcs;
      })
    };
  }

  function featureOrCollection(topology, o) {
    return o.type === "GeometryCollection" ? {
      type: "FeatureCollection",
      features: o.geometries.map(function(o) { return feature(topology, o); })
    } : feature(topology, o);
  }

  function feature(topology, o) {
    var f = {
      type: "Feature",
      id: o.id,
      properties: o.properties || {},
      geometry: object(topology, o)
    };
    if (o.id == null) delete f.id;
    return f;
  }

  function object(topology, o) {
    var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
        points.push(p = a[k].slice());
        absolute(p, k);
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      p = p.slice();
      absolute(p, 0);
      return p;
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0].slice());
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0].slice());
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var t = o.type;
      return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
          : null;
    }

    var geometryType = {
      Point: function(o) { return point(o.coordinates); },
      MultiPoint: function(o) { return o.coordinates.map(point); },
      LineString: function(o) { return line(o.arcs); },
      MultiLineString: function(o) { return o.arcs.map(line); },
      Polygon: function(o) { return polygon(o.arcs); },
      MultiPolygon: function(o) { return o.arcs.map(polygon); }
    };

    return geometry(o);
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function bisect(a, x) {
    var lo = 0, hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() { return []; });

    function line(arcs, i) {
      arcs.forEach(function(a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);
        else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function(arc) { line(arc, i); });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j], ik = indexes[k], n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function presimplify(topology, triangleArea) {
    var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

    if (!triangleArea) triangleArea = cartesianTriangleArea;

    topology.arcs.forEach(function(arc) {
      var triangles = [],
          maxArea = 0,
          triangle;

      // To store each points effective area, we create a new array rather than
      // extending the passed-in point to workaround a Chrome/V8 bug (getting
      // stuck in smi mode). For midpoints, the initial effective area of
      // Infinity will be computed in the next step.
      for (var i = 0, n = arc.length, p; i < n; ++i) {
        p = arc[i];
        absolute(arc[i] = [p[0], p[1], Infinity], i);
      }

      for (var i = 1, n = arc.length - 1; i < n; ++i) {
        triangle = arc.slice(i - 1, i + 2);
        triangle[1][2] = triangleArea(triangle);
        triangles.push(triangle);
        heap.push(triangle);
      }

      for (var i = 0, n = triangles.length; i < n; ++i) {
        triangle = triangles[i];
        triangle.previous = triangles[i - 1];
        triangle.next = triangles[i + 1];
      }

      while (triangle = heap.pop()) {
        var previous = triangle.previous,
            next = triangle.next;

        // If the area of the current point is less than that of the previous point
        // to be eliminated, use the latter's area instead. This ensures that the
        // current point cannot be eliminated without eliminating previously-
        // eliminated points.
        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
        else maxArea = triangle[1][2];

        if (previous) {
          previous.next = next;
          previous[2] = triangle[2];
          update(previous);
        }

        if (next) {
          next.previous = previous;
          next[0] = triangle[0];
          update(next);
        }
      }

      arc.forEach(relative);
    });

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = triangleArea(triangle);
      heap.push(triangle);
    }

    return topology;
  };

  function cartesianRingArea(ring) {
    var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = ring[i];
      area += a[0] * b[1] - a[1] * b[0];
    }

    return area * .5;
  }

  function cartesianTriangleArea(triangle) {
    var a = triangle[0], b = triangle[1], c = triangle[2];
    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
  }

  function compareArea(a, b) {
    return a[1][2] - b[1][2];
  }

  function minAreaHeap() {
    var heap = {},
        array = [],
        size = 0;

    heap.push = function(object) {
      up(array[object._ = size] = object, size++);
      return size;
    };

    heap.pop = function() {
      if (size <= 0) return;
      var removed = array[0], object;
      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
      return removed;
    };

    heap.remove = function(removed) {
      var i = removed._, object;
      if (array[i] !== removed) return; // invalid request
      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
      return i;
    };

    function up(object, i) {
      while (i > 0) {
        var j = ((i + 1) >> 1) - 1,
            parent = array[j];
        if (compareArea(object, parent) >= 0) break;
        array[parent._ = i] = parent;
        array[object._ = i = j] = object;
      }
    }

    function down(object, i) {
      while (true) {
        var r = (i + 1) << 1,
            l = r - 1,
            j = i,
            child = array[j];
        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
        if (j === i) break;
        array[child._ = i] = child;
        array[object._ = i = j] = object;
      }
    }

    return heap;
  }

  function transformAbsolute(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      point[0] = (x0 += point[0]) * kx + dx;
      point[1] = (y0 += point[1]) * ky + dy;
    };
  }

  function transformRelative(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
      point[0] = x1 - x0;
      point[1] = y1 - y0;
      x0 = x1;
      y0 = y1;
    };
  }

  function noop() {}

  if (typeof define === "function" && define.amd) define(topojson);
  else if (typeof module === "object" && module.exports) module.exports = topojson;
  else this.topojson = topojson;
}();
},{}],596:[function(require,module,exports){
/**
  @license
  when.js - https://github.com/cujojs/when

  MIT License (c) copyright B Cavalier & J Hann

 * A lightweight CommonJS Promises/A and when() implementation
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @version 1.7.1
 */

(function(define) { 'use strict';
define(function () {
	var reduceArray, slice, undef;

	//
	// Public API
	//

	when.defer     = defer;     // Create a deferred
	when.resolve   = resolve;   // Create a resolved promise
	when.reject    = reject;    // Create a rejected promise

	when.join      = join;      // Join 2 or more promises

	when.all       = all;       // Resolve a list of promises
	when.map       = map;       // Array.map() for promises
	when.reduce    = reduce;    // Array.reduce() for promises

	when.any       = any;       // One-winner race
	when.some      = some;      // Multi-winner race

	when.chain     = chain;     // Make a promise trigger another resolver

	when.isPromise = isPromise; // Determine if a thing is a promise

	/**
	 * Register an observer for a promise or immediate value.
	 *
	 * @param {*} promiseOrValue
	 * @param {function?} [onFulfilled] callback to be called when promiseOrValue is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} [onRejected] callback to be called when promiseOrValue is
	 *   rejected.
	 * @param {function?} [onProgress] callback to be called when progress updates
	 *   are issued for promiseOrValue.
	 * @returns {Promise} a new {@link Promise} that will complete with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(promiseOrValue, onFulfilled, onRejected, onProgress) {
		// Get a trusted promise for the input promiseOrValue, and then
		// register promise handlers
		return resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
	 * promiseOrValue is a foreign promise, or a new, already-fulfilled {@link Promise}
	 * whose value is promiseOrValue if promiseOrValue is an immediate value.
	 *
	 * @param {*} promiseOrValue
	 * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
	 *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
	 *   whose resolution value is:
	 *   * the resolution value of promiseOrValue if it's a foreign promise, or
	 *   * promiseOrValue if it's a value
	 */
	function resolve(promiseOrValue) {
		var promise, deferred;

		if(promiseOrValue instanceof Promise) {
			// It's a when.js promise, so we trust it
			promise = promiseOrValue;

		} else {
			// It's not a when.js promise. See if it's a foreign promise or a value.
			if(isPromise(promiseOrValue)) {
				// It's a thenable, but we don't know where it came from, so don't trust
				// its implementation entirely.  Introduce a trusted middleman when.js promise
				deferred = defer();

				// IMPORTANT: This is the only place when.js should ever call .then() on an
				// untrusted promise. Don't expose the return value to the untrusted promise
				promiseOrValue.then(
					function(value)  { deferred.resolve(value); },
					function(reason) { deferred.reject(reason); },
					function(update) { deferred.progress(update); }
				);

				promise = deferred.promise;

			} else {
				// It's a value, not a promise.  Create a resolved promise for it.
				promise = fulfilled(promiseOrValue);
			}
		}

		return promise;
	}

	/**
	 * Returns a rejected promise for the supplied promiseOrValue.  The returned
	 * promise will be rejected with:
	 * - promiseOrValue, if it is a value, or
	 * - if promiseOrValue is a promise
	 *   - promiseOrValue's value after it is fulfilled
	 *   - promiseOrValue's reason after it is rejected
	 * @param {*} promiseOrValue the rejected value of the returned {@link Promise}
	 * @returns {Promise} rejected {@link Promise}
	 */
	function reject(promiseOrValue) {
		return when(promiseOrValue, rejected);
	}

	/**
	 * Trusted Promise constructor.  A Promise created from this constructor is
	 * a trusted when.js promise.  Any other duck-typed promise is considered
	 * untrusted.
	 * @constructor
	 * @name Promise
	 */
	function Promise(then) {
		this.then = then;
	}

	Promise.prototype = {
		/**
		 * Register a callback that will be called when a promise is
		 * fulfilled or rejected.  Optionally also register a progress handler.
		 * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress)
		 * @param {function?} [onFulfilledOrRejected]
		 * @param {function?} [onProgress]
		 * @returns {Promise}
		 */
		always: function(onFulfilledOrRejected, onProgress) {
			return this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);
		},

		/**
		 * Register a rejection handler.  Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @returns {Promise}
		 */
		otherwise: function(onRejected) {
			return this.then(undef, onRejected);
		},

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @returns {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		yield: function(value) {
			return this.then(function() {
				return value;
			});
		},

		/**
		 * Assumes that this promise will fulfill with an array, and arranges
		 * for the onFulfilled to be called with the array as its argument list
		 * i.e. onFulfilled.spread(undefined, array).
		 * @param {function} onFulfilled function to receive spread arguments
		 * @returns {Promise}
		 */
		spread: function(onFulfilled) {
			return this.then(function(array) {
				// array may contain promises, so resolve its contents.
				return all(array, function(array) {
					return onFulfilled.apply(undef, array);
				});
			});
		}
	};

	/**
	 * Create an already-resolved promise for the supplied value
	 * @private
	 *
	 * @param {*} value
	 * @returns {Promise} fulfilled promise
	 */
	function fulfilled(value) {
		var p = new Promise(function(onFulfilled) {
			// TODO: Promises/A+ check typeof onFulfilled
			try {
				return resolve(onFulfilled ? onFulfilled(value) : value);
			} catch(e) {
				return rejected(e);
			}
		});

		return p;
	}

	/**
	 * Create an already-rejected {@link Promise} with the supplied
	 * rejection reason.
	 * @private
	 *
	 * @param {*} reason
	 * @returns {Promise} rejected promise
	 */
	function rejected(reason) {
		var p = new Promise(function(_, onRejected) {
			// TODO: Promises/A+ check typeof onRejected
			try {
				return onRejected ? resolve(onRejected(reason)) : rejected(reason);
			} catch(e) {
				return rejected(e);
			}
		});

		return p;
	}

	/**
	 * Creates a new, Deferred with fully isolated resolver and promise parts,
	 * either or both of which may be given out safely to consumers.
	 * The Deferred itself has the full API: resolve, reject, progress, and
	 * then. The resolver has resolve, reject, and progress.  The promise
	 * only has then.
	 *
	 * @returns {Deferred}
	 */
	function defer() {
		var deferred, promise, handlers, progressHandlers,
			_then, _progress, _resolve;

		/**
		 * The promise for the new deferred
		 * @type {Promise}
		 */
		promise = new Promise(then);

		/**
		 * The full Deferred object, with {@link Promise} and {@link Resolver} parts
		 * @class Deferred
		 * @name Deferred
		 */
		deferred = {
			then:     then, // DEPRECATED: use deferred.promise.then
			resolve:  promiseResolve,
			reject:   promiseReject,
			// TODO: Consider renaming progress() to notify()
			progress: promiseProgress,

			promise:  promise,

			resolver: {
				resolve:  promiseResolve,
				reject:   promiseReject,
				progress: promiseProgress
			}
		};

		handlers = [];
		progressHandlers = [];

		/**
		 * Pre-resolution then() that adds the supplied callback, errback, and progback
		 * functions to the registered listeners
		 * @private
		 *
		 * @param {function?} [onFulfilled] resolution handler
		 * @param {function?} [onRejected] rejection handler
		 * @param {function?} [onProgress] progress handler
		 */
		_then = function(onFulfilled, onRejected, onProgress) {
			// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
			var deferred, progressHandler;

			deferred = defer();

			progressHandler = typeof onProgress === 'function'
				? function(update) {
					try {
						// Allow progress handler to transform progress event
						deferred.progress(onProgress(update));
					} catch(e) {
						// Use caught value as progress
						deferred.progress(e);
					}
				}
				: function(update) { deferred.progress(update); };

			handlers.push(function(promise) {
				promise.then(onFulfilled, onRejected)
					.then(deferred.resolve, deferred.reject, progressHandler);
			});

			progressHandlers.push(progressHandler);

			return deferred.promise;
		};

		/**
		 * Issue a progress event, notifying all progress listeners
		 * @private
		 * @param {*} update progress event payload to pass to all listeners
		 */
		_progress = function(update) {
			processQueue(progressHandlers, update);
			return update;
		};

		/**
		 * Transition from pre-resolution state to post-resolution state, notifying
		 * all listeners of the resolution or rejection
		 * @private
		 * @param {*} value the value of this deferred
		 */
		_resolve = function(value) {
			value = resolve(value);

			// Replace _then with one that directly notifies with the result.
			_then = value.then;
			// Replace _resolve so that this Deferred can only be resolved once
			_resolve = resolve;
			// Make _progress a noop, to disallow progress for the resolved promise.
			_progress = noop;

			// Notify handlers
			processQueue(handlers, value);

			// Free progressHandlers array since we'll never issue progress events
			progressHandlers = handlers = undef;

			return value;
		};

		return deferred;

		/**
		 * Wrapper to allow _then to be replaced safely
		 * @param {function?} [onFulfilled] resolution handler
		 * @param {function?} [onRejected] rejection handler
		 * @param {function?} [onProgress] progress handler
		 * @returns {Promise} new promise
		 */
		function then(onFulfilled, onRejected, onProgress) {
			// TODO: Promises/A+ check typeof onFulfilled, onRejected, onProgress
			return _then(onFulfilled, onRejected, onProgress);
		}

		/**
		 * Wrapper to allow _resolve to be replaced
		 */
		function promiseResolve(val) {
			return _resolve(val);
		}

		/**
		 * Wrapper to allow _reject to be replaced
		 */
		function promiseReject(err) {
			return _resolve(rejected(err));
		}

		/**
		 * Wrapper to allow _progress to be replaced
		 */
		function promiseProgress(update) {
			return _progress(update);
		}
	}

	/**
	 * Determines if promiseOrValue is a promise or not.  Uses the feature
	 * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
	 * promiseOrValue is a promise.
	 *
	 * @param {*} promiseOrValue anything
	 * @returns {boolean} true if promiseOrValue is a {@link Promise}
	 */
	function isPromise(promiseOrValue) {
		return promiseOrValue && typeof promiseOrValue.then === 'function';
	}

	/**
	 * Initiates a competitive race, returning a promise that will resolve when
	 * howMany of the supplied promisesOrValues have resolved, or will reject when
	 * it becomes impossible for howMany to resolve, for example, when
	 * (promisesOrValues.length - howMany) + 1 input promises reject.
	 *
	 * @param {Array} promisesOrValues array of anything, may contain a mix
	 *      of promises and values
	 * @param howMany {number} number of promisesOrValues to resolve
	 * @param {function?} [onFulfilled] resolution handler
	 * @param {function?} [onRejected] rejection handler
	 * @param {function?} [onProgress] progress handler
	 * @returns {Promise} promise that will resolve to an array of howMany values that
	 * resolved first, or will reject with an array of (promisesOrValues.length - howMany) + 1
	 * rejection reasons.
	 */
	function some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {

		checkCallbacks(2, arguments);

		return when(promisesOrValues, function(promisesOrValues) {

			var toResolve, toReject, values, reasons, deferred, fulfillOne, rejectOne, progress, len, i;

			len = promisesOrValues.length >>> 0;

			toResolve = Math.max(0, Math.min(howMany, len));
			values = [];

			toReject = (len - toResolve) + 1;
			reasons = [];

			deferred = defer();

			// No items in the input, resolve immediately
			if (!toResolve) {
				deferred.resolve(values);

			} else {
				progress = deferred.progress;

				rejectOne = function(reason) {
					reasons.push(reason);
					if(!--toReject) {
						fulfillOne = rejectOne = noop;
						deferred.reject(reasons);
					}
				};

				fulfillOne = function(val) {
					// This orders the values based on promise resolution order
					// Another strategy would be to use the original position of
					// the corresponding promise.
					values.push(val);

					if (!--toResolve) {
						fulfillOne = rejectOne = noop;
						deferred.resolve(values);
					}
				};

				for(i = 0; i < len; ++i) {
					if(i in promisesOrValues) {
						when(promisesOrValues[i], fulfiller, rejecter, progress);
					}
				}
			}

			return deferred.then(onFulfilled, onRejected, onProgress);

			function rejecter(reason) {
				rejectOne(reason);
			}

			function fulfiller(val) {
				fulfillOne(val);
			}

		});
	}

	/**
	 * Initiates a competitive race, returning a promise that will resolve when
	 * any one of the supplied promisesOrValues has resolved or will reject when
	 * *all* promisesOrValues have rejected.
	 *
	 * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param {function?} [onFulfilled] resolution handler
	 * @param {function?} [onRejected] rejection handler
	 * @param {function?} [onProgress] progress handler
	 * @returns {Promise} promise that will resolve to the value that resolved first, or
	 * will reject with an array of all rejected inputs.
	 */
	function any(promisesOrValues, onFulfilled, onRejected, onProgress) {

		function unwrapSingleResult(val) {
			return onFulfilled ? onFulfilled(val[0]) : val[0];
		}

		return some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);
	}

	/**
	 * Return a promise that will resolve only once all the supplied promisesOrValues
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the promisesOrValues.
	 * @memberOf when
	 *
	 * @param {Array|Promise} promisesOrValues array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param {function?} [onFulfilled] resolution handler
	 * @param {function?} [onRejected] rejection handler
	 * @param {function?} [onProgress] progress handler
	 * @returns {Promise}
	 */
	function all(promisesOrValues, onFulfilled, onRejected, onProgress) {
		checkCallbacks(1, arguments);
		return map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Joins multiple promises into a single returned promise.
	 * @returns {Promise} a promise that will fulfill when *all* the input promises
	 * have fulfilled, or will reject when *any one* of the input promises rejects.
	 */
	function join(/* ...promises */) {
		return map(arguments, identity);
	}

	/**
	 * Traditional map function, similar to `Array.prototype.map()`, but allows
	 * input to contain {@link Promise}s and/or values, and mapFunc may return
	 * either a value or a {@link Promise}
	 *
	 * @param {Array|Promise} promise array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param {function} mapFunc mapping function mapFunc(value) which may return
	 *      either a {@link Promise} or value
	 * @returns {Promise} a {@link Promise} that will resolve to an array containing
	 *      the mapped output values.
	 */
	function map(promise, mapFunc) {
		return when(promise, function(array) {
			var results, len, toResolve, resolve, i, d;

			// Since we know the resulting length, we can preallocate the results
			// array to avoid array expansions.
			toResolve = len = array.length >>> 0;
			results = [];
			d = defer();

			if(!toResolve) {
				d.resolve(results);
			} else {

				resolve = function resolveOne(item, i) {
					when(item, mapFunc).then(function(mapped) {
						results[i] = mapped;

						if(!--toResolve) {
							d.resolve(results);
						}
					}, d.reject);
				};

				// Since mapFunc may be async, get all invocations of it into flight
				for(i = 0; i < len; i++) {
					if(i in array) {
						resolve(array[i], i);
					} else {
						--toResolve;
					}
				}

			}

			return d.promise;

		});
	}

	/**
	 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
	 * input may contain promises and/or values, and reduceFunc
	 * may return either a value or a promise, *and* initialValue may
	 * be a promise for the starting value.
	 *
	 * @param {Array|Promise} promise array or promise for an array of anything,
	 *      may contain a mix of promises and values.
	 * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),
	 *      where total is the total number of items being reduced, and will be the same
	 *      in each call to reduceFunc.
	 * @returns {Promise} that will resolve to the final reduced value
	 */
	function reduce(promise, reduceFunc /*, initialValue */) {
		var args = slice.call(arguments, 1);

		return when(promise, function(array) {
			var total;

			total = array.length;

			// Wrap the supplied reduceFunc with one that handles promises and then
			// delegates to the supplied.
			args[0] = function (current, val, i) {
				return when(current, function (c) {
					return when(val, function (value) {
						return reduceFunc(c, value, i, total);
					});
				});
			};

			return reduceArray.apply(array, args);
		});
	}

	/**
	 * Ensure that resolution of promiseOrValue will trigger resolver with the
	 * value or reason of promiseOrValue, or instead with resolveValue if it is provided.
	 *
	 * @param promiseOrValue
	 * @param {Object} resolver
	 * @param {function} resolver.resolve
	 * @param {function} resolver.reject
	 * @param {*} [resolveValue]
	 * @returns {Promise}
	 */
	function chain(promiseOrValue, resolver, resolveValue) {
		var useResolveValue = arguments.length > 2;

		return when(promiseOrValue,
			function(val) {
				val = useResolveValue ? resolveValue : val;
				resolver.resolve(val);
				return val;
			},
			function(reason) {
				resolver.reject(reason);
				return rejected(reason);
			},
			resolver.progress
		);
	}

	//
	// Utility functions
	//

	/**
	 * Apply all functions in queue to value
	 * @param {Array} queue array of functions to execute
	 * @param {*} value argument passed to each function
	 */
	function processQueue(queue, value) {
		var handler, i = 0;

		while (handler = queue[i++]) {
			handler(value);
		}
	}

	/**
	 * Helper that checks arrayOfCallbacks to ensure that each element is either
	 * a function, or null or undefined.
	 * @private
	 * @param {number} start index at which to start checking items in arrayOfCallbacks
	 * @param {Array} arrayOfCallbacks array to check
	 * @throws {Error} if any element of arrayOfCallbacks is something other than
	 * a functions, null, or undefined.
	 */
	function checkCallbacks(start, arrayOfCallbacks) {
		// TODO: Promises/A+ update type checking and docs
		var arg, i = arrayOfCallbacks.length;

		while(i > start) {
			arg = arrayOfCallbacks[--i];

			if (arg != null && typeof arg != 'function') {
				throw new Error('arg '+i+' must be a function');
			}
		}
	}

	/**
	 * No-Op function used in method replacement
	 * @private
	 */
	function noop() {}

	slice = [].slice;

	// ES5 reduce implementation if native not available
	// See: http://es5.github.com/#x15.4.4.21 as there are many
	// specifics and edge cases.
	reduceArray = [].reduce ||
		function(reduceFunc /*, initialValue */) {
			/*jshint maxcomplexity: 7*/

			// ES5 dictates that reduce.length === 1

			// This implementation deviates from ES5 spec in the following ways:
			// 1. It does not check if reduceFunc is a Callable

			var arr, args, reduced, len, i;

			i = 0;
			// This generates a jshint warning, despite being valid
			// "Missing 'new' prefix when invoking a constructor."
			// See https://github.com/jshint/jshint/issues/392
			arr = Object(this);
			len = arr.length >>> 0;
			args = arguments;

			// If no initialValue, use first item of array (we know length !== 0 here)
			// and adjust i to start at second item
			if(args.length <= 1) {
				// Skip to the first real element in the array
				for(;;) {
					if(i in arr) {
						reduced = arr[i++];
						break;
					}

					// If we reached the end of the array without finding any real
					// elements, it's a TypeError
					if(++i >= len) {
						throw new TypeError();
					}
				}
			} else {
				// If initialValue provided, use it
				reduced = args[1];
			}

			// Do the actual reduce
			for(;i < len; ++i) {
				// Skip holes
				if(i in arr) {
					reduced = reduceFunc(reduced, arr[i], i, arr);
				}
			}

			return reduced;
		};

	function identity(x) {
		return x;
	}

	return when;
});
})(typeof define == 'function' && define.amd
	? define
	: function (factory) { typeof exports === 'object'
		? (module.exports = factory())
		: (this.when      = factory());
	}
	// Boilerplate for AMD, Node, and browser global
);
},{}],597:[function(require,module,exports){
var buildModuleUrl = require('../Core/buildModuleUrl');
var tmp = {};
(function (obj) {
    var ERR_BAD_FORMAT = 'File format is not recognized.';
    var ERR_ENCRYPTED = 'File contains encrypted entry.';
    var ERR_ZIP64 = 'File is using Zip64 (4gb+ file size).';
    var ERR_READ = 'Error while reading zip file.';
    var ERR_WRITE = 'Error while writing zip file.';
    var ERR_WRITE_DATA = 'Error while writing file data.';
    var ERR_READ_DATA = 'Error while reading file data.';
    var ERR_DUPLICATED_NAME = 'File already exists.';
    var CHUNK_SIZE = 512 * 1024;
    var INFLATE_JS = 'inflate.js';
    var DEFLATE_JS = 'deflate.js';
    var TEXT_PLAIN = 'text/plain';
    var MESSAGE_EVENT = 'message';
    var appendABViewSupported;
    try {
        appendABViewSupported = new Blob([new DataView(new ArrayBuffer(0))]).size === 0;
    } catch (e) {
    }
    function Crc32() {
        var crc = -1, that = this;
        that.append = function (data) {
            var offset, table = that.table;
            for (offset = 0; offset < data.length; offset++)
                crc = crc >>> 8 ^ table[(crc ^ data[offset]) & 255];
        };
        that.get = function () {
            return ~crc;
        };
    }
    Crc32.prototype.table = function () {
        var i, j, t, table = [];
        for (i = 0; i < 256; i++) {
            t = i;
            for (j = 0; j < 8; j++)
                if (t & 1)
                    t = t >>> 1 ^ 3988292384;
                else
                    t = t >>> 1;
            table[i] = t;
        }
        return table;
    }();
    function blobSlice(blob, index, length) {
        if (blob.slice)
            return blob.slice(index, index + length);
        else if (blob.webkitSlice)
            return blob.webkitSlice(index, index + length);
        else if (blob.mozSlice)
            return blob.mozSlice(index, index + length);
        else if (blob.msSlice)
            return blob.msSlice(index, index + length);
    }
    function getDataHelper(byteLength, bytes) {
        var dataBuffer, dataArray;
        dataBuffer = new ArrayBuffer(byteLength);
        dataArray = new Uint8Array(dataBuffer);
        if (bytes)
            dataArray.set(bytes, 0);
        return {
            buffer: dataBuffer,
            array: dataArray,
            view: new DataView(dataBuffer)
        };
    }
    function Reader() {
    }
    function TextReader(text) {
        var that = this, blobReader;
        function init(callback, onerror) {
            var blob = new Blob([text], { type: TEXT_PLAIN });
            blobReader = new BlobReader(blob);
            blobReader.init(function () {
                that.size = blobReader.size;
                callback();
            }, onerror);
        }
        function readUint8Array(index, length, callback, onerror) {
            blobReader.readUint8Array(index, length, callback, onerror);
        }
        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    TextReader.prototype = new Reader();
    TextReader.prototype.constructor = TextReader;
    function Data64URIReader(dataURI) {
        var that = this, dataStart;
        function init(callback) {
            var dataEnd = dataURI.length;
            while (dataURI.charAt(dataEnd - 1) == '=')
                dataEnd--;
            dataStart = dataURI.indexOf(',') + 1;
            that.size = Math.floor((dataEnd - dataStart) * 0.75);
            callback();
        }
        function readUint8Array(index, length, callback) {
            var i, data = getDataHelper(length);
            var start = Math.floor(index / 3) * 4;
            var end = Math.ceil((index + length) / 3) * 4;
            var bytes = window.atob(dataURI.substring(start + dataStart, end + dataStart));
            var delta = index - Math.floor(start / 4) * 3;
            for (i = delta; i < delta + length; i++)
                data.array[i - delta] = bytes.charCodeAt(i);
            callback(data.array);
        }
        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    Data64URIReader.prototype = new Reader();
    Data64URIReader.prototype.constructor = Data64URIReader;
    function BlobReader(blob) {
        var that = this;
        function init(callback) {
            this.size = blob.size;
            callback();
        }
        function readUint8Array(index, length, callback, onerror) {
            var reader = new FileReader();
            reader.onload = function (e) {
                callback(new Uint8Array(e.target.result));
            };
            reader.onerror = onerror;
            reader.readAsArrayBuffer(blobSlice(blob, index, length));
        }
        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
    }
    BlobReader.prototype = new Reader();
    BlobReader.prototype.constructor = BlobReader;
    function Writer() {
    }
    Writer.prototype.getData = function (callback) {
        callback(this.data);
    };
    function TextWriter(encoding) {
        var that = this, blob;
        function init(callback) {
            blob = new Blob([], { type: TEXT_PLAIN });
            callback();
        }
        function writeUint8Array(array, callback) {
            blob = new Blob([
                blob,
                appendABViewSupported ? array : array.buffer
            ], { type: TEXT_PLAIN });
            callback();
        }
        function getData(callback, onerror) {
            var reader = new FileReader();
            reader.onload = function (e) {
                callback(e.target.result);
            };
            reader.onerror = onerror;
            reader.readAsText(blob, encoding);
        }
        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    TextWriter.prototype = new Writer();
    TextWriter.prototype.constructor = TextWriter;
    function Data64URIWriter(contentType) {
        var that = this, data = '', pending = '';
        function init(callback) {
            data += 'data:' + (contentType || '') + ';base64,';
            callback();
        }
        function writeUint8Array(array, callback) {
            var i, delta = pending.length, dataString = pending;
            pending = '';
            for (i = 0; i < Math.floor((delta + array.length) / 3) * 3 - delta; i++)
                dataString += String.fromCharCode(array[i]);
            for (; i < array.length; i++)
                pending += String.fromCharCode(array[i]);
            if (dataString.length > 2)
                data += window.btoa(dataString);
            else
                pending = dataString;
            callback();
        }
        function getData(callback) {
            callback(data + window.btoa(pending));
        }
        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    Data64URIWriter.prototype = new Writer();
    Data64URIWriter.prototype.constructor = Data64URIWriter;
    function BlobWriter(contentType) {
        var blob, that = this;
        function init(callback) {
            blob = new Blob([], { type: contentType });
            callback();
        }
        function writeUint8Array(array, callback) {
            blob = new Blob([
                blob,
                appendABViewSupported ? array : array.buffer
            ], { type: contentType });
            callback();
        }
        function getData(callback) {
            callback(blob);
        }
        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
    }
    BlobWriter.prototype = new Writer();
    BlobWriter.prototype.constructor = BlobWriter;
    function launchWorkerProcess(worker, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0, index, outputSize;
        function onflush() {
            worker.removeEventListener(MESSAGE_EVENT, onmessage, false);
            onend(outputSize);
        }
        function onmessage(event) {
            var message = event.data, data = message.data;
            if (message.onappend) {
                outputSize += data.length;
                writer.writeUint8Array(data, function () {
                    onappend(false, data);
                    step();
                }, onwriteerror);
            }
            if (message.onflush)
                if (data) {
                    outputSize += data.length;
                    writer.writeUint8Array(data, function () {
                        onappend(false, data);
                        onflush();
                    }, onwriteerror);
                } else
                    onflush();
            if (message.progress && onprogress)
                onprogress(index + message.current, size);
        }
        function step() {
            index = chunkIndex * CHUNK_SIZE;
            if (index < size)
                reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function (array) {
                    worker.postMessage({
                        append: true,
                        data: array
                    });
                    chunkIndex++;
                    if (onprogress)
                        onprogress(index, size);
                    onappend(true, array);
                }, onreaderror);
            else
                worker.postMessage({ flush: true });
        }
        outputSize = 0;
        worker.addEventListener(MESSAGE_EVENT, onmessage, false);
        step();
    }
    function launchProcess(process, reader, writer, offset, size, onappend, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0, index, outputSize = 0;
        function step() {
            var outputData;
            index = chunkIndex * CHUNK_SIZE;
            if (index < size)
                reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function (inputData) {
                    var outputData = process.append(inputData, function () {
                            if (onprogress)
                                onprogress(offset + index, size);
                        });
                    outputSize += outputData.length;
                    onappend(true, inputData);
                    writer.writeUint8Array(outputData, function () {
                        onappend(false, outputData);
                        chunkIndex++;
                        setTimeout(step, 1);
                    }, onwriteerror);
                    if (onprogress)
                        onprogress(index, size);
                }, onreaderror);
            else {
                outputData = process.flush();
                if (outputData) {
                    outputSize += outputData.length;
                    writer.writeUint8Array(outputData, function () {
                        onappend(false, outputData);
                        onend(outputSize);
                    }, onwriteerror);
                } else
                    onend(outputSize);
            }
        }
        step();
    }
    function inflate(reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var worker, crc32 = new Crc32();
        function oninflateappend(sending, array) {
            if (computeCrc32 && !sending)
                crc32.append(array);
        }
        function oninflateend(outputSize) {
            onend(outputSize, crc32.get());
        }
        if (obj.zip.useWebWorkers) {
            worker = new Worker(obj.zip.workerScriptsPath + INFLATE_JS);
            launchWorkerProcess(worker, reader, writer, offset, size, oninflateappend, onprogress, oninflateend, onreaderror, onwriteerror);
        } else
            launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, oninflateappend, onprogress, oninflateend, onreaderror, onwriteerror);
        return worker;
    }
    function deflate(reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
        var worker, crc32 = new Crc32();
        function ondeflateappend(sending, array) {
            if (sending)
                crc32.append(array);
        }
        function ondeflateend(outputSize) {
            onend(outputSize, crc32.get());
        }
        function onmessage() {
            worker.removeEventListener(MESSAGE_EVENT, onmessage, false);
            launchWorkerProcess(worker, reader, writer, 0, reader.size, ondeflateappend, onprogress, ondeflateend, onreaderror, onwriteerror);
        }
        if (obj.zip.useWebWorkers) {
            worker = new Worker(obj.zip.workerScriptsPath + DEFLATE_JS);
            worker.addEventListener(MESSAGE_EVENT, onmessage, false);
            worker.postMessage({
                init: true,
                level: level
            });
        } else
            launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, ondeflateappend, onprogress, ondeflateend, onreaderror, onwriteerror);
        return worker;
    }
    function copy(reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var chunkIndex = 0, crc32 = new Crc32();
        function step() {
            var index = chunkIndex * CHUNK_SIZE;
            if (index < size)
                reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function (array) {
                    if (computeCrc32)
                        crc32.append(array);
                    if (onprogress)
                        onprogress(index, size, array);
                    writer.writeUint8Array(array, function () {
                        chunkIndex++;
                        step();
                    }, onwriteerror);
                }, onreaderror);
            else
                onend(size, crc32.get());
        }
        step();
    }
    function decodeASCII(str) {
        var i, out = '', charCode, extendedASCII = [
                '\xc7',
                '\xfc',
                '\xe9',
                '\xe2',
                '\xe4',
                '\xe0',
                '\xe5',
                '\xe7',
                '\xea',
                '\xeb',
                '\xe8',
                '\xef',
                '\xee',
                '\xec',
                '\xc4',
                '\xc5',
                '\xc9',
                '\xe6',
                '\xc6',
                '\xf4',
                '\xf6',
                '\xf2',
                '\xfb',
                '\xf9',
                '\xff',
                '\xd6',
                '\xdc',
                '\xf8',
                '\xa3',
                '\xd8',
                '\xd7',
                '\u0192',
                '\xe1',
                '\xed',
                '\xf3',
                '\xfa',
                '\xf1',
                '\xd1',
                '\xaa',
                '\xba',
                '\xbf',
                '\xae',
                '\xac',
                '\xbd',
                '\xbc',
                '\xa1',
                '\xab',
                '\xbb',
                '_',
                '_',
                '_',
                '\xa6',
                '\xa6',
                '\xc1',
                '\xc2',
                '\xc0',
                '\xa9',
                '\xa6',
                '\xa6',
                '+',
                '+',
                '\xa2',
                '\xa5',
                '+',
                '+',
                '-',
                '-',
                '+',
                '-',
                '+',
                '\xe3',
                '\xc3',
                '+',
                '+',
                '-',
                '-',
                '\xa6',
                '-',
                '+',
                '\xa4',
                '\xf0',
                '\xd0',
                '\xca',
                '\xcb',
                '\xc8',
                'i',
                '\xcd',
                '\xce',
                '\xcf',
                '+',
                '+',
                '_',
                '_',
                '\xa6',
                '\xcc',
                '_',
                '\xd3',
                '\xdf',
                '\xd4',
                '\xd2',
                '\xf5',
                '\xd5',
                '\xb5',
                '\xfe',
                '\xde',
                '\xda',
                '\xdb',
                '\xd9',
                '\xfd',
                '\xdd',
                '\xaf',
                '\xb4',
                '\xad',
                '\xb1',
                '_',
                '\xbe',
                '\xb6',
                '\xa7',
                '\xf7',
                '\xb8',
                '\xb0',
                '\xa8',
                '\xb7',
                '\xb9',
                '\xb3',
                '\xb2',
                '_',
                ' '
            ];
        for (i = 0; i < str.length; i++) {
            charCode = str.charCodeAt(i) & 255;
            if (charCode > 127)
                out += extendedASCII[charCode - 128];
            else
                out += String.fromCharCode(charCode);
        }
        return out;
    }
    function decodeUTF8(string) {
        return decodeURIComponent(escape(string));
    }
    function getString(bytes) {
        var i, str = '';
        for (i = 0; i < bytes.length; i++)
            str += String.fromCharCode(bytes[i]);
        return str;
    }
    function getDate(timeRaw) {
        var date = (timeRaw & 4294901760) >> 16, time = timeRaw & 65535;
        try {
            return new Date(1980 + ((date & 65024) >> 9), ((date & 480) >> 5) - 1, date & 31, (time & 63488) >> 11, (time & 2016) >> 5, (time & 31) * 2, 0);
        } catch (e) {
        }
    }
    function readCommonHeader(entry, data, index, centralDirectory, onerror) {
        entry.version = data.view.getUint16(index, true);
        entry.bitFlag = data.view.getUint16(index + 2, true);
        entry.compressionMethod = data.view.getUint16(index + 4, true);
        entry.lastModDateRaw = data.view.getUint32(index + 6, true);
        entry.lastModDate = getDate(entry.lastModDateRaw);
        if ((entry.bitFlag & 1) === 1) {
            onerror(ERR_ENCRYPTED);
            return;
        }
        if (centralDirectory || (entry.bitFlag & 8) != 8) {
            entry.crc32 = data.view.getUint32(index + 10, true);
            entry.compressedSize = data.view.getUint32(index + 14, true);
            entry.uncompressedSize = data.view.getUint32(index + 18, true);
        }
        if (entry.compressedSize === 4294967295 || entry.uncompressedSize === 4294967295) {
            onerror(ERR_ZIP64);
            return;
        }
        entry.filenameLength = data.view.getUint16(index + 22, true);
        entry.extraFieldLength = data.view.getUint16(index + 24, true);
    }
    function createZipReader(reader, onerror) {
        function Entry() {
        }
        Entry.prototype.getData = function (writer, onend, onprogress, checkCrc32) {
            var that = this, worker;
            function terminate(callback, param) {
                if (worker)
                    worker.terminate();
                worker = null;
                if (callback)
                    callback(param);
            }
            function testCrc32(crc32) {
                var dataCrc32 = getDataHelper(4);
                dataCrc32.view.setUint32(0, crc32);
                return that.crc32 == dataCrc32.view.getUint32(0);
            }
            function getWriterData(uncompressedSize, crc32) {
                if (checkCrc32 && !testCrc32(crc32))
                    onreaderror();
                else
                    writer.getData(function (data) {
                        terminate(onend, data);
                    });
            }
            function onreaderror() {
                terminate(onerror, ERR_READ_DATA);
            }
            function onwriteerror() {
                terminate(onerror, ERR_WRITE_DATA);
            }
            reader.readUint8Array(that.offset, 30, function (bytes) {
                var data = getDataHelper(bytes.length, bytes), dataOffset;
                if (data.view.getUint32(0) != 1347093252) {
                    onerror(ERR_BAD_FORMAT);
                    return;
                }
                readCommonHeader(that, data, 4, false, onerror);
                dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
                writer.init(function () {
                    if (that.compressionMethod === 0)
                        copy(reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
                    else
                        worker = inflate(reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
                }, onwriteerror);
            }, onreaderror);
        };
        function seekEOCDR(offset, entriesCallback) {
            reader.readUint8Array(reader.size - offset, offset, function (bytes) {
                var dataView = getDataHelper(bytes.length, bytes).view;
                if (dataView.getUint32(0) != 1347093766) {
                    seekEOCDR(offset + 1, entriesCallback);
                } else {
                    entriesCallback(dataView);
                }
            }, function () {
                onerror(ERR_READ);
            });
        }
        return {
            getEntries: function (callback) {
                if (reader.size < 22) {
                    onerror(ERR_BAD_FORMAT);
                    return;
                }
                seekEOCDR(22, function (dataView) {
                    var datalength, fileslength;
                    datalength = dataView.getUint32(16, true);
                    fileslength = dataView.getUint16(8, true);
                    reader.readUint8Array(datalength, reader.size - datalength, function (bytes) {
                        var i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);
                        for (i = 0; i < fileslength; i++) {
                            entry = new Entry();
                            if (data.view.getUint32(index) != 1347092738) {
                                onerror(ERR_BAD_FORMAT);
                                return;
                            }
                            readCommonHeader(entry, data, index + 6, true, onerror);
                            entry.commentLength = data.view.getUint16(index + 32, true);
                            entry.directory = (data.view.getUint8(index + 38) & 16) == 16;
                            entry.offset = data.view.getUint32(index + 42, true);
                            filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
                            entry.filename = (entry.bitFlag & 2048) === 2048 ? decodeUTF8(filename) : decodeASCII(filename);
                            if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == '/')
                                entry.directory = true;
                            comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength));
                            entry.comment = (entry.bitFlag & 2048) === 2048 ? decodeUTF8(comment) : decodeASCII(comment);
                            entries.push(entry);
                            index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
                        }
                        callback(entries);
                    }, function () {
                        onerror(ERR_READ);
                    });
                });
            },
            close: function (callback) {
                if (callback)
                    callback();
            }
        };
    }
    function encodeUTF8(string) {
        return unescape(encodeURIComponent(string));
    }
    function getBytes(str) {
        var i, array = [];
        for (i = 0; i < str.length; i++)
            array.push(str.charCodeAt(i));
        return array;
    }
    function createZipWriter(writer, onerror, dontDeflate) {
        var worker, files = {}, filenames = [], datalength = 0;
        function terminate(callback, message) {
            if (worker)
                worker.terminate();
            worker = null;
            if (callback)
                callback(message);
        }
        function onwriteerror() {
            terminate(onerror, ERR_WRITE);
        }
        function onreaderror() {
            terminate(onerror, ERR_READ_DATA);
        }
        return {
            add: function (name, reader, onend, onprogress, options) {
                var header, filename, date;
                function writeHeader(callback) {
                    var data;
                    date = options.lastModDate || new Date();
                    header = getDataHelper(26);
                    files[name] = {
                        headerArray: header.array,
                        directory: options.directory,
                        filename: filename,
                        offset: datalength,
                        comment: getBytes(encodeUTF8(options.comment || ''))
                    };
                    header.view.setUint32(0, 335546376);
                    if (options.version)
                        header.view.setUint8(0, options.version);
                    if (!dontDeflate && options.level !== 0 && !options.directory)
                        header.view.setUint16(4, 2048);
                    header.view.setUint16(6, (date.getHours() << 6 | date.getMinutes()) << 5 | date.getSeconds() / 2, true);
                    header.view.setUint16(8, (date.getFullYear() - 1980 << 4 | date.getMonth() + 1) << 5 | date.getDate(), true);
                    header.view.setUint16(22, filename.length, true);
                    data = getDataHelper(30 + filename.length);
                    data.view.setUint32(0, 1347093252);
                    data.array.set(header.array, 4);
                    data.array.set(filename, 30);
                    datalength += data.array.length;
                    writer.writeUint8Array(data.array, callback, onwriteerror);
                }
                function writeFooter(compressedLength, crc32) {
                    var footer = getDataHelper(16);
                    datalength += compressedLength || 0;
                    footer.view.setUint32(0, 1347094280);
                    if (typeof crc32 != 'undefined') {
                        header.view.setUint32(10, crc32, true);
                        footer.view.setUint32(4, crc32, true);
                    }
                    if (reader) {
                        footer.view.setUint32(8, compressedLength, true);
                        header.view.setUint32(14, compressedLength, true);
                        footer.view.setUint32(12, reader.size, true);
                        header.view.setUint32(18, reader.size, true);
                    }
                    writer.writeUint8Array(footer.array, function () {
                        datalength += 16;
                        terminate(onend);
                    }, onwriteerror);
                }
                function writeFile() {
                    options = options || {};
                    name = name.trim();
                    if (options.directory && name.charAt(name.length - 1) != '/')
                        name += '/';
                    if (files.hasOwnProperty(name)) {
                        onerror(ERR_DUPLICATED_NAME);
                        return;
                    }
                    filename = getBytes(encodeUTF8(name));
                    filenames.push(name);
                    writeHeader(function () {
                        if (reader)
                            if (dontDeflate || options.level === 0)
                                copy(reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
                            else
                                worker = deflate(reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
                        else
                            writeFooter();
                    }, onwriteerror);
                }
                if (reader)
                    reader.init(writeFile, onreaderror);
                else
                    writeFile();
            },
            close: function (callback) {
                var data, length = 0, index = 0, indexFilename, file;
                for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
                    file = files[filenames[indexFilename]];
                    length += 46 + file.filename.length + file.comment.length;
                }
                data = getDataHelper(length + 22);
                for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
                    file = files[filenames[indexFilename]];
                    data.view.setUint32(index, 1347092738);
                    data.view.setUint16(index + 4, 5120);
                    data.array.set(file.headerArray, index + 6);
                    data.view.setUint16(index + 32, file.comment.length, true);
                    if (file.directory)
                        data.view.setUint8(index + 38, 16);
                    data.view.setUint32(index + 42, file.offset, true);
                    data.array.set(file.filename, index + 46);
                    data.array.set(file.comment, index + 46 + file.filename.length);
                    index += 46 + file.filename.length + file.comment.length;
                }
                data.view.setUint32(index, 1347093766);
                data.view.setUint16(index + 8, filenames.length, true);
                data.view.setUint16(index + 10, filenames.length, true);
                data.view.setUint32(index + 12, length, true);
                data.view.setUint32(index + 16, datalength, true);
                writer.writeUint8Array(data.array, function () {
                    terminate(function () {
                        writer.getData(callback);
                    });
                }, onwriteerror);
            }
        };
    }
    obj.zip = {
        Reader: Reader,
        Writer: Writer,
        BlobReader: BlobReader,
        Data64URIReader: Data64URIReader,
        TextReader: TextReader,
        BlobWriter: BlobWriter,
        Data64URIWriter: Data64URIWriter,
        TextWriter: TextWriter,
        createReader: function (reader, callback, onerror) {
            reader.init(function () {
                callback(createZipReader(reader, onerror));
            }, onerror);
        },
        createWriter: function (writer, callback, onerror, dontDeflate) {
            writer.init(function () {
                callback(createZipWriter(writer, onerror, dontDeflate));
            }, onerror);
        },
        workerScriptsPath: buildModuleUrl('ThirdParty/Workers/'),
        useWebWorkers: true
    };
}(tmp));
module.exports = tmp.zip;
},{"../Core/buildModuleUrl":239}],598:[function(require,module,exports){
var Color = require('../../Core/Color'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), getElement = require('../getElement'), subscribeAndEvaluate = require('../subscribeAndEvaluate');
'use strict';
var svgNS = 'http://www.w3.org/2000/svg';
var xlinkNS = 'http://www.w3.org/1999/xlink';
var widgetForDrag;
var gradientEnabledColor0 = Color.fromCssColorString('rgba(247,250,255,0.384)');
var gradientEnabledColor1 = Color.fromCssColorString('rgba(143,191,255,0.216)');
var gradientEnabledColor2 = Color.fromCssColorString('rgba(153,197,255,0.098)');
var gradientEnabledColor3 = Color.fromCssColorString('rgba(255,255,255,0.086)');
var gradientDisabledColor0 = Color.fromCssColorString('rgba(255,255,255,0.267)');
var gradientDisabledColor1 = Color.fromCssColorString('rgba(255,255,255,0)');
var gradientKnobColor = Color.fromCssColorString('rgba(66,67,68,0.3)');
var gradientPointerColor = Color.fromCssColorString('rgba(0,0,0,0.5)');
function getElementColor(element) {
    return Color.fromCssColorString(window.getComputedStyle(element).getPropertyValue('color'));
}
function svgFromObject(obj) {
    var ele = document.createElementNS(svgNS, obj.tagName);
    for (var field in obj) {
        if (obj.hasOwnProperty(field) && field !== 'tagName') {
            if (field === 'children') {
                var i;
                var len = obj.children.length;
                for (i = 0; i < len; ++i) {
                    ele.appendChild(svgFromObject(obj.children[i]));
                }
            } else if (field.indexOf('xlink:') === 0) {
                ele.setAttributeNS(xlinkNS, field.substring(6), obj[field]);
            } else if (field === 'textContent') {
                ele.textContent = obj[field];
            } else {
                ele.setAttribute(field, obj[field]);
            }
        }
    }
    return ele;
}
function svgText(x, y, msg) {
    var text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', y);
    text.setAttribute('class', 'cesium-animation-svgText');
    var tspan = document.createElementNS(svgNS, 'tspan');
    tspan.textContent = msg;
    text.appendChild(tspan);
    return text;
}
function setShuttleRingPointer(shuttleRingPointer, knobOuter, angle) {
    shuttleRingPointer.setAttribute('transform', 'translate(100,100) rotate(' + angle + ')');
    knobOuter.setAttribute('transform', 'rotate(' + angle + ')');
}
var makeColorStringScratch = new Color();
function makeColorString(background, gradient) {
    var gradientAlpha = gradient.alpha;
    var backgroundAlpha = 1 - gradientAlpha;
    makeColorStringScratch.red = background.red * backgroundAlpha + gradient.red * gradientAlpha;
    makeColorStringScratch.green = background.green * backgroundAlpha + gradient.green * gradientAlpha;
    makeColorStringScratch.blue = background.blue * backgroundAlpha + gradient.blue * gradientAlpha;
    return makeColorStringScratch.toCssColorString();
}
function rectButton(x, y, path) {
    var button = {
            tagName: 'g',
            'class': 'cesium-animation-rectButton',
            transform: 'translate(' + x + ',' + y + ')',
            children: [
                {
                    tagName: 'rect',
                    'class': 'cesium-animation-buttonGlow',
                    width: 32,
                    height: 32,
                    rx: 2,
                    ry: 2
                },
                {
                    tagName: 'rect',
                    'class': 'cesium-animation-buttonMain',
                    width: 32,
                    height: 32,
                    rx: 4,
                    ry: 4
                },
                {
                    tagName: 'use',
                    'class': 'cesium-animation-buttonPath',
                    'xlink:href': path
                },
                {
                    tagName: 'title',
                    textContent: ''
                }
            ]
        };
    return svgFromObject(button);
}
function wingButton(x, y, path) {
    var button = {
            tagName: 'g',
            'class': 'cesium-animation-rectButton',
            transform: 'translate(' + x + ',' + y + ')',
            children: [
                {
                    tagName: 'use',
                    'class': 'cesium-animation-buttonGlow',
                    'xlink:href': '#animation_pathWingButton'
                },
                {
                    tagName: 'use',
                    'class': 'cesium-animation-buttonMain',
                    'xlink:href': '#animation_pathWingButton'
                },
                {
                    tagName: 'use',
                    'class': 'cesium-animation-buttonPath',
                    'xlink:href': path
                },
                {
                    tagName: 'title',
                    textContent: ''
                }
            ]
        };
    return svgFromObject(button);
}
function setShuttleRingFromMouseOrTouch(widget, e) {
    var viewModel = widget._viewModel;
    var shuttleRingDragging = viewModel.shuttleRingDragging;
    if (shuttleRingDragging && widgetForDrag !== widget) {
        return;
    }
    if (e.type === 'mousedown' || shuttleRingDragging && e.type === 'mousemove' || e.type === 'touchstart' && e.touches.length === 1 || shuttleRingDragging && e.type === 'touchmove' && e.touches.length === 1) {
        var centerX = widget._centerX;
        var centerY = widget._centerY;
        var svg = widget._svgNode;
        var rect = svg.getBoundingClientRect();
        var clientX;
        var clientY;
        if (e.type === 'touchstart' || e.type === 'touchmove') {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        if (!shuttleRingDragging && (clientX > rect.right || clientX < rect.left || clientY < rect.top || clientY > rect.bottom)) {
            return;
        }
        var pointerRect = widget._shuttleRingPointer.getBoundingClientRect();
        var x = clientX - centerX - rect.left;
        var y = clientY - centerY - rect.top;
        var angle = Math.atan2(y, x) * 180 / Math.PI + 90;
        if (angle > 180) {
            angle -= 360;
        }
        var shuttleRingAngle = viewModel.shuttleRingAngle;
        if (shuttleRingDragging || clientX < pointerRect.right && clientX > pointerRect.left && clientY > pointerRect.top && clientY < pointerRect.bottom) {
            widgetForDrag = widget;
            viewModel.shuttleRingDragging = true;
            viewModel.shuttleRingAngle = angle;
        } else if (angle < shuttleRingAngle) {
            viewModel.slower();
        } else if (angle > shuttleRingAngle) {
            viewModel.faster();
        }
        e.preventDefault();
    } else {
        if (widget === widgetForDrag) {
            widgetForDrag = undefined;
        }
        viewModel.shuttleRingDragging = false;
    }
}
var SvgButton = function (svgElement, viewModel) {
    this._viewModel = viewModel;
    this.svgElement = svgElement;
    this._enabled = undefined;
    this._toggled = undefined;
    var that = this;
    this._clickFunction = function () {
        var command = that._viewModel.command;
        if (command.canExecute) {
            command();
        }
    };
    svgElement.addEventListener('click', this._clickFunction, true);
    this._subscriptions = [
        subscribeAndEvaluate(viewModel, 'toggled', this.setToggled, this),
        subscribeAndEvaluate(viewModel, 'tooltip', this.setTooltip, this),
        subscribeAndEvaluate(viewModel.command, 'canExecute', this.setEnabled, this)
    ];
};
SvgButton.prototype.destroy = function () {
    this.svgElement.removeEventListener('click', this._clickFunction, true);
    var subscriptions = this._subscriptions;
    for (var i = 0, len = subscriptions.length; i < len; i++) {
        subscriptions[i].dispose();
    }
    destroyObject(this);
};
SvgButton.prototype.isDestroyed = function () {
    return false;
};
SvgButton.prototype.setEnabled = function (enabled) {
    if (this._enabled !== enabled) {
        this._enabled = enabled;
        if (!enabled) {
            this.svgElement.setAttribute('class', 'cesium-animation-buttonDisabled');
            return;
        }
        if (this._toggled) {
            this.svgElement.setAttribute('class', 'cesium-animation-rectButton cesium-animation-buttonToggled');
            return;
        }
        this.svgElement.setAttribute('class', 'cesium-animation-rectButton');
    }
};
SvgButton.prototype.setToggled = function (toggled) {
    if (this._toggled !== toggled) {
        this._toggled = toggled;
        if (this._enabled) {
            if (toggled) {
                this.svgElement.setAttribute('class', 'cesium-animation-rectButton cesium-animation-buttonToggled');
            } else {
                this.svgElement.setAttribute('class', 'cesium-animation-rectButton');
            }
        }
    }
};
SvgButton.prototype.setTooltip = function (tooltip) {
    this.svgElement.getElementsByTagName('title')[0].textContent = tooltip;
};
var Animation = function (container, viewModel) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    if (!defined(viewModel)) {
        throw new DeveloperError('viewModel is required.');
    }
    container = getElement(container);
    this._viewModel = viewModel;
    this._container = container;
    this._centerX = 0;
    this._centerY = 0;
    this._defsElement = undefined;
    this._svgNode = undefined;
    this._topG = undefined;
    this._lastHeight = undefined;
    this._lastWidth = undefined;
    var cssStyle = document.createElement('style');
    cssStyle.textContent = '.cesium-animation-rectButton .cesium-animation-buttonGlow { filter: url(#animation_blurred); }.cesium-animation-rectButton .cesium-animation-buttonMain { fill: url(#animation_buttonNormal); }.cesium-animation-buttonToggled .cesium-animation-buttonMain { fill: url(#animation_buttonToggled); }.cesium-animation-rectButton:hover .cesium-animation-buttonMain { fill: url(#animation_buttonHovered); }.cesium-animation-buttonDisabled .cesium-animation-buttonMain { fill: url(#animation_buttonDisabled); }.cesium-animation-shuttleRingG .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshGradient); }.cesium-animation-shuttleRingG:hover .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshHovered); }.cesium-animation-shuttleRingPointer { fill: url(#animation_shuttleRingPointerGradient); }.cesium-animation-shuttleRingPausePointer { fill: url(#animation_shuttleRingPointerPaused); }.cesium-animation-knobOuter { fill: url(#animation_knobOuter); }.cesium-animation-knobInner { fill: url(#animation_knobInner); }';
    document.head.insertBefore(cssStyle, document.head.childNodes[0]);
    var themeEle = document.createElement('div');
    themeEle.className = 'cesium-animation-theme';
    themeEle.innerHTML = '<div class="cesium-animation-themeNormal"></div><div class="cesium-animation-themeHover"></div><div class="cesium-animation-themeSelect"></div><div class="cesium-animation-themeDisabled"></div><div class="cesium-animation-themeKnob"></div><div class="cesium-animation-themePointer"></div><div class="cesium-animation-themeSwoosh"></div><div class="cesium-animation-themeSwooshHover"></div>';
    this._theme = themeEle;
    this._themeNormal = themeEle.childNodes[0];
    this._themeHover = themeEle.childNodes[1];
    this._themeSelect = themeEle.childNodes[2];
    this._themeDisabled = themeEle.childNodes[3];
    this._themeKnob = themeEle.childNodes[4];
    this._themePointer = themeEle.childNodes[5];
    this._themeSwoosh = themeEle.childNodes[6];
    this._themeSwooshHover = themeEle.childNodes[7];
    var svg = document.createElementNS(svgNS, 'svg:svg');
    this._svgNode = svg;
    svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', xlinkNS);
    var topG = document.createElementNS(svgNS, 'g');
    this._topG = topG;
    this._realtimeSVG = new SvgButton(wingButton(3, 4, '#animation_pathClock'), viewModel.playRealtimeViewModel);
    this._playReverseSVG = new SvgButton(rectButton(44, 99, '#animation_pathPlayReverse'), viewModel.playReverseViewModel);
    this._playForwardSVG = new SvgButton(rectButton(124, 99, '#animation_pathPlay'), viewModel.playForwardViewModel);
    this._pauseSVG = new SvgButton(rectButton(84, 99, '#animation_pathPause'), viewModel.pauseViewModel);
    var buttonsG = document.createElementNS(svgNS, 'g');
    buttonsG.appendChild(this._realtimeSVG.svgElement);
    buttonsG.appendChild(this._playReverseSVG.svgElement);
    buttonsG.appendChild(this._playForwardSVG.svgElement);
    buttonsG.appendChild(this._pauseSVG.svgElement);
    var shuttleRingBackPanel = svgFromObject({
            tagName: 'circle',
            'class': 'cesium-animation-shuttleRingBack',
            cx: 100,
            cy: 100,
            r: 99
        });
    this._shuttleRingBackPanel = shuttleRingBackPanel;
    var shuttleRingSwooshG = svgFromObject({
            tagName: 'g',
            'class': 'cesium-animation-shuttleRingSwoosh',
            children: [
                {
                    tagName: 'use',
                    transform: 'translate(100,97) scale(-1,1)',
                    'xlink:href': '#animation_pathSwooshFX'
                },
                {
                    tagName: 'use',
                    transform: 'translate(100,97)',
                    'xlink:href': '#animation_pathSwooshFX'
                },
                {
                    tagName: 'line',
                    x1: 100,
                    y1: 8,
                    x2: 100,
                    y2: 22
                }
            ]
        });
    this._shuttleRingSwooshG = shuttleRingSwooshG;
    this._shuttleRingPointer = svgFromObject({
        tagName: 'use',
        'class': 'cesium-animation-shuttleRingPointer',
        'xlink:href': '#animation_pathPointer'
    });
    var knobG = svgFromObject({
            tagName: 'g',
            transform: 'translate(100,100)'
        });
    this._knobOuter = svgFromObject({
        tagName: 'circle',
        'class': 'cesium-animation-knobOuter',
        cx: 0,
        cy: 0,
        r: 71
    });
    var knobInnerAndShieldSize = 61;
    var knobInner = svgFromObject({
            tagName: 'circle',
            'class': 'cesium-animation-knobInner',
            cx: 0,
            cy: 0,
            r: knobInnerAndShieldSize
        });
    this._knobDate = svgText(0, -24, '');
    this._knobTime = svgText(0, -7, '');
    this._knobStatus = svgText(0, -41, '');
    var knobShield = svgFromObject({
            tagName: 'circle',
            'class': 'cesium-animation-blank',
            cx: 0,
            cy: 0,
            r: knobInnerAndShieldSize
        });
    var shuttleRingBackG = document.createElementNS(svgNS, 'g');
    shuttleRingBackG.setAttribute('class', 'cesium-animation-shuttleRingG');
    container.appendChild(themeEle);
    topG.appendChild(shuttleRingBackG);
    topG.appendChild(knobG);
    topG.appendChild(buttonsG);
    shuttleRingBackG.appendChild(shuttleRingBackPanel);
    shuttleRingBackG.appendChild(shuttleRingSwooshG);
    shuttleRingBackG.appendChild(this._shuttleRingPointer);
    knobG.appendChild(this._knobOuter);
    knobG.appendChild(knobInner);
    knobG.appendChild(this._knobDate);
    knobG.appendChild(this._knobTime);
    knobG.appendChild(this._knobStatus);
    knobG.appendChild(knobShield);
    svg.appendChild(topG);
    container.appendChild(svg);
    var that = this;
    var mouseCallback = function (e) {
        setShuttleRingFromMouseOrTouch(that, e);
    };
    this._mouseCallback = mouseCallback;
    shuttleRingBackPanel.addEventListener('mousedown', mouseCallback, true);
    shuttleRingBackPanel.addEventListener('touchstart', mouseCallback, true);
    shuttleRingSwooshG.addEventListener('mousedown', mouseCallback, true);
    shuttleRingSwooshG.addEventListener('touchstart', mouseCallback, true);
    document.addEventListener('mousemove', mouseCallback, true);
    document.addEventListener('touchmove', mouseCallback, true);
    document.addEventListener('mouseup', mouseCallback, true);
    document.addEventListener('touchend', mouseCallback, true);
    this._shuttleRingPointer.addEventListener('mousedown', mouseCallback, true);
    this._shuttleRingPointer.addEventListener('touchstart', mouseCallback, true);
    this._knobOuter.addEventListener('mousedown', mouseCallback, true);
    this._knobOuter.addEventListener('touchstart', mouseCallback, true);
    var timeNode = this._knobTime.childNodes[0];
    var dateNode = this._knobDate.childNodes[0];
    var statusNode = this._knobStatus.childNodes[0];
    var isPaused;
    this._subscriptions = [
        subscribeAndEvaluate(viewModel.pauseViewModel, 'toggled', function (value) {
            if (isPaused !== value) {
                isPaused = value;
                if (isPaused) {
                    that._shuttleRingPointer.setAttribute('class', 'cesium-animation-shuttleRingPausePointer');
                } else {
                    that._shuttleRingPointer.setAttribute('class', 'cesium-animation-shuttleRingPointer');
                }
            }
        }),
        subscribeAndEvaluate(viewModel, 'shuttleRingAngle', function (value) {
            setShuttleRingPointer(that._shuttleRingPointer, that._knobOuter, value);
        }),
        subscribeAndEvaluate(viewModel, 'dateLabel', function (value) {
            if (dateNode.textContent !== value) {
                dateNode.textContent = value;
            }
        }),
        subscribeAndEvaluate(viewModel, 'timeLabel', function (value) {
            if (timeNode.textContent !== value) {
                timeNode.textContent = value;
            }
        }),
        subscribeAndEvaluate(viewModel, 'multiplierLabel', function (value) {
            if (statusNode.textContent !== value) {
                statusNode.textContent = value;
            }
        })
    ];
    this.applyThemeChanges();
    this.resize();
};
defineProperties(Animation.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
Animation.prototype.isDestroyed = function () {
    return false;
};
Animation.prototype.destroy = function () {
    var mouseCallback = this._mouseCallback;
    this._shuttleRingBackPanel.removeEventListener('mousedown', mouseCallback, true);
    this._shuttleRingBackPanel.removeEventListener('touchstart', mouseCallback, true);
    this._shuttleRingSwooshG.removeEventListener('mousedown', mouseCallback, true);
    this._shuttleRingSwooshG.removeEventListener('touchstart', mouseCallback, true);
    document.removeEventListener('mousemove', mouseCallback, true);
    document.removeEventListener('touchmove', mouseCallback, true);
    document.removeEventListener('mouseup', mouseCallback, true);
    document.removeEventListener('touchend', mouseCallback, true);
    this._shuttleRingPointer.removeEventListener('mousedown', mouseCallback, true);
    this._shuttleRingPointer.removeEventListener('touchstart', mouseCallback, true);
    this._knobOuter.removeEventListener('mousedown', mouseCallback, true);
    this._knobOuter.removeEventListener('touchstart', mouseCallback, true);
    this._container.removeChild(this._svgNode);
    this._container.removeChild(this._theme);
    this._realtimeSVG.destroy();
    this._playReverseSVG.destroy();
    this._playForwardSVG.destroy();
    this._pauseSVG.destroy();
    var subscriptions = this._subscriptions;
    for (var i = 0, len = subscriptions.length; i < len; i++) {
        subscriptions[i].dispose();
    }
    return destroyObject(this);
};
Animation.prototype.resize = function () {
    var parentWidth = this._container.clientWidth;
    var parentHeight = this._container.clientHeight;
    if (parentWidth === this._lastWidth && parentHeight === this._lastHeight) {
        return;
    }
    var svg = this._svgNode;
    var baseWidth = 200;
    var baseHeight = 132;
    var width = parentWidth;
    var height = parentHeight;
    if (parentWidth === 0 && parentHeight === 0) {
        width = baseWidth;
        height = baseHeight;
    } else if (parentWidth === 0) {
        height = parentHeight;
        width = baseWidth * (parentHeight / baseHeight);
    } else if (parentHeight === 0) {
        width = parentWidth;
        height = baseHeight * (parentWidth / baseWidth);
    }
    var scaleX = width / baseWidth;
    var scaleY = height / baseHeight;
    svg.style.cssText = 'width: ' + width + 'px; height: ' + height + 'px; position: absolute; bottom: 0; left: 0; overflow: hidden;';
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', '0 0 ' + width + ' ' + height);
    this._topG.setAttribute('transform', 'scale(' + scaleX + ',' + scaleY + ')');
    this._centerX = Math.max(1, 100 * scaleX);
    this._centerY = Math.max(1, 100 * scaleY);
    this._lastHeight = parentWidth;
    this._lastWidth = parentHeight;
};
Animation.prototype.applyThemeChanges = function () {
    var buttonNormalBackColor = getElementColor(this._themeNormal);
    var buttonHoverBackColor = getElementColor(this._themeHover);
    var buttonToggledBackColor = getElementColor(this._themeSelect);
    var buttonDisabledBackColor = getElementColor(this._themeDisabled);
    var knobBackColor = getElementColor(this._themeKnob);
    var pointerColor = getElementColor(this._themePointer);
    var swooshColor = getElementColor(this._themeSwoosh);
    var swooshHoverColor = getElementColor(this._themeSwooshHover);
    var defsElement = svgFromObject({
            tagName: 'defs',
            children: [
                {
                    id: 'animation_buttonNormal',
                    tagName: 'linearGradient',
                    x1: '50%',
                    y1: '0%',
                    x2: '50%',
                    y2: '100%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '0%',
                            'stop-color': makeColorString(buttonNormalBackColor, gradientEnabledColor0)
                        },
                        {
                            tagName: 'stop',
                            offset: '12%',
                            'stop-color': makeColorString(buttonNormalBackColor, gradientEnabledColor1)
                        },
                        {
                            tagName: 'stop',
                            offset: '46%',
                            'stop-color': makeColorString(buttonNormalBackColor, gradientEnabledColor2)
                        },
                        {
                            tagName: 'stop',
                            offset: '81%',
                            'stop-color': makeColorString(buttonNormalBackColor, gradientEnabledColor3)
                        }
                    ]
                },
                {
                    id: 'animation_buttonHovered',
                    tagName: 'linearGradient',
                    x1: '50%',
                    y1: '0%',
                    x2: '50%',
                    y2: '100%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '0%',
                            'stop-color': makeColorString(buttonHoverBackColor, gradientEnabledColor0)
                        },
                        {
                            tagName: 'stop',
                            offset: '12%',
                            'stop-color': makeColorString(buttonHoverBackColor, gradientEnabledColor1)
                        },
                        {
                            tagName: 'stop',
                            offset: '46%',
                            'stop-color': makeColorString(buttonHoverBackColor, gradientEnabledColor2)
                        },
                        {
                            tagName: 'stop',
                            offset: '81%',
                            'stop-color': makeColorString(buttonHoverBackColor, gradientEnabledColor3)
                        }
                    ]
                },
                {
                    id: 'animation_buttonToggled',
                    tagName: 'linearGradient',
                    x1: '50%',
                    y1: '0%',
                    x2: '50%',
                    y2: '100%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '0%',
                            'stop-color': makeColorString(buttonToggledBackColor, gradientEnabledColor0)
                        },
                        {
                            tagName: 'stop',
                            offset: '12%',
                            'stop-color': makeColorString(buttonToggledBackColor, gradientEnabledColor1)
                        },
                        {
                            tagName: 'stop',
                            offset: '46%',
                            'stop-color': makeColorString(buttonToggledBackColor, gradientEnabledColor2)
                        },
                        {
                            tagName: 'stop',
                            offset: '81%',
                            'stop-color': makeColorString(buttonToggledBackColor, gradientEnabledColor3)
                        }
                    ]
                },
                {
                    id: 'animation_buttonDisabled',
                    tagName: 'linearGradient',
                    x1: '50%',
                    y1: '0%',
                    x2: '50%',
                    y2: '100%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '0%',
                            'stop-color': makeColorString(buttonDisabledBackColor, gradientDisabledColor0)
                        },
                        {
                            tagName: 'stop',
                            offset: '75%',
                            'stop-color': makeColorString(buttonDisabledBackColor, gradientDisabledColor1)
                        }
                    ]
                },
                {
                    id: 'animation_blurred',
                    tagName: 'filter',
                    width: '200%',
                    height: '200%',
                    x: '-50%',
                    y: '-50%',
                    children: [{
                            tagName: 'feGaussianBlur',
                            stdDeviation: 4,
                            'in': 'SourceGraphic'
                        }]
                },
                {
                    id: 'animation_shuttleRingSwooshGradient',
                    tagName: 'linearGradient',
                    x1: '50%',
                    y1: '0%',
                    x2: '50%',
                    y2: '100%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '0%',
                            'stop-opacity': 0.2,
                            'stop-color': swooshColor.toCssColorString()
                        },
                        {
                            tagName: 'stop',
                            offset: '85%',
                            'stop-opacity': 0.85,
                            'stop-color': swooshColor.toCssColorString()
                        },
                        {
                            tagName: 'stop',
                            offset: '95%',
                            'stop-opacity': 0.05,
                            'stop-color': swooshColor.toCssColorString()
                        }
                    ]
                },
                {
                    id: 'animation_shuttleRingSwooshHovered',
                    tagName: 'linearGradient',
                    x1: '50%',
                    y1: '0%',
                    x2: '50%',
                    y2: '100%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '0%',
                            'stop-opacity': 0.2,
                            'stop-color': swooshHoverColor.toCssColorString()
                        },
                        {
                            tagName: 'stop',
                            offset: '85%',
                            'stop-opacity': 0.85,
                            'stop-color': swooshHoverColor.toCssColorString()
                        },
                        {
                            tagName: 'stop',
                            offset: '95%',
                            'stop-opacity': 0.05,
                            'stop-color': swooshHoverColor.toCssColorString()
                        }
                    ]
                },
                {
                    id: 'animation_shuttleRingPointerGradient',
                    tagName: 'linearGradient',
                    x1: '0%',
                    y1: '50%',
                    x2: '100%',
                    y2: '50%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '0%',
                            'stop-color': pointerColor.toCssColorString()
                        },
                        {
                            tagName: 'stop',
                            offset: '40%',
                            'stop-color': pointerColor.toCssColorString()
                        },
                        {
                            tagName: 'stop',
                            offset: '60%',
                            'stop-color': makeColorString(pointerColor, gradientPointerColor)
                        },
                        {
                            tagName: 'stop',
                            offset: '100%',
                            'stop-color': makeColorString(pointerColor, gradientPointerColor)
                        }
                    ]
                },
                {
                    id: 'animation_shuttleRingPointerPaused',
                    tagName: 'linearGradient',
                    x1: '0%',
                    y1: '50%',
                    x2: '100%',
                    y2: '50%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '0%',
                            'stop-color': '#CCC'
                        },
                        {
                            tagName: 'stop',
                            offset: '40%',
                            'stop-color': '#CCC'
                        },
                        {
                            tagName: 'stop',
                            offset: '60%',
                            'stop-color': '#555'
                        },
                        {
                            tagName: 'stop',
                            offset: '100%',
                            'stop-color': '#555'
                        }
                    ]
                },
                {
                    id: 'animation_knobOuter',
                    tagName: 'linearGradient',
                    x1: '20%',
                    y1: '0%',
                    x2: '90%',
                    y2: '100%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '5%',
                            'stop-color': makeColorString(knobBackColor, gradientEnabledColor0)
                        },
                        {
                            tagName: 'stop',
                            offset: '60%',
                            'stop-color': makeColorString(knobBackColor, gradientKnobColor)
                        },
                        {
                            tagName: 'stop',
                            offset: '85%',
                            'stop-color': makeColorString(knobBackColor, gradientEnabledColor1)
                        }
                    ]
                },
                {
                    id: 'animation_knobInner',
                    tagName: 'linearGradient',
                    x1: '20%',
                    y1: '0%',
                    x2: '90%',
                    y2: '100%',
                    children: [
                        {
                            tagName: 'stop',
                            offset: '5%',
                            'stop-color': makeColorString(knobBackColor, gradientKnobColor)
                        },
                        {
                            tagName: 'stop',
                            offset: '60%',
                            'stop-color': makeColorString(knobBackColor, gradientEnabledColor0)
                        },
                        {
                            tagName: 'stop',
                            offset: '85%',
                            'stop-color': makeColorString(knobBackColor, gradientEnabledColor3)
                        }
                    ]
                },
                {
                    id: 'animation_pathReset',
                    tagName: 'path',
                    transform: 'translate(16,16) scale(0.85) translate(-16,-16)',
                    d: 'M24.316,5.318,9.833,13.682,9.833,5.5,5.5,5.5,5.5,25.5,9.833,25.5,9.833,17.318,24.316,25.682z'
                },
                {
                    id: 'animation_pathPause',
                    tagName: 'path',
                    transform: 'translate(16,16) scale(0.85) translate(-16,-16)',
                    d: 'M13,5.5,7.5,5.5,7.5,25.5,13,25.5zM24.5,5.5,19,5.5,19,25.5,24.5,25.5z'
                },
                {
                    id: 'animation_pathPlay',
                    tagName: 'path',
                    transform: 'translate(16,16) scale(0.85) translate(-16,-16)',
                    d: 'M6.684,25.682L24.316,15.5L6.684,5.318V25.682z'
                },
                {
                    id: 'animation_pathPlayReverse',
                    tagName: 'path',
                    transform: 'translate(16,16) scale(-0.85,0.85) translate(-16,-16)',
                    d: 'M6.684,25.682L24.316,15.5L6.684,5.318V25.682z'
                },
                {
                    id: 'animation_pathLoop',
                    tagName: 'path',
                    transform: 'translate(16,16) scale(0.85) translate(-16,-16)',
                    d: 'M24.249,15.499c-0.009,4.832-3.918,8.741-8.75,8.75c-2.515,0-4.768-1.064-6.365-2.763l2.068-1.442l-7.901-3.703l0.744,8.694l2.193-1.529c2.244,2.594,5.562,4.242,9.26,4.242c6.767,0,12.249-5.482,12.249-12.249H24.249zM15.499,6.75c2.516,0,4.769,1.065,6.367,2.764l-2.068,1.443l7.901,3.701l-0.746-8.693l-2.192,1.529c-2.245-2.594-5.562-4.245-9.262-4.245C8.734,3.25,3.25,8.734,3.249,15.499H6.75C6.758,10.668,10.668,6.758,15.499,6.75z'
                },
                {
                    id: 'animation_pathClock',
                    tagName: 'path',
                    transform: 'translate(16,16) scale(0.85) translate(-16,-15.5)',
                    d: 'M15.5,2.374C8.251,2.375,2.376,8.251,2.374,15.5C2.376,22.748,8.251,28.623,15.5,28.627c7.249-0.004,13.124-5.879,13.125-13.127C28.624,8.251,22.749,2.375,15.5,2.374zM15.5,25.623C9.909,25.615,5.385,21.09,5.375,15.5C5.385,9.909,9.909,5.384,15.5,5.374c5.59,0.01,10.115,4.535,10.124,10.125C25.615,21.09,21.091,25.615,15.5,25.623zM8.625,15.5c-0.001-0.552-0.448-0.999-1.001-1c-0.553,0-1,0.448-1,1c0,0.553,0.449,1,1,1C8.176,16.5,8.624,16.053,8.625,15.5zM8.179,18.572c-0.478,0.277-0.642,0.889-0.365,1.367c0.275,0.479,0.889,0.641,1.365,0.365c0.479-0.275,0.643-0.887,0.367-1.367C9.27,18.461,8.658,18.297,8.179,18.572zM9.18,10.696c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366c0.479,0.276,1.09,0.113,1.367-0.366C9.821,11.584,9.657,10.973,9.18,10.696zM22.822,12.428c0.478-0.275,0.643-0.888,0.366-1.366c-0.275-0.478-0.89-0.642-1.366-0.366c-0.479,0.278-0.642,0.89-0.366,1.367C21.732,12.54,22.344,12.705,22.822,12.428zM12.062,21.455c-0.478-0.275-1.089-0.111-1.366,0.367c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.277,1.091,0.111,1.365-0.365C12.704,22.344,12.54,21.732,12.062,21.455zM12.062,9.545c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,9.658,11.584,9.822,12.062,9.545zM22.823,18.572c-0.48-0.275-1.092-0.111-1.367,0.365c-0.275,0.479-0.112,1.092,0.367,1.367c0.477,0.275,1.089,0.113,1.365-0.365C23.464,19.461,23.3,18.848,22.823,18.572zM19.938,7.813c-0.477-0.276-1.091-0.111-1.365,0.366c-0.275,0.48-0.111,1.091,0.366,1.367s1.089,0.112,1.366-0.366C20.581,8.702,20.418,8.089,19.938,7.813zM23.378,14.5c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1c0.551,0,1-0.447,1-1C24.378,14.949,23.929,14.5,23.378,14.5zM15.501,6.624c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96c-0.478,0.277-0.642,0.889-0.365,1.365c0.275,0.479,0.889,0.643,1.365,0.367l3.305-1.676C15.39,16.99,15.444,17,15.501,17c0.828,0,1.5-0.671,1.5-1.5l-0.5-7.876C16.501,7.072,16.053,6.624,15.501,6.624zM15.501,22.377c-0.552,0-1,0.447-1,1s0.448,1,1,1s1-0.447,1-1S16.053,22.377,15.501,22.377zM18.939,21.455c-0.479,0.277-0.643,0.889-0.366,1.367c0.275,0.477,0.888,0.643,1.366,0.365c0.478-0.275,0.642-0.889,0.366-1.365C20.028,21.344,19.417,21.18,18.939,21.455z'
                },
                {
                    id: 'animation_pathWingButton',
                    tagName: 'path',
                    d: 'm 4.5,0.5 c -2.216,0 -4,1.784 -4,4 l 0,24 c 0,2.216 1.784,4 4,4 l 13.71875,0 C 22.478584,27.272785 27.273681,22.511272 32.5,18.25 l 0,-13.75 c 0,-2.216 -1.784,-4 -4,-4 l -24,0 z'
                },
                {
                    id: 'animation_pathPointer',
                    tagName: 'path',
                    d: 'M-15,-65,-15,-55,15,-55,15,-65,0,-95z'
                },
                {
                    id: 'animation_pathSwooshFX',
                    tagName: 'path',
                    d: 'm 85,0 c 0,16.617 -4.813944,35.356 -13.131081,48.4508 h 6.099803 c 8.317138,-13.0948 13.13322,-28.5955 13.13322,-45.2124 0,-46.94483 -38.402714,-85.00262 -85.7743869,-85.00262 -1.0218522,0 -2.0373001,0.0241 -3.0506131,0.0589 45.958443,1.59437 82.723058,35.77285 82.723058,81.70532 z'
                }
            ]
        });
    if (!defined(this._defsElement)) {
        this._svgNode.appendChild(defsElement);
    } else {
        this._svgNode.replaceChild(defsElement, this._defsElement);
    }
    this._defsElement = defsElement;
};
module.exports = Animation;
},{"../../Core/Color":111,"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../getElement":628,"../subscribeAndEvaluate":629}],599:[function(require,module,exports){
var binarySearch = require('../../Core/binarySearch'), ClockRange = require('../../Core/ClockRange'), ClockStep = require('../../Core/ClockStep'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), DeveloperError = require('../../Core/DeveloperError'), JulianDate = require('../../Core/JulianDate'), knockout = require('../../ThirdParty/knockout'), sprintf = require('../../ThirdParty/sprintf'), createCommand = require('../createCommand'), ToggleButtonViewModel = require('../ToggleButtonViewModel');
'use strict';
var monthNames = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
    ];
var realtimeShuttleRingAngle = 15;
var maxShuttleRingAngle = 105;
function cancelRealtime(clockViewModel) {
    if (clockViewModel.clockStep === ClockStep.SYSTEM_CLOCK) {
        clockViewModel.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
        clockViewModel.multiplier = 1;
    }
}
function unpause(clockViewModel) {
    cancelRealtime(clockViewModel);
    clockViewModel.shouldAnimate = true;
}
function numberComparator(left, right) {
    return left - right;
}
function getTypicalMultiplierIndex(multiplier, shuttleRingTicks) {
    var index = binarySearch(shuttleRingTicks, multiplier, numberComparator);
    return index < 0 ? ~index : index;
}
function angleToMultiplier(angle, shuttleRingTicks) {
    if (Math.abs(angle) <= realtimeShuttleRingAngle) {
        return angle / realtimeShuttleRingAngle;
    }
    var minp = realtimeShuttleRingAngle;
    var maxp = maxShuttleRingAngle;
    var maxv;
    var minv = 0;
    var scale;
    if (angle > 0) {
        maxv = Math.log(shuttleRingTicks[shuttleRingTicks.length - 1]);
        scale = (maxv - minv) / (maxp - minp);
        return Math.exp(minv + scale * (angle - minp));
    }
    maxv = Math.log(-shuttleRingTicks[0]);
    scale = (maxv - minv) / (maxp - minp);
    return -Math.exp(minv + scale * (Math.abs(angle) - minp));
}
function multiplierToAngle(multiplier, shuttleRingTicks, clockViewModel) {
    if (clockViewModel.clockStep === ClockStep.SYSTEM_CLOCK) {
        return realtimeShuttleRingAngle;
    }
    if (Math.abs(multiplier) <= 1) {
        return multiplier * realtimeShuttleRingAngle;
    }
    var minp = realtimeShuttleRingAngle;
    var maxp = maxShuttleRingAngle;
    var maxv;
    var minv = 0;
    var scale;
    if (multiplier > 0) {
        maxv = Math.log(shuttleRingTicks[shuttleRingTicks.length - 1]);
        scale = (maxv - minv) / (maxp - minp);
        return (Math.log(multiplier) - minv) / scale + minp;
    }
    maxv = Math.log(-shuttleRingTicks[0]);
    scale = (maxv - minv) / (maxp - minp);
    return -((Math.log(Math.abs(multiplier)) - minv) / scale + minp);
}
var AnimationViewModel = function (clockViewModel) {
    if (!defined(clockViewModel)) {
        throw new DeveloperError('clockViewModel is required.');
    }
    var that = this;
    this._clockViewModel = clockViewModel;
    this._allShuttleRingTicks = [];
    this._dateFormatter = AnimationViewModel.defaultDateFormatter;
    this._timeFormatter = AnimationViewModel.defaultTimeFormatter;
    this.shuttleRingDragging = false;
    this.snapToTicks = false;
    knockout.track(this, [
        '_allShuttleRingTicks',
        '_dateFormatter',
        '_timeFormatter',
        'shuttleRingDragging',
        'snapToTicks'
    ]);
    this._sortedFilteredPositiveTicks = [];
    this.setShuttleRingTicks(AnimationViewModel.defaultTicks);
    this.timeLabel = undefined;
    knockout.defineProperty(this, 'timeLabel', function () {
        return that._timeFormatter(that._clockViewModel.currentTime, that);
    });
    this.dateLabel = undefined;
    knockout.defineProperty(this, 'dateLabel', function () {
        return that._dateFormatter(that._clockViewModel.currentTime, that);
    });
    this.multiplierLabel = undefined;
    knockout.defineProperty(this, 'multiplierLabel', function () {
        var clockViewModel = that._clockViewModel;
        if (clockViewModel.clockStep === ClockStep.SYSTEM_CLOCK) {
            return 'Today';
        }
        var multiplier = clockViewModel.multiplier;
        if (multiplier % 1 === 0) {
            return multiplier.toFixed(0) + 'x';
        }
        return multiplier.toFixed(3).replace(/0{0,3}$/, '') + 'x';
    });
    this.shuttleRingAngle = undefined;
    knockout.defineProperty(this, 'shuttleRingAngle', {
        get: function () {
            return multiplierToAngle(clockViewModel.multiplier, that._allShuttleRingTicks, clockViewModel);
        },
        set: function (angle) {
            angle = Math.max(Math.min(angle, maxShuttleRingAngle), -maxShuttleRingAngle);
            var ticks = that._allShuttleRingTicks;
            var clockViewModel = that._clockViewModel;
            clockViewModel.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;
            if (Math.abs(angle) === maxShuttleRingAngle) {
                clockViewModel.multiplier = angle > 0 ? ticks[ticks.length - 1] : ticks[0];
                return;
            }
            var multiplier = angleToMultiplier(angle, ticks);
            if (that.snapToTicks) {
                multiplier = ticks[getTypicalMultiplierIndex(multiplier, ticks)];
            } else {
                if (multiplier !== 0) {
                    var positiveMultiplier = Math.abs(multiplier);
                    if (positiveMultiplier > 100) {
                        var numDigits = positiveMultiplier.toFixed(0).length - 2;
                        var divisor = Math.pow(10, numDigits);
                        multiplier = Math.round(multiplier / divisor) * divisor | 0;
                    } else if (positiveMultiplier > realtimeShuttleRingAngle) {
                        multiplier = Math.round(multiplier);
                    } else if (positiveMultiplier > 1) {
                        multiplier = +multiplier.toFixed(1);
                    } else if (positiveMultiplier > 0) {
                        multiplier = +multiplier.toFixed(2);
                    }
                }
            }
            clockViewModel.multiplier = multiplier;
        }
    });
    this._canAnimate = undefined;
    knockout.defineProperty(this, '_canAnimate', function () {
        var clockViewModel = that._clockViewModel;
        var clockRange = clockViewModel.clockRange;
        if (that.shuttleRingDragging || clockRange === ClockRange.UNBOUNDED) {
            return true;
        }
        var multiplier = clockViewModel.multiplier;
        var currentTime = clockViewModel.currentTime;
        var startTime = clockViewModel.startTime;
        var result = false;
        if (clockRange === ClockRange.LOOP_STOP) {
            result = JulianDate.greaterThan(currentTime, startTime) || currentTime.equals(startTime) && multiplier > 0;
        } else {
            var stopTime = clockViewModel.stopTime;
            result = JulianDate.greaterThan(currentTime, startTime) && JulianDate.lessThan(currentTime, stopTime) || currentTime.equals(startTime) && multiplier > 0 || currentTime.equals(stopTime) && multiplier < 0;
        }
        if (!result) {
            clockViewModel.shouldAnimate = false;
        }
        return result;
    });
    this._isSystemTimeAvailable = undefined;
    knockout.defineProperty(this, '_isSystemTimeAvailable', function () {
        var clockViewModel = that._clockViewModel;
        var clockRange = clockViewModel.clockRange;
        if (clockRange === ClockRange.UNBOUNDED) {
            return true;
        }
        var systemTime = clockViewModel.systemTime;
        return JulianDate.greaterThanOrEquals(systemTime, clockViewModel.startTime) && JulianDate.lessThanOrEquals(systemTime, clockViewModel.stopTime);
    });
    this._isAnimating = undefined;
    knockout.defineProperty(this, '_isAnimating', function () {
        return that._clockViewModel.shouldAnimate && (that._canAnimate || that.shuttleRingDragging);
    });
    var pauseCommand = createCommand(function () {
            var clockViewModel = that._clockViewModel;
            if (clockViewModel.shouldAnimate) {
                cancelRealtime(clockViewModel);
                clockViewModel.shouldAnimate = false;
            } else if (that._canAnimate) {
                unpause(clockViewModel);
            }
        });
    this._pauseViewModel = new ToggleButtonViewModel(pauseCommand, {
        toggled: knockout.computed(function () {
            return !that._isAnimating;
        }),
        tooltip: 'Pause'
    });
    var playReverseCommand = createCommand(function () {
            var clockViewModel = that._clockViewModel;
            cancelRealtime(clockViewModel);
            var multiplier = clockViewModel.multiplier;
            if (multiplier > 0) {
                clockViewModel.multiplier = -multiplier;
            }
            clockViewModel.shouldAnimate = true;
        });
    this._playReverseViewModel = new ToggleButtonViewModel(playReverseCommand, {
        toggled: knockout.computed(function () {
            return that._isAnimating && clockViewModel.multiplier < 0;
        }),
        tooltip: 'Play Reverse'
    });
    var playForwardCommand = createCommand(function () {
            var clockViewModel = that._clockViewModel;
            cancelRealtime(clockViewModel);
            var multiplier = clockViewModel.multiplier;
            if (multiplier < 0) {
                clockViewModel.multiplier = -multiplier;
            }
            clockViewModel.shouldAnimate = true;
        });
    this._playForwardViewModel = new ToggleButtonViewModel(playForwardCommand, {
        toggled: knockout.computed(function () {
            return that._isAnimating && clockViewModel.multiplier > 0 && clockViewModel.clockStep !== ClockStep.SYSTEM_CLOCK;
        }),
        tooltip: 'Play Forward'
    });
    var playRealtimeCommand = createCommand(function () {
            var clockViewModel = that._clockViewModel;
            clockViewModel.clockStep = ClockStep.SYSTEM_CLOCK;
            clockViewModel.multiplier = 1;
            clockViewModel.shouldAnimate = true;
        }, knockout.getObservable(this, '_isSystemTimeAvailable'));
    this._playRealtimeViewModel = new ToggleButtonViewModel(playRealtimeCommand, {
        toggled: knockout.computed(function () {
            return clockViewModel.shouldAnimate && clockViewModel.clockStep === ClockStep.SYSTEM_CLOCK;
        }),
        tooltip: knockout.computed(function () {
            return that._isSystemTimeAvailable ? 'Today (real-time)' : 'Current time not in range';
        })
    });
    this._slower = createCommand(function () {
        var clockViewModel = that._clockViewModel;
        cancelRealtime(clockViewModel);
        var shuttleRingTicks = that._allShuttleRingTicks;
        var multiplier = clockViewModel.multiplier;
        var index = getTypicalMultiplierIndex(multiplier, shuttleRingTicks) - 1;
        if (index >= 0) {
            clockViewModel.multiplier = shuttleRingTicks[index];
        }
    });
    this._faster = createCommand(function () {
        var clockViewModel = that._clockViewModel;
        cancelRealtime(clockViewModel);
        var shuttleRingTicks = that._allShuttleRingTicks;
        var multiplier = clockViewModel.multiplier;
        var index = getTypicalMultiplierIndex(multiplier, shuttleRingTicks) + 1;
        if (index < shuttleRingTicks.length) {
            clockViewModel.multiplier = shuttleRingTicks[index];
        }
    });
};
AnimationViewModel.defaultDateFormatter = function (date, viewModel) {
    var gregorianDate = JulianDate.toGregorianDate(date);
    return monthNames[gregorianDate.month - 1] + ' ' + gregorianDate.day + ' ' + gregorianDate.year;
};
AnimationViewModel.defaultTicks = [
    0.001,
    0.002,
    0.005,
    0.01,
    0.02,
    0.05,
    0.1,
    0.25,
    0.5,
    1,
    2,
    5,
    10,
    15,
    30,
    60,
    120,
    300,
    600,
    900,
    1800,
    3600,
    7200,
    14400,
    21600,
    43200,
    86400,
    172800,
    345600,
    604800
];
AnimationViewModel.defaultTimeFormatter = function (date, viewModel) {
    var gregorianDate = JulianDate.toGregorianDate(date);
    var millisecond = Math.round(gregorianDate.millisecond);
    if (Math.abs(viewModel._clockViewModel.multiplier) < 1) {
        return sprintf('%02d:%02d:%02d.%03d', gregorianDate.hour, gregorianDate.minute, gregorianDate.second, millisecond);
    }
    return sprintf('%02d:%02d:%02d UTC', gregorianDate.hour, gregorianDate.minute, gregorianDate.second);
};
AnimationViewModel.prototype.getShuttleRingTicks = function () {
    return this._sortedFilteredPositiveTicks.slice(0);
};
AnimationViewModel.prototype.setShuttleRingTicks = function (positiveTicks) {
    if (!defined(positiveTicks)) {
        throw new DeveloperError('positiveTicks is required.');
    }
    var i;
    var len;
    var tick;
    var hash = {};
    var sortedFilteredPositiveTicks = this._sortedFilteredPositiveTicks;
    sortedFilteredPositiveTicks.length = 0;
    for (i = 0, len = positiveTicks.length; i < len; ++i) {
        tick = positiveTicks[i];
        if (!hash.hasOwnProperty(tick)) {
            hash[tick] = true;
            sortedFilteredPositiveTicks.push(tick);
        }
    }
    sortedFilteredPositiveTicks.sort(numberComparator);
    var allTicks = [];
    for (len = sortedFilteredPositiveTicks.length, i = len - 1; i >= 0; --i) {
        tick = sortedFilteredPositiveTicks[i];
        if (tick !== 0) {
            allTicks.push(-tick);
        }
    }
    Array.prototype.push.apply(allTicks, sortedFilteredPositiveTicks);
    this._allShuttleRingTicks = allTicks;
};
defineProperties(AnimationViewModel.prototype, {
    slower: {
        get: function () {
            return this._slower;
        }
    },
    faster: {
        get: function () {
            return this._faster;
        }
    },
    clockViewModel: {
        get: function () {
            return this._clockViewModel;
        }
    },
    pauseViewModel: {
        get: function () {
            return this._pauseViewModel;
        }
    },
    playReverseViewModel: {
        get: function () {
            return this._playReverseViewModel;
        }
    },
    playForwardViewModel: {
        get: function () {
            return this._playForwardViewModel;
        }
    },
    playRealtimeViewModel: {
        get: function () {
            return this._playRealtimeViewModel;
        }
    },
    dateFormatter: {
        get: function () {
            return this._dateFormatter;
        },
        set: function (dateFormatter) {
            if (typeof dateFormatter !== 'function') {
                throw new DeveloperError('dateFormatter must be a function');
            }
            this._dateFormatter = dateFormatter;
        }
    },
    timeFormatter: {
        get: function () {
            return this._timeFormatter;
        },
        set: function (timeFormatter) {
            if (typeof timeFormatter !== 'function') {
                throw new DeveloperError('timeFormatter must be a function');
            }
            this._timeFormatter = timeFormatter;
        }
    }
});
AnimationViewModel._maxShuttleRingAngle = maxShuttleRingAngle;
AnimationViewModel._realtimeShuttleRingAngle = realtimeShuttleRingAngle;
module.exports = AnimationViewModel;
},{"../../Core/ClockRange":109,"../../Core/ClockStep":110,"../../Core/DeveloperError":123,"../../Core/JulianDate":168,"../../Core/binarySearch":238,"../../Core/defineProperties":244,"../../Core/defined":245,"../../ThirdParty/knockout":591,"../../ThirdParty/sprintf":594,"../ToggleButtonViewModel":625,"../createCommand":627}],600:[function(require,module,exports){
var defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), getElement = require('../getElement'), BaseLayerPickerViewModel = require('./BaseLayerPickerViewModel');
'use strict';
var BaseLayerPicker = function (container, options) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    container = getElement(container);
    var viewModel = new BaseLayerPickerViewModel(options);
    var element = document.createElement('button');
    element.type = 'button';
    element.className = 'cesium-button cesium-toolbar-button';
    element.setAttribute('data-bind', 'attr: { title: buttonTooltip },click: toggleDropDown');
    container.appendChild(element);
    var imgElement = document.createElement('img');
    imgElement.setAttribute('draggable', 'false');
    imgElement.className = 'cesium-baseLayerPicker-selected';
    imgElement.setAttribute('data-bind', 'attr: { src: buttonImageUrl }');
    element.appendChild(imgElement);
    var dropPanel = document.createElement('div');
    dropPanel.className = 'cesium-baseLayerPicker-dropDown';
    dropPanel.setAttribute('data-bind', 'css: { "cesium-baseLayerPicker-dropDown-visible" : dropDownVisible }');
    container.appendChild(dropPanel);
    var imageryTitle = document.createElement('div');
    imageryTitle.className = 'cesium-baseLayerPicker-sectionTitle';
    imageryTitle.setAttribute('data-bind', 'visible: imageryProviderViewModels.length > 0');
    imageryTitle.innerHTML = 'Imagery';
    dropPanel.appendChild(imageryTitle);
    var imageryChoices = document.createElement('div');
    imageryChoices.className = 'cesium-baseLayerPicker-choices';
    imageryChoices.setAttribute('data-bind', 'foreach: imageryProviderViewModels');
    dropPanel.appendChild(imageryChoices);
    var imageryProvider = document.createElement('div');
    imageryProvider.className = 'cesium-baseLayerPicker-item';
    imageryProvider.setAttribute('data-bind', 'css: { "cesium-baseLayerPicker-selectedItem" : $data === $parent.selectedImagery },attr: { title: tooltip },visible: creationCommand.canExecute,click: function($data) { $parent.selectedImagery = $data; }');
    imageryChoices.appendChild(imageryProvider);
    var providerIcon = document.createElement('img');
    providerIcon.className = 'cesium-baseLayerPicker-itemIcon';
    providerIcon.setAttribute('data-bind', 'attr: { src: iconUrl }');
    providerIcon.setAttribute('draggable', 'false');
    imageryProvider.appendChild(providerIcon);
    var providerLabel = document.createElement('div');
    providerLabel.className = 'cesium-baseLayerPicker-itemLabel';
    providerLabel.setAttribute('data-bind', 'text: name');
    imageryProvider.appendChild(providerLabel);
    var terrainTitle = document.createElement('div');
    terrainTitle.className = 'cesium-baseLayerPicker-sectionTitle';
    terrainTitle.setAttribute('data-bind', 'visible: terrainProviderViewModels.length > 0');
    terrainTitle.innerHTML = 'Terrain';
    dropPanel.appendChild(terrainTitle);
    var terrainChoices = document.createElement('div');
    terrainChoices.className = 'cesium-baseLayerPicker-choices';
    terrainChoices.setAttribute('data-bind', 'foreach: terrainProviderViewModels');
    dropPanel.appendChild(terrainChoices);
    var terrainProvider = document.createElement('div');
    terrainProvider.className = 'cesium-baseLayerPicker-item';
    terrainProvider.setAttribute('data-bind', 'css: { "cesium-baseLayerPicker-selectedItem" : $data === $parent.selectedTerrain },attr: { title: tooltip },visible: creationCommand.canExecute,click: function($data) { $parent.selectedTerrain = $data; }');
    terrainChoices.appendChild(terrainProvider);
    var terrainProviderIcon = document.createElement('img');
    terrainProviderIcon.className = 'cesium-baseLayerPicker-itemIcon';
    terrainProviderIcon.setAttribute('data-bind', 'attr: { src: iconUrl }');
    terrainProviderIcon.setAttribute('draggable', 'false');
    terrainProvider.appendChild(terrainProviderIcon);
    var terrainProviderLabel = document.createElement('div');
    terrainProviderLabel.className = 'cesium-baseLayerPicker-itemLabel';
    terrainProviderLabel.setAttribute('data-bind', 'text: name');
    terrainProvider.appendChild(terrainProviderLabel);
    knockout.applyBindings(viewModel, element);
    knockout.applyBindings(viewModel, dropPanel);
    this._viewModel = viewModel;
    this._container = container;
    this._element = element;
    this._dropPanel = dropPanel;
    this._closeDropDown = function (e) {
        if (!(element.contains(e.target) || dropPanel.contains(e.target))) {
            viewModel.dropDownVisible = false;
        }
    };
    document.addEventListener('mousedown', this._closeDropDown, true);
    document.addEventListener('touchstart', this._closeDropDown, true);
};
defineProperties(BaseLayerPicker.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
BaseLayerPicker.prototype.isDestroyed = function () {
    return false;
};
BaseLayerPicker.prototype.destroy = function () {
    document.removeEventListener('mousedown', this._closeDropDown, true);
    document.removeEventListener('touchstart', this._closeDropDown, true);
    knockout.cleanNode(this._element);
    knockout.cleanNode(this._dropPanel);
    this._container.removeChild(this._element);
    this._container.removeChild(this._dropPanel);
    return destroyObject(this);
};
module.exports = BaseLayerPicker;
},{"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../getElement":628,"./BaseLayerPickerViewModel":601}],601:[function(require,module,exports){
var defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), DeveloperError = require('../../Core/DeveloperError'), EllipsoidTerrainProvider = require('../../Core/EllipsoidTerrainProvider'), isArray = require('../../Core/isArray'), knockout = require('../../ThirdParty/knockout'), createCommand = require('../createCommand');
'use strict';
var BaseLayerPickerViewModel = function (options) {
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var globe = options.globe;
    var imageryProviderViewModels = defaultValue(options.imageryProviderViewModels, []);
    var terrainProviderViewModels = defaultValue(options.terrainProviderViewModels, []);
    if (!defined(globe)) {
        throw new DeveloperError('globe is required');
    }
    this._globe = globe;
    this.imageryProviderViewModels = imageryProviderViewModels.slice(0);
    this.terrainProviderViewModels = terrainProviderViewModels.slice(0);
    this.dropDownVisible = false;
    knockout.track(this, [
        'imageryProviderViewModels',
        'terrainProviderViewModels',
        'dropDownVisible'
    ]);
    this.buttonTooltip = undefined;
    knockout.defineProperty(this, 'buttonTooltip', function () {
        var selectedImagery = this.selectedImagery;
        var selectedTerrain = this.selectedTerrain;
        var imageryTip = defined(selectedImagery) ? selectedImagery.name : undefined;
        var terrainTip = defined(selectedTerrain) ? selectedTerrain.name : undefined;
        if (defined(imageryTip) && defined(terrainTip)) {
            return imageryTip + '\n' + terrainTip;
        } else if (defined(imageryTip)) {
            return imageryTip;
        }
        return terrainTip;
    });
    this.buttonImageUrl = undefined;
    knockout.defineProperty(this, 'buttonImageUrl', function () {
        var viewModel = this.selectedImagery;
        return defined(viewModel) ? viewModel.iconUrl : undefined;
    });
    this.selectedImagery = undefined;
    var selectedImageryViewModel = knockout.observable();
    this._currentImageryProviders = [];
    knockout.defineProperty(this, 'selectedImagery', {
        get: function () {
            return selectedImageryViewModel();
        },
        set: function (value) {
            if (selectedImageryViewModel() === value) {
                this.dropDownVisible = false;
                return;
            }
            var i;
            var currentImageryProviders = this._currentImageryProviders;
            var currentImageryProvidersLength = currentImageryProviders.length;
            var imageryLayers = this._globe.imageryLayers;
            for (i = 0; i < currentImageryProvidersLength; i++) {
                var layersLength = imageryLayers.length;
                for (var x = 0; x < layersLength; x++) {
                    var layer = imageryLayers.get(x);
                    if (layer.imageryProvider === currentImageryProviders[i]) {
                        imageryLayers.remove(layer);
                        break;
                    }
                }
            }
            if (defined(value)) {
                var newProviders = value.creationCommand();
                if (isArray(newProviders)) {
                    var newProvidersLength = newProviders.length;
                    for (i = newProvidersLength - 1; i >= 0; i--) {
                        imageryLayers.addImageryProvider(newProviders[i], 0);
                    }
                    this._currentImageryProviders = newProviders.slice(0);
                } else {
                    this._currentImageryProviders = [newProviders];
                    imageryLayers.addImageryProvider(newProviders, 0);
                }
            }
            selectedImageryViewModel(value);
            this.dropDownVisible = false;
        }
    });
    this.selectedTerrain = undefined;
    var selectedTerrainViewModel = knockout.observable();
    knockout.defineProperty(this, 'selectedTerrain', {
        get: function () {
            return selectedTerrainViewModel();
        },
        set: function (value) {
            if (selectedTerrainViewModel() === value) {
                this.dropDownVisible = false;
                return;
            }
            var newProvider;
            if (defined(value)) {
                newProvider = value.creationCommand();
            }
            this._globe.depthTestAgainstTerrain = !(newProvider instanceof EllipsoidTerrainProvider);
            this._globe.terrainProvider = newProvider;
            selectedTerrainViewModel(value);
            this.dropDownVisible = false;
        }
    });
    var that = this;
    this._toggleDropDown = createCommand(function () {
        that.dropDownVisible = !that.dropDownVisible;
    });
    this.selectedImagery = defaultValue(options.selectedImageryProviderViewModel, imageryProviderViewModels[0]);
    this.selectedTerrain = defaultValue(options.selectedTerrainProviderViewModel, terrainProviderViewModels[0]);
};
defineProperties(BaseLayerPickerViewModel.prototype, {
    toggleDropDown: {
        get: function () {
            return this._toggleDropDown;
        }
    },
    globe: {
        get: function () {
            return this._globe;
        }
    }
});
module.exports = BaseLayerPickerViewModel;
},{"../../Core/DeveloperError":123,"../../Core/EllipsoidTerrainProvider":135,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/isArray":253,"../../ThirdParty/knockout":591,"../createCommand":627}],602:[function(require,module,exports){
var defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), createCommand = require('../createCommand');
'use strict';
var ProviderViewModel = function (options) {
    if (!defined(options.name)) {
        throw new DeveloperError('options.name is required.');
    }
    if (!defined(options.tooltip)) {
        throw new DeveloperError('options.tooltip is required.');
    }
    if (!defined(options.iconUrl)) {
        throw new DeveloperError('options.iconUrl is required.');
    }
    if (typeof options.creationFunction !== 'function') {
        throw new DeveloperError('options.creationFunction is required.');
    }
    var creationCommand = options.creationFunction;
    if (!defined(creationCommand.canExecute)) {
        creationCommand = createCommand(creationCommand);
    }
    this._creationCommand = creationCommand;
    this.name = options.name;
    this.tooltip = options.tooltip;
    this.iconUrl = options.iconUrl;
    knockout.track(this, [
        'name',
        'tooltip',
        'iconUrl'
    ]);
};
defineProperties(ProviderViewModel.prototype, {
    creationCommand: {
        get: function () {
            return this._creationCommand;
        }
    }
});
module.exports = ProviderViewModel;
},{"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../ThirdParty/knockout":591,"../createCommand":627}],603:[function(require,module,exports){
var buildModuleUrl = require('../../Core/buildModuleUrl'), ArcGisMapServerImageryProvider = require('../../Scene/ArcGisMapServerImageryProvider'), BingMapsImageryProvider = require('../../Scene/BingMapsImageryProvider'), BingMapsStyle = require('../../Scene/BingMapsStyle'), OpenStreetMapImageryProvider = require('../../Scene/OpenStreetMapImageryProvider'), TileMapServiceImageryProvider = require('../../Scene/TileMapServiceImageryProvider'), ProviderViewModel = require('../BaseLayerPicker/ProviderViewModel');
'use strict';
function createDefaultImageryProviderViewModels() {
    var providerViewModels = [];
    providerViewModels.push(new ProviderViewModel({
        name: 'Bing Maps Aerial',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/bingAerial.png'),
        tooltip: 'Bing Maps aerial imagery \nhttp://www.bing.com/maps',
        creationFunction: function () {
            return new BingMapsImageryProvider({
                url: '//dev.virtualearth.net',
                mapStyle: BingMapsStyle.AERIAL
            });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'Bing Maps Aerial with Labels',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/bingAerialLabels.png'),
        tooltip: 'Bing Maps aerial imagery with label overlays \nhttp://www.bing.com/maps',
        creationFunction: function () {
            return new BingMapsImageryProvider({
                url: '//dev.virtualearth.net',
                mapStyle: BingMapsStyle.AERIAL_WITH_LABELS
            });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'Bing Maps Roads',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/bingRoads.png'),
        tooltip: 'Bing Maps standard road maps\nhttp://www.bing.com/maps',
        creationFunction: function () {
            return new BingMapsImageryProvider({
                url: '//dev.virtualearth.net',
                mapStyle: BingMapsStyle.ROAD
            });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'ESRI World Imagery',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/esriWorldImagery.png'),
        tooltip: 'World Imagery provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide.  The map includes NASA Blue Marble: Next Generation 500m resolution imagery at small scales (above 1:1,000,000), i-cubed 15m eSAT imagery at medium-to-large scales (down to 1:70,000) for the world, and USGS 15m Landsat imagery for Antarctica. The map features 0.3m resolution imagery in the continental United States and 0.6m resolution imagery in parts of Western Europe from DigitalGlobe. In other parts of the world, 1 meter resolution imagery is available from GeoEye IKONOS, i-cubed Nationwide Prime, Getmapping, AeroGRID, IGN Spain, and IGP Portugal.  Additionally, imagery at different resolutions has been contributed by the GIS User Community.\nhttp://www.esri.com',
        creationFunction: function () {
            return new ArcGisMapServerImageryProvider({ url: '//services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer' });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'ESRI World Street Map',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/esriWorldStreetMap.png'),
        tooltip: 'This worldwide street map presents highway-level data for the world. Street-level data includes the United States; much of Canada; Japan; most countries in Europe; Australia and New Zealand; India; parts of South America including Argentina, Brazil, Chile, Colombia, and Venezuela; Ghana; and parts of southern Africa including Botswana, Lesotho, Namibia, South Africa, and Swaziland.\nhttp://www.esri.com',
        creationFunction: function () {
            return new ArcGisMapServerImageryProvider({ url: '//services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer' });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'ESRI National Geographic',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/esriNationalGeographic.png'),
        tooltip: 'This web map contains the National Geographic World Map service. This map service is designed to be used as a general reference map for informational and educational purposes as well as a basemap by GIS professionals and other users for creating web maps and web mapping applications.\nhttp://www.esri.com',
        creationFunction: function () {
            return new ArcGisMapServerImageryProvider({ url: '//services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/' });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'Open\xadStreet\xadMap',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/openStreetMap.png'),
        tooltip: 'OpenStreetMap (OSM) is a collaborative project to create a free editable map of the world.\nhttp://www.openstreetmap.org',
        creationFunction: function () {
            return new OpenStreetMapImageryProvider({ url: '//a.tile.openstreetmap.org/' });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'Stamen Watercolor',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/stamenWatercolor.png'),
        tooltip: 'Reminiscent of hand drawn maps, Stamen watercolor maps apply raster effect area washes and organic edges over a paper texture to add warm pop to any map.\nhttp://maps.stamen.com',
        creationFunction: function () {
            return new OpenStreetMapImageryProvider({
                url: '//stamen-tiles.a.ssl.fastly.net/watercolor/',
                credit: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA.'
            });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'Stamen Toner',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/stamenToner.png'),
        tooltip: 'A high contrast black and white map.\nhttp://maps.stamen.com',
        creationFunction: function () {
            return new OpenStreetMapImageryProvider({
                url: '//stamen-tiles.a.ssl.fastly.net/toner/',
                credit: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under CC BY SA.'
            });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'MapQuest Open\xadStreet\xadMap',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/mapQuestOpenStreetMap.png'),
        tooltip: 'OpenStreetMap (OSM) is a collaborative project to create a free editable map of the world.\nhttp://www.openstreetmap.org',
        creationFunction: function () {
            return new OpenStreetMapImageryProvider({ url: '//otile1-s.mqcdn.com/tiles/1.0.0/osm/' });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'The Black Marble',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/blackMarble.png'),
        tooltip: 'The lights of cities and villages trace the outlines of civilization in this global view of the Earth at night as seen by NASA/NOAA\'s Suomi NPP satellite.',
        creationFunction: function () {
            return new TileMapServiceImageryProvider({
                url: '//cesiumjs.org/blackmarble',
                maximumLevel: 8,
                credit: 'Black Marble imagery courtesy NASA Earth Observatory'
            });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'Natural Earth\xa0II',
        iconUrl: buildModuleUrl('Widgets/Images/ImageryProviders/naturalEarthII.png'),
        tooltip: 'Natural Earth II, darkened for contrast.\nhttp://www.naturalearthdata.com/',
        creationFunction: function () {
            return new TileMapServiceImageryProvider({ url: buildModuleUrl('Assets/Textures/NaturalEarthII') });
        }
    }));
    return providerViewModels;
}
module.exports = createDefaultImageryProviderViewModels;
},{"../../Core/buildModuleUrl":239,"../../Scene/ArcGisMapServerImageryProvider":367,"../../Scene/BingMapsImageryProvider":370,"../../Scene/BingMapsStyle":371,"../../Scene/OpenStreetMapImageryProvider":417,"../../Scene/TileMapServiceImageryProvider":450,"../BaseLayerPicker/ProviderViewModel":602}],604:[function(require,module,exports){
var buildModuleUrl = require('../../Core/buildModuleUrl'), CesiumTerrainProvider = require('../../Core/CesiumTerrainProvider'), EllipsoidTerrainProvider = require('../../Core/EllipsoidTerrainProvider'), ProviderViewModel = require('../BaseLayerPicker/ProviderViewModel');
'use strict';
function createDefaultTerrainProviderViewModels() {
    var providerViewModels = [];
    providerViewModels.push(new ProviderViewModel({
        name: 'WGS84 Ellipsoid',
        iconUrl: buildModuleUrl('Widgets/Images/TerrainProviders/Ellipsoid.png'),
        tooltip: 'WGS84 standard ellipsoid, also known as EPSG:4326',
        creationFunction: function () {
            return new EllipsoidTerrainProvider();
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'STK World Terrain meshes',
        iconUrl: buildModuleUrl('Widgets/Images/TerrainProviders/STK.png'),
        tooltip: 'High-resolution, mesh-based terrain for the entire globe. Free for use on the Internet. Closed-network options are available.\nhttp://www.agi.com',
        creationFunction: function () {
            return new CesiumTerrainProvider({ url: '//cesiumjs.org/stk-terrain/tilesets/world/tiles' });
        }
    }));
    providerViewModels.push(new ProviderViewModel({
        name: 'Small Terrain heightmaps with water',
        iconUrl: buildModuleUrl('Widgets/Images/TerrainProviders/STK.png'),
        tooltip: 'Medium-resolution, heightmap-based terrain for the entire globe. This tileset also includes a water mask. Free for use on the Internet.\nhttp://www.agi.com',
        creationFunction: function () {
            return new CesiumTerrainProvider({
                url: '//cesiumjs.org/smallterrain',
                credit: 'Terrain data courtesy Analytical Graphics, Inc.'
            });
        }
    }));
    return providerViewModels;
}
module.exports = createDefaultTerrainProviderViewModels;
},{"../../Core/CesiumTerrainProvider":105,"../../Core/EllipsoidTerrainProvider":135,"../../Core/buildModuleUrl":239,"../BaseLayerPicker/ProviderViewModel":602}],605:[function(require,module,exports){
var buildModuleUrl = require('../../Core/buildModuleUrl'), Cartesian3 = require('../../Core/Cartesian3'), Clock = require('../../Core/Clock'), Credit = require('../../Core/Credit'), defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), Ellipsoid = require('../../Core/Ellipsoid'), formatError = require('../../Core/formatError'), requestAnimationFrame = require('../../Core/requestAnimationFrame'), ScreenSpaceEventHandler = require('../../Core/ScreenSpaceEventHandler'), BingMapsImageryProvider = require('../../Scene/BingMapsImageryProvider'), Globe = require('../../Scene/Globe'), Moon = require('../../Scene/Moon'), Scene = require('../../Scene/Scene'), SceneMode = require('../../Scene/SceneMode'), SkyAtmosphere = require('../../Scene/SkyAtmosphere'), SkyBox = require('../../Scene/SkyBox'), Sun = require('../../Scene/Sun'), getElement = require('../getElement');
'use strict';
function getDefaultSkyBoxUrl(suffix) {
    return buildModuleUrl('Assets/Textures/SkyBox/tycho2t3_80_' + suffix + '.jpg');
}
function startRenderLoop(widget) {
    widget._renderLoopRunning = true;
    var lastFrameTime = 0;
    function render(frameTime) {
        if (widget.isDestroyed()) {
            return;
        }
        if (widget._useDefaultRenderLoop) {
            try {
                var targetFrameRate = widget._targetFrameRate;
                if (!defined(targetFrameRate)) {
                    widget.resize();
                    widget.render();
                    requestAnimationFrame(render);
                } else {
                    var interval = 1000 / targetFrameRate;
                    var delta = frameTime - lastFrameTime;
                    if (delta > interval) {
                        widget.resize();
                        widget.render();
                        lastFrameTime = frameTime - delta % interval;
                    }
                    requestAnimationFrame(render);
                }
            } catch (error) {
                widget._useDefaultRenderLoop = false;
                widget._renderLoopRunning = false;
                if (widget._showRenderLoopErrors) {
                    var title = 'An error occurred while rendering.  Rendering has stopped.';
                    widget.showErrorPanel(title, undefined, error);
                }
            }
        } else {
            widget._renderLoopRunning = false;
        }
    }
    requestAnimationFrame(render);
}
function configureCanvasSize(widget) {
    var canvas = widget._canvas;
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;
    var zoomFactor = defaultValue(window.devicePixelRatio, 1) * widget._resolutionScale;
    widget._canvasWidth = width;
    widget._canvasHeight = height;
    width *= zoomFactor;
    height *= zoomFactor;
    canvas.width = width;
    canvas.height = height;
    widget._canRender = width !== 0 && height !== 0;
}
function configureCameraFrustum(widget) {
    var canvas = widget._canvas;
    var width = canvas.width;
    var height = canvas.height;
    if (width !== 0 && height !== 0) {
        var frustum = widget._scene.camera.frustum;
        if (defined(frustum.aspectRatio)) {
            frustum.aspectRatio = width / height;
        } else {
            frustum.top = frustum.right * (height / width);
            frustum.bottom = -frustum.top;
        }
    }
}
var cesiumLogoData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHYAAAAaCAYAAABikagwAAAAAXNSR0IArs4c6QAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB9wGGRQyF371QVsAABOHSURBVGje7Vp5cFTHmf91v2Nm3owGnYMuEEJCOBiEjDlsDMYQjGMOOwmXcWxiLywpJ9iuTXZd612corJssFOxi8LerXizxEGUvWsivNxxHHCQ8WYBYSFzmUMCCXQjaUajOd/V+4f6Kc14kI/KZv/xq+p6M/PmO15/9/c1wa0vwpcMQAHgBuAFoPG7mz8jAGwASQBxADFhJQGYACwAjK+vrr/AJQ8jVMqfuwH4AGQByAaQnTNqXGHWqHGFbq8/g1BJsgw9GQ12Bds/qWsxEvEeAEEAfQDCAKKCgPGVcP//BOsIVQHgAZAJIACgsHTqvDvK7150T2bR2DFaZm6W4slwUypR20yaiUg4OtDbcaP36rlPPt6/7f2B3q5mAB0AeriAE18J9y93kVu4X4W73BwAhQBK5v/gZ98ZVXXvDG92IJMx569MQDEoK0tPmOHu1s4L7799sH7vtvcAXAPQCaCfu2qLu+7h+Eh3sS8Bcyt48iVgPos2+4J7jS+BIx2etDBSynfH/Xq46y0CUL70n3/zXMmUuXepWoZHFCQhFIQARCBFJYV6/Nn+QHnVBH9Ovq/51JFWADpfJhcqEzyDcx9ukTTr/xr2VnDpng0nuHR0h1u3wvWF6EspgBIAFYAfQAGAsuU/rfm7kePvvJ0QiTj6QSgBISS9ujEGSikkxaXklIwfK8uK2Xru2HVurWKspZyezGmmWwp/LqVsupPQub4grPQ5YIejKQvPJAGflLLJSBGmxPEqKXhU4XdJEBq7BR5Z+L+DKx3MTTHWEaybx9WCud/btCJQMeX2Qevk+NPoks0YPArF/RUj0NyXxOmO2CAy1a1OmL9yUVfTmatXTx52EildYFQVNlgRmBR1xQJgCBbPBAVUhcw8lTObLz0FVk4RIEmJJyJNZzFBiCTFBRL+f50rriFUATRFiZSU/XYEAw6X5LlIUghZqXvl5p8pfycRZsgjymlKGw1Adm7JbRUVs785nwGghP5pp9mfFMOxWstmuC3gwdcrRqA/buJUWwyKRMAYgydrZNZt9337623njn+ixyN9nAmdM5nBvYOPfxc3mnEmTQ4T5VZv8hfz8aUKnocJd5tvVhxAhOMADzNefleFjRUFa/D/xzi8LQhIEpTG4VXnNBzlZYISufk7juCfqaAoLkHYcZ6HBAEM8O+ObJz3HcFDpJfDJwWYfiHMMTklviocKHv6I3+zRFLdKhEEatmALBFIBIibNhQ6KFyJEjT2JHDoUj/a+nVIVIBhBGOnzptWXzhmTFfT2TZBOH4AgSeeeGJqRUVFqdfr9btcLnVQXwapmqZpJZPJRCgUCh47duzie++9dwWAXl5enrlp06bF0WhUM01TYYwRrmg2vzNKqS3Lsunz+Yy6urpTP//5z09blkVLSkryVq9ePT03NzegqqqbUnqTGyOEMNM0k319fX2///3vz9bW1l4DYD700EPFy5Ytm65pmvbBBx9c2rp166Wnnnqq7MEHH5zAGIu8/vrr+w8ePPgJVwrRO2gAcg8cOLA2mUx62tvbB9avX39s+fLlo++///5JXNiwbXugpqam9tChQ2cEj6NzuQwlsi+//PKSzMzMQtu2qcfjMZqbm09v2LDht4J3sQEQOU2Jo8mKKzt7VEU5lSgFBi3PZkBZrgv3lGbCo1Jc7I7iSGN40JcQgoGkhXdO94ESQJEoGI+1k/M9mDKqQHEv++akl186e45rNAAE3njjjccWLFhwfyAQyJEkiabGbcc7JJNJva2trX3Lli3vvPbaa+eKi4uLV6xY8d10cf5TcZ8x5OXl5b366qs9lFLtrbfeWldVVXW7pmkuxhjS0SSEIJlMGitXrrz2/PPPv1lTU3NtypQp0x955JG/kmVZdrlcR7du3WrOnTt33pIlS+YDwNGjR68ePHiwjVtukm+wI9ichQsXPgUAHR0d3evXr78xc+bMu9asWbOQUjpENz8/v/jQoUP/IiiH40UzAeQvW7Zs1rp16/7a5/NpDr/19fWlGzZsOM4tNsphkc5iPaXTvl6uuDUvY4MZLwNQ4Ffw+LR8+KQQTCuJSQUFcMsEe88FoSkSKCFwyWSISQbg9pEefHdGAJHIdUydVjFecL3K448/Pm3hwoUPBAKBHFGIlmU5pRCRpMGEze12q2PHjh2zatWqeTt37gwODAxkOQIJhUJ6Y2Njn6IojFJqE0KYsGyPx0POnTvXnUgkfGvXrr1j5syZU7iFsKampv5YLBZ34GzbJgAwatSo7MzMTE95eXnZT37yk0dramr+PRQKZSQSCdPn88nBYNADID8UCmkAYBiGGQ6Hna6cksbdZliWZUuSRKPRKAAUBINBfywWM30+n+yEtenTp9+5YsWKGTt37oxwz+a44RwARc8+++xSr9eriQrY398v8311CUncTTHN0Q7Vl1OQJymq4iBwyxQPT8qDVwri1d1/i8ttp/AP39mOBeMn41pQx9mOGFSZ3qT52ZqMR6aMRGvXKfzbgX9Ea3PnSLEdOWXKlK/5/X4/AFy8ePHG6tWr90QikS5VVaOEEIsxRhljngcffLBi8+bNjxBCUFJSMrKkpMRvGIbboXP27Nn+2bNn/3cgEIgSQmKEEAOARQixKKVxRVEioVAoYtu2dMcdd4x24Hbv3t3+ox/96ONoNBqklMa4ppNkMinNnz8///nnn6/y+Xw0mUxaANy6rrsdl28YhguAX9d1F98jwn9TUjJkJ5N1DWV0ti0ByDAMw+PsbzQatX0+Hy0oKMhcvnz5nP3791+IxWJRIUaPfO655+ZVVlaOA4BoNGprmkZ5uJJThZouKyYAqOrWVEKoE7cwszQDlQUK3jr8S5y++iEIIXh55/fwylOH8e3KHHSEdfQnLFBuRbJEsLQyF27Sh3eO/iuudV+EaSuqkJF6MjMzs9xutwIAv/rVr06eOHHiEwCtPBHQOaPaxYsXLxcXF8cKCwtzOzo6+ltbW4OFhYU+h2nDMAgAqbu7W8xkLSEBcsos1bbtocZIIBBQs7Ky5Pb2dkvXdV1wfaipqemsqak5yF1bFABljNEU4Sj87nia1LKHCJWGLLh6AkDhiksAoLq6um/VqlWZWVlZ8gMPPHDHwoULK2tqasJcYJ7y8vKyb33rW/f4/X43YwybNm26vnnz5pIUb0tvVe44maSVjEfizDJtmwFlOS4srczGiQvv4ncnd4ASAkIo+mN92LLrB/j7Vb/GQxOz8Z/1PTDsQXc6p3QEqopU7Dr6S5y8fAiKpCKhs6SQSUqyLKsO4d7e3j4AvbxD1csFQQF4EolEaP369TVCFjuiqKiogG8w5s6dm8sY++ZwcfbZZ5/dvHXr1isnT55scVz+rFmz8urr6xc4Ls22bZZIJExd181oNGr09PREDx06dPmFF144Ho/HTVGIjiE4guECoyl1LYTPcppGEAghDAAikUjixRdfbHnppZfKfD6fa82aNfMOHz7cHgwGbwBwr1ix4u677rqrgsfU4I4dO66lCPZTXSkqpOaMa60e7mjuosw0RmYoWHf3SLT3NOKt91+CbsZBeOlDCcX5luP4rw9fw4wSH+4p9cMlU3xtpAfLJmej/vIR7PnjLyDRwXeKhoxubokWAOYkDXxTLE5brB11oTZMCrWoNQgymJwZhsHC4bAZjUaNaDRqxGIx3VnxeDzJky8TQGLHjh3n9u3bd6ytrS3U2dkZ6e3tjfX398cHBgYS8XjcIIQQr9frKioq8ldWVhb88Ic/vHfbtm3zAXhs25aHUx7uEt1COeXEXM3JfAWLvWnSxRhLbNu2rampqSlMCME3vvGNyXPmzKkCUFZeXn776tWr72WMwbZtvPDCCx+5XK6wo6BcOdhwQ4Chuu/KR39onDGS9T80u9ivkgiqD/0UbT2NcKvelMaEhXfrqlGaPwEPT5qH0lwvqopcaOtpxPb3/gmGmYBEFRBC0HUlfp67tQQALxMKYsaYU+tlcSadNN8NIOO+++4bnZ2d7Q+Hw+zIkSNJxtiQ9TQ1NUW3bNnSmJWVlZBlWaeUWs5SVTUxYsSIRF1dXScAwzTN2MMPP7w3Pz//ZFVVVUFubq7L6/VKmqZRl8ulKIriVlVVmz59ev6cOXMCLpeLLliwYDyAOpGm08SglA659mQy6eHTrwiPtRYXbi6vP2/yjI61AoDL5Ur09vZ2bt++/ezGjRvvppSSjRs3Lti9e/fvnnzyyfHjx48fyRjDwYMHL9TW1jYWFhZ6xfIs3UhUTlPQRwGE9Gv/c/ba9YGi2rPv0FONf/iUUB3Lj8SDqD60GYtmdGBcYSVOnL+K39b9Gp19zVDkwZzBSpLY9Qv9Z3lKHgOgmaYZd9zg1KlTS994441L3G3lcD6oo/1btmxZFwgEctrb27vWrFlzwLIs2cmKW1pa4q+//vp1AbchdIKiPGZHAJDFixcHpk+ffnsoFNLefvvt3ra2Nl0YSDhdt4zy8vLwsWPHsl0ul6ooigSACuEZXKBJwzAMxhhUVZW8Xm8uH5hQ3mCwOf95VVVVYx03yQVhUEpNQbBxADfefPPN6NKlS8dUVlYWVlZW5r344osz1q1bV8IYQzAYjFVXV5+IxWIdkiTlpfDCUgcC6Sw2CqBvw4ZN+7/9d+Wzo1avT5HU9N1tMpj4dfU14z/efxletx9xPYpIPAhVccO2bVBKcf189I/h3mSLkBi5b9y40RWLxZJer9f12GOPTa6oqMjq6enpJYQYlFLGyx21tLQ0MGnSpDGEECQSCZMQIjuNCF6aqI8++mheVlZWJrdYkzcoLEVREj6fL1FfX39x165dzfPnzy/7/ve/v1LXdWvlypVde/bsuRKLxQyn1LEsS2aMeebNm1fs8/lkxhgsy7IAJBRF0Yc2TZZ1AANNTU0djoJt2rRpzqxZs/K6urq6JUnSCSHMMAxZ07SsxYsXV1JKCWMMAwMDMQBhVVWTjtU6gr1y5Yq1d+/ej8aNG5eraZr6zDPPjPV4PBJjDLW1ted27dr1MYCYqqpDcpMkyRIaEyydxToxNgagr7e3t+XEe0rNxPkjnvhTznNr4Sb0KBL6YO9BovJQnRXptTqaPgr9wTLsDgAhTkOurq4+unz58vs1TRvl9/vVuXPnljHGxgqxw2GcEjLYJLlw4cKV06dPd06bNo04+MePH+/ftm3bNNG1iW5KVVVl//79ew4cONC8d+/ey88884ysKIp85513jpo8eXJh2pHX4EUIITh58uRFAN1utzvHcb0ejycGoKuurk5vbW29u7i4ODB69OisJ5988i4xxDhsKIoiEUJgmqZ94MCBOgBdmqaVODxrmhbhiaP+4x//+N2lS5dOmjBhwhiPxyMBQFdXV191dfX7tm23AdBdLtdQzFYUxWmb3iRcmqbh7vQfOz9+v/PdjvP6kcHuE288MJZWuM4Smw1mgkQvHw/v6Wga+BjADY53AEDfmTNnLq9du/Znp06datB13RA3ROwGmaZphcPhgX379v326aefftO27Tafz9fJGGOmadqMMSbLMpEkiaZbjDFommYQQsK1tbWNr7zyymvhcLifEIJbwRBCmGVZ1vHjxz9atGjRLwA0Z2dndzpdHb/fHwTQcuLEiYann3761fPnz3+i67pBCCGUUkoIofwjpZQS27ZZd3f3ja1bt1Zv3LhxL4CrmZmZPYQQkxCCjIyMEIB2AG0Amrdv3/6beDweNwzD1nXdPHXq1Indu3cf48+7MjIyupw98ng8EW4wCWH4kHbQLgsnJ4oAlN332Ji1hbeps6lEaLohQLrhQCJi9zcei77TcLh9H4CrALp4rLN5LBvBE4scAP6JEyfmBQIBL6VUopSCMcYGBgYSly5dCvX19YW5QkQAmD6fz3PvvfeWxmIxr2EYHqFXPBRrKKWWJEmG1+uNtbW1dTU0NNzgz7wA/OXl5bkFBQV+XsYQwVpZMpk0jh8/3snpRQCYo0aN8k6YMCHX5XLRa9euBRsaGnr4Jnp458c7ceLEbK/X6xL5MQzDbGhoCNq2HeO4YgBYWVmZv6KiIkdVVbS0tHQ3NDR0CsORrDlz5oyllHoYY3p9ff31cDjczeGhaVrGkiVLSg3DkLu7u/s+/PDDFn4UKeJYLhnmAJvGs9QCAKOnLMhfNHqSNl/LlHOpTORbWa4et2ORXqv1wgf9NVfO9B7nTYcuPvlICq02t9CJ8ggjOJomodOF0ZQtHNvxCC08pBnbmcIhO53jdA7mpXaKUkOSWGoxYaaKlIa7IozT0uET+XDGehDGhhBGb6bTmBHezeb8OyNPCPQk/ptzeHConCSfcZDNI1hWQXaBVl5254hZmSPVce4MKUdxEQ+VJMnUbcNIWJFoyOzoa02eOX2k+yg/79TFNWkgZchOUobe4vA63WzUEmpYsa+dCoM0Izgz5aQkTUOPpGvUpKFJBaUR8Q03cLdT8NkppyEgPGOCYcnCiNASsn2SwrstDA2Gxnbkc5xSdHGrcmaBWYoqZ+YUe4pcXuqXJCobupWIhaze3vZohzAfdOaKN2mSwPxwR0ZSZ6uptZoIN9yxFCYIiqV5v3THStgwNNPhvtXxFgzDP9K8q52Cj6ZRNnaLffoUDfI5zhVLgrvxCN0Ux5URYXYYF84Wf2qqf4uDV591ZuiLHir7c8F+mZOU5M+Iazg8n3mYjnxORkV3I6dxg6KrMQW3Yaexlq+uv8D1v2IL+t4z3B/NAAAAAElFTkSuQmCC';
var CesiumWidget = function (container, options) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    container = getElement(container);
    options = defaultValue(options, {});
    var element = document.createElement('div');
    element.className = 'cesium-widget';
    container.appendChild(element);
    var canvas = document.createElement('canvas');
    canvas.oncontextmenu = function () {
        return false;
    };
    canvas.onselectstart = function () {
        return false;
    };
    element.appendChild(canvas);
    var creditContainer = document.createElement('div');
    creditContainer.className = 'cesium-widget-credits';
    var creditContainerContainer = defined(options.creditContainer) ? getElement(options.creditContainer) : element;
    creditContainerContainer.appendChild(creditContainer);
    this._element = element;
    this._container = container;
    this._canvas = canvas;
    this._canvasWidth = 0;
    this._canvasHeight = 0;
    this._creditContainer = creditContainer;
    this._canRender = false;
    this._renderLoopRunning = false;
    this._showRenderLoopErrors = defaultValue(options.showRenderLoopErrors, true);
    this._resolutionScale = 1;
    this._forceResize = false;
    this._clock = defined(options.clock) ? options.clock : new Clock();
    configureCanvasSize(this);
    try {
        var scene = new Scene({
                canvas: canvas,
                contextOptions: options.contextOptions,
                creditContainer: creditContainer,
                mapProjection: options.mapProjection,
                orderIndependentTranslucency: options.orderIndependentTranslucency,
                scene3DOnly: defaultValue(options.scene3DOnly, false)
            });
        this._scene = scene;
        scene.camera.constrainedAxis = Cartesian3.UNIT_Z;
        configureCameraFrustum(this);
        var ellipsoid = Ellipsoid.WGS84;
        var creditDisplay = scene.frameState.creditDisplay;
        var cesiumCredit = new Credit('Cesium', cesiumLogoData, 'http://cesiumjs.org/');
        creditDisplay.addDefaultCredit(cesiumCredit);
        var globe = new Globe(ellipsoid);
        this._globe = globe;
        scene.globe = globe;
        var skyBox = options.skyBox;
        if (!defined(skyBox)) {
            skyBox = new SkyBox({
                sources: {
                    positiveX: getDefaultSkyBoxUrl('px'),
                    negativeX: getDefaultSkyBoxUrl('mx'),
                    positiveY: getDefaultSkyBoxUrl('py'),
                    negativeY: getDefaultSkyBoxUrl('my'),
                    positiveZ: getDefaultSkyBoxUrl('pz'),
                    negativeZ: getDefaultSkyBoxUrl('mz')
                }
            });
        }
        scene.skyBox = skyBox;
        scene.skyAtmosphere = new SkyAtmosphere(ellipsoid);
        scene.sun = new Sun();
        scene.moon = new Moon();
        var imageryProvider = options.imageryProvider;
        if (!defined(imageryProvider)) {
            imageryProvider = new BingMapsImageryProvider({ url: '//dev.virtualearth.net' });
        }
        if (imageryProvider !== false) {
            scene.imageryLayers.addImageryProvider(imageryProvider);
        }
        if (defined(options.terrainProvider)) {
            scene.terrainProvider = options.terrainProvider;
        }
        this._screenSpaceEventHandler = new ScreenSpaceEventHandler(canvas, false);
        if (defined(options.sceneMode)) {
            if (options.sceneMode === SceneMode.SCENE2D) {
                this._scene.morphTo2D(0);
            }
            if (options.sceneMode === SceneMode.COLUMBUS_VIEW) {
                this._scene.morphToColumbusView(0);
            }
        }
        this._useDefaultRenderLoop = undefined;
        this.useDefaultRenderLoop = defaultValue(options.useDefaultRenderLoop, true);
        this._targetFrameRate = undefined;
        this.targetFrameRate = options.targetFrameRate;
        var that = this;
        scene.renderError.addEventListener(function (scene, error) {
            that._useDefaultRenderLoop = false;
            that._renderLoopRunning = false;
            if (that._showRenderLoopErrors) {
                var title = 'An error occurred while rendering.  Rendering has stopped.';
                that.showErrorPanel(title, undefined, error);
            }
        });
    } catch (error) {
        var title = 'Error constructing CesiumWidget.';
        var message = 'Visit <a href="http://get.webgl.org">http://get.webgl.org</a> to verify that your web browser and hardware support WebGL.  Consider trying a different web browser or updating your video drivers.  Detailed error information is below:';
        this.showErrorPanel(title, message, error);
        throw error;
    }
};
defineProperties(CesiumWidget.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    canvas: {
        get: function () {
            return this._canvas;
        }
    },
    creditContainer: {
        get: function () {
            return this._creditContainer;
        }
    },
    scene: {
        get: function () {
            return this._scene;
        }
    },
    imageryLayers: {
        get: function () {
            return this._scene.imageryLayers;
        }
    },
    terrainProvider: {
        get: function () {
            return this._scene.terrainProvider;
        },
        set: function (terrainProvider) {
            this._scene.terrainProvider = terrainProvider;
        }
    },
    camera: {
        get: function () {
            return this._scene.camera;
        }
    },
    clock: {
        get: function () {
            return this._clock;
        }
    },
    screenSpaceEventHandler: {
        get: function () {
            return this._screenSpaceEventHandler;
        }
    },
    targetFrameRate: {
        get: function () {
            return this._targetFrameRate;
        },
        set: function (value) {
            if (value <= 0) {
                throw new DeveloperError('targetFrameRate must be greater than 0.');
            }
            this._targetFrameRate = value;
        }
    },
    useDefaultRenderLoop: {
        get: function () {
            return this._useDefaultRenderLoop;
        },
        set: function (value) {
            if (this._useDefaultRenderLoop !== value) {
                this._useDefaultRenderLoop = value;
                if (value && !this._renderLoopRunning) {
                    startRenderLoop(this);
                }
            }
        }
    },
    resolutionScale: {
        get: function () {
            return this._resolutionScale;
        },
        set: function (value) {
            if (value <= 0) {
                throw new DeveloperError('resolutionScale must be greater than 0.');
            }
            this._resolutionScale = value;
            this._forceResize = true;
        }
    }
});
CesiumWidget.prototype.showErrorPanel = function (title, message, error) {
    var element = this._element;
    var overlay = document.createElement('div');
    overlay.className = 'cesium-widget-errorPanel';
    var content = document.createElement('div');
    content.className = 'cesium-widget-errorPanel-content';
    overlay.appendChild(content);
    var errorHeader = document.createElement('div');
    errorHeader.className = 'cesium-widget-errorPanel-header';
    errorHeader.appendChild(document.createTextNode(title));
    content.appendChild(errorHeader);
    var errorPanelScroller = document.createElement('div');
    errorPanelScroller.className = 'cesium-widget-errorPanel-scroll';
    content.appendChild(errorPanelScroller);
    var resizeCallback = function () {
        errorPanelScroller.style.maxHeight = Math.max(Math.round(element.clientHeight * 0.9 - 100), 30) + 'px';
    };
    resizeCallback();
    if (defined(window.addEventListener)) {
        window.addEventListener('resize', resizeCallback, false);
    }
    if (defined(message)) {
        var errorMessage = document.createElement('div');
        errorMessage.className = 'cesium-widget-errorPanel-message';
        errorMessage.innerHTML = '<p>' + message + '</p>';
        errorPanelScroller.appendChild(errorMessage);
    }
    var errorDetails = '(no error details available)';
    if (defined(error)) {
        errorDetails = formatError(error);
    }
    var errorMessageDetails = document.createElement('div');
    errorMessageDetails.className = 'cesium-widget-errorPanel-message';
    errorMessageDetails.appendChild(document.createTextNode(errorDetails));
    errorPanelScroller.appendChild(errorMessageDetails);
    var buttonPanel = document.createElement('div');
    buttonPanel.className = 'cesium-widget-errorPanel-buttonPanel';
    content.appendChild(buttonPanel);
    var okButton = document.createElement('button');
    okButton.setAttribute('type', 'button');
    okButton.className = 'cesium-button';
    okButton.appendChild(document.createTextNode('OK'));
    okButton.onclick = function () {
        if (defined(resizeCallback) && defined(window.removeEventListener)) {
            window.removeEventListener('resize', resizeCallback, false);
        }
        element.removeChild(overlay);
    };
    buttonPanel.appendChild(okButton);
    element.appendChild(overlay);
    console.error(title + '\n' + message + '\n' + errorDetails);
};
CesiumWidget.prototype.isDestroyed = function () {
    return false;
};
CesiumWidget.prototype.destroy = function () {
    this._scene = this._scene && this._scene.destroy();
    this._container.removeChild(this._element);
    destroyObject(this);
};
CesiumWidget.prototype.resize = function () {
    var canvas = this._canvas;
    var width = canvas.clientWidth;
    var height = canvas.clientHeight;
    if (!this._forceResize && this._canvasWidth === width && this._canvasHeight === height) {
        return;
    }
    this._forceResize = false;
    configureCanvasSize(this);
    configureCameraFrustum(this);
};
CesiumWidget.prototype.render = function () {
    this._scene.initializeFrame();
    var currentTime = this._clock.tick();
    if (this._canRender) {
        this._scene.render(currentTime);
    }
};
module.exports = CesiumWidget;
},{"../../Core/Cartesian3":102,"../../Core/Clock":108,"../../Core/Credit":118,"../../Core/DeveloperError":123,"../../Core/Ellipsoid":130,"../../Core/ScreenSpaceEventHandler":208,"../../Core/buildModuleUrl":239,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../Core/formatError":248,"../../Core/requestAnimationFrame":270,"../../Scene/BingMapsImageryProvider":370,"../../Scene/Globe":390,"../../Scene/Moon":415,"../../Scene/Scene":437,"../../Scene/SceneMode":438,"../../Scene/SkyAtmosphere":443,"../../Scene/SkyBox":444,"../../Scene/Sun":445,"../getElement":628}],606:[function(require,module,exports){
var Clock = require('../Core/Clock'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), destroyObject = require('../Core/destroyObject'), EventHelper = require('../Core/EventHelper'), JulianDate = require('../Core/JulianDate'), knockout = require('../ThirdParty/knockout');
'use strict';
var ClockViewModel = function (clock) {
    if (!defined(clock)) {
        clock = new Clock();
    }
    this._clock = clock;
    this._eventHelper = new EventHelper();
    this._eventHelper.add(clock.onTick, this.synchronize, this);
    var startTime = knockout.observable(clock.startTime);
    startTime.equalityComparer = JulianDate.equals;
    this.systemTime = knockout.observable(JulianDate.now());
    this.systemTime.equalityComparer = JulianDate.equals;
    knockout.track(this, ['systemTime']);
    this.startTime = undefined;
    knockout.defineProperty(this, 'startTime', {
        get: startTime,
        set: function (value) {
            startTime(value);
            clock.startTime = value;
        }
    });
    var stopTime = knockout.observable(clock.stopTime);
    stopTime.equalityComparer = JulianDate.equals;
    this.stopTime = undefined;
    knockout.defineProperty(this, 'stopTime', {
        get: stopTime,
        set: function (value) {
            clock.stopTime = value;
            stopTime(value);
        }
    });
    var currentTime = knockout.observable(clock.currentTime);
    currentTime.equalityComparer = JulianDate.equals;
    this.currentTime = undefined;
    knockout.defineProperty(this, 'currentTime', {
        get: currentTime,
        set: function (value) {
            clock.currentTime = value;
            currentTime(value);
        }
    });
    var multiplier = knockout.observable(clock.multiplier);
    this.multiplier = undefined;
    knockout.defineProperty(this, 'multiplier', {
        get: multiplier,
        set: function (value) {
            clock.multiplier = value;
            multiplier(value);
        }
    });
    var clockStep = knockout.observable(clock.clockStep);
    clockStep.equalityComparer = function (a, b) {
        return a === b;
    };
    this.clockStep = undefined;
    knockout.defineProperty(this, 'clockStep', {
        get: clockStep,
        set: function (value) {
            clockStep(value);
            clock.clockStep = value;
        }
    });
    var clockRange = knockout.observable(clock.clockRange);
    clockRange.equalityComparer = function (a, b) {
        return a === b;
    };
    this.clockRange = undefined;
    knockout.defineProperty(this, 'clockRange', {
        get: clockRange,
        set: function (value) {
            clockRange(value);
            clock.clockRange = value;
        }
    });
    var canAnimate = knockout.observable(clock.canAnimate);
    this.canAnimate = undefined;
    knockout.defineProperty(this, 'canAnimate', {
        get: canAnimate,
        set: function (value) {
            canAnimate(value);
            clock.canAnimate = value;
        }
    });
    var shouldAnimate = knockout.observable(clock.shouldAnimate);
    this.shouldAnimate = undefined;
    knockout.defineProperty(this, 'shouldAnimate', {
        get: shouldAnimate,
        set: function (value) {
            shouldAnimate(value);
            clock.shouldAnimate = value;
        }
    });
};
defineProperties(ClockViewModel.prototype, {
    clock: {
        get: function () {
            return this._clock;
        }
    }
});
ClockViewModel.prototype.synchronize = function () {
    var clock = this._clock;
    var startTime = clock.startTime;
    var stopTime = clock.stopTime;
    var currentTime = clock.currentTime;
    var multiplier = clock.multiplier;
    var clockStep = clock.clockStep;
    var clockRange = clock.clockRange;
    var canAnimate = clock.canAnimate;
    var shouldAnimate = clock.shouldAnimate;
    this.systemTime = JulianDate.now();
    this.startTime = startTime;
    this.stopTime = stopTime;
    this.currentTime = currentTime;
    this.multiplier = multiplier;
    this.clockStep = clockStep;
    this.clockRange = clockRange;
    this.canAnimate = canAnimate;
    this.shouldAnimate = shouldAnimate;
};
ClockViewModel.prototype.isDestroyed = function () {
    return false;
};
ClockViewModel.prototype.destroy = function () {
    this._eventHelper.removeAll();
    destroyObject(this);
};
module.exports = ClockViewModel;
},{"../Core/Clock":108,"../Core/EventHelper":139,"../Core/JulianDate":168,"../Core/defineProperties":244,"../Core/defined":245,"../Core/destroyObject":247,"../ThirdParty/knockout":591}],607:[function(require,module,exports){
var defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), getElement = require('../getElement'), FullscreenButtonViewModel = require('./FullscreenButtonViewModel');
'use strict';
var enterFullScreenPath = 'M 83.96875 17.5625 L 83.96875 17.59375 L 76.65625 24.875 L 97.09375 24.96875 L 76.09375 45.96875 L 81.9375 51.8125 L 102.78125 30.9375 L 102.875 51.15625 L 110.15625 43.875 L 110.1875 17.59375 L 83.96875 17.5625 z M 44.125 17.59375 L 17.90625 17.625 L 17.9375 43.90625 L 25.21875 51.1875 L 25.3125 30.96875 L 46.15625 51.8125 L 52 45.96875 L 31 25 L 51.4375 24.90625 L 44.125 17.59375 z M 46.0625 76.03125 L 25.1875 96.875 L 25.09375 76.65625 L 17.8125 83.9375 L 17.8125 110.21875 L 44 110.25 L 51.3125 102.9375 L 30.90625 102.84375 L 51.875 81.875 L 46.0625 76.03125 z M 82 76.15625 L 76.15625 82 L 97.15625 103 L 76.71875 103.0625 L 84.03125 110.375 L 110.25 110.34375 L 110.21875 84.0625 L 102.9375 76.8125 L 102.84375 97 L 82 76.15625 z';
var exitFullScreenPath = 'M 104.34375 17.5625 L 83.5 38.4375 L 83.40625 18.21875 L 76.125 25.5 L 76.09375 51.78125 L 102.3125 51.8125 L 102.3125 51.78125 L 109.625 44.5 L 89.1875 44.40625 L 110.1875 23.40625 L 104.34375 17.5625 z M 23.75 17.59375 L 17.90625 23.4375 L 38.90625 44.4375 L 18.5 44.53125 L 25.78125 51.8125 L 52 51.78125 L 51.96875 25.53125 L 44.6875 18.25 L 44.625 38.46875 L 23.75 17.59375 z M 25.6875 76.03125 L 18.375 83.3125 L 38.78125 83.40625 L 17.8125 104.40625 L 23.625 110.25 L 44.5 89.375 L 44.59375 109.59375 L 51.875 102.3125 L 51.875 76.0625 L 25.6875 76.03125 z M 102.375 76.15625 L 76.15625 76.1875 L 76.1875 102.4375 L 83.46875 109.71875 L 83.5625 89.53125 L 104.40625 110.375 L 110.25 104.53125 L 89.25 83.53125 L 109.6875 83.46875 L 102.375 76.15625 z';
var FullscreenButton = function (container, fullscreenElement) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    container = getElement(container);
    var viewModel = new FullscreenButtonViewModel(fullscreenElement);
    viewModel._exitFullScreenPath = exitFullScreenPath;
    viewModel._enterFullScreenPath = enterFullScreenPath;
    var element = document.createElement('button');
    element.type = 'button';
    element.className = 'cesium-button cesium-fullscreenButton';
    element.setAttribute('data-bind', 'attr: { title: tooltip },click: command,enable: isFullscreenEnabled,cesiumSvgPath: { path: isFullscreen ? _exitFullScreenPath : _enterFullScreenPath, width: 128, height: 128 }');
    container.appendChild(element);
    knockout.applyBindings(viewModel, element);
    this._container = container;
    this._viewModel = viewModel;
    this._element = element;
};
defineProperties(FullscreenButton.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
FullscreenButton.prototype.isDestroyed = function () {
    return false;
};
FullscreenButton.prototype.destroy = function () {
    this._viewModel.destroy();
    knockout.cleanNode(this._element);
    this._container.removeChild(this._element);
    return destroyObject(this);
};
module.exports = FullscreenButton;
},{"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../getElement":628,"./FullscreenButtonViewModel":608}],608:[function(require,module,exports){
var defaultValue = require('../../Core/defaultValue'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), Fullscreen = require('../../Core/Fullscreen'), knockout = require('../../ThirdParty/knockout'), createCommand = require('../createCommand'), getElement = require('../getElement');
'use strict';
var FullscreenButtonViewModel = function (fullscreenElement) {
    var that = this;
    var tmpIsFullscreen = knockout.observable(Fullscreen.fullscreen);
    var tmpIsEnabled = knockout.observable(Fullscreen.enabled);
    this.isFullscreen = undefined;
    knockout.defineProperty(this, 'isFullscreen', {
        get: function () {
            return tmpIsFullscreen();
        }
    });
    this.isFullscreenEnabled = undefined;
    knockout.defineProperty(this, 'isFullscreenEnabled', {
        get: function () {
            return tmpIsEnabled();
        },
        set: function (value) {
            tmpIsEnabled(value && Fullscreen.enabled);
        }
    });
    this.tooltip = undefined;
    knockout.defineProperty(this, 'tooltip', function () {
        if (!this.isFullscreenEnabled) {
            return 'Full screen unavailable';
        }
        return tmpIsFullscreen() ? 'Exit full screen' : 'Full screen';
    });
    this._command = createCommand(function () {
        if (Fullscreen.fullscreen) {
            Fullscreen.exitFullscreen();
        } else {
            Fullscreen.requestFullscreen(that._fullscreenElement);
        }
    }, knockout.getObservable(this, 'isFullscreenEnabled'));
    this._fullscreenElement = defaultValue(getElement(fullscreenElement), document.body);
    this._callback = function () {
        tmpIsFullscreen(Fullscreen.fullscreen);
    };
    document.addEventListener(Fullscreen.changeEventName, this._callback);
};
defineProperties(FullscreenButtonViewModel.prototype, {
    fullscreenElement: {
        get: function () {
            return this._fullscreenElement;
        },
        set: function (value) {
            if (!(value instanceof Element)) {
                throw new DeveloperError('value must be a valid Element.');
            }
            this._fullscreenElement = value;
        }
    },
    command: {
        get: function () {
            return this._command;
        }
    }
});
FullscreenButtonViewModel.prototype.isDestroyed = function () {
    return false;
};
FullscreenButtonViewModel.prototype.destroy = function () {
    document.removeEventListener(Fullscreen.changeEventName, this._callback);
    destroyObject(this);
};
module.exports = FullscreenButtonViewModel;
},{"../../Core/DeveloperError":123,"../../Core/Fullscreen":142,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../createCommand":627,"../getElement":628}],609:[function(require,module,exports){
var defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), getElement = require('../getElement'), GeocoderViewModel = require('./GeocoderViewModel');
'use strict';
var startSearchPath = 'M29.772,26.433l-7.126-7.126c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127L29.772,26.433zM7.203,13.885c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486c-0.007,3.58-2.905,6.476-6.484,6.484C10.106,20.361,7.209,17.465,7.203,13.885z';
var stopSearchPath = 'M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z';
var Geocoder = function (options) {
    if (!defined(options) || !defined(options.container)) {
        throw new DeveloperError('options.container is required.');
    }
    if (!defined(options.scene)) {
        throw new DeveloperError('options.scene is required.');
    }
    var container = getElement(options.container);
    var viewModel = new GeocoderViewModel(options);
    viewModel._startSearchPath = startSearchPath;
    viewModel._stopSearchPath = stopSearchPath;
    var form = document.createElement('form');
    form.setAttribute('data-bind', 'submit: search');
    var textBox = document.createElement('input');
    textBox.type = 'search';
    textBox.className = 'cesium-geocoder-input';
    textBox.setAttribute('placeholder', 'Enter an address or landmark...');
    textBox.setAttribute('data-bind', 'value: searchText,valueUpdate: "afterkeydown",disable: isSearchInProgress,css: { "cesium-geocoder-input-wide" : searchText.length > 0 }');
    form.appendChild(textBox);
    var searchButton = document.createElement('span');
    searchButton.className = 'cesium-geocoder-searchButton';
    searchButton.setAttribute('data-bind', 'click: search,cesiumSvgPath: { path: isSearchInProgress ? _stopSearchPath : _startSearchPath, width: 32, height: 32 }');
    form.appendChild(searchButton);
    container.appendChild(form);
    knockout.applyBindings(viewModel, form);
    this._container = container;
    this._viewModel = viewModel;
    this._form = form;
    this._onInputBegin = function (e) {
        if (!container.contains(e.target)) {
            textBox.blur();
        }
    };
    this._onInputEnd = function (e) {
        if (container.contains(e.target)) {
            textBox.focus();
        }
    };
    document.addEventListener('mousedown', this._onInputBegin, true);
    document.addEventListener('mouseup', this._onInputEnd, true);
    document.addEventListener('touchstart', this._onInputBegin, true);
    document.addEventListener('touchend', this._onInputEnd, true);
};
defineProperties(Geocoder.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
Geocoder.prototype.isDestroyed = function () {
    return false;
};
Geocoder.prototype.destroy = function () {
    document.removeEventListener('mousedown', this._onInputBegin, true);
    document.removeEventListener('mouseup', this._onInputEnd, true);
    document.removeEventListener('touchstart', this._onInputBegin, true);
    document.removeEventListener('touchend', this._onInputEnd, true);
    knockout.cleanNode(this._form);
    this._container.removeChild(this._form);
    return destroyObject(this);
};
module.exports = Geocoder;
},{"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../getElement":628,"./GeocoderViewModel":610}],610:[function(require,module,exports){
var BingMapsApi = require('../../Core/BingMapsApi'), defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), DeveloperError = require('../../Core/DeveloperError'), jsonp = require('../../Core/jsonp'), Matrix4 = require('../../Core/Matrix4'), Rectangle = require('../../Core/Rectangle'), knockout = require('../../ThirdParty/knockout'), when = require('../../ThirdParty/when'), createCommand = require('../createCommand');
'use strict';
var GeocoderViewModel = function (options) {
    if (!defined(options) || !defined(options.scene)) {
        throw new DeveloperError('options.scene is required.');
    }
    this._url = defaultValue(options.url, '//dev.virtualearth.net/');
    if (this._url.length > 0 && this._url[this._url.length - 1] !== '/') {
        this._url += '/';
    }
    this._key = BingMapsApi.getKey(options.key);
    this._scene = options.scene;
    this._flightDuration = defaultValue(options.flightDuration, 1.5);
    this._searchText = '';
    this._isSearchInProgress = false;
    this._geocodeInProgress = undefined;
    var that = this;
    this._searchCommand = createCommand(function () {
        if (that.isSearchInProgress) {
            cancelGeocode(that);
        } else {
            geocode(that);
        }
    });
    knockout.track(this, [
        '_searchText',
        '_isSearchInProgress'
    ]);
    this.isSearchInProgress = undefined;
    knockout.defineProperty(this, 'isSearchInProgress', {
        get: function () {
            return this._isSearchInProgress;
        }
    });
    this.searchText = undefined;
    knockout.defineProperty(this, 'searchText', {
        get: function () {
            if (this.isSearchInProgress) {
                return 'Searching...';
            }
            return this._searchText;
        },
        set: function (value) {
            if (typeof value !== 'string') {
                throw new DeveloperError('value must be a valid string.');
            }
            this._searchText = value;
        }
    });
    this.flightDuration = undefined;
    knockout.defineProperty(this, 'flightDuration', {
        get: function () {
            return this._flightDuration;
        },
        set: function (value) {
            if (value < 0) {
                throw new DeveloperError('value must be positive.');
            }
            this._flightDuration = value;
        }
    });
};
defineProperties(GeocoderViewModel.prototype, {
    url: {
        get: function () {
            return this._url;
        }
    },
    key: {
        get: function () {
            return this._key;
        }
    },
    scene: {
        get: function () {
            return this._scene;
        }
    },
    search: {
        get: function () {
            return this._searchCommand;
        }
    }
});
function geocode(viewModel) {
    var query = viewModel.searchText;
    if (/^\s*$/.test(query)) {
        return;
    }
    viewModel._isSearchInProgress = true;
    var promise = jsonp(viewModel._url + 'REST/v1/Locations', {
            parameters: {
                query: query,
                key: viewModel._key
            },
            callbackParameterName: 'jsonp'
        });
    var geocodeInProgress = viewModel._geocodeInProgress = when(promise, function (result) {
            if (geocodeInProgress.cancel) {
                return;
            }
            viewModel._isSearchInProgress = false;
            if (result.resourceSets.length === 0) {
                viewModel.searchText = viewModel._searchText + ' (not found)';
                return;
            }
            var resourceSet = result.resourceSets[0];
            if (resourceSet.resources.length === 0) {
                viewModel.searchText = viewModel._searchText + ' (not found)';
                return;
            }
            var resource = resourceSet.resources[0];
            viewModel._searchText = resource.name;
            var bbox = resource.bbox;
            var south = bbox[0];
            var west = bbox[1];
            var north = bbox[2];
            var east = bbox[3];
            var rectangle = Rectangle.fromDegrees(west, south, east, north);
            var camera = viewModel._scene.camera;
            var position = camera.getRectangleCameraCoordinates(rectangle);
            if (!defined(position)) {
                return;
            }
            viewModel._scene.camera.flyTo({
                destination: position,
                duration: viewModel._flightDuration,
                endTransform: Matrix4.IDENTITY,
                convert: false
            });
        }, function () {
            if (geocodeInProgress.cancel) {
                return;
            }
            viewModel._isSearchInProgress = false;
            viewModel.searchText = viewModel._searchText + ' (error)';
        });
}
function cancelGeocode(viewModel) {
    viewModel._isSearchInProgress = false;
    if (defined(viewModel._geocodeInProgress)) {
        viewModel._geocodeInProgress.cancel = true;
        viewModel._geocodeInProgress = undefined;
    }
}
module.exports = GeocoderViewModel;
},{"../../Core/BingMapsApi":96,"../../Core/DeveloperError":123,"../../Core/Matrix4":177,"../../Core/Rectangle":201,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/jsonp":256,"../../ThirdParty/knockout":591,"../../ThirdParty/when":596,"../createCommand":627}],611:[function(require,module,exports){
var defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), getElement = require('../getElement'), HomeButtonViewModel = require('./HomeButtonViewModel');
'use strict';
var HomeButton = function (container, scene, duration) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    container = getElement(container);
    var viewModel = new HomeButtonViewModel(scene, duration);
    viewModel._svgPath = 'M14,4l-10,8.75h20l-4.25-3.7188v-4.6562h-2.812v2.1875l-2.938-2.5625zm-7.0938,9.906v10.094h14.094v-10.094h-14.094zm2.1876,2.313h3.3122v4.25h-3.3122v-4.25zm5.8442,1.281h3.406v6.438h-3.406v-6.438z';
    var element = document.createElement('button');
    element.type = 'button';
    element.className = 'cesium-button cesium-toolbar-button cesium-home-button';
    element.setAttribute('data-bind', 'attr: { title: tooltip },click: command,cesiumSvgPath: { path: _svgPath, width: 28, height: 28 }');
    container.appendChild(element);
    knockout.applyBindings(viewModel, element);
    this._container = container;
    this._viewModel = viewModel;
    this._element = element;
};
defineProperties(HomeButton.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
HomeButton.prototype.isDestroyed = function () {
    return false;
};
HomeButton.prototype.destroy = function () {
    knockout.cleanNode(this._element);
    this._container.removeChild(this._element);
    return destroyObject(this);
};
module.exports = HomeButton;
},{"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../getElement":628,"./HomeButtonViewModel":612}],612:[function(require,module,exports){
var Cartesian3 = require('../../Core/Cartesian3'), defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), DeveloperError = require('../../Core/DeveloperError'), Matrix4 = require('../../Core/Matrix4'), Rectangle = require('../../Core/Rectangle'), Camera = require('../../Scene/Camera'), SceneMode = require('../../Scene/SceneMode'), knockout = require('../../ThirdParty/knockout'), createCommand = require('../createCommand');
'use strict';
function viewHome(scene, duration) {
    var mode = scene.mode;
    if (defined(scene) && mode === SceneMode.MORPHING) {
        scene.completeMorph();
    }
    var direction;
    var right;
    var up;
    if (mode === SceneMode.SCENE2D) {
        scene.camera.flyToRectangle({
            destination: Rectangle.MAX_VALUE,
            duration: duration,
            endTransform: Matrix4.IDENTITY
        });
    } else if (mode === SceneMode.SCENE3D) {
        var destination = scene.camera.getRectangleCameraCoordinates(Camera.DEFAULT_VIEW_RECTANGLE);
        var mag = Cartesian3.magnitude(destination);
        mag += mag * Camera.DEFAULT_VIEW_FACTOR;
        Cartesian3.normalize(destination, destination);
        Cartesian3.multiplyByScalar(destination, mag, destination);
        direction = Cartesian3.normalize(destination, new Cartesian3());
        Cartesian3.negate(direction, direction);
        right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, new Cartesian3());
        up = Cartesian3.cross(right, direction, new Cartesian3());
        scene.camera.flyTo({
            destination: destination,
            direction: direction,
            up: up,
            duration: duration,
            endTransform: Matrix4.IDENTITY
        });
    } else if (mode === SceneMode.COLUMBUS_VIEW) {
        var maxRadii = scene.globe.ellipsoid.maximumRadius;
        var position = new Cartesian3(0, -1, 1);
        position = Cartesian3.multiplyByScalar(Cartesian3.normalize(position, position), 5 * maxRadii, position);
        direction = new Cartesian3();
        direction = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.ZERO, position, direction), direction);
        right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, new Cartesian3());
        up = Cartesian3.cross(right, direction, new Cartesian3());
        scene.camera.flyTo({
            destination: position,
            duration: duration,
            up: up,
            direction: direction,
            endTransform: Matrix4.IDENTITY,
            convert: false
        });
    }
}
var HomeButtonViewModel = function (scene, duration) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    duration = defaultValue(duration, 1.5);
    this._scene = scene;
    this._duration = duration;
    var that = this;
    this._command = createCommand(function () {
        viewHome(that._scene, that._duration);
    });
    this.tooltip = 'View Home';
    knockout.track(this, ['tooltip']);
};
defineProperties(HomeButtonViewModel.prototype, {
    scene: {
        get: function () {
            return this._scene;
        }
    },
    command: {
        get: function () {
            return this._command;
        }
    },
    duration: {
        get: function () {
            return this._duration;
        },
        set: function (value) {
            if (value < 0) {
                throw new DeveloperError('value must be positive.');
            }
            this._duration = value;
        }
    }
});
module.exports = HomeButtonViewModel;
},{"../../Core/Cartesian3":102,"../../Core/DeveloperError":123,"../../Core/Matrix4":177,"../../Core/Rectangle":201,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Scene/Camera":375,"../../Scene/SceneMode":438,"../../ThirdParty/knockout":591,"../createCommand":627}],613:[function(require,module,exports){
var defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), getElement = require('../getElement'), InfoBoxViewModel = require('./InfoBoxViewModel');
'use strict';
var InfoBox = function (container) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    container = getElement(container);
    this._container = container;
    var infoElement = document.createElement('div');
    infoElement.className = 'cesium-infoBox';
    infoElement.setAttribute('data-bind', 'css: { "cesium-infoBox-visible" : showInfo, "cesium-infoBox-bodyless" : _bodyless }');
    container.appendChild(infoElement);
    this._element = infoElement;
    var titleElement = document.createElement('div');
    titleElement.className = 'cesium-infoBox-title';
    titleElement.setAttribute('data-bind', 'text: titleText');
    infoElement.appendChild(titleElement);
    var cameraElement = document.createElement('button');
    cameraElement.type = 'button';
    cameraElement.className = 'cesium-button cesium-infoBox-camera';
    cameraElement.setAttribute('data-bind', 'attr: { title: "Focus camera on object" },click: function () { cameraClicked.raiseEvent(this); },enable: enableCamera,cesiumSvgPath: { path: cameraIconPath, width: 32, height: 32 }');
    infoElement.appendChild(cameraElement);
    var closeElement = document.createElement('button');
    closeElement.type = 'button';
    closeElement.className = 'cesium-infoBox-close';
    closeElement.setAttribute('data-bind', 'click: function () { closeClicked.raiseEvent(this); }');
    closeElement.innerHTML = '&times;';
    infoElement.appendChild(closeElement);
    var infoBodyElement = document.createElement('div');
    infoBodyElement.className = 'cesium-infoBox-body';
    infoElement.appendChild(infoBodyElement);
    var descriptionElement = document.createElement('div');
    descriptionElement.className = 'cesium-infoBox-description';
    descriptionElement.setAttribute('data-bind', 'html: descriptionSanitizedHtml,style : { maxHeight : maxHeightOffset(40) }');
    infoBodyElement.appendChild(descriptionElement);
    var viewModel = new InfoBoxViewModel();
    this._viewModel = viewModel;
    knockout.applyBindings(this._viewModel, infoElement);
};
defineProperties(InfoBox.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
InfoBox.prototype.isDestroyed = function () {
    return false;
};
InfoBox.prototype.destroy = function () {
    var container = this._container;
    knockout.cleanNode(this._element);
    container.removeChild(this._element);
    return destroyObject(this);
};
module.exports = InfoBox;
},{"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../getElement":628,"./InfoBoxViewModel":614}],614:[function(require,module,exports){
var defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), Event = require('../../Core/Event'), FeatureDetection = require('../../Core/FeatureDetection'), formatError = require('../../Core/formatError'), TaskProcessor = require('../../Core/TaskProcessor'), knockout = require('../../ThirdParty/knockout'), when = require('../../ThirdParty/when');
'use strict';
var cameraEnabledPath = 'M 13.84375 7.03125 C 11.412798 7.03125 9.46875 8.975298 9.46875 11.40625 L 9.46875 11.59375 L 2.53125 7.21875 L 2.53125 24.0625 L 9.46875 19.6875 C 9.4853444 22.104033 11.423165 24.0625 13.84375 24.0625 L 25.875 24.0625 C 28.305952 24.0625 30.28125 22.087202 30.28125 19.65625 L 30.28125 11.40625 C 30.28125 8.975298 28.305952 7.03125 25.875 7.03125 L 13.84375 7.03125 z';
var cameraDisabledPath = 'M 27.34375 1.65625 L 5.28125 27.9375 L 8.09375 30.3125 L 30.15625 4.03125 L 27.34375 1.65625 z M 13.84375 7.03125 C 11.412798 7.03125 9.46875 8.975298 9.46875 11.40625 L 9.46875 11.59375 L 2.53125 7.21875 L 2.53125 24.0625 L 9.46875 19.6875 C 9.4724893 20.232036 9.5676108 20.7379 9.75 21.21875 L 21.65625 7.03125 L 13.84375 7.03125 z M 28.21875 7.71875 L 14.53125 24.0625 L 25.875 24.0625 C 28.305952 24.0625 30.28125 22.087202 30.28125 19.65625 L 30.28125 11.40625 C 30.28125 9.8371439 29.456025 8.4902779 28.21875 7.71875 z';
var InfoBoxViewModel = function () {
    this._sanitizer = undefined;
    this._descriptionRawHtml = '';
    this._descriptionSanitizedHtml = '';
    this._cameraClicked = new Event();
    this._closeClicked = new Event();
    this.maxHeight = 500;
    this.enableCamera = false;
    this.isCameraTracking = false;
    this.showInfo = false;
    this.titleText = '';
    this.loadingIndicatorHtml = '<div class="cesium-infoBox-loadingContainer"><span class="cesium-infoBox-loading"></span></div>';
    knockout.track(this, [
        'showInfo',
        'titleText',
        '_descriptionRawHtml',
        '_descriptionSanitizedHtml',
        'maxHeight',
        'enableCamera',
        'isCameraTracking'
    ]);
    this.descriptionRawHtml = undefined;
    knockout.defineProperty(this, 'descriptionRawHtml', {
        get: function () {
            return this._descriptionRawHtml;
        },
        set: function (value) {
            if (this._descriptionRawHtml !== value) {
                this._descriptionRawHtml = value;
                this._descriptionSanitizedHtml = this.loadingIndicatorHtml;
                var that = this;
                when(this.sanitizer(value), function (sanitized) {
                    if (that._descriptionRawHtml === value) {
                        that._descriptionSanitizedHtml = sanitized;
                    }
                }).otherwise(function (error) {
                    console.log('An error occurred while sanitizing HTML: ' + formatError(error));
                });
            }
        }
    });
    this.descriptionSanitizedHtml = undefined;
    knockout.defineProperty(this, 'descriptionSanitizedHtml', {
        get: function () {
            return this._descriptionSanitizedHtml;
        }
    });
    this.cameraIconPath = undefined;
    knockout.defineProperty(this, 'cameraIconPath', {
        get: function () {
            return !this.enableCamera || this.isCameraTracking ? cameraDisabledPath : cameraEnabledPath;
        }
    });
    knockout.defineProperty(this, '_bodyless', {
        get: function () {
            return !this._descriptionSanitizedHtml;
        }
    });
};
InfoBoxViewModel.prototype.maxHeightOffset = function (offset) {
    return this.maxHeight - offset + 'px';
};
var sanitizerTaskProcessor;
function defaultSanitizer(html) {
    if (!defined(sanitizerTaskProcessor)) {
        if (FeatureDetection.supportsWebWorkers()) {
            sanitizerTaskProcessor = new TaskProcessor('sanitizeHtml', Infinity);
        } else {
            sanitizerTaskProcessor = {
                scheduleTask: function (html) {
                    return html;
                }
            };
        }
    }
    return sanitizerTaskProcessor.scheduleTask(html);
}
InfoBoxViewModel.defaultSanitizer = defaultSanitizer;
defineProperties(InfoBoxViewModel.prototype, {
    cameraClicked: {
        get: function () {
            return this._cameraClicked;
        }
    },
    closeClicked: {
        get: function () {
            return this._closeClicked;
        }
    },
    sanitizer: {
        get: function () {
            return defaultValue(this._sanitizer, InfoBoxViewModel.defaultSanitizer);
        },
        set: function (value) {
            this._sanitizer = value;
            var oldHtml = this._descriptionRawHtml;
            this._descriptionRawHtml = '';
            this.descriptionRawHtml = oldHtml;
        }
    }
});
module.exports = InfoBoxViewModel;
},{"../../Core/Event":138,"../../Core/FeatureDetection":141,"../../Core/TaskProcessor":217,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/formatError":248,"../../ThirdParty/knockout":591,"../../ThirdParty/when":596}],615:[function(require,module,exports){
var buildModuleUrl = require('../../Core/buildModuleUrl'), defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), getElement = require('../getElement'), NavigationHelpButtonViewModel = require('./NavigationHelpButtonViewModel');
'use strict';
var NavigationHelpButton = function (options) {
    if (!defined(options) || !defined(options.container)) {
        throw new DeveloperError('options.container is required.');
    }
    var container = getElement(options.container);
    var viewModel = new NavigationHelpButtonViewModel();
    var showInsructionsDefault = defaultValue(options.instructionsInitiallyVisible, false);
    viewModel.showInstructions = showInsructionsDefault;
    viewModel._svgPath = 'M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466z M17.328,24.371h-2.707v-2.596h2.707V24.371zM17.328,19.003v0.858h-2.707v-1.057c0-3.19,3.63-3.696,3.63-5.963c0-1.034-0.924-1.826-2.134-1.826c-1.254,0-2.354,0.924-2.354,0.924l-1.541-1.915c0,0,1.519-1.584,4.137-1.584c2.487,0,4.796,1.54,4.796,4.136C21.156,16.208,17.328,16.627,17.328,19.003z';
    var wrapper = document.createElement('span');
    wrapper.className = 'cesium-navigationHelpButton-wrapper';
    container.appendChild(wrapper);
    var button = document.createElement('button');
    button.type = 'button';
    button.className = 'cesium-button cesium-toolbar-button cesium-navigation-help-button';
    button.setAttribute('data-bind', 'attr: { title: tooltip },click: command,cesiumSvgPath: { path: _svgPath, width: 32, height: 32 }');
    wrapper.appendChild(button);
    var instructionContainer = document.createElement('div');
    instructionContainer.className = 'cesium-navigation-help';
    instructionContainer.setAttribute('data-bind', 'css: { "cesium-navigation-help-visible" : showInstructions}');
    wrapper.appendChild(instructionContainer);
    var mouseButton = document.createElement('button');
    mouseButton.className = 'cesium-navigation-button cesium-navigation-button-left';
    mouseButton.setAttribute('data-bind', 'click: showClick, css: {"cesium-navigation-button-selected": !_touch, "cesium-navigation-button-unselected": _touch}');
    var mouseIcon = document.createElement('img');
    mouseIcon.src = buildModuleUrl('Widgets/Images/NavigationHelp/Mouse.svg');
    mouseIcon.className = 'cesium-navigation-button-icon';
    mouseIcon.style.width = '25px';
    mouseIcon.style.height = '25px';
    mouseButton.appendChild(mouseIcon);
    mouseButton.appendChild(document.createTextNode('Mouse'));
    var touchButton = document.createElement('button');
    touchButton.className = 'cesium-navigation-button cesium-navigation-button-right';
    touchButton.setAttribute('data-bind', 'click: showTouch, css: {"cesium-navigation-button-selected": _touch, "cesium-navigation-button-unselected": !_touch}');
    var touchIcon = document.createElement('img');
    touchIcon.src = buildModuleUrl('Widgets/Images/NavigationHelp/Touch.svg');
    touchIcon.className = 'cesium-navigation-button-icon';
    touchIcon.style.width = '25px';
    touchIcon.style.height = '25px';
    touchButton.appendChild(touchIcon);
    touchButton.appendChild(document.createTextNode('Touch'));
    instructionContainer.appendChild(mouseButton);
    instructionContainer.appendChild(touchButton);
    var clickInstructions = document.createElement('div');
    clickInstructions.className = 'cesium-click-navigation-help cesium-navigation-help-instructions';
    clickInstructions.setAttribute('data-bind', 'css: { "cesium-click-navigation-help-visible" : !_touch}');
    clickInstructions.innerHTML = '            <table>                <tr>                    <td><img src="' + buildModuleUrl('Widgets/Images/NavigationHelp/MouseLeft.svg') + '" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-pan">Pan view</div>                        <div class="cesium-navigation-help-details">Left click + drag</div>                    </td>                </tr>                <tr>                    <td><img src="' + buildModuleUrl('Widgets/Images/NavigationHelp/MouseRight.svg') + '" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-zoom">Zoom view</div>                        <div class="cesium-navigation-help-details">Right click + drag, or</div>                        <div class="cesium-navigation-help-details">Mouse wheel scroll</div>                    </td>                </tr>                <tr>                    <td><img src="' + buildModuleUrl('Widgets/Images/NavigationHelp/MouseMiddle.svg') + '" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-rotate">Rotate view</div>                        <div class="cesium-navigation-help-details">Middle click + drag, or</div>                        <div class="cesium-navigation-help-details">CTRL + Left click + drag</div>                    </td>                </tr>            </table>';
    instructionContainer.appendChild(clickInstructions);
    var touchInstructions = document.createElement('div');
    touchInstructions.className = 'cesium-touch-navigation-help cesium-navigation-help-instructions';
    touchInstructions.setAttribute('data-bind', 'css: { "cesium-touch-navigation-help-visible" : _touch}');
    touchInstructions.innerHTML = '            <table>                <tr>                    <td><img src="' + buildModuleUrl('Widgets/Images/NavigationHelp/TouchDrag.svg') + '" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-pan">Pan view</div>                        <div class="cesium-navigation-help-details">One finger drag</div>                    </td>                </tr>                <tr>                    <td><img src="' + buildModuleUrl('Widgets/Images/NavigationHelp/TouchZoom.svg') + '" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-zoom">Zoom view</div>                        <div class="cesium-navigation-help-details">Two finger pinch</div>                    </td>                </tr>                <tr>                    <td><img src="' + buildModuleUrl('Widgets/Images/NavigationHelp/TouchTilt.svg') + '" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-rotate">Tilt view</div>                        <div class="cesium-navigation-help-details">Two finger drag, same direction</div>                    </td>                </tr>                <tr>                    <td><img src="' + buildModuleUrl('Widgets/Images/NavigationHelp/TouchRotate.svg') + '" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-tilt">Rotate view</div>                        <div class="cesium-navigation-help-details">Two finger drag, opposite direction</div>                    </td>                </tr>            </table>';
    instructionContainer.appendChild(touchInstructions);
    knockout.applyBindings(viewModel, wrapper);
    this._container = container;
    this._viewModel = viewModel;
    this._wrapper = wrapper;
    this._closeInstructions = function (e) {
        if (!wrapper.contains(e.target)) {
            viewModel.showInstructions = false;
        }
    };
    document.addEventListener('mousedown', this._closeInstructions, true);
    document.addEventListener('touchstart', this._closeInstructions, true);
};
defineProperties(NavigationHelpButton.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
NavigationHelpButton.prototype.isDestroyed = function () {
    return false;
};
NavigationHelpButton.prototype.destroy = function () {
    document.removeEventListener('mousedown', this._closeInstructions, true);
    document.removeEventListener('touchstart', this._closeInstructions, true);
    knockout.cleanNode(this._wrapper);
    this._container.removeChild(this._wrapper);
    return destroyObject(this);
};
module.exports = NavigationHelpButton;
},{"../../Core/DeveloperError":123,"../../Core/buildModuleUrl":239,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../getElement":628,"./NavigationHelpButtonViewModel":616}],616:[function(require,module,exports){
var defineProperties = require('../../Core/defineProperties'), knockout = require('../../ThirdParty/knockout'), createCommand = require('../createCommand');
'use strict';
var NavigationHelpButtonViewModel = function () {
    this.showInstructions = false;
    var that = this;
    this._command = createCommand(function () {
        that.showInstructions = !that.showInstructions;
    });
    this._showClick = createCommand(function () {
        that._touch = false;
    });
    this._showTouch = createCommand(function () {
        that._touch = true;
    });
    this._touch = false;
    this.tooltip = 'Navigation Instructions';
    knockout.track(this, [
        'tooltip',
        'showInstructions',
        '_touch'
    ]);
};
defineProperties(NavigationHelpButtonViewModel.prototype, {
    command: {
        get: function () {
            return this._command;
        }
    },
    showClick: {
        get: function () {
            return this._showClick;
        }
    },
    showTouch: {
        get: function () {
            return this._showTouch;
        }
    }
});
module.exports = NavigationHelpButtonViewModel;
},{"../../Core/defineProperties":244,"../../ThirdParty/knockout":591,"../createCommand":627}],617:[function(require,module,exports){
var defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), getElement = require('../getElement'), SceneModePickerViewModel = require('./SceneModePickerViewModel');
'use strict';
var globePath = 'm 32.401392,4.9330437 c -7.087603,0 -14.096095,2.884602 -19.10793,7.8946843 -5.0118352,5.010083 -7.9296167,11.987468 -7.9296167,19.072999 0,7.085531 2.9177815,14.097848 7.9296167,19.107931 4.837653,4.835961 11.541408,7.631372 18.374354,7.82482 0.05712,0.01231 0.454119,0.139729 0.454119,0.139729 l 0.03493,-0.104797 c 0.08246,7.84e-4 0.162033,0.03493 0.244525,0.03493 0.08304,0 0.161515,-0.03414 0.244526,-0.03493 l 0.03493,0.104797 c 0,0 0.309474,-0.129487 0.349323,-0.139729 6.867765,-0.168094 13.582903,-2.965206 18.444218,-7.82482 2.558195,-2.5573 4.551081,-5.638134 5.903547,-8.977584 1.297191,-3.202966 2.02607,-6.661489 2.02607,-10.130347 0,-6.237309 -2.366261,-12.31219 -6.322734,-17.116794 -0.0034,-0.02316 0.0049,-0.04488 0,-0.06986 -0.01733,-0.08745 -0.104529,-0.278855 -0.104797,-0.279458 -5.31e-4,-0.0012 -0.522988,-0.628147 -0.523984,-0.62878         -3.47e-4,-2.2e-4 -0.133444,-0.03532 -0.244525,-0.06987 C 51.944299,13.447603 51.751076,13.104317 51.474391,12.827728 46.462556,7.8176457 39.488996,4.9330437 32.401392,4.9330437 z m -2.130866,3.5281554 0.104797,9.6762289 c -4.111695,-0.08361 -7.109829,-0.423664 -9.257041,-0.943171 1.198093,-2.269271 2.524531,-4.124404 3.91241,-5.414496 2.167498,-2.0147811 3.950145,-2.8540169 5.239834,-3.3185619 z m 2.794579,0 c 1.280302,0.4754953 3.022186,1.3285948 5.065173,3.2486979 1.424667,1.338973 2.788862,3.303645 3.982275,5.728886 -2.29082,0.403367 -5.381258,0.621049 -8.942651,0.698645 L 33.065105,8.4611991 z m 5.728886,0.2445256 c 4.004072,1.1230822 7.793098,3.1481363 10.724195,6.0782083 0.03468,0.03466 0.07033,0.06991 0.104797,0.104797 -0.45375,0.313891 -0.923054,0.663002 -1.956205,1.082899 -0.647388,0.263114 -1.906242,0.477396 -2.829511,0.733577 -1.382296,-2.988132         -3.027146,-5.368585 -4.785716,-7.0213781 -0.422866,-0.397432 -0.835818,-0.6453247 -1.25756,-0.9781032 z m -15.33525,0.7685092 c -0.106753,0.09503 -0.207753,0.145402 -0.31439,0.244526 -1.684973,1.5662541 -3.298068,3.8232211 -4.680919,6.5672591 -0.343797,-0.14942 -1.035052,-0.273198 -1.292493,-0.419186 -0.956528,-0.542427 -1.362964,-1.022024 -1.537018,-1.292493 -0.0241,-0.03745 -0.01868,-0.0401 -0.03493,-0.06986 2.250095,-2.163342 4.948824,-3.869984 7.859752,-5.0302421 z m -9.641296,7.0912431 c 0.464973,0.571618 0.937729,1.169056 1.956205,1.746612 0.349907,0.198425 1.107143,0.335404 1.537018,0.523983 -1.20166,3.172984 -1.998037,7.051901 -2.165798,11.772162 C 14.256557,30.361384 12.934823,30.161483 12.280427,29.90959 10.644437,29.279855 9.6888882,28.674891 9.1714586,28.267775 8.6540289,27.860658 8.6474751,27.778724 8.6474751,27.778724 l -0.069864,0.03493 C 9.3100294,23.691285         11.163248,19.798527 13.817445,16.565477 z m 37.552149,0.523984 c 2.548924,3.289983 4.265057,7.202594 4.890513,11.318043 -0.650428,0.410896 -1.756876,1.001936 -3.563088,1.606882 -1.171552,0.392383 -3.163859,0.759153 -4.960377,1.117832 -0.04367,-4.752703 -0.784809,-8.591423 -1.88634,-11.807094 0.917574,-0.263678 2.170552,-0.486495 2.864443,-0.76851 1.274693,-0.518066 2.003942,-1.001558 2.654849,-1.467153 z m -31.439008,2.619917 c 2.487341,0.672766 5.775813,1.137775 10.479669,1.222628 l 0.104797,10.689263 0,0.03493 0,0.733577 c -5.435005,-0.09059 -9.512219,-0.519044 -12.610536,-1.117831 0.106127,-4.776683 0.879334,-8.55791 2.02607,-11.562569 z m 23.264866,0.31439 c 1.073459,3.067541 1.833795,6.821314 1.816476,11.702298 -3.054474,0.423245 -7.062018,0.648559 -11.702298,0.698644 l 0,-0.838373 -0.104796,-10.654331 c 4.082416,-0.0864 7.404468,-0.403886 9.990618,-0.908238 z         M 8.2632205,30.922625 c 0.7558676,0.510548 1.5529563,1.013339 3.0041715,1.57195 0.937518,0.360875 2.612202,0.647642 3.91241,0.978102 0.112814,3.85566 0.703989,7.107756 1.606883,9.920754 -1.147172,-0.324262 -2.644553,-0.640648 -3.423359,-0.978102 -1.516688,-0.657177 -2.386627,-1.287332 -2.864443,-1.71168 -0.477816,-0.424347 -0.489051,-0.489051 -0.489051,-0.489051 L 9.8002387,40.319395 C 8.791691,37.621767 8.1584238,34.769583 8.1584238,31.900727 c 0,-0.330153 0.090589,-0.648169 0.1047967,-0.978102 z m 48.2763445,0.419186 c 0.0047,0.188973 0.06986,0.36991 0.06986,0.558916 0,2.938869 -0.620228,5.873558 -1.676747,8.628261 -0.07435,0.07583 -0.06552,0.07411 -0.454119,0.349323 -0.606965,0.429857 -1.631665,1.042044 -3.318562,1.676747 -1.208528,0.454713 -3.204964,0.850894 -5.135038,1.25756 0.84593,-2.765726 1.41808,-6.005357 1.606883,-9.815957 2.232369,-0.413371 4.483758,-0.840201         5.938479,-1.327425 1.410632,-0.472457 2.153108,-0.89469 2.96924,-1.327425 z m -38.530252,2.864443 c 3.208141,0.56697 7.372279,0.898588 12.575603,0.978103 l 0.174662,9.885821 c -4.392517,-0.06139 -8.106722,-0.320566 -10.863925,-0.803441 -1.051954,-2.664695 -1.692909,-6.043794 -1.88634,-10.060483 z m 26.793022,0.31439 c -0.246298,3.923551 -0.877762,7.263679 -1.816476,9.885822 -2.561957,0.361954 -5.766249,0.560708 -9.431703,0.62878 l -0.174661,-9.815957 c 4.491734,-0.04969 8.334769,-0.293032 11.42284,-0.698645 z M 12.035901,44.860585 c 0.09977,0.04523 0.105535,0.09465 0.209594,0.139729 1.337656,0.579602 3.441099,1.058072 5.589157,1.537018 1.545042,3.399208 3.548524,5.969402 5.589157,7.789888 -3.034411,-1.215537 -5.871615,-3.007978 -8.174142,-5.309699 -1.245911,-1.245475 -2.271794,-2.662961 -3.213766,-4.156936 z m 40.69605,0 c -0.941972,1.493975 -1.967855,2.911461         -3.213765,4.156936 -2.74253,2.741571 -6.244106,4.696717 -9.955686,5.868615 0.261347,-0.241079 0.507495,-0.394491 0.768509,-0.663713 1.674841,-1.727516 3.320792,-4.181056 4.645987,-7.265904 2.962447,-0.503021 5.408965,-1.122293 7.161107,-1.781544 0.284034,-0.106865 0.337297,-0.207323 0.593848,-0.31439 z m -31.404076,2.305527 c 2.645807,0.376448 5.701178,0.649995 9.466635,0.698645 l 0.139729,7.789888 c -1.38739,-0.480844 -3.316218,-1.29837 -5.659022,-3.388427 -1.388822,-1.238993 -2.743668,-3.0113 -3.947342,-5.100106 z m 20.365491,0.104797 c -1.04872,2.041937 -2.174337,3.779068 -3.353494,4.995309 -1.853177,1.911459 -3.425515,2.82679 -4.611055,3.353494 l -0.139729,-7.789887 c 3.13091,-0.05714 5.728238,-0.278725 8.104278,-0.558916 z';
var flatMapPath = 'm 2.9825053,17.550598 0,1.368113 0,26.267766 0,1.368113 1.36811,0 54.9981397,0 1.36811,0 0,-1.368113 0,-26.267766 0,-1.368113 -1.36811,0 -54.9981397,0 -1.36811,0 z m 2.73623,2.736226 10.3292497,0 0,10.466063 -10.3292497,0 0,-10.466063 z m 13.0654697,0 11.69737,0 0,10.466063 -11.69737,0 0,-10.466063 z m 14.43359,0 11.69737,0 0,10.466063 -11.69737,0 0,-10.466063 z m 14.43359,0 10.32926,0 0,10.466063 -10.32926,0 0,-10.466063 z m -41.9326497,13.202288 10.3292497,0 0,10.329252 -10.3292497,0 0,-10.329252 z m 13.0654697,0 11.69737,0 0,10.329252 -11.69737,0 0,-10.329252 z m 14.43359,0 11.69737,0 0,10.329252 -11.69737,0 0,-10.329252 z m 14.43359,0 10.32926,0 0,10.329252 -10.32926,0 0,-10.329252 z';
var columbusViewPath = 'm 14.723969,17.675598 -0.340489,0.817175 -11.1680536,26.183638 -0.817175,1.872692 2.076986,0 54.7506996,0 2.07698,0 -0.81717,-1.872692 -11.16805,-26.183638 -0.34049,-0.817175 -0.91933,0 -32.414586,0 -0.919322,0 z m 1.838643,2.723916 6.196908,0 -2.928209,10.418977 -7.729111,0 4.460412,-10.418977 z m 9.02297,0 4.903049,0 0,10.418977 -7.831258,0 2.928209,-10.418977 z m 7.626964,0 5.584031,0 2.62176,10.418977 -8.205791,0 0,-10.418977 z m 8.410081,0 5.51593,0 4.46042,10.418977 -7.38863,0 -2.58772,-10.418977 z m -30.678091,13.142892 8.103649,0 -2.89416,10.282782 -9.6018026,0 4.3923136,-10.282782 z m 10.929711,0 8.614384,0 0,10.282782 -11.508544,0 2.89416,-10.282782 z m 11.338299,0 8.852721,0 2.58772,10.282782 -11.440441,0 0,-10.282782 z m 11.678781,0 7.86531,0 4.39231,10.282782 -9.6699,0 -2.58772,-10.282782 z';
var SceneModePicker = function (container, scene, duration) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    container = getElement(container);
    var viewModel = new SceneModePickerViewModel(scene, duration);
    viewModel._globePath = globePath;
    viewModel._flatMapPath = flatMapPath;
    viewModel._columbusViewPath = columbusViewPath;
    var wrapper = document.createElement('span');
    wrapper.className = 'cesium-sceneModePicker-wrapper cesium-toolbar-button';
    container.appendChild(wrapper);
    var button = document.createElement('button');
    button.type = 'button';
    button.className = 'cesium-button cesium-toolbar-button';
    button.setAttribute('data-bind', 'css: { "cesium-sceneModePicker-button2D": sceneMode === _sceneMode.SCENE2D,       "cesium-sceneModePicker-button3D": sceneMode === _sceneMode.SCENE3D,       "cesium-sceneModePicker-buttonColumbusView": sceneMode === _sceneMode.COLUMBUS_VIEW,       "cesium-sceneModePicker-selected": dropDownVisible },attr: { title: selectedTooltip },click: toggleDropDown');
    button.innerHTML = '<!-- ko cesiumSvgPath: { path: _globePath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-icon3D" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _flatMapPath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-icon2D" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _columbusViewPath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-iconColumbusView" } --><!-- /ko -->';
    wrapper.appendChild(button);
    var morphTo3DButton = document.createElement('button');
    morphTo3DButton.type = 'button';
    morphTo3DButton.className = 'cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon';
    morphTo3DButton.setAttribute('data-bind', 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE3D)) || (!dropDownVisible && (sceneMode === _sceneMode.SCENE3D)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE3D,       "cesium-sceneModePicker-hidden" : !dropDownVisible },attr: { title: tooltip3D },click: morphTo3D,cesiumSvgPath: { path: _globePath, width: 64, height: 64 }');
    wrapper.appendChild(morphTo3DButton);
    var morphTo2DButton = document.createElement('button');
    morphTo2DButton.type = 'button';
    morphTo2DButton.className = 'cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon';
    morphTo2DButton.setAttribute('data-bind', 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE2D)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE2D,       "cesium-sceneModePicker-hidden" : !dropDownVisible },attr: { title: tooltip2D },click: morphTo2D,cesiumSvgPath: { path: _flatMapPath, width: 64, height: 64 }');
    wrapper.appendChild(morphTo2DButton);
    var morphToCVButton = document.createElement('button');
    morphToCVButton.type = 'button';
    morphToCVButton.className = 'cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon';
    morphToCVButton.setAttribute('data-bind', 'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.COLUMBUS_VIEW)) || (!dropDownVisible && (sceneMode === _sceneMode.COLUMBUS_VIEW)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.COLUMBUS_VIEW,       "cesium-sceneModePicker-hidden" : !dropDownVisible},attr: { title: tooltipColumbusView },click: morphToColumbusView,cesiumSvgPath: { path: _columbusViewPath, width: 64, height: 64 }');
    wrapper.appendChild(morphToCVButton);
    knockout.applyBindings(viewModel, wrapper);
    this._viewModel = viewModel;
    this._container = container;
    this._wrapper = wrapper;
    this._closeDropDown = function (e) {
        if (!wrapper.contains(e.target)) {
            viewModel.dropDownVisible = false;
        }
    };
    document.addEventListener('mousedown', this._closeDropDown, true);
    document.addEventListener('touchstart', this._closeDropDown, true);
};
defineProperties(SceneModePicker.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
SceneModePicker.prototype.isDestroyed = function () {
    return false;
};
SceneModePicker.prototype.destroy = function () {
    this._viewModel.destroy();
    document.removeEventListener('mousedown', this._closeDropDown, true);
    document.removeEventListener('touchstart', this._closeDropDown, true);
    knockout.cleanNode(this._wrapper);
    this._container.removeChild(this._wrapper);
    return destroyObject(this);
};
module.exports = SceneModePicker;
},{"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../getElement":628,"./SceneModePickerViewModel":618}],618:[function(require,module,exports){
var defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), EventHelper = require('../../Core/EventHelper'), SceneMode = require('../../Scene/SceneMode'), knockout = require('../../ThirdParty/knockout'), createCommand = require('../createCommand');
'use strict';
var SceneModePickerViewModel = function (scene, duration) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    this._scene = scene;
    var that = this;
    var morphStart = function (transitioner, oldMode, newMode, isMorphing) {
        that.sceneMode = newMode;
        that.dropDownVisible = false;
    };
    this._eventHelper = new EventHelper();
    this._eventHelper.add(scene.morphStart, morphStart);
    this._duration = defaultValue(duration, 2);
    this.sceneMode = scene.mode;
    this.dropDownVisible = false;
    this.tooltip2D = '2D';
    this.tooltip3D = '3D';
    this.tooltipColumbusView = 'Columbus View';
    knockout.track(this, [
        'sceneMode',
        'dropDownVisible',
        'tooltip2D',
        'tooltip3D',
        'tooltipColumbusView'
    ]);
    this.selectedTooltip = undefined;
    knockout.defineProperty(this, 'selectedTooltip', function () {
        var mode = that.sceneMode;
        if (mode === SceneMode.SCENE2D) {
            return that.tooltip2D;
        }
        if (mode === SceneMode.SCENE3D) {
            return that.tooltip3D;
        }
        return that.tooltipColumbusView;
    });
    this._toggleDropDown = createCommand(function () {
        that.dropDownVisible = !that.dropDownVisible;
    });
    this._morphTo2D = createCommand(function () {
        scene.morphTo2D(that._duration);
    });
    this._morphTo3D = createCommand(function () {
        scene.morphTo3D(that._duration);
    });
    this._morphToColumbusView = createCommand(function () {
        scene.morphToColumbusView(that._duration);
    });
    this._sceneMode = SceneMode;
};
defineProperties(SceneModePickerViewModel.prototype, {
    scene: {
        get: function () {
            return this._scene;
        }
    },
    duration: {
        get: function () {
            return this._duration;
        },
        set: function (value) {
            if (value < 0) {
                throw new DeveloperError('duration value must be positive.');
            }
            this._duration = value;
        }
    },
    toggleDropDown: {
        get: function () {
            return this._toggleDropDown;
        }
    },
    morphTo2D: {
        get: function () {
            return this._morphTo2D;
        }
    },
    morphTo3D: {
        get: function () {
            return this._morphTo3D;
        }
    },
    morphToColumbusView: {
        get: function () {
            return this._morphToColumbusView;
        }
    }
});
SceneModePickerViewModel.prototype.isDestroyed = function () {
    return false;
};
SceneModePickerViewModel.prototype.destroy = function () {
    this._eventHelper.removeAll();
    destroyObject(this);
};
module.exports = SceneModePickerViewModel;
},{"../../Core/DeveloperError":123,"../../Core/EventHelper":139,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../Scene/SceneMode":438,"../../ThirdParty/knockout":591,"../createCommand":627}],619:[function(require,module,exports){
var defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), knockout = require('../../ThirdParty/knockout'), getElement = require('../getElement'), SelectionIndicatorViewModel = require('./SelectionIndicatorViewModel');
'use strict';
var SelectionIndicator = function (container, scene) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    container = getElement(container);
    this._container = container;
    var el = document.createElement('div');
    el.className = 'cesium-selection-wrapper';
    el.setAttribute('data-bind', 'style: { "top" : _screenPositionY, "left" : _screenPositionX },css: { "cesium-selection-wrapper-visible" : isVisible }');
    container.appendChild(el);
    this._element = el;
    var svgNS = 'http://www.w3.org/2000/svg';
    var path = 'M -34 -34 L -34 -11.25 L -30 -15.25 L -30 -30 L -15.25 -30 L -11.25 -34 L -34 -34 z M 11.25 -34 L 15.25 -30 L 30 -30 L 30 -15.25 L 34 -11.25 L 34 -34 L 11.25 -34 z M -34 11.25 L -34 34 L -11.25 34 L -15.25 30 L -30 30 L -30 15.25 L -34 11.25 z M 34 11.25 L 30 15.25 L 30 30 L 15.25 30 L 11.25 34 L 34 34 L 34 11.25 z';
    var svg = document.createElementNS(svgNS, 'svg:svg');
    svg.setAttribute('width', 160);
    svg.setAttribute('height', 160);
    svg.setAttribute('viewBox', '0 0 160 160');
    var group = document.createElementNS(svgNS, 'g');
    group.setAttribute('transform', 'translate(80,80)');
    svg.appendChild(group);
    var pathElement = document.createElementNS(svgNS, 'path');
    pathElement.setAttribute('data-bind', 'attr: { transform: _transform }');
    pathElement.setAttribute('d', path);
    group.appendChild(pathElement);
    el.appendChild(svg);
    var viewModel = new SelectionIndicatorViewModel(scene, this._element, this._container);
    this._viewModel = viewModel;
    knockout.applyBindings(this._viewModel, this._element);
};
defineProperties(SelectionIndicator.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    viewModel: {
        get: function () {
            return this._viewModel;
        }
    }
});
SelectionIndicator.prototype.isDestroyed = function () {
    return false;
};
SelectionIndicator.prototype.destroy = function () {
    var container = this._container;
    knockout.cleanNode(this._element);
    container.removeChild(this._element);
    return destroyObject(this);
};
module.exports = SelectionIndicator;
},{"../../Core/DeveloperError":123,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../ThirdParty/knockout":591,"../getElement":628,"./SelectionIndicatorViewModel":620}],620:[function(require,module,exports){
var Cartesian2 = require('../../Core/Cartesian2'), defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), DeveloperError = require('../../Core/DeveloperError'), EasingFunction = require('../../Core/EasingFunction'), SceneTransforms = require('../../Scene/SceneTransforms'), knockout = require('../../ThirdParty/knockout');
'use strict';
var screenSpacePos = new Cartesian2();
var offScreen = '-1000px';
var SelectionIndicatorViewModel = function (scene, selectionIndicatorElement, container) {
    if (!defined(scene)) {
        throw new DeveloperError('scene is required.');
    }
    if (!defined(selectionIndicatorElement)) {
        throw new DeveloperError('selectionIndicatorElement is required.');
    }
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    this._scene = scene;
    this._screenPositionX = offScreen;
    this._screenPositionY = offScreen;
    this._tweens = scene.tweens;
    this._container = defaultValue(container, document.body);
    this._selectionIndicatorElement = selectionIndicatorElement;
    this._scale = 1;
    this.position = undefined;
    this.showSelection = false;
    knockout.track(this, [
        'position',
        '_screenPositionX',
        '_screenPositionY',
        '_scale',
        'showSelection'
    ]);
    this.isVisible = undefined;
    knockout.defineProperty(this, 'isVisible', {
        get: function () {
            return this.showSelection && defined(this.position);
        }
    });
    knockout.defineProperty(this, '_transform', {
        get: function () {
            return 'scale(' + this._scale + ')';
        }
    });
    this.computeScreenSpacePosition = function (position, result) {
        return SceneTransforms.wgs84ToWindowCoordinates(scene, position, result);
    };
};
SelectionIndicatorViewModel.prototype.update = function () {
    if (this.showSelection && defined(this.position)) {
        var screenPosition = this.computeScreenSpacePosition(this.position, screenSpacePos);
        if (!defined(screenPosition)) {
            this._screenPositionX = offScreen;
            this._screenPositionY = offScreen;
        } else {
            var container = this._container;
            var containerWidth = container.parentNode.clientWidth;
            var containerHeight = container.parentNode.clientHeight;
            var indicatorSize = this._selectionIndicatorElement.clientWidth;
            var halfSize = indicatorSize * 0.5;
            screenPosition.x = Math.min(Math.max(screenPosition.x, -indicatorSize), containerWidth + indicatorSize) - halfSize;
            screenPosition.y = Math.min(Math.max(screenPosition.y, -indicatorSize), containerHeight + indicatorSize) - halfSize;
            this._screenPositionX = Math.floor(screenPosition.x + 0.25) + 'px';
            this._screenPositionY = Math.floor(screenPosition.y + 0.25) + 'px';
        }
    }
};
SelectionIndicatorViewModel.prototype.animateAppear = function () {
    this._tweens.addProperty({
        object: this,
        property: '_scale',
        startValue: 2,
        stopValue: 1,
        duration: 0.8,
        easingFunction: EasingFunction.EXPONENTIAL_OUT
    });
};
SelectionIndicatorViewModel.prototype.animateDepart = function () {
    this._tweens.addProperty({
        object: this,
        property: '_scale',
        startValue: this._scale,
        stopValue: 1.5,
        duration: 0.8,
        easingFunction: EasingFunction.EXPONENTIAL_OUT
    });
};
defineProperties(SelectionIndicatorViewModel.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    selectionIndicatorElement: {
        get: function () {
            return this._selectionIndicatorElement;
        }
    },
    scene: {
        get: function () {
            return this._scene;
        }
    }
});
module.exports = SelectionIndicatorViewModel;
},{"../../Core/Cartesian2":101,"../../Core/DeveloperError":123,"../../Core/EasingFunction":126,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Scene/SceneTransforms":439,"../../ThirdParty/knockout":591}],621:[function(require,module,exports){
'use strict';
var svgNS = 'http://www.w3.org/2000/svg';
var svgClassName = 'cesium-svgPath-svg';
var SvgPathBindingHandler = {
        register: function (knockout) {
            knockout.bindingHandlers.cesiumSvgPath = {
                init: function (element, valueAccessor) {
                    var svg = document.createElementNS(svgNS, 'svg:svg');
                    svg.setAttribute('class', svgClassName);
                    var pathElement = document.createElementNS(svgNS, 'path');
                    svg.appendChild(pathElement);
                    knockout.virtualElements.setDomNodeChildren(element, [svg]);
                    knockout.computed({
                        read: function () {
                            var value = knockout.unwrap(valueAccessor());
                            pathElement.setAttribute('d', knockout.unwrap(value.path));
                            var pathWidth = knockout.unwrap(value.width);
                            var pathHeight = knockout.unwrap(value.height);
                            svg.setAttribute('width', pathWidth);
                            svg.setAttribute('height', pathHeight);
                            svg.setAttribute('viewBox', '0 0 ' + pathWidth + ' ' + pathHeight);
                            var fillRule = knockout.unwrap(value['fill-rule']);
                            if (fillRule) {
                                svg.setAttribute('fill-rule', fillRule);
                            }
                            if (value.css) {
                                svg.setAttribute('class', svgClassName + ' ' + knockout.unwrap(value.css));
                            }
                        },
                        disposeWhenNodeIsRemoved: element
                    });
                    return { controlsDescendantBindings: true };
                }
            };
            knockout.virtualElements.allowedBindings.cesiumSvgPath = true;
        }
    };
module.exports = SvgPathBindingHandler;
},{}],622:[function(require,module,exports){
var ClockRange = require('../../Core/ClockRange'), defined = require('../../Core/defined'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), JulianDate = require('../../Core/JulianDate'), getElement = require('../getElement'), TimelineHighlightRange = require('./TimelineHighlightRange'), TimelineTrack = require('./TimelineTrack');
'use strict';
var timelineWheelDelta = 1000000000000;
var timelineMouseMode = {
        none: 0,
        scrub: 1,
        slide: 2,
        zoom: 3,
        touchOnly: 4
    };
var timelineTouchMode = {
        none: 0,
        scrub: 1,
        slideZoom: 2,
        singleTap: 3,
        ignore: 4
    };
var timelineTicScales = [
        0.001,
        0.002,
        0.005,
        0.01,
        0.02,
        0.05,
        0.1,
        0.25,
        0.5,
        1,
        2,
        5,
        10,
        15,
        30,
        60,
        120,
        300,
        600,
        900,
        1800,
        3600,
        7200,
        14400,
        21600,
        43200,
        86400,
        172800,
        345600,
        604800,
        1296000,
        2592000,
        5184000,
        7776000,
        15552000,
        31536000,
        63072000,
        126144000,
        157680000,
        315360000,
        630720000,
        1261440000,
        1576800000,
        3153600000,
        6307200000,
        12614400000,
        15768000000,
        31536000000
    ];
var timelineMonthNames = [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
    ];
var Timeline = function (container, clock) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    if (!defined(clock)) {
        throw new DeveloperError('clock is required.');
    }
    container = getElement(container);
    this.container = container;
    var topDiv = document.createElement('div');
    topDiv.className = 'cesium-timeline-main';
    container.appendChild(topDiv);
    this._topDiv = topDiv;
    this._endJulian = undefined;
    this._epochJulian = undefined;
    this._lastXPos = undefined;
    this._scrubElement = undefined;
    this._startJulian = undefined;
    this._timeBarSecondsSpan = undefined;
    this._clock = clock;
    this._scrubJulian = clock.currentTime;
    this._mainTicSpan = -1;
    this._mouseMode = timelineMouseMode.none;
    this._touchMode = timelineTouchMode.none;
    this._touchState = {
        centerX: 0,
        spanX: 0
    };
    this._mouseX = 0;
    this._timelineDrag = 0;
    this._timelineDragLocation = undefined;
    this._lastHeight = undefined;
    this._lastWidth = undefined;
    this._topDiv.innerHTML = '<div class="cesium-timeline-bar"></div><div class="cesium-timeline-trackContainer">' + '<canvas class="cesium-timeline-tracks" width="10" height="1">' + '</canvas></div><div class="cesium-timeline-needle"></div><span class="cesium-timeline-ruler"></span>';
    this._timeBarEle = this._topDiv.childNodes[0];
    this._trackContainer = this._topDiv.childNodes[1];
    this._trackListEle = this._topDiv.childNodes[1].childNodes[0];
    this._needleEle = this._topDiv.childNodes[2];
    this._rulerEle = this._topDiv.childNodes[3];
    this._context = this._trackListEle.getContext('2d');
    this._trackList = [];
    this._highlightRanges = [];
    this.zoomTo(clock.startTime, clock.stopTime);
    this._onMouseDown = createMouseDownCallback(this);
    this._onMouseUp = createMouseUpCallback(this);
    this._onMouseMove = createMouseMoveCallback(this);
    this._onMouseWheel = createMouseWheelCallback(this);
    this._onTouchStart = createTouchStartCallback(this);
    this._onTouchMove = createTouchMoveCallback(this);
    this._onTouchEnd = createTouchEndCallback(this);
    var timeBarEle = this._timeBarEle;
    document.addEventListener('mouseup', this._onMouseUp, false);
    document.addEventListener('mousemove', this._onMouseMove, false);
    timeBarEle.addEventListener('mousedown', this._onMouseDown, false);
    timeBarEle.addEventListener('DOMMouseScroll', this._onMouseWheel, false);
    timeBarEle.addEventListener('mousewheel', this._onMouseWheel, false);
    timeBarEle.addEventListener('touchstart', this._onTouchStart, false);
    timeBarEle.addEventListener('touchmove', this._onTouchMove, false);
    timeBarEle.addEventListener('touchend', this._onTouchEnd, false);
    this._topDiv.oncontextmenu = function () {
        return false;
    };
    clock.onTick.addEventListener(this.updateFromClock, this);
    this.updateFromClock();
};
Timeline.prototype.addEventListener = function (type, listener, useCapture) {
    this._topDiv.addEventListener(type, listener, useCapture);
};
Timeline.prototype.removeEventListener = function (type, listener, useCapture) {
    this._topDiv.removeEventListener(type, listener, useCapture);
};
Timeline.prototype.isDestroyed = function () {
    return false;
};
Timeline.prototype.destroy = function () {
    this._clock.onTick.removeEventListener(this.updateFromClock, this);
    document.removeEventListener('mouseup', this._onMouseUp, false);
    document.removeEventListener('mousemove', this._onMouseMove, false);
    var timeBarEle = this._timeBarEle;
    timeBarEle.removeEventListener('mousedown', this._onMouseDown, false);
    timeBarEle.removeEventListener('DOMMouseScroll', this._onMouseWheel, false);
    timeBarEle.removeEventListener('mousewheel', this._onMouseWheel, false);
    timeBarEle.removeEventListener('touchstart', this._onTouchStart, false);
    timeBarEle.removeEventListener('touchmove', this._onTouchMove, false);
    timeBarEle.removeEventListener('touchend', this._onTouchEnd, false);
    this.container.removeChild(this._topDiv);
    destroyObject(this);
};
Timeline.prototype.addHighlightRange = function (color, heightInPx, base) {
    var newHighlightRange = new TimelineHighlightRange(color, heightInPx, base);
    this._highlightRanges.push(newHighlightRange);
    this.resize();
    return newHighlightRange;
};
Timeline.prototype.addTrack = function (interval, heightInPx, color, backgroundColor) {
    var newTrack = new TimelineTrack(interval, heightInPx, color, backgroundColor);
    this._trackList.push(newTrack);
    this._lastHeight = undefined;
    this.resize();
    return newTrack;
};
Timeline.prototype.zoomTo = function (startTime, stopTime) {
    if (!defined(startTime)) {
        throw new DeveloperError('startTime is required.');
    }
    if (!defined(stopTime)) {
        throw new DeveloperError('stopTime is required');
    }
    if (JulianDate.lessThanOrEquals(stopTime, startTime)) {
        throw new DeveloperError('Start time must come before end time.');
    }
    this._startJulian = startTime;
    this._endJulian = stopTime;
    this._timeBarSecondsSpan = JulianDate.secondsDifference(stopTime, startTime);
    if (this._clock && this._clock.clockRange !== ClockRange.UNBOUNDED) {
        var clockStart = this._clock.startTime;
        var clockEnd = this._clock.stopTime;
        var clockSpan = JulianDate.secondsDifference(clockEnd, clockStart);
        var startOffset = JulianDate.secondsDifference(clockStart, this._startJulian);
        var endOffset = JulianDate.secondsDifference(clockEnd, this._endJulian);
        if (this._timeBarSecondsSpan >= clockSpan) {
            this._timeBarSecondsSpan = clockSpan;
            this._startJulian = this._clock.startTime;
            this._endJulian = this._clock.stopTime;
        } else if (startOffset > 0) {
            this._endJulian = JulianDate.addSeconds(this._endJulian, startOffset, new JulianDate());
            this._startJulian = clockStart;
            this._timeBarSecondsSpan = JulianDate.secondsDifference(this._endJulian, this._startJulian);
        } else if (endOffset < 0) {
            this._startJulian = JulianDate.addSeconds(this._startJulian, endOffset, new JulianDate());
            this._endJulian = clockEnd;
            this._timeBarSecondsSpan = JulianDate.secondsDifference(this._endJulian, this._startJulian);
        }
    }
    this._makeTics();
    var evt = document.createEvent('Event');
    evt.initEvent('setzoom', true, true);
    evt.startJulian = this._startJulian;
    evt.endJulian = this._endJulian;
    evt.epochJulian = this._epochJulian;
    evt.totalSpan = this._timeBarSecondsSpan;
    evt.mainTicSpan = this._mainTicSpan;
    this._topDiv.dispatchEvent(evt);
};
Timeline.prototype.zoomFrom = function (amount) {
    var centerSec = JulianDate.secondsDifference(this._scrubJulian, this._startJulian);
    if (amount > 1 || centerSec < 0 || centerSec > this._timeBarSecondsSpan) {
        centerSec = this._timeBarSecondsSpan * 0.5;
    } else {
        centerSec += centerSec - this._timeBarSecondsSpan * 0.5;
    }
    var centerSecFlip = this._timeBarSecondsSpan - centerSec;
    this.zoomTo(JulianDate.addSeconds(this._startJulian, centerSec - centerSec * amount, new JulianDate()), JulianDate.addSeconds(this._endJulian, centerSecFlip * amount - centerSecFlip, new JulianDate()));
};
function twoDigits(num) {
    return num < 10 ? '0' + num.toString() : num.toString();
}
Timeline.prototype.makeLabel = function (time) {
    var gregorian = JulianDate.toGregorianDate(time);
    var millisecond = gregorian.millisecond, millisecondString = ' UTC';
    if (millisecond > 0 && this._timeBarSecondsSpan < 3600) {
        millisecondString = Math.floor(millisecond).toString();
        while (millisecondString.length < 3) {
            millisecondString = '0' + millisecondString;
        }
        millisecondString = '.' + millisecondString;
    }
    return timelineMonthNames[gregorian.month - 1] + ' ' + gregorian.day + ' ' + gregorian.year + ' ' + twoDigits(gregorian.hour) + ':' + twoDigits(gregorian.minute) + ':' + twoDigits(gregorian.second) + millisecondString;
};
Timeline.prototype.smallestTicInPixels = 7;
Timeline.prototype._makeTics = function () {
    var timeBar = this._timeBarEle;
    var seconds = JulianDate.secondsDifference(this._scrubJulian, this._startJulian);
    var xPos = Math.round(seconds * this._topDiv.clientWidth / this._timeBarSecondsSpan);
    var scrubX = xPos - 8, tic;
    var widget = this;
    this._needleEle.style.left = xPos.toString() + 'px';
    var tics = '';
    var minimumDuration = 0.01;
    var maximumDuration = 31536000000;
    var epsilon = 1e-10;
    var minSize = 0;
    var duration = this._timeBarSecondsSpan;
    if (duration < minimumDuration) {
        duration = minimumDuration;
        this._timeBarSecondsSpan = minimumDuration;
        this._endJulian = JulianDate.addSeconds(this._startJulian, minimumDuration, new JulianDate());
    } else if (duration > maximumDuration) {
        duration = maximumDuration;
        this._timeBarSecondsSpan = maximumDuration;
        this._endJulian = JulianDate.addSeconds(this._startJulian, maximumDuration, new JulianDate());
    }
    var timeBarWidth = this._timeBarEle.clientWidth;
    if (timeBarWidth < 10) {
        timeBarWidth = 10;
    }
    var startJulian = this._startJulian;
    var epsilonTime = Math.min(duration / timeBarWidth * 0.00001, 0.4);
    var epochJulian;
    if (duration > 315360000) {
        epochJulian = JulianDate.fromIso8601(JulianDate.toDate(startJulian).toISOString().substring(0, 2) + '00-01-01T00:00:00Z');
    } else if (duration > 31536000) {
        epochJulian = JulianDate.fromIso8601(JulianDate.toDate(startJulian).toISOString().substring(0, 3) + '0-01-01T00:00:00Z');
    } else if (duration > 86400) {
        epochJulian = JulianDate.fromIso8601(JulianDate.toDate(startJulian).toISOString().substring(0, 4) + '-01-01T00:00:00Z');
    } else {
        epochJulian = JulianDate.fromIso8601(JulianDate.toDate(startJulian).toISOString().substring(0, 10) + 'T00:00:00Z');
    }
    var startTime = JulianDate.secondsDifference(this._startJulian, JulianDate.addSeconds(epochJulian, epsilonTime, new JulianDate()));
    var endTime = startTime + duration;
    this._epochJulian = epochJulian;
    function getStartTic(ticScale) {
        return Math.floor(startTime / ticScale) * ticScale;
    }
    function getNextTic(tic, ticScale) {
        return Math.ceil(tic / ticScale + 0.5) * ticScale;
    }
    function getAlpha(time) {
        return (time - startTime) / duration;
    }
    function remainder(x, y) {
        return x - y * Math.round(x / y);
    }
    this._rulerEle.innerHTML = this.makeLabel(JulianDate.addSeconds(this._endJulian, -minimumDuration, new JulianDate()));
    var sampleWidth = this._rulerEle.offsetWidth + 20;
    if (sampleWidth < 30) {
        sampleWidth = 180;
    }
    var origMinSize = minSize;
    minSize -= epsilon;
    var renderState = {
            startTime: startTime,
            startJulian: startJulian,
            epochJulian: epochJulian,
            duration: duration,
            timeBarWidth: timeBarWidth,
            getAlpha: getAlpha
        };
    this._highlightRanges.forEach(function (highlightRange) {
        tics += highlightRange.render(renderState);
    });
    var mainTic = 0, subTic = 0, tinyTic = 0;
    var idealTic = sampleWidth / timeBarWidth;
    if (idealTic > 1) {
        idealTic = 1;
    }
    idealTic *= this._timeBarSecondsSpan;
    var ticIndex = -1, smallestIndex = -1;
    var i, ticScaleLen = timelineTicScales.length;
    for (i = 0; i < ticScaleLen; ++i) {
        var sc = timelineTicScales[i];
        ++ticIndex;
        mainTic = sc;
        if (sc > idealTic && sc > minSize) {
            break;
        }
        if (smallestIndex < 0 && timeBarWidth * (sc / this._timeBarSecondsSpan) >= this.smallestTicInPixels) {
            smallestIndex = ticIndex;
        }
    }
    if (ticIndex > 0) {
        while (ticIndex > 0) {
            --ticIndex;
            if (Math.abs(remainder(mainTic, timelineTicScales[ticIndex])) < 0.00001) {
                if (timelineTicScales[ticIndex] >= minSize) {
                    subTic = timelineTicScales[ticIndex];
                }
                break;
            }
        }
        if (smallestIndex >= 0) {
            while (smallestIndex < ticIndex) {
                if (Math.abs(remainder(subTic, timelineTicScales[smallestIndex])) < 0.00001 && timelineTicScales[smallestIndex] >= minSize) {
                    tinyTic = timelineTicScales[smallestIndex];
                    break;
                }
                ++smallestIndex;
            }
        }
    }
    minSize = origMinSize;
    if (minSize > epsilon && tinyTic < 0.00001 && Math.abs(minSize - mainTic) > epsilon) {
        tinyTic = minSize;
        if (minSize <= mainTic + epsilon) {
            subTic = 0;
        }
    }
    var lastTextLeft = -999999, textWidth;
    if (timeBarWidth * (tinyTic / this._timeBarSecondsSpan) >= 3) {
        for (tic = getStartTic(tinyTic); tic <= endTime; tic = getNextTic(tic, tinyTic)) {
            tics += '<span class="cesium-timeline-ticTiny" style="left: ' + Math.round(timeBarWidth * getAlpha(tic)).toString() + 'px;"></span>';
        }
    }
    if (timeBarWidth * (subTic / this._timeBarSecondsSpan) >= 3) {
        for (tic = getStartTic(subTic); tic <= endTime; tic = getNextTic(tic, subTic)) {
            tics += '<span class="cesium-timeline-ticSub" style="left: ' + Math.round(timeBarWidth * getAlpha(tic)).toString() + 'px;"></span>';
        }
    }
    if (timeBarWidth * (mainTic / this._timeBarSecondsSpan) >= 2) {
        this._mainTicSpan = mainTic;
        endTime += mainTic;
        tic = getStartTic(mainTic);
        var leapSecond = JulianDate.computeTaiMinusUtc(epochJulian);
        while (tic <= endTime) {
            var ticTime = JulianDate.addSeconds(startJulian, tic - startTime, new JulianDate());
            if (mainTic > 2.1) {
                var ticLeap = JulianDate.computeTaiMinusUtc(ticTime);
                if (Math.abs(ticLeap - leapSecond) > 0.1) {
                    tic += ticLeap - leapSecond;
                    ticTime = JulianDate.addSeconds(startJulian, tic - startTime, new JulianDate());
                }
            }
            var ticLeft = Math.round(timeBarWidth * getAlpha(tic));
            var ticLabel = this.makeLabel(ticTime);
            this._rulerEle.innerHTML = ticLabel;
            textWidth = this._rulerEle.offsetWidth;
            if (textWidth < 10) {
                textWidth = sampleWidth;
            }
            var labelLeft = ticLeft - (textWidth / 2 - 1);
            if (labelLeft > lastTextLeft) {
                lastTextLeft = labelLeft + textWidth + 5;
                tics += '<span class="cesium-timeline-ticMain" style="left: ' + ticLeft.toString() + 'px;"></span>' + '<span class="cesium-timeline-ticLabel" style="left: ' + labelLeft.toString() + 'px;">' + ticLabel + '</span>';
            } else {
                tics += '<span class="cesium-timeline-ticSub" style="left: ' + ticLeft.toString() + 'px;"></span>';
            }
            tic = getNextTic(tic, mainTic);
        }
    } else {
        this._mainTicSpan = -1;
    }
    tics += '<span class="cesium-timeline-icon16" style="left:' + scrubX + 'px;bottom:0;background-position: 0px 0px;"></span>';
    timeBar.innerHTML = tics;
    this._scrubElement = timeBar.lastChild;
    this._context.clearRect(0, 0, this._trackListEle.width, this._trackListEle.height);
    renderState.y = 0;
    this._trackList.forEach(function (track) {
        track.render(widget._context, renderState);
        renderState.y += track.height;
    });
};
Timeline.prototype.updateFromClock = function () {
    this._scrubJulian = this._clock.currentTime;
    var scrubElement = this._scrubElement;
    if (defined(this._scrubElement)) {
        var seconds = JulianDate.secondsDifference(this._scrubJulian, this._startJulian);
        var xPos = Math.round(seconds * this._topDiv.clientWidth / this._timeBarSecondsSpan);
        if (this._lastXPos !== xPos) {
            this._lastXPos = xPos;
            scrubElement.style.left = xPos - 8 + 'px';
            this._needleEle.style.left = xPos + 'px';
        }
    }
    if (defined(this._timelineDragLocation)) {
        this._setTimeBarTime(this._timelineDragLocation, this._timelineDragLocation * this._timeBarSecondsSpan / this._topDiv.clientWidth);
        this.zoomTo(JulianDate.addSeconds(this._startJulian, this._timelineDrag, new JulianDate()), JulianDate.addSeconds(this._endJulian, this._timelineDrag, new JulianDate()));
    }
};
Timeline.prototype._setTimeBarTime = function (xPos, seconds) {
    xPos = Math.round(xPos);
    this._scrubJulian = JulianDate.addSeconds(this._startJulian, seconds, new JulianDate());
    if (this._scrubElement) {
        var scrubX = xPos - 8;
        this._scrubElement.style.left = scrubX.toString() + 'px';
        this._needleEle.style.left = xPos.toString() + 'px';
    }
    var evt = document.createEvent('Event');
    evt.initEvent('settime', true, true);
    evt.clientX = xPos;
    evt.timeSeconds = seconds;
    evt.timeJulian = this._scrubJulian;
    evt.clock = this._clock;
    this._topDiv.dispatchEvent(evt);
};
function createMouseDownCallback(timeline) {
    return function (e) {
        if (timeline._mouseMode !== timelineMouseMode.touchOnly) {
            if (e.button === 0) {
                timeline._mouseMode = timelineMouseMode.scrub;
                if (timeline._scrubElement) {
                    timeline._scrubElement.style.backgroundPosition = '-16px 0';
                }
                timeline._onMouseMove(e);
            } else {
                timeline._mouseX = e.clientX;
                if (e.button === 2) {
                    timeline._mouseMode = timelineMouseMode.zoom;
                } else {
                    timeline._mouseMode = timelineMouseMode.slide;
                }
            }
        }
        e.preventDefault();
    };
}
function createMouseUpCallback(timeline) {
    return function (e) {
        timeline._mouseMode = timelineMouseMode.none;
        if (timeline._scrubElement) {
            timeline._scrubElement.style.backgroundPosition = '0px 0px';
        }
        timeline._timelineDrag = 0;
        timeline._timelineDragLocation = undefined;
    };
}
function createMouseMoveCallback(timeline) {
    return function (e) {
        var dx;
        if (timeline._mouseMode === timelineMouseMode.scrub) {
            e.preventDefault();
            var x = e.clientX - timeline._topDiv.getBoundingClientRect().left;
            if (x < 0) {
                timeline._timelineDragLocation = 0;
                timeline._timelineDrag = -0.01 * timeline._timeBarSecondsSpan;
            } else if (x > timeline._topDiv.clientWidth) {
                timeline._timelineDragLocation = timeline._topDiv.clientWidth;
                timeline._timelineDrag = 0.01 * timeline._timeBarSecondsSpan;
            } else {
                timeline._timelineDragLocation = undefined;
                timeline._setTimeBarTime(x, x * timeline._timeBarSecondsSpan / timeline._topDiv.clientWidth);
            }
        } else if (timeline._mouseMode === timelineMouseMode.slide) {
            dx = timeline._mouseX - e.clientX;
            timeline._mouseX = e.clientX;
            if (dx !== 0) {
                var dsec = dx * timeline._timeBarSecondsSpan / timeline._topDiv.clientWidth;
                timeline.zoomTo(JulianDate.addSeconds(timeline._startJulian, dsec, new JulianDate()), JulianDate.addSeconds(timeline._endJulian, dsec, new JulianDate()));
            }
        } else if (timeline._mouseMode === timelineMouseMode.zoom) {
            dx = timeline._mouseX - e.clientX;
            timeline._mouseX = e.clientX;
            if (dx !== 0) {
                timeline.zoomFrom(Math.pow(1.01, dx));
            }
        }
    };
}
function createMouseWheelCallback(timeline) {
    return function (e) {
        var dy = e.wheelDeltaY || e.wheelDelta || -e.detail;
        timelineWheelDelta = Math.max(Math.min(Math.abs(dy), timelineWheelDelta), 1);
        dy /= timelineWheelDelta;
        timeline.zoomFrom(Math.pow(1.05, -dy));
    };
}
function createTouchStartCallback(timeline) {
    return function (e) {
        var len = e.touches.length, seconds, xPos, leftX = timeline._topDiv.getBoundingClientRect().left;
        e.preventDefault();
        timeline._mouseMode = timelineMouseMode.touchOnly;
        if (len === 1) {
            seconds = JulianDate.secondsDifference(timeline._scrubJulian, timeline._startJulian);
            xPos = Math.round(seconds * timeline._topDiv.clientWidth / timeline._timeBarSecondsSpan + leftX);
            if (Math.abs(e.touches[0].clientX - xPos) < 50) {
                timeline._touchMode = timelineTouchMode.scrub;
                if (timeline._scrubElement) {
                    timeline._scrubElement.style.backgroundPosition = len === 1 ? '-16px 0' : '0 0';
                }
            } else {
                timeline._touchMode = timelineTouchMode.singleTap;
                timeline._touchState.centerX = e.touches[0].clientX - leftX;
            }
        } else if (len === 2) {
            timeline._touchMode = timelineTouchMode.slideZoom;
            timeline._touchState.centerX = (e.touches[0].clientX + e.touches[1].clientX) * 0.5 - leftX;
            timeline._touchState.spanX = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
        } else {
            timeline._touchMode = timelineTouchMode.ignore;
        }
    };
}
function createTouchEndCallback(timeline) {
    return function (e) {
        var len = e.touches.length, leftX = timeline._topDiv.getBoundingClientRect().left;
        if (timeline._touchMode === timelineTouchMode.singleTap) {
            timeline._touchMode = timelineTouchMode.scrub;
            timeline._handleTouchMove(e);
        } else if (timeline._touchMode === timelineTouchMode.scrub) {
            timeline._handleTouchMove(e);
        }
        timeline._mouseMode = timelineMouseMode.touchOnly;
        if (len !== 1) {
            timeline._touchMode = len > 0 ? timelineTouchMode.ignore : timelineTouchMode.none;
        } else if (timeline._touchMode === timelineTouchMode.slideZoom) {
            timeline._touchState.centerX = e.touches[0].clientX - leftX;
        }
        if (timeline._scrubElement) {
            timeline._scrubElement.style.backgroundPosition = '0 0';
        }
    };
}
function createTouchMoveCallback(timeline) {
    return function (e) {
        var dx, x, len, newCenter, newSpan, newStartTime, zoom = 1, leftX = timeline._topDiv.getBoundingClientRect().left;
        if (timeline._touchMode === timelineTouchMode.singleTap) {
            timeline._touchMode = timelineTouchMode.slideZoom;
        }
        timeline._mouseMode = timelineMouseMode.touchOnly;
        if (timeline._touchMode === timelineTouchMode.scrub) {
            e.preventDefault();
            if (e.changedTouches.length === 1) {
                x = e.changedTouches[0].clientX - leftX;
                if (x >= 0 && x <= timeline._topDiv.clientWidth) {
                    timeline._setTimeBarTime(x, x * timeline._timeBarSecondsSpan / timeline._topDiv.clientWidth);
                }
            }
        } else if (timeline._touchMode === timelineTouchMode.slideZoom) {
            len = e.touches.length;
            if (len === 2) {
                newCenter = (e.touches[0].clientX + e.touches[1].clientX) * 0.5 - leftX;
                newSpan = Math.abs(e.touches[0].clientX - e.touches[1].clientX);
            } else if (len === 1) {
                newCenter = e.touches[0].clientX - leftX;
                newSpan = 0;
            }
            if (defined(newCenter)) {
                if (newSpan > 0 && timeline._touchState.spanX > 0) {
                    zoom = timeline._touchState.spanX / newSpan;
                    newStartTime = JulianDate.addSeconds(timeline._startJulian, (timeline._touchState.centerX * timeline._timeBarSecondsSpan - newCenter * timeline._timeBarSecondsSpan * zoom) / timeline._topDiv.clientWidth, new JulianDate());
                } else {
                    dx = timeline._touchState.centerX - newCenter;
                    newStartTime = JulianDate.addSeconds(timeline._startJulian, dx * timeline._timeBarSecondsSpan / timeline._topDiv.clientWidth, new JulianDate());
                }
                timeline.zoomTo(newStartTime, JulianDate.addSeconds(newStartTime, timeline._timeBarSecondsSpan * zoom, new JulianDate()));
                timeline._touchState.centerX = newCenter;
                timeline._touchState.spanX = newSpan;
            }
        }
    };
}
Timeline.prototype.resize = function () {
    var width = this.container.clientWidth;
    var height = this.container.clientHeight;
    if (width === this._lastWidth && height === this._lastHeight) {
        return;
    }
    this._trackContainer.style.height = height + 'px';
    var trackListHeight = 1;
    this._trackList.forEach(function (track) {
        trackListHeight += track.height;
    });
    this._trackListEle.style.height = trackListHeight.toString() + 'px';
    this._trackListEle.width = this._trackListEle.clientWidth;
    this._trackListEle.height = trackListHeight;
    this._makeTics();
    this._lastWidth = width;
    this._lastHeight = height;
};
module.exports = Timeline;
},{"../../Core/ClockRange":109,"../../Core/DeveloperError":123,"../../Core/JulianDate":168,"../../Core/defined":245,"../../Core/destroyObject":247,"../getElement":628,"./TimelineHighlightRange":623,"./TimelineTrack":624}],623:[function(require,module,exports){
var defaultValue = require('../../Core/defaultValue'), JulianDate = require('../../Core/JulianDate');
'use strict';
function TimelineHighlightRange(color, heightInPx, base) {
    this._color = color;
    this._height = heightInPx;
    this._base = defaultValue(base, 0);
}
TimelineHighlightRange.prototype.getHeight = function () {
    return this._height;
};
TimelineHighlightRange.prototype.getBase = function () {
    return this._base;
};
TimelineHighlightRange.prototype.getStartTime = function () {
    return this._start;
};
TimelineHighlightRange.prototype.getStopTime = function () {
    return this._stop;
};
TimelineHighlightRange.prototype.setRange = function (start, stop) {
    this._start = start;
    this._stop = stop;
};
TimelineHighlightRange.prototype.render = function (renderState) {
    var range = '';
    if (this._start && this._stop && this._color) {
        var highlightStart = JulianDate.secondsDifference(this._start, renderState.epochJulian);
        var highlightLeft = Math.round(renderState.timeBarWidth * renderState.getAlpha(highlightStart));
        var highlightStop = JulianDate.secondsDifference(this._stop, renderState.epochJulian);
        var highlightWidth = Math.round(renderState.timeBarWidth * renderState.getAlpha(highlightStop)) - highlightLeft;
        if (highlightLeft < 0) {
            highlightWidth += highlightLeft;
            highlightLeft = 0;
        }
        if (highlightLeft + highlightWidth > renderState.timeBarWidth) {
            highlightWidth = renderState.timeBarWidth - highlightLeft;
        }
        if (highlightWidth > 0) {
            range = '<span class="cesium-timeline-highlight" style="left: ' + highlightLeft.toString() + 'px; width: ' + highlightWidth.toString() + 'px; bottom: ' + this._base.toString() + 'px; height: ' + this._height + 'px; background-color: ' + this._color + ';"></span>';
        }
    }
    return range;
};
module.exports = TimelineHighlightRange;
},{"../../Core/JulianDate":168,"../../Core/defaultValue":243}],624:[function(require,module,exports){
var Color = require('../../Core/Color'), defined = require('../../Core/defined'), JulianDate = require('../../Core/JulianDate');
'use strict';
function TimelineTrack(interval, pixelHeight, color, backgroundColor) {
    this.interval = interval;
    this.height = pixelHeight;
    this.color = color || new Color(0.5, 0.5, 0.5, 1);
    this.backgroundColor = backgroundColor || new Color(0, 0, 0, 0);
}
TimelineTrack.prototype.render = function (context, renderState) {
    var startInterval = this.interval.start;
    var stopInterval = this.interval.stop;
    var spanStart = renderState.startJulian;
    var spanStop = JulianDate.addSeconds(renderState.startJulian, renderState.duration, new JulianDate());
    if (JulianDate.lessThan(startInterval, spanStart) && JulianDate.greaterThan(stopInterval, spanStop)) {
        context.fillStyle = this.color.toCssColorString();
        context.fillRect(0, renderState.y, renderState.timeBarWidth, this.height);
    } else if (JulianDate.lessThanOrEquals(startInterval, spanStop) && JulianDate.greaterThanOrEquals(stopInterval, spanStart)) {
        var x;
        var start, stop;
        for (x = 0; x < renderState.timeBarWidth; ++x) {
            var currentTime = JulianDate.addSeconds(renderState.startJulian, x / renderState.timeBarWidth * renderState.duration, new JulianDate());
            if (!defined(start) && JulianDate.greaterThanOrEquals(currentTime, startInterval)) {
                start = x;
            } else if (!defined(stop) && JulianDate.greaterThanOrEquals(currentTime, stopInterval)) {
                stop = x;
            }
        }
        context.fillStyle = this.backgroundColor.toCssColorString();
        context.fillRect(0, renderState.y, renderState.timeBarWidth, this.height);
        if (defined(start)) {
            if (!defined(stop)) {
                stop = renderState.timeBarWidth;
            }
            context.fillStyle = this.color.toCssColorString();
            context.fillRect(start, renderState.y, Math.max(stop - start, 1), this.height);
        }
    }
};
module.exports = TimelineTrack;
},{"../../Core/Color":111,"../../Core/JulianDate":168,"../../Core/defined":245}],625:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), knockout = require('../ThirdParty/knockout');
'use strict';
var ToggleButtonViewModel = function (command, options) {
    if (!defined(command)) {
        throw new DeveloperError('command is required.');
    }
    this._command = command;
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.toggled = defaultValue(options.toggled, false);
    this.tooltip = defaultValue(options.tooltip, '');
    knockout.track(this, [
        'toggled',
        'tooltip'
    ]);
};
defineProperties(ToggleButtonViewModel.prototype, {
    command: {
        get: function () {
            return this._command;
        }
    }
});
module.exports = ToggleButtonViewModel;
},{"../Core/DeveloperError":123,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../ThirdParty/knockout":591}],626:[function(require,module,exports){
var Cartesian3 = require('../../Core/Cartesian3'), defaultValue = require('../../Core/defaultValue'), defined = require('../../Core/defined'), defineProperties = require('../../Core/defineProperties'), destroyObject = require('../../Core/destroyObject'), DeveloperError = require('../../Core/DeveloperError'), EventHelper = require('../../Core/EventHelper'), Matrix4 = require('../../Core/Matrix4'), ScreenSpaceEventType = require('../../Core/ScreenSpaceEventType'), ConstantPositionProperty = require('../../DataSources/ConstantPositionProperty'), DataSourceCollection = require('../../DataSources/DataSourceCollection'), DataSourceDisplay = require('../../DataSources/DataSourceDisplay'), Entity = require('../../DataSources/Entity'), EntityView = require('../../DataSources/EntityView'), SceneMode = require('../../Scene/SceneMode'), knockout = require('../../ThirdParty/knockout'), when = require('../../ThirdParty/when'), Animation = require('../Animation/Animation'), AnimationViewModel = require('../Animation/AnimationViewModel'), BaseLayerPicker = require('../BaseLayerPicker/BaseLayerPicker'), createDefaultImageryProviderViewModels = require('../BaseLayerPicker/createDefaultImageryProviderViewModels'), createDefaultTerrainProviderViewModels = require('../BaseLayerPicker/createDefaultTerrainProviderViewModels'), CesiumWidget = require('../CesiumWidget/CesiumWidget'), ClockViewModel = require('../ClockViewModel'), FullscreenButton = require('../FullscreenButton/FullscreenButton'), Geocoder = require('../Geocoder/Geocoder'), getElement = require('../getElement'), HomeButton = require('../HomeButton/HomeButton'), InfoBox = require('../InfoBox/InfoBox'), NavigationHelpButton = require('../NavigationHelpButton/NavigationHelpButton'), SceneModePicker = require('../SceneModePicker/SceneModePicker'), SelectionIndicator = require('../SelectionIndicator/SelectionIndicator'), subscribeAndEvaluate = require('../subscribeAndEvaluate'), Timeline = require('../Timeline/Timeline');
'use strict';
function onTimelineScrubfunction(e) {
    var clock = e.clock;
    clock.currentTime = e.timeJulian;
    clock.shouldAnimate = false;
}
function pickEntity(viewer, e) {
    var picked = viewer.scene.pick(e.position);
    if (defined(picked)) {
        var id = defaultValue(picked.id, picked.primitive.id);
        if (id instanceof Entity) {
            return id;
        }
    }
    return pickImageryLayerFeature(viewer, e.position);
}
function trackDataSourceClock(timeline, clock, dataSource) {
    if (defined(dataSource)) {
        var dataSourceClock = dataSource.clock;
        if (defined(dataSourceClock)) {
            dataSourceClock.getValue(clock);
            if (defined(timeline)) {
                timeline.updateFromClock();
                timeline.zoomTo(dataSourceClock.startTime, dataSourceClock.stopTime);
            }
        }
    }
}
var cartesian3Scratch = new Cartesian3();
function pickImageryLayerFeature(viewer, windowPosition) {
    var scene = viewer.scene;
    var pickRay = scene.camera.getPickRay(windowPosition);
    var imageryLayerFeaturePromise = scene.imageryLayers.pickImageryLayerFeatures(pickRay, scene);
    if (!defined(imageryLayerFeaturePromise)) {
        return;
    }
    var loadingMessage = new Entity('Loading...');
    loadingMessage.description = {
        getValue: function () {
            return 'Loading feature information...';
        }
    };
    when(imageryLayerFeaturePromise, function (features) {
        if (viewer.selectedEntity !== loadingMessage) {
            return;
        }
        if (!defined(features) || features.length === 0) {
            viewer.selectedEntity = createNoFeaturesEntity();
            return;
        }
        var feature = features[0];
        var entity = new Entity(feature.name);
        entity.description = {
            getValue: function () {
                return feature.description;
            }
        };
        if (defined(feature.position)) {
            var ecfPosition = viewer.scene.globe.ellipsoid.cartographicToCartesian(feature.position, cartesian3Scratch);
            entity.position = new ConstantPositionProperty(ecfPosition);
        }
        viewer.selectedEntity = entity;
    }, function () {
        if (viewer.selectedEntity !== loadingMessage) {
            return;
        }
        var entity = new Entity('None');
        entity.description = {
            getValue: function () {
                return 'No features found.';
            }
        };
        viewer.selectedEntity = createNoFeaturesEntity();
    });
    return loadingMessage;
}
function createNoFeaturesEntity() {
    var entity = new Entity('None');
    entity.description = {
        getValue: function () {
            return 'No features found.';
        }
    };
    return entity;
}
var Viewer = function (container, options) {
    if (!defined(container)) {
        throw new DeveloperError('container is required.');
    }
    container = getElement(container);
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    var createBaseLayerPicker = !defined(options.baseLayerPicker) || options.baseLayerPicker !== false;
    if (createBaseLayerPicker && defined(options.imageryProvider)) {
        throw new DeveloperError('options.imageryProvider is not available when using the BaseLayerPicker widget. Either specify options.selectedImageryProviderViewModel instead or set options.baseLayerPicker to false.');
    }
    if (!createBaseLayerPicker && defined(options.selectedImageryProviderViewModel)) {
        throw new DeveloperError('options.selectedImageryProviderViewModel is not available when not using the BaseLayerPicker widget. Either specify options.imageryProvider instead or set options.baseLayerPicker to true.');
    }
    if (createBaseLayerPicker && defined(options.terrainProvider)) {
        throw new DeveloperError('options.terrainProvider is not available when using the BaseLayerPicker widget. Either specify options.selectedTerrainProviderViewModel instead or set options.baseLayerPicker to false.');
    }
    if (!createBaseLayerPicker && defined(options.selectedTerrainProviderViewModel)) {
        throw new DeveloperError('options.selectedTerrainProviderViewModel is not available when not using the BaseLayerPicker widget. Either specify options.terrainProvider instead or set options.baseLayerPicker to true.');
    }
    var viewerContainer = document.createElement('div');
    viewerContainer.className = 'cesium-viewer';
    container.appendChild(viewerContainer);
    var cesiumWidgetContainer = document.createElement('div');
    cesiumWidgetContainer.className = 'cesium-viewer-cesiumWidgetContainer';
    viewerContainer.appendChild(cesiumWidgetContainer);
    var bottomContainer = document.createElement('div');
    bottomContainer.className = 'cesium-viewer-bottom';
    viewerContainer.appendChild(bottomContainer);
    var scene3DOnly = defaultValue(options.scene3DOnly, false);
    var cesiumWidget = new CesiumWidget(cesiumWidgetContainer, {
            terrainProvider: options.terrainProvider,
            imageryProvider: createBaseLayerPicker ? false : options.imageryProvider,
            clock: options.clock,
            skyBox: options.skyBox,
            sceneMode: options.sceneMode,
            mapProjection: options.mapProjection,
            orderIndependentTranslucency: options.orderIndependentTranslucency,
            contextOptions: options.contextOptions,
            useDefaultRenderLoop: options.useDefaultRenderLoop,
            targetFrameRate: options.targetFrameRate,
            showRenderLoopErrors: options.showRenderLoopErrors,
            creditContainer: defined(options.creditContainer) ? options.creditContainer : bottomContainer,
            scene3DOnly: scene3DOnly
        });
    var dataSourceCollection = options.dataSources;
    var destroyDataSourceCollection = false;
    if (!defined(dataSourceCollection)) {
        dataSourceCollection = new DataSourceCollection();
        destroyDataSourceCollection = true;
    }
    var dataSourceDisplay = new DataSourceDisplay({
            scene: cesiumWidget.scene,
            dataSourceCollection: dataSourceCollection
        });
    var clock = cesiumWidget.clock;
    var clockViewModel = new ClockViewModel(clock);
    var eventHelper = new EventHelper();
    eventHelper.add(clock.onTick, Viewer.prototype._onTick, this);
    var selectionIndicator;
    if (!defined(options.selectionIndicator) || options.selectionIndicator !== false) {
        var selectionIndicatorContainer = document.createElement('div');
        selectionIndicatorContainer.className = 'cesium-viewer-selectionIndicatorContainer';
        viewerContainer.appendChild(selectionIndicatorContainer);
        selectionIndicator = new SelectionIndicator(selectionIndicatorContainer, cesiumWidget.scene);
    }
    var infoBox;
    if (!defined(options.infoBox) || options.infoBox !== false) {
        var infoBoxContainer = document.createElement('div');
        infoBoxContainer.className = 'cesium-viewer-infoBoxContainer';
        viewerContainer.appendChild(infoBoxContainer);
        infoBox = new InfoBox(infoBoxContainer);
        var infoBoxViewModel = infoBox.viewModel;
        eventHelper.add(infoBoxViewModel.cameraClicked, Viewer.prototype._onInfoBoxCameraClicked, this);
        eventHelper.add(infoBoxViewModel.closeClicked, Viewer.prototype._onInfoBoxClockClicked, this);
    }
    var toolbar = document.createElement('div');
    toolbar.className = 'cesium-viewer-toolbar';
    viewerContainer.appendChild(toolbar);
    var geocoder;
    if (!defined(options.geocoder) || options.geocoder !== false) {
        var geocoderContainer = document.createElement('div');
        geocoderContainer.className = 'cesium-viewer-geocoderContainer';
        toolbar.appendChild(geocoderContainer);
        geocoder = new Geocoder({
            container: geocoderContainer,
            scene: cesiumWidget.scene
        });
        eventHelper.add(geocoder.viewModel.search.beforeExecute, Viewer.prototype._clearObjects, this);
    }
    var homeButton;
    if (!defined(options.homeButton) || options.homeButton !== false) {
        homeButton = new HomeButton(toolbar, cesiumWidget.scene);
        if (defined(geocoder)) {
            eventHelper.add(homeButton.viewModel.command.afterExecute, function () {
                var viewModel = geocoder.viewModel;
                viewModel.searchText = '';
                if (viewModel.isSearchInProgress) {
                    viewModel.search();
                }
            });
        }
        eventHelper.add(homeButton.viewModel.command.beforeExecute, Viewer.prototype._clearTrackedObject, this);
    }
    if (options.sceneModePicker === true && scene3DOnly) {
        throw new DeveloperError('options.sceneModePicker is not available when options.scene3DOnly is set to true.');
    }
    var sceneModePicker;
    if (!scene3DOnly && (!defined(options.sceneModePicker) || options.sceneModePicker !== false)) {
        sceneModePicker = new SceneModePicker(toolbar, cesiumWidget.scene);
    }
    var baseLayerPicker;
    var baseLayerPickerDropDown;
    if (createBaseLayerPicker) {
        var imageryProviderViewModels = defaultValue(options.imageryProviderViewModels, createDefaultImageryProviderViewModels());
        var terrainProviderViewModels = defaultValue(options.terrainProviderViewModels, createDefaultTerrainProviderViewModels());
        baseLayerPicker = new BaseLayerPicker(toolbar, {
            globe: cesiumWidget.scene.globe,
            imageryProviderViewModels: imageryProviderViewModels,
            selectedImageryProviderViewModel: options.selectedImageryProviderViewModel,
            terrainProviderViewModels: terrainProviderViewModels,
            selectedTerrainProviderViewModel: options.selectedTerrainProviderViewModel
        });
        var elements = toolbar.getElementsByClassName('cesium-baseLayerPicker-dropDown');
        baseLayerPickerDropDown = elements[0];
    }
    var navigationHelpButton;
    if (!defined(options.navigationHelpButton) || options.navigationHelpButton !== false) {
        var showNavHelp = true;
        if (defined(window.localStorage)) {
            var hasSeenNavHelp = window.localStorage.getItem('cesium-hasSeenNavHelp');
            if (defined(hasSeenNavHelp) && Boolean(hasSeenNavHelp)) {
                showNavHelp = false;
            } else {
                window.localStorage.setItem('cesium-hasSeenNavHelp', 'true');
            }
        }
        navigationHelpButton = new NavigationHelpButton({
            container: toolbar,
            instructionsInitiallyVisible: defaultValue(options.navigationInstructionsInitiallyVisible, showNavHelp)
        });
    }
    var animation;
    if (!defined(options.animation) || options.animation !== false) {
        var animationContainer = document.createElement('div');
        animationContainer.className = 'cesium-viewer-animationContainer';
        viewerContainer.appendChild(animationContainer);
        animation = new Animation(animationContainer, new AnimationViewModel(clockViewModel));
    }
    var timeline;
    if (!defined(options.timeline) || options.timeline !== false) {
        var timelineContainer = document.createElement('div');
        timelineContainer.className = 'cesium-viewer-timelineContainer';
        viewerContainer.appendChild(timelineContainer);
        timeline = new Timeline(timelineContainer, clock);
        timeline.addEventListener('settime', onTimelineScrubfunction, false);
        timeline.zoomTo(clock.startTime, clock.stopTime);
    }
    var fullscreenButton;
    var fullscreenSubscription;
    if (!defined(options.fullscreenButton) || options.fullscreenButton !== false) {
        var fullscreenContainer = document.createElement('div');
        fullscreenContainer.className = 'cesium-viewer-fullscreenContainer';
        viewerContainer.appendChild(fullscreenContainer);
        fullscreenButton = new FullscreenButton(fullscreenContainer, options.fullscreenElement);
        fullscreenSubscription = subscribeAndEvaluate(fullscreenButton.viewModel, 'isFullscreenEnabled', function (isFullscreenEnabled) {
            fullscreenContainer.style.display = isFullscreenEnabled ? 'block' : 'none';
            if (defined(timeline)) {
                timeline.container.style.right = fullscreenContainer.clientWidth + 'px';
                timeline.resize();
            }
        });
    } else if (defined(timeline)) {
        timeline.container.style.right = 0;
    }
    this._baseLayerPickerDropDown = baseLayerPickerDropDown;
    this._fullscreenSubscription = fullscreenSubscription;
    this._dataSourceChangedListeners = {};
    this._automaticallyTrackDataSourceClocks = defaultValue(options.automaticallyTrackDataSourceClocks, true);
    this._container = container;
    this._bottomContainer = bottomContainer;
    this._element = viewerContainer;
    this._cesiumWidget = cesiumWidget;
    this._selectionIndicator = selectionIndicator;
    this._infoBox = infoBox;
    this._dataSourceCollection = dataSourceCollection;
    this._destroyDataSourceCollection = destroyDataSourceCollection;
    this._dataSourceDisplay = dataSourceDisplay;
    this._clockViewModel = clockViewModel;
    this._toolbar = toolbar;
    this._homeButton = homeButton;
    this._sceneModePicker = sceneModePicker;
    this._baseLayerPicker = baseLayerPicker;
    this._animation = animation;
    this._timeline = timeline;
    this._fullscreenButton = fullscreenButton;
    this._geocoder = geocoder;
    this._eventHelper = eventHelper;
    this._lastWidth = 0;
    this._lastHeight = 0;
    this._allowDataSourcesToSuspendAnimation = true;
    this._entityView = undefined;
    this._enableInfoOrSelection = defined(infoBox) || defined(selectionIndicator);
    this._clockTrackedDataSource = undefined;
    this._trackedEntity = undefined;
    this._selectedEntity = undefined;
    this._clockTrackedDataSource = undefined;
    this._forceResize = false;
    knockout.track(this, [
        '_trackedEntity',
        '_selectedEntity',
        '_clockTrackedDataSource'
    ]);
    eventHelper.add(dataSourceCollection.dataSourceAdded, Viewer.prototype._onDataSourceAdded, this);
    eventHelper.add(dataSourceCollection.dataSourceRemoved, Viewer.prototype._onDataSourceRemoved, this);
    eventHelper.add(cesiumWidget.scene.preRender, Viewer.prototype.resize, this);
    var dataSourceLength = dataSourceCollection.length;
    for (var i = 0; i < dataSourceLength; i++) {
        this._dataSourceAdded(dataSourceCollection, dataSourceCollection.get(i));
    }
    eventHelper.add(dataSourceCollection.dataSourceAdded, Viewer.prototype._dataSourceAdded, this);
    eventHelper.add(dataSourceCollection.dataSourceRemoved, Viewer.prototype._dataSourceRemoved, this);
    var that = this;
    function pickAndTrackObject(e) {
        var entity = pickEntity(that, e);
        if (defined(entity) && defined(entity.position)) {
            that.trackedEntity = entity;
        }
    }
    function pickAndSelectObject(e) {
        that.selectedEntity = pickEntity(that, e);
    }
    cesiumWidget.screenSpaceEventHandler.setInputAction(pickAndSelectObject, ScreenSpaceEventType.LEFT_CLICK);
    cesiumWidget.screenSpaceEventHandler.setInputAction(pickAndTrackObject, ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
};
defineProperties(Viewer.prototype, {
    container: {
        get: function () {
            return this._container;
        }
    },
    bottomContainer: {
        get: function () {
            return this._bottomContainer;
        }
    },
    cesiumWidget: {
        get: function () {
            return this._cesiumWidget;
        }
    },
    selectionIndicator: {
        get: function () {
            return this._selectionIndicator;
        }
    },
    infoBox: {
        get: function () {
            return this._infoBox;
        }
    },
    geocoder: {
        get: function () {
            return this._geocoder;
        }
    },
    homeButton: {
        get: function () {
            return this._homeButton;
        }
    },
    sceneModePicker: {
        get: function () {
            return this._sceneModePicker;
        }
    },
    baseLayerPicker: {
        get: function () {
            return this._baseLayerPicker;
        }
    },
    animation: {
        get: function () {
            return this._animation;
        }
    },
    timeline: {
        get: function () {
            return this._timeline;
        }
    },
    fullscreenButton: {
        get: function () {
            return this._fullscreenButton;
        }
    },
    dataSourceDisplay: {
        get: function () {
            return this._dataSourceDisplay;
        }
    },
    dataSources: {
        get: function () {
            return this._dataSourceCollection;
        }
    },
    canvas: {
        get: function () {
            return this._cesiumWidget.canvas;
        }
    },
    cesiumLogo: {
        get: function () {
            return this._cesiumWidget.cesiumLogo;
        }
    },
    scene: {
        get: function () {
            return this._cesiumWidget.scene;
        }
    },
    imageryLayers: {
        get: function () {
            return this.scene.imageryLayers;
        }
    },
    terrainProvider: {
        get: function () {
            return this.scene.terrainProvider;
        },
        set: function (terrainProvider) {
            this.scene.terrainProvider = terrainProvider;
        }
    },
    camera: {
        get: function () {
            return this.scene.camera;
        }
    },
    clock: {
        get: function () {
            return this._cesiumWidget.clock;
        }
    },
    screenSpaceEventHandler: {
        get: function () {
            return this._cesiumWidget.screenSpaceEventHandler;
        }
    },
    targetFrameRate: {
        get: function () {
            return this._cesiumWidget.targetFrameRate;
        },
        set: function (value) {
            this._cesiumWidget.targetFrameRate = value;
        }
    },
    useDefaultRenderLoop: {
        get: function () {
            return this._cesiumWidget.useDefaultRenderLoop;
        },
        set: function (value) {
            this._cesiumWidget.useDefaultRenderLoop = value;
        }
    },
    resolutionScale: {
        get: function () {
            return this._cesiumWidget.resolutionScale;
        },
        set: function (value) {
            this._cesiumWidget.resolutionScale = value;
            this._forceResize = true;
        }
    },
    allowDataSourcesToSuspendAnimation: {
        get: function () {
            return this._allowDataSourcesToSuspendAnimation;
        },
        set: function (value) {
            this._allowDataSourcesToSuspendAnimation = value;
        }
    },
    trackedEntity: {
        get: function () {
            return this._trackedEntity;
        },
        set: function (value) {
            if (this._trackedEntity !== value) {
                this._trackedEntity = value;
                var scene = this.scene;
                var sceneMode = scene.mode;
                var isTracking = defined(value);
                if (sceneMode === SceneMode.COLUMBUS_VIEW || sceneMode === SceneMode.SCENE2D) {
                    scene.screenSpaceCameraController.enableTranslate = !isTracking;
                }
                if (sceneMode === SceneMode.COLUMBUS_VIEW || sceneMode === SceneMode.SCENE3D) {
                    scene.screenSpaceCameraController.enableTilt = !isTracking;
                }
                if (isTracking && defined(value.position)) {
                    this._entityView = new EntityView(value, scene, this.scene.globe.ellipsoid);
                } else {
                    this._entityView = undefined;
                    this.camera.setTransform(Matrix4.IDENTITY);
                }
            }
        }
    },
    selectedEntity: {
        get: function () {
            return this._selectedEntity;
        },
        set: function (value) {
            if (this._selectedEntity !== value) {
                this._selectedEntity = value;
                var selectionIndicatorViewModel = defined(this._selectionIndicator) ? this._selectionIndicator.viewModel : undefined;
                if (defined(value)) {
                    var infoBoxViewModel = defined(this._infoBox) ? this._infoBox.viewModel : undefined;
                    if (defined(infoBoxViewModel)) {
                        infoBoxViewModel.titleText = defined(value.name) ? value.name : value.id;
                    }
                    if (defined(selectionIndicatorViewModel)) {
                        selectionIndicatorViewModel.animateAppear();
                    }
                } else {
                    if (defined(selectionIndicatorViewModel)) {
                        selectionIndicatorViewModel.animateDepart();
                    }
                }
            }
        }
    },
    clockTrackedDataSource: {
        get: function () {
            return this._clockTrackedDataSource;
        },
        set: function (value) {
            if (this._clockTrackedDataSource !== value) {
                this._clockTrackedDataSource = value;
                trackDataSourceClock(this._timeline, this.clock, value);
            }
        }
    }
});
Viewer.prototype.extend = function (mixin, options) {
    if (!defined(mixin)) {
        throw new DeveloperError('mixin is required.');
    }
    mixin(this, options);
};
Viewer.prototype.resize = function () {
    var cesiumWidget = this._cesiumWidget;
    var container = this._container;
    var width = container.clientWidth;
    var height = container.clientHeight;
    var animationExists = defined(this._animation);
    var timelineExists = defined(this._timeline);
    if (!this._forceResize && width === this._lastWidth && height === this._lastHeight) {
        return;
    }
    cesiumWidget.resize();
    this._forceResize = false;
    var panelMaxHeight = height - 125;
    var baseLayerPickerDropDown = this._baseLayerPickerDropDown;
    if (defined(baseLayerPickerDropDown)) {
        baseLayerPickerDropDown.style.maxHeight = panelMaxHeight + 'px';
    }
    if (defined(this._infoBox)) {
        this._infoBox.viewModel.maxHeight = panelMaxHeight;
    }
    var timeline = this._timeline;
    var animationContainer;
    var animationWidth = 0;
    var creditLeft = 0;
    var creditBottom = 0;
    if (animationExists && window.getComputedStyle(this._animation.container).visibility !== 'hidden') {
        var lastWidth = this._lastWidth;
        animationContainer = this._animation.container;
        if (width > 900) {
            animationWidth = 169;
            if (lastWidth <= 900) {
                animationContainer.style.width = '169px';
                animationContainer.style.height = '112px';
                this._animation.resize();
            }
        } else if (width >= 600) {
            animationWidth = 136;
            if (lastWidth < 600 || lastWidth > 900) {
                animationContainer.style.width = '136px';
                animationContainer.style.height = '90px';
                this._animation.resize();
            }
        } else {
            animationWidth = 106;
            if (lastWidth > 600 || lastWidth === 0) {
                animationContainer.style.width = '106px';
                animationContainer.style.height = '70px';
                this._animation.resize();
            }
        }
        creditLeft = animationWidth + 5;
    }
    if (timelineExists && window.getComputedStyle(this._timeline.container).visibility !== 'hidden') {
        var fullscreenButton = this._fullscreenButton;
        var timelineContainer = timeline.container;
        var timelineStyle = timelineContainer.style;
        creditBottom = timelineContainer.clientHeight + 3;
        timelineStyle.left = animationWidth + 'px';
        if (defined(fullscreenButton)) {
            timelineStyle.right = fullscreenButton.container.clientWidth + 'px';
        }
        timeline.resize();
    }
    this._bottomContainer.style.left = creditLeft + 'px';
    this._bottomContainer.style.bottom = creditBottom + 'px';
    this._lastWidth = width;
    this._lastHeight = height;
};
Viewer.prototype.forceResize = function () {
    this._lastWidth = 0;
    this.resize();
};
Viewer.prototype.render = function () {
    this._cesiumWidget.render();
};
Viewer.prototype.isDestroyed = function () {
    return false;
};
Viewer.prototype.destroy = function () {
    var i;
    this.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_CLICK);
    this.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
    var dataSources = this.dataSources;
    var dataSourceLength = dataSources.length;
    for (i = 0; i < dataSourceLength; i++) {
        this._dataSourceRemoved(dataSources, dataSources.get(i));
    }
    this._container.removeChild(this._element);
    this._element.removeChild(this._toolbar);
    this._eventHelper.removeAll();
    if (defined(this._geocoder)) {
        this._geocoder = this._geocoder.destroy();
    }
    if (defined(this._homeButton)) {
        this._homeButton = this._homeButton.destroy();
    }
    if (defined(this._sceneModePicker)) {
        this._sceneModePicker = this._sceneModePicker.destroy();
    }
    if (defined(this._baseLayerPicker)) {
        this._baseLayerPicker = this._baseLayerPicker.destroy();
    }
    if (defined(this._animation)) {
        this._element.removeChild(this._animation.container);
        this._animation = this._animation.destroy();
    }
    if (defined(this._timeline)) {
        this._timeline.removeEventListener('settime', onTimelineScrubfunction, false);
        this._element.removeChild(this._timeline.container);
        this._timeline = this._timeline.destroy();
    }
    if (defined(this._fullscreenButton)) {
        this._fullscreenSubscription.dispose();
        this._element.removeChild(this._fullscreenButton.container);
        this._fullscreenButton = this._fullscreenButton.destroy();
    }
    if (defined(this._infoBox)) {
        this._element.removeChild(this._infoBox.container);
        this._infoBox = this._infoBox.destroy();
    }
    if (defined(this._selectionIndicator)) {
        this._element.removeChild(this._selectionIndicator.container);
        this._selectionIndicator = this._selectionIndicator.destroy();
    }
    this._clockViewModel = this._clockViewModel.destroy();
    this._dataSourceDisplay = this._dataSourceDisplay.destroy();
    this._cesiumWidget = this._cesiumWidget.destroy();
    if (this._destroyDataSourceCollection) {
        this._dataSourceCollection = this._dataSourceCollection.destroy();
    }
    return destroyObject(this);
};
Viewer.prototype._dataSourceAdded = function (dataSourceCollection, dataSource) {
    var entityCollection = dataSource.entities;
    entityCollection.collectionChanged.addEventListener(Viewer.prototype._onEntityCollectionChanged, this);
};
Viewer.prototype._dataSourceRemoved = function (dataSourceCollection, dataSource) {
    var entityCollection = dataSource.entities;
    entityCollection.collectionChanged.removeEventListener(Viewer.prototype._onEntityCollectionChanged, this);
    if (defined(this.trackedEntity)) {
        if (entityCollection.getById(this.trackedEntity.id) === this.trackedEntity) {
            this.trackedEntity = undefined;
        }
    }
    if (defined(this.selectedEntity)) {
        if (entityCollection.getById(this.selectedEntity.id) === this.selectedEntity) {
            this.selectedEntity = undefined;
        }
    }
};
Viewer.prototype._onTick = function (clock) {
    var time = clock.currentTime;
    var entityView = this._entityView;
    var infoBoxViewModel = defined(this._infoBox) ? this._infoBox.viewModel : undefined;
    var selectionIndicatorViewModel = defined(this._selectionIndicator) ? this._selectionIndicator.viewModel : undefined;
    var isUpdated = this._dataSourceDisplay.update(time);
    if (this._allowDataSourcesToSuspendAnimation) {
        this._clockViewModel.canAnimate = isUpdated;
    }
    if (defined(entityView)) {
        entityView.update(time);
    }
    var selectedEntity = this.selectedEntity;
    var showSelection = defined(selectedEntity) && this._enableInfoOrSelection;
    if (showSelection) {
        var oldPosition = defined(selectionIndicatorViewModel) ? selectionIndicatorViewModel.position : undefined;
        var position;
        var enableCamera = false;
        if (selectedEntity.isAvailable(time)) {
            if (defined(selectedEntity.position)) {
                position = selectedEntity.position.getValue(time, oldPosition);
                enableCamera = defined(position);
            }
        }
        if (defined(selectionIndicatorViewModel)) {
            selectionIndicatorViewModel.position = position;
        }
        if (defined(infoBoxViewModel)) {
            infoBoxViewModel.enableCamera = enableCamera;
            infoBoxViewModel.isCameraTracking = this.trackedEntity === this.selectedEntity;
            if (defined(selectedEntity.description)) {
                infoBoxViewModel.descriptionRawHtml = defaultValue(selectedEntity.description.getValue(time), '');
            } else {
                infoBoxViewModel.descriptionRawHtml = '';
            }
        }
    }
    if (defined(selectionIndicatorViewModel)) {
        selectionIndicatorViewModel.showSelection = showSelection;
        selectionIndicatorViewModel.update();
    }
    if (defined(infoBoxViewModel)) {
        infoBoxViewModel.showInfo = showSelection;
    }
};
Viewer.prototype._onEntityCollectionChanged = function (collection, added, removed) {
    var length = removed.length;
    for (var i = 0; i < length; i++) {
        var removedObject = removed[i];
        if (this.trackedEntity === removedObject) {
            this.trackedEntity = undefined;
        }
        if (this.selectedEntity === removedObject) {
            this.selectedEntity = undefined;
        }
    }
};
Viewer.prototype._onInfoBoxCameraClicked = function (infoBoxViewModel) {
    if (infoBoxViewModel.isCameraTracking && this.trackedEntity === this.selectedEntity) {
        this.trackedEntity = undefined;
    } else {
        this.trackedEntity = this.selectedEntity;
    }
};
Viewer.prototype._clearTrackedObject = function () {
    this.trackedEntity = undefined;
};
Viewer.prototype._onInfoBoxClockClicked = function (infoBoxViewModel) {
    this.selectedEntity = undefined;
};
Viewer.prototype._clearObjects = function () {
    this.trackedEntity = undefined;
    this.selectedEntity = undefined;
};
Viewer.prototype._onDataSourceChanged = function (dataSource) {
    if (this.clockTrackedDataSource === dataSource) {
        trackDataSourceClock(this.timeline, this.clock, dataSource);
    }
};
Viewer.prototype._onDataSourceAdded = function (dataSourceCollection, dataSource) {
    if (this._automaticallyTrackDataSourceClocks) {
        this.clockTrackedDataSource = dataSource;
    }
    var id = dataSource.entities.id;
    var removalFunc = this._eventHelper.add(dataSource.changedEvent, Viewer.prototype._onDataSourceChanged, this);
    this._dataSourceChangedListeners[id] = removalFunc;
};
Viewer.prototype._onDataSourceRemoved = function (dataSourceCollection, dataSource) {
    var resetClock = this.clockTrackedDataSource === dataSource;
    var id = dataSource.entities.id;
    this._dataSourceChangedListeners[id]();
    this._dataSourceChangedListeners[id] = undefined;
    if (resetClock) {
        var numDataSources = dataSourceCollection.length;
        if (this._automaticallyTrackDataSourceClocks && numDataSources > 0) {
            this.clockTrackedDataSource = dataSourceCollection.get(numDataSources - 1);
        } else {
            this.clockTrackedDataSource = undefined;
        }
    }
};
module.exports = Viewer;
},{"../../Core/Cartesian3":102,"../../Core/DeveloperError":123,"../../Core/EventHelper":139,"../../Core/Matrix4":177,"../../Core/ScreenSpaceEventType":209,"../../Core/defaultValue":243,"../../Core/defineProperties":244,"../../Core/defined":245,"../../Core/destroyObject":247,"../../DataSources/ConstantPositionProperty":282,"../../DataSources/DataSourceCollection":289,"../../DataSources/DataSourceDisplay":290,"../../DataSources/Entity":295,"../../DataSources/EntityView":297,"../../Scene/SceneMode":438,"../../ThirdParty/knockout":591,"../../ThirdParty/when":596,"../Animation/Animation":598,"../Animation/AnimationViewModel":599,"../BaseLayerPicker/BaseLayerPicker":600,"../BaseLayerPicker/createDefaultImageryProviderViewModels":603,"../BaseLayerPicker/createDefaultTerrainProviderViewModels":604,"../CesiumWidget/CesiumWidget":605,"../ClockViewModel":606,"../FullscreenButton/FullscreenButton":607,"../Geocoder/Geocoder":609,"../HomeButton/HomeButton":611,"../InfoBox/InfoBox":613,"../NavigationHelpButton/NavigationHelpButton":615,"../SceneModePicker/SceneModePicker":617,"../SelectionIndicator/SelectionIndicator":619,"../Timeline/Timeline":622,"../getElement":628,"../subscribeAndEvaluate":629}],627:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), defineProperties = require('../Core/defineProperties'), DeveloperError = require('../Core/DeveloperError'), Event = require('../Core/Event'), knockout = require('../ThirdParty/knockout');
'use strict';
var createCommand = function (func, canExecute) {
    if (!defined(func)) {
        throw new DeveloperError('func is required.');
    }
    canExecute = defaultValue(canExecute, true);
    var beforeExecute = new Event();
    var afterExecute = new Event();
    function command() {
        if (!command.canExecute) {
            throw new DeveloperError('Cannot execute command, canExecute is false.');
        }
        var commandInfo = {
                args: arguments,
                cancel: false
            };
        var result;
        beforeExecute.raiseEvent(commandInfo);
        if (!commandInfo.cancel) {
            result = func.apply(null, arguments);
            afterExecute.raiseEvent(result);
        }
        return result;
    }
    command.canExecute = canExecute;
    knockout.track(command, ['canExecute']);
    defineProperties(command, {
        beforeExecute: { value: beforeExecute },
        afterExecute: { value: afterExecute }
    });
    return command;
};
module.exports = createCommand;
},{"../Core/DeveloperError":123,"../Core/Event":138,"../Core/defaultValue":243,"../Core/defineProperties":244,"../Core/defined":245,"../ThirdParty/knockout":591}],628:[function(require,module,exports){
var DeveloperError = require('../Core/DeveloperError');
'use strict';
var getElement = function (element) {
    if (typeof element === 'string') {
        var foundElement = document.getElementById(element);
        if (foundElement === null) {
            throw new DeveloperError('Element with id "' + element + '" does not exist in the document.');
        }
        element = foundElement;
    }
    return element;
};
module.exports = getElement;
},{"../Core/DeveloperError":123}],629:[function(require,module,exports){
var knockout = require('../ThirdParty/knockout');
'use strict';
var subscribeAndEvaluate = function (owner, observablePropertyName, callback, target, event) {
    callback.call(target, owner[observablePropertyName]);
    return knockout.getObservable(owner, observablePropertyName).subscribe(callback, target, event);
};
module.exports = subscribeAndEvaluate;
},{"../ThirdParty/knockout":591}],"sXJgqi":[function(require,module,exports){
var PrimitivePipeline = require('../Scene/PrimitivePipeline'), createTaskProcessorWorker = require('./createTaskProcessorWorker');
'use strict';
function combineGeometry(packedParameters, transferableObjects) {
    var parameters = PrimitivePipeline.unpackCombineGeometryParameters(packedParameters);
    var results = PrimitivePipeline.combineGeometry(parameters);
    return PrimitivePipeline.packCombineGeometryResults(results, transferableObjects);
}
module.exports = createTaskProcessorWorker(combineGeometry);
},{"../Scene/PrimitivePipeline":430,"./createTaskProcessorWorker":678}],"Workers/combineGeometry":[function(require,module,exports){
module.exports=require('sXJgqi');
},{}],"dCYmke":[function(require,module,exports){
var BoxGeometry = require('../Core/BoxGeometry'), defined = require('../Core/defined');
'use strict';
module.exports = function (boxGeometry, offset) {
    if (defined(offset)) {
        boxGeometry = BoxGeometry.unpack(boxGeometry, offset);
    }
    return BoxGeometry.createGeometry(boxGeometry);
};
},{"../Core/BoxGeometry":99,"../Core/defined":245}],"Workers/createBoxGeometry":[function(require,module,exports){
module.exports=require('dCYmke');
},{}],"Workers/createBoxOutlineGeometry":[function(require,module,exports){
module.exports=require('MqdJWf');
},{}],"MqdJWf":[function(require,module,exports){
var BoxOutlineGeometry = require('../Core/BoxOutlineGeometry'), defined = require('../Core/defined');
'use strict';
module.exports = function (boxGeometry, offset) {
    if (defined(offset)) {
        boxGeometry = BoxOutlineGeometry.unpack(boxGeometry, offset);
    }
    return BoxOutlineGeometry.createGeometry(boxGeometry);
};
},{"../Core/BoxOutlineGeometry":100,"../Core/defined":245}],"QS75K3":[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), CircleGeometry = require('../Core/CircleGeometry'), defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid');
'use strict';
function createCircleGeometry(circleGeometry, offset) {
    if (defined(offset)) {
        circleGeometry = CircleGeometry.unpack(circleGeometry, offset);
    }
    circleGeometry._ellipseGeometry._center = Cartesian3.clone(circleGeometry._ellipseGeometry._center);
    circleGeometry._ellipseGeometry._ellipsoid = Ellipsoid.clone(circleGeometry._ellipseGeometry._ellipsoid);
    return CircleGeometry.createGeometry(circleGeometry);
}
module.exports = createCircleGeometry;
},{"../Core/Cartesian3":102,"../Core/CircleGeometry":106,"../Core/Ellipsoid":130,"../Core/defined":245}],"Workers/createCircleGeometry":[function(require,module,exports){
module.exports=require('QS75K3');
},{}],"Workers/createCircleOutlineGeometry":[function(require,module,exports){
module.exports=require('33+tCo');
},{}],"33+tCo":[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), CircleOutlineGeometry = require('../Core/CircleOutlineGeometry'), defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid');
'use strict';
function createCircleOutlineGeometry(circleGeometry, offset) {
    if (defined(offset)) {
        circleGeometry = CircleOutlineGeometry.unpack(circleGeometry, offset);
    }
    circleGeometry._ellipseGeometry._center = Cartesian3.clone(circleGeometry._ellipseGeometry._center);
    circleGeometry._ellipseGeometry._ellipsoid = Ellipsoid.clone(circleGeometry._ellipseGeometry._ellipsoid);
    return CircleOutlineGeometry.createGeometry(circleGeometry);
}
module.exports = createCircleOutlineGeometry;
},{"../Core/Cartesian3":102,"../Core/CircleOutlineGeometry":107,"../Core/Ellipsoid":130,"../Core/defined":245}],"Workers/createCorridorGeometry":[function(require,module,exports){
module.exports=require('BvGZfS');
},{}],"BvGZfS":[function(require,module,exports){
var CorridorGeometry = require('../Core/CorridorGeometry'), defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid');
'use strict';
function createCorridorGeometry(corridorGeometry, offset) {
    if (defined(offset)) {
        corridorGeometry = CorridorGeometry.unpack(corridorGeometry, offset);
    }
    corridorGeometry._ellipsoid = Ellipsoid.clone(corridorGeometry._ellipsoid);
    return CorridorGeometry.createGeometry(corridorGeometry);
}
module.exports = createCorridorGeometry;
},{"../Core/CorridorGeometry":115,"../Core/Ellipsoid":130,"../Core/defined":245}],"Workers/createCorridorOutlineGeometry":[function(require,module,exports){
module.exports=require('S/Cglp');
},{}],"S/Cglp":[function(require,module,exports){
var CorridorOutlineGeometry = require('../Core/CorridorOutlineGeometry'), defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid');
'use strict';
function createCorridorOutlineGeometry(corridorOutlineGeometry, offset) {
    if (defined(offset)) {
        corridorOutlineGeometry = CorridorOutlineGeometry.unpack(corridorOutlineGeometry, offset);
    }
    corridorOutlineGeometry._ellipsoid = Ellipsoid.clone(corridorOutlineGeometry._ellipsoid);
    return CorridorOutlineGeometry.createGeometry(corridorOutlineGeometry);
}
module.exports = createCorridorOutlineGeometry;
},{"../Core/CorridorOutlineGeometry":117,"../Core/Ellipsoid":130,"../Core/defined":245}],"Workers/createCylinderGeometry":[function(require,module,exports){
module.exports=require('KzTL0u');
},{}],"KzTL0u":[function(require,module,exports){
var CylinderGeometry = require('../Core/CylinderGeometry'), defined = require('../Core/defined');
'use strict';
module.exports = function (cylinderGeometry, offset) {
    if (defined(offset)) {
        cylinderGeometry = CylinderGeometry.unpack(cylinderGeometry, offset);
    }
    return CylinderGeometry.createGeometry(cylinderGeometry);
};
},{"../Core/CylinderGeometry":120,"../Core/defined":245}],"Workers/createCylinderOutlineGeometry":[function(require,module,exports){
module.exports=require('DAesjn');
},{}],"DAesjn":[function(require,module,exports){
var CylinderOutlineGeometry = require('../Core/CylinderOutlineGeometry'), defined = require('../Core/defined');
'use strict';
module.exports = function (cylinderGeometry, offset) {
    if (defined(offset)) {
        cylinderGeometry = CylinderOutlineGeometry.unpack(cylinderGeometry, offset);
    }
    return CylinderOutlineGeometry.createGeometry(cylinderGeometry);
};
},{"../Core/CylinderOutlineGeometry":122,"../Core/defined":245}],"Workers/createEllipseGeometry":[function(require,module,exports){
module.exports=require('UB5+OX');
},{}],"UB5+OX":[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defined = require('../Core/defined'), EllipseGeometry = require('../Core/EllipseGeometry'), Ellipsoid = require('../Core/Ellipsoid');
'use strict';
function createEllipseGeometry(ellipseGeometry, offset) {
    if (defined(offset)) {
        ellipseGeometry = EllipseGeometry.unpack(ellipseGeometry, offset);
    }
    ellipseGeometry._center = Cartesian3.clone(ellipseGeometry._center);
    ellipseGeometry._ellipsoid = Ellipsoid.clone(ellipseGeometry._ellipsoid);
    return EllipseGeometry.createGeometry(ellipseGeometry);
}
module.exports = createEllipseGeometry;
},{"../Core/Cartesian3":102,"../Core/EllipseGeometry":127,"../Core/Ellipsoid":130,"../Core/defined":245}],"Workers/createEllipseOutlineGeometry":[function(require,module,exports){
module.exports=require('EE4Ayi');
},{}],"EE4Ayi":[function(require,module,exports){
var Cartesian3 = require('../Core/Cartesian3'), defined = require('../Core/defined'), EllipseOutlineGeometry = require('../Core/EllipseOutlineGeometry'), Ellipsoid = require('../Core/Ellipsoid');
'use strict';
function createEllipseOutlineGeometry(ellipseGeometry, offset) {
    if (defined(offset)) {
        ellipseGeometry = EllipseOutlineGeometry.unpack(ellipseGeometry, offset);
    }
    ellipseGeometry._center = Cartesian3.clone(ellipseGeometry._center);
    ellipseGeometry._ellipsoid = Ellipsoid.clone(ellipseGeometry._ellipsoid);
    return EllipseOutlineGeometry.createGeometry(ellipseGeometry);
}
module.exports = createEllipseOutlineGeometry;
},{"../Core/Cartesian3":102,"../Core/EllipseOutlineGeometry":129,"../Core/Ellipsoid":130,"../Core/defined":245}],"Dk74c4":[function(require,module,exports){
var defined = require('../Core/defined'), EllipsoidGeometry = require('../Core/EllipsoidGeometry');
'use strict';
module.exports = function (ellipsoidGeometry, offset) {
    if (defined(offset)) {
        ellipsoidGeometry = EllipsoidGeometry.unpack(ellipsoidGeometry, offset);
    }
    return EllipsoidGeometry.createGeometry(ellipsoidGeometry);
};
},{"../Core/EllipsoidGeometry":132,"../Core/defined":245}],"Workers/createEllipsoidGeometry":[function(require,module,exports){
module.exports=require('Dk74c4');
},{}],"PDAFMp":[function(require,module,exports){
var defined = require('../Core/defined'), EllipsoidOutlineGeometry = require('../Core/EllipsoidOutlineGeometry');
'use strict';
module.exports = function (ellipsoidGeometry, offset) {
    if (defined(ellipsoidGeometry.buffer, offset)) {
        ellipsoidGeometry = EllipsoidOutlineGeometry.unpack(ellipsoidGeometry, offset);
    }
    return EllipsoidOutlineGeometry.createGeometry(ellipsoidGeometry);
};
},{"../Core/EllipsoidOutlineGeometry":133,"../Core/defined":245}],"Workers/createEllipsoidOutlineGeometry":[function(require,module,exports){
module.exports=require('PDAFMp');
},{}],"Workers/createGeometry":[function(require,module,exports){
module.exports=require('8pmFOJ');
},{}],"8pmFOJ":[function(require,module,exports){
var defined = require('../Core/defined'), PrimitivePipeline = require('../Scene/PrimitivePipeline'), when = require('../ThirdParty/when'), createTaskProcessorWorker = require('./createTaskProcessorWorker');
'use strict';
var moduleCache = {};
function getModule(moduleName) {
    var module = moduleCache[moduleName];
    if (!defined(module)) {
        if (typeof exports === 'object') {
            moduleCache[module] = module = require('Workers/' + moduleName);
        } else {
            require(['./' + moduleName], function (f) {
                module = f;
                moduleCache[module] = f;
            });
        }
    }
    return module;
}
function createGeometry(parameters, transferableObjects) {
    var subTasks = parameters.subTasks;
    var length = subTasks.length;
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
        var task = subTasks[i];
        var geometry = task.geometry;
        var moduleName = task.moduleName;
        if (defined(moduleName)) {
            var createFunction = getModule(moduleName);
            results[i] = createFunction(geometry, task.offset);
        } else {
            results[i] = geometry;
        }
    }
    return PrimitivePipeline.packCreateGeometryResults(results, transferableObjects);
}
module.exports = createTaskProcessorWorker(createGeometry);
},{"../Core/defined":245,"../Scene/PrimitivePipeline":430,"../ThirdParty/when":596,"./createTaskProcessorWorker":678}],"zZg0VZ":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), PolygonGeometry = require('../Core/PolygonGeometry');
'use strict';
function createPolygonGeometry(polygonGeometry, offset) {
    if (defined(offset)) {
        polygonGeometry = PolygonGeometry.unpack(polygonGeometry, offset);
    }
    polygonGeometry._ellipsoid = Ellipsoid.clone(polygonGeometry._ellipsoid);
    return PolygonGeometry.createGeometry(polygonGeometry);
}
module.exports = createPolygonGeometry;
},{"../Core/Ellipsoid":130,"../Core/PolygonGeometry":183,"../Core/defined":245}],"Workers/createPolygonGeometry":[function(require,module,exports){
module.exports=require('zZg0VZ');
},{}],"Workers/createPolygonOutlineGeometry":[function(require,module,exports){
module.exports=require('/l4rvw');
},{}],"/l4rvw":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), PolygonOutlineGeometry = require('../Core/PolygonOutlineGeometry');
'use strict';
function createPolygonOutlineGeometry(polygonGeometry, offset) {
    if (defined(offset)) {
        polygonGeometry = PolygonOutlineGeometry.unpack(polygonGeometry, offset);
    }
    polygonGeometry._ellipsoid = Ellipsoid.clone(polygonGeometry._ellipsoid);
    return PolygonOutlineGeometry.createGeometry(polygonGeometry);
}
module.exports = createPolygonOutlineGeometry;
},{"../Core/Ellipsoid":130,"../Core/PolygonOutlineGeometry":186,"../Core/defined":245}],"Workers/createPolylineGeometry":[function(require,module,exports){
module.exports=require('Ag5lVE');
},{}],"Ag5lVE":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), PolylineGeometry = require('../Core/PolylineGeometry');
'use strict';
function createPolylineGeometry(polylineGeometry, offset) {
    if (defined(offset)) {
        polylineGeometry = PolylineGeometry.unpack(polylineGeometry, offset);
    }
    polylineGeometry._ellipsoid = Ellipsoid.clone(polylineGeometry._ellipsoid);
    return PolylineGeometry.createGeometry(polylineGeometry);
}
module.exports = createPolylineGeometry;
},{"../Core/Ellipsoid":130,"../Core/PolylineGeometry":188,"../Core/defined":245}],"7uyJDd":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), PolylineVolumeGeometry = require('../Core/PolylineVolumeGeometry');
'use strict';
function createPolylineVolumeGeometry(polylineVolumeGeometry, offset) {
    if (defined(offset)) {
        polylineVolumeGeometry = PolylineVolumeGeometry.unpack(polylineVolumeGeometry, offset);
    }
    polylineVolumeGeometry._ellipsoid = Ellipsoid.clone(polylineVolumeGeometry._ellipsoid);
    return PolylineVolumeGeometry.createGeometry(polylineVolumeGeometry);
}
module.exports = createPolylineVolumeGeometry;
},{"../Core/Ellipsoid":130,"../Core/PolylineVolumeGeometry":190,"../Core/defined":245}],"Workers/createPolylineVolumeGeometry":[function(require,module,exports){
module.exports=require('7uyJDd');
},{}],"YyTftC":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), PolylineVolumeOutlineGeometry = require('../Core/PolylineVolumeOutlineGeometry');
'use strict';
function createPolylineVolumeOutlineGeometry(polylineVolumeOutlineGeometry, offset) {
    if (defined(offset)) {
        polylineVolumeOutlineGeometry = PolylineVolumeOutlineGeometry.unpack(polylineVolumeOutlineGeometry, offset);
    }
    polylineVolumeOutlineGeometry._ellipsoid = Ellipsoid.clone(polylineVolumeOutlineGeometry._ellipsoid);
    return PolylineVolumeOutlineGeometry.createGeometry(polylineVolumeOutlineGeometry);
}
module.exports = createPolylineVolumeOutlineGeometry;
},{"../Core/Ellipsoid":130,"../Core/PolylineVolumeOutlineGeometry":192,"../Core/defined":245}],"Workers/createPolylineVolumeOutlineGeometry":[function(require,module,exports){
module.exports=require('YyTftC');
},{}],"Workers/createRectangleGeometry":[function(require,module,exports){
module.exports=require('C7/XtK');
},{}],"C7/XtK":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), Rectangle = require('../Core/Rectangle'), RectangleGeometry = require('../Core/RectangleGeometry');
'use strict';
function createRectangleGeometry(rectangleGeometry, offset) {
    if (defined(offset)) {
        rectangleGeometry = RectangleGeometry.unpack(rectangleGeometry, offset);
    }
    rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);
    rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);
    return RectangleGeometry.createGeometry(rectangleGeometry);
}
module.exports = createRectangleGeometry;
},{"../Core/Ellipsoid":130,"../Core/Rectangle":201,"../Core/RectangleGeometry":202,"../Core/defined":245}],"Z/0oaq":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), Rectangle = require('../Core/Rectangle'), RectangleOutlineGeometry = require('../Core/RectangleOutlineGeometry');
'use strict';
function createRectangleOutlineGeometry(rectangleGeometry, offset) {
    if (defined(offset)) {
        rectangleGeometry = RectangleOutlineGeometry.unpack(rectangleGeometry, offset);
    }
    rectangleGeometry._ellipsoid = Ellipsoid.clone(rectangleGeometry._ellipsoid);
    rectangleGeometry._rectangle = Rectangle.clone(rectangleGeometry._rectangle);
    return RectangleOutlineGeometry.createGeometry(rectangleGeometry);
}
module.exports = createRectangleOutlineGeometry;
},{"../Core/Ellipsoid":130,"../Core/Rectangle":201,"../Core/RectangleOutlineGeometry":204,"../Core/defined":245}],"Workers/createRectangleOutlineGeometry":[function(require,module,exports){
module.exports=require('Z/0oaq');
},{}],"UTbVRy":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), SimplePolylineGeometry = require('../Core/SimplePolylineGeometry');
'use strict';
function createSimplePolylineGeometry(simplePolylineGeometry, offset) {
    if (defined(offset)) {
        simplePolylineGeometry = SimplePolylineGeometry.unpack(simplePolylineGeometry, offset);
    }
    simplePolylineGeometry._ellipsoid = Ellipsoid.clone(simplePolylineGeometry._ellipsoid);
    return SimplePolylineGeometry.createGeometry(simplePolylineGeometry);
}
module.exports = createSimplePolylineGeometry;
},{"../Core/Ellipsoid":130,"../Core/SimplePolylineGeometry":212,"../Core/defined":245}],"Workers/createSimplePolylineGeometry":[function(require,module,exports){
module.exports=require('UTbVRy');
},{}],"hxOWOT":[function(require,module,exports){
var defined = require('../Core/defined'), SphereGeometry = require('../Core/SphereGeometry');
'use strict';
module.exports = function (sphereGeometry, offset) {
    if (defined(offset)) {
        sphereGeometry = SphereGeometry.unpack(sphereGeometry, offset);
    }
    return SphereGeometry.createGeometry(sphereGeometry);
};
},{"../Core/SphereGeometry":213,"../Core/defined":245}],"Workers/createSphereGeometry":[function(require,module,exports){
module.exports=require('hxOWOT');
},{}],"AcWMKa":[function(require,module,exports){
var defined = require('../Core/defined'), SphereOutlineGeometry = require('../Core/SphereOutlineGeometry');
'use strict';
module.exports = function (sphereGeometry, offset) {
    if (defined(offset)) {
        sphereGeometry = SphereOutlineGeometry.unpack(sphereGeometry, offset);
    }
    return SphereOutlineGeometry.createGeometry(sphereGeometry);
};
},{"../Core/SphereOutlineGeometry":214,"../Core/defined":245}],"Workers/createSphereOutlineGeometry":[function(require,module,exports){
module.exports=require('AcWMKa');
},{}],678:[function(require,module,exports){
var defaultValue = require('../Core/defaultValue'), defined = require('../Core/defined'), formatError = require('../Core/formatError');
'use strict';
var createTaskProcessorWorker = function (workerFunction) {
    var postMessage;
    var transferableObjects = [];
    var responseMessage = {
            id: undefined,
            result: undefined,
            error: undefined
        };
    return function (event) {
        var data = event.data;
        transferableObjects.length = 0;
        responseMessage.id = data.id;
        responseMessage.error = undefined;
        responseMessage.result = undefined;
        try {
            responseMessage.result = workerFunction(data.parameters, transferableObjects);
        } catch (e) {
            if (e instanceof Error) {
                responseMessage.error = {
                    name: e.name,
                    message: e.message,
                    stack: e.stack
                };
            } else {
                responseMessage.error = e;
            }
        }
        if (!defined(postMessage)) {
            postMessage = defaultValue(self.webkitPostMessage, self.postMessage);
        }
        if (!data.canTransferArrayBuffer) {
            transferableObjects.length = 0;
        }
        try {
            postMessage(responseMessage, transferableObjects);
        } catch (e) {
            responseMessage.result = undefined;
            responseMessage.error = 'postMessage failed with error: ' + formatError(e) + '\n  with responseMessage: ' + JSON.stringify(responseMessage);
            postMessage(responseMessage);
        }
    };
};
module.exports = createTaskProcessorWorker;
},{"../Core/defaultValue":243,"../Core/defined":245,"../Core/formatError":248}],"wqjcpF":[function(require,module,exports){
var BoundingSphere = require('../Core/BoundingSphere'), Ellipsoid = require('../Core/Ellipsoid'), EllipsoidalOccluder = require('../Core/EllipsoidalOccluder'), HeightmapTessellator = require('../Core/HeightmapTessellator'), Rectangle = require('../Core/Rectangle'), createTaskProcessorWorker = require('./createTaskProcessorWorker');
'use strict';
function createVerticesFromHeightmap(parameters, transferableObjects) {
    var numberOfAttributes = 6;
    var arrayWidth = parameters.width;
    var arrayHeight = parameters.height;
    if (parameters.skirtHeight > 0) {
        arrayWidth += 2;
        arrayHeight += 2;
    }
    var vertices = new Float32Array(arrayWidth * arrayHeight * numberOfAttributes);
    transferableObjects.push(vertices.buffer);
    parameters.ellipsoid = Ellipsoid.clone(parameters.ellipsoid);
    parameters.rectangle = Rectangle.clone(parameters.rectangle);
    parameters.vertices = vertices;
    var statistics = HeightmapTessellator.computeVertices(parameters);
    var boundingSphere3D = BoundingSphere.fromVertices(vertices, parameters.relativeToCenter, numberOfAttributes);
    var ellipsoid = parameters.ellipsoid;
    var occluder = new EllipsoidalOccluder(ellipsoid);
    var occludeePointInScaledSpace = occluder.computeHorizonCullingPointFromVertices(parameters.relativeToCenter, vertices, numberOfAttributes, parameters.relativeToCenter);
    return {
        vertices: vertices.buffer,
        numberOfAttributes: numberOfAttributes,
        minimumHeight: statistics.minimumHeight,
        maximumHeight: statistics.maximumHeight,
        gridWidth: arrayWidth,
        gridHeight: arrayHeight,
        boundingSphere3D: boundingSphere3D,
        occludeePointInScaledSpace: occludeePointInScaledSpace
    };
}
module.exports = createTaskProcessorWorker(createVerticesFromHeightmap);
},{"../Core/BoundingSphere":98,"../Core/Ellipsoid":130,"../Core/EllipsoidalOccluder":136,"../Core/HeightmapTessellator":154,"../Core/Rectangle":201,"./createTaskProcessorWorker":678}],"Workers/createVerticesFromHeightmap":[function(require,module,exports){
module.exports=require('wqjcpF');
},{}],"Workers/createVerticesFromQuantizedTerrainMesh":[function(require,module,exports){
module.exports=require('2YNTXy');
},{}],"2YNTXy":[function(require,module,exports){
var AttributeCompression = require('../Core/AttributeCompression'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartographic = require('../Core/Cartographic'), defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), IndexDatatype = require('../Core/IndexDatatype'), CesiumMath = require('../Core/Math'), createTaskProcessorWorker = require('./createTaskProcessorWorker');
'use strict';
var maxShort = 32767;
var xIndex = 0;
var yIndex = 1;
var zIndex = 2;
var hIndex = 3;
var uIndex = 4;
var vIndex = 5;
var nIndex = 6;
var cartesian3Scratch = new Cartesian3();
var cartographicScratch = new Cartographic();
var toPack = new Cartesian2();
function createVerticesFromQuantizedTerrainMesh(parameters, transferableObjects) {
    var quantizedVertices = parameters.quantizedVertices;
    var quantizedVertexCount = quantizedVertices.length / 3;
    var octEncodedNormals = parameters.octEncodedNormals;
    var edgeVertexCount = parameters.westIndices.length + parameters.eastIndices.length + parameters.southIndices.length + parameters.northIndices.length;
    var minimumHeight = parameters.minimumHeight;
    var maximumHeight = parameters.maximumHeight;
    var center = parameters.relativeToCenter;
    var rectangle = parameters.rectangle;
    var west = rectangle.west;
    var south = rectangle.south;
    var east = rectangle.east;
    var north = rectangle.north;
    var ellipsoid = Ellipsoid.clone(parameters.ellipsoid);
    var uBuffer = quantizedVertices.subarray(0, quantizedVertexCount);
    var vBuffer = quantizedVertices.subarray(quantizedVertexCount, 2 * quantizedVertexCount);
    var heightBuffer = quantizedVertices.subarray(quantizedVertexCount * 2, 3 * quantizedVertexCount);
    var hasVertexNormals = defined(octEncodedNormals);
    var vertexStride = 6;
    if (hasVertexNormals) {
        vertexStride += 1;
    }
    var vertexBuffer = new Float32Array(quantizedVertexCount * vertexStride + edgeVertexCount * vertexStride);
    for (var i = 0, bufferIndex = 0, n = 0; i < quantizedVertexCount; ++i, bufferIndex += vertexStride, n += 2) {
        var u = uBuffer[i] / maxShort;
        var v = vBuffer[i] / maxShort;
        var height = CesiumMath.lerp(minimumHeight, maximumHeight, heightBuffer[i] / maxShort);
        cartographicScratch.longitude = CesiumMath.lerp(west, east, u);
        cartographicScratch.latitude = CesiumMath.lerp(south, north, v);
        cartographicScratch.height = height;
        ellipsoid.cartographicToCartesian(cartographicScratch, cartesian3Scratch);
        vertexBuffer[bufferIndex + xIndex] = cartesian3Scratch.x - center.x;
        vertexBuffer[bufferIndex + yIndex] = cartesian3Scratch.y - center.y;
        vertexBuffer[bufferIndex + zIndex] = cartesian3Scratch.z - center.z;
        vertexBuffer[bufferIndex + hIndex] = height;
        vertexBuffer[bufferIndex + uIndex] = u;
        vertexBuffer[bufferIndex + vIndex] = v;
        if (hasVertexNormals) {
            toPack.x = octEncodedNormals[n];
            toPack.y = octEncodedNormals[n + 1];
            vertexBuffer[bufferIndex + nIndex] = AttributeCompression.octPackFloat(toPack);
        }
    }
    var edgeTriangleCount = Math.max(0, (edgeVertexCount - 4) * 2);
    var indexBufferLength = parameters.indices.length + edgeTriangleCount * 3;
    var indexBuffer = IndexDatatype.createTypedArray(quantizedVertexCount + edgeVertexCount, indexBufferLength);
    indexBuffer.set(parameters.indices, 0);
    var vertexBufferIndex = quantizedVertexCount * vertexStride;
    var indexBufferIndex = parameters.indices.length;
    indexBufferIndex = addSkirt(vertexBuffer, vertexBufferIndex, indexBuffer, indexBufferIndex, parameters.westIndices, center, ellipsoid, rectangle, parameters.westSkirtHeight, true, hasVertexNormals);
    vertexBufferIndex += parameters.westIndices.length * vertexStride;
    indexBufferIndex = addSkirt(vertexBuffer, vertexBufferIndex, indexBuffer, indexBufferIndex, parameters.southIndices, center, ellipsoid, rectangle, parameters.southSkirtHeight, false, hasVertexNormals);
    vertexBufferIndex += parameters.southIndices.length * vertexStride;
    indexBufferIndex = addSkirt(vertexBuffer, vertexBufferIndex, indexBuffer, indexBufferIndex, parameters.eastIndices, center, ellipsoid, rectangle, parameters.eastSkirtHeight, false, hasVertexNormals);
    vertexBufferIndex += parameters.eastIndices.length * vertexStride;
    indexBufferIndex = addSkirt(vertexBuffer, vertexBufferIndex, indexBuffer, indexBufferIndex, parameters.northIndices, center, ellipsoid, rectangle, parameters.northSkirtHeight, true, hasVertexNormals);
    vertexBufferIndex += parameters.northIndices.length * vertexStride;
    transferableObjects.push(vertexBuffer.buffer, indexBuffer.buffer);
    return {
        vertices: vertexBuffer.buffer,
        indices: indexBuffer.buffer
    };
}
function addSkirt(vertexBuffer, vertexBufferIndex, indexBuffer, indexBufferIndex, edgeVertices, center, ellipsoid, rectangle, skirtLength, isWestOrNorthEdge, hasVertexNormals) {
    var start, end, increment;
    var vertexStride = 6;
    if (hasVertexNormals) {
        vertexStride += 1;
    }
    if (isWestOrNorthEdge) {
        start = edgeVertices.length - 1;
        end = -1;
        increment = -1;
    } else {
        start = 0;
        end = edgeVertices.length;
        increment = 1;
    }
    var previousIndex = -1;
    var vertexIndex = vertexBufferIndex / vertexStride;
    var north = rectangle.north;
    var south = rectangle.south;
    var east = rectangle.east;
    var west = rectangle.west;
    if (east < west) {
        east += CesiumMath.TWO_PI;
    }
    for (var i = start; i !== end; i += increment) {
        var index = edgeVertices[i];
        var offset = index * vertexStride;
        var u = vertexBuffer[offset + uIndex];
        var v = vertexBuffer[offset + vIndex];
        var h = vertexBuffer[offset + hIndex];
        cartographicScratch.longitude = CesiumMath.lerp(west, east, u);
        cartographicScratch.latitude = CesiumMath.lerp(south, north, v);
        cartographicScratch.height = h - skirtLength;
        var position = ellipsoid.cartographicToCartesian(cartographicScratch, cartesian3Scratch);
        Cartesian3.subtract(position, center, position);
        vertexBuffer[vertexBufferIndex++] = position.x;
        vertexBuffer[vertexBufferIndex++] = position.y;
        vertexBuffer[vertexBufferIndex++] = position.z;
        vertexBuffer[vertexBufferIndex++] = cartographicScratch.height;
        vertexBuffer[vertexBufferIndex++] = u;
        vertexBuffer[vertexBufferIndex++] = v;
        if (hasVertexNormals) {
            vertexBuffer[vertexBufferIndex++] = vertexBuffer[offset + nIndex];
        }
        if (previousIndex !== -1) {
            indexBuffer[indexBufferIndex++] = previousIndex;
            indexBuffer[indexBufferIndex++] = vertexIndex - 1;
            indexBuffer[indexBufferIndex++] = index;
            indexBuffer[indexBufferIndex++] = vertexIndex - 1;
            indexBuffer[indexBufferIndex++] = vertexIndex;
            indexBuffer[indexBufferIndex++] = index;
        }
        previousIndex = index;
        ++vertexIndex;
    }
    return indexBufferIndex;
}
module.exports = createTaskProcessorWorker(createVerticesFromQuantizedTerrainMesh);
},{"../Core/AttributeCompression":94,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartographic":104,"../Core/Ellipsoid":130,"../Core/IndexDatatype":162,"../Core/Math":174,"../Core/defined":245,"./createTaskProcessorWorker":678}],"Workers/createWallGeometry":[function(require,module,exports){
module.exports=require('Zjp28a');
},{}],"Zjp28a":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), WallGeometry = require('../Core/WallGeometry');
'use strict';
function createWallGeometry(wallGeometry, offset) {
    if (defined(offset)) {
        wallGeometry = WallGeometry.unpack(wallGeometry, offset);
    }
    wallGeometry._ellipsoid = Ellipsoid.clone(wallGeometry._ellipsoid);
    return WallGeometry.createGeometry(wallGeometry);
}
module.exports = createWallGeometry;
},{"../Core/Ellipsoid":130,"../Core/WallGeometry":230,"../Core/defined":245}],"Kx32F/":[function(require,module,exports){
var defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), WallOutlineGeometry = require('../Core/WallOutlineGeometry');
'use strict';
function createWallOutlineGeometry(wallGeometry, offset) {
    if (defined(offset)) {
        wallGeometry = WallOutlineGeometry.unpack(wallGeometry, offset);
    }
    wallGeometry._ellipsoid = Ellipsoid.clone(wallGeometry._ellipsoid);
    return WallOutlineGeometry.createGeometry(wallGeometry);
}
module.exports = createWallOutlineGeometry;
},{"../Core/Ellipsoid":130,"../Core/WallOutlineGeometry":232,"../Core/defined":245}],"Workers/createWallOutlineGeometry":[function(require,module,exports){
module.exports=require('Kx32F/');
},{}],"Workers/sanitizeHtml":[function(require,module,exports){
module.exports=require('llTr0M');
},{}],"llTr0M":[function(require,module,exports){
var defined = require('../Core/defined'), RuntimeError = require('../Core/RuntimeError'), createTaskProcessorWorker = require('./createTaskProcessorWorker');
'use strict';
var cajaScript = 'https://caja.appspot.com/html-css-sanitizer-minified.js';
var html_sanitize;
var sanitizeHtml = function (html) {
    if (!defined(html_sanitize)) {
        self.window = {};
        importScripts(cajaScript);
        html_sanitize = window.html_sanitize;
        if (!defined(html_sanitize)) {
            throw new RuntimeError('Unable to load Google Caja sanitizer script.');
        }
    }
    return html_sanitize(html);
};
module.exports = createTaskProcessorWorker(sanitizeHtml);
},{"../Core/RuntimeError":207,"../Core/defined":245,"./createTaskProcessorWorker":678}],"Workers/upsampleQuantizedTerrainMesh":[function(require,module,exports){
module.exports=require('Ig0JhT');
},{}],"Ig0JhT":[function(require,module,exports){
var AttributeCompression = require('../Core/AttributeCompression'), BoundingSphere = require('../Core/BoundingSphere'), Cartesian2 = require('../Core/Cartesian2'), Cartesian3 = require('../Core/Cartesian3'), Cartographic = require('../Core/Cartographic'), defined = require('../Core/defined'), Ellipsoid = require('../Core/Ellipsoid'), EllipsoidalOccluder = require('../Core/EllipsoidalOccluder'), IndexDatatype = require('../Core/IndexDatatype'), Intersections2D = require('../Core/Intersections2D'), CesiumMath = require('../Core/Math'), createTaskProcessorWorker = require('./createTaskProcessorWorker');
'use strict';
var maxShort = 32767;
var halfMaxShort = maxShort / 2 | 0;
var clipScratch = [];
var clipScratch2 = [];
var verticesScratch = [];
var cartographicScratch = new Cartographic();
var cartesian3Scratch = new Cartesian3();
var uScratch = [];
var vScratch = [];
var heightScratch = [];
var indicesScratch = [];
var normalsScratch = [];
var horizonOcclusionPointScratch = new Cartesian3();
var boundingSphereScratch = new BoundingSphere();
function upsampleQuantizedTerrainMesh(parameters, transferableObjects) {
    var isEastChild = parameters.isEastChild;
    var isNorthChild = parameters.isNorthChild;
    var minU = isEastChild ? halfMaxShort : 0;
    var maxU = isEastChild ? maxShort : halfMaxShort;
    var minV = isNorthChild ? halfMaxShort : 0;
    var maxV = isNorthChild ? maxShort : halfMaxShort;
    var uBuffer = uScratch;
    var vBuffer = vScratch;
    var heightBuffer = heightScratch;
    var normalBuffer = normalsScratch;
    uBuffer.length = 0;
    vBuffer.length = 0;
    heightBuffer.length = 0;
    normalBuffer.length = 0;
    var indices = indicesScratch;
    indices.length = 0;
    var vertexMap = {};
    var parentVertices = parameters.vertices;
    var parentNormalBuffer = parameters.encodedNormals;
    var parentIndices = parameters.indices;
    var quantizedVertexCount = parentVertices.length / 3;
    var parentUBuffer = parentVertices.subarray(0, quantizedVertexCount);
    var parentVBuffer = parentVertices.subarray(quantizedVertexCount, 2 * quantizedVertexCount);
    var parentHeightBuffer = parentVertices.subarray(quantizedVertexCount * 2, 3 * quantizedVertexCount);
    var vertexCount = 0;
    var hasVertexNormals = defined(parentNormalBuffer);
    var i, n, u, v;
    for (i = 0, n = 0; i < quantizedVertexCount; ++i, n += 2) {
        u = parentUBuffer[i];
        v = parentVBuffer[i];
        if ((isEastChild && u >= halfMaxShort || !isEastChild && u <= halfMaxShort) && (isNorthChild && v >= halfMaxShort || !isNorthChild && v <= halfMaxShort)) {
            vertexMap[i] = vertexCount;
            uBuffer.push(u);
            vBuffer.push(v);
            heightBuffer.push(parentHeightBuffer[i]);
            if (hasVertexNormals) {
                normalBuffer.push(parentNormalBuffer[n]);
                normalBuffer.push(parentNormalBuffer[n + 1]);
            }
            ++vertexCount;
        }
    }
    var triangleVertices = [];
    triangleVertices.push(new Vertex());
    triangleVertices.push(new Vertex());
    triangleVertices.push(new Vertex());
    var clippedTriangleVertices = [];
    clippedTriangleVertices.push(new Vertex());
    clippedTriangleVertices.push(new Vertex());
    clippedTriangleVertices.push(new Vertex());
    var clippedIndex;
    var clipped2;
    for (i = 0; i < parentIndices.length; i += 3) {
        var i0 = parentIndices[i];
        var i1 = parentIndices[i + 1];
        var i2 = parentIndices[i + 2];
        var u0 = parentUBuffer[i0];
        var u1 = parentUBuffer[i1];
        var u2 = parentUBuffer[i2];
        triangleVertices[0].initializeIndexed(parentUBuffer, parentVBuffer, parentHeightBuffer, parentNormalBuffer, i0);
        triangleVertices[1].initializeIndexed(parentUBuffer, parentVBuffer, parentHeightBuffer, parentNormalBuffer, i1);
        triangleVertices[2].initializeIndexed(parentUBuffer, parentVBuffer, parentHeightBuffer, parentNormalBuffer, i2);
        var clipped = Intersections2D.clipTriangleAtAxisAlignedThreshold(halfMaxShort, isEastChild, u0, u1, u2, clipScratch);
        clippedIndex = 0;
        if (clippedIndex >= clipped.length) {
            continue;
        }
        clippedIndex = clippedTriangleVertices[0].initializeFromClipResult(clipped, clippedIndex, triangleVertices);
        if (clippedIndex >= clipped.length) {
            continue;
        }
        clippedIndex = clippedTriangleVertices[1].initializeFromClipResult(clipped, clippedIndex, triangleVertices);
        if (clippedIndex >= clipped.length) {
            continue;
        }
        clippedIndex = clippedTriangleVertices[2].initializeFromClipResult(clipped, clippedIndex, triangleVertices);
        clipped2 = Intersections2D.clipTriangleAtAxisAlignedThreshold(halfMaxShort, isNorthChild, clippedTriangleVertices[0].getV(), clippedTriangleVertices[1].getV(), clippedTriangleVertices[2].getV(), clipScratch2);
        addClippedPolygon(uBuffer, vBuffer, heightBuffer, normalBuffer, indices, vertexMap, clipped2, clippedTriangleVertices, hasVertexNormals);
        if (clippedIndex < clipped.length) {
            clippedTriangleVertices[2].clone(clippedTriangleVertices[1]);
            clippedTriangleVertices[2].initializeFromClipResult(clipped, clippedIndex, triangleVertices);
            clipped2 = Intersections2D.clipTriangleAtAxisAlignedThreshold(halfMaxShort, isNorthChild, clippedTriangleVertices[0].getV(), clippedTriangleVertices[1].getV(), clippedTriangleVertices[2].getV(), clipScratch2);
            addClippedPolygon(uBuffer, vBuffer, heightBuffer, normalBuffer, indices, vertexMap, clipped2, clippedTriangleVertices, hasVertexNormals);
        }
    }
    var uOffset = isEastChild ? -maxShort : 0;
    var vOffset = isNorthChild ? -maxShort : 0;
    var parentMinimumHeight = parameters.minimumHeight;
    var parentMaximumHeight = parameters.maximumHeight;
    var westIndices = [];
    var southIndices = [];
    var eastIndices = [];
    var northIndices = [];
    var minimumHeight = Number.MAX_VALUE;
    var maximumHeight = -minimumHeight;
    var cartesianVertices = verticesScratch;
    cartesianVertices.length = 0;
    var ellipsoid = Ellipsoid.clone(parameters.ellipsoid);
    var rectangle = parameters.childRectangle;
    var north = rectangle.north;
    var south = rectangle.south;
    var east = rectangle.east;
    var west = rectangle.west;
    if (east < west) {
        east += CesiumMath.TWO_PI;
    }
    for (i = 0; i < uBuffer.length; ++i) {
        u = Math.round(uBuffer[i]);
        if (u <= minU) {
            westIndices.push(i);
            u = 0;
        } else if (u >= maxU) {
            eastIndices.push(i);
            u = maxShort;
        } else {
            u = u * 2 + uOffset;
        }
        uBuffer[i] = u;
        v = Math.round(vBuffer[i]);
        if (v <= minV) {
            southIndices.push(i);
            v = 0;
        } else if (v >= maxV) {
            northIndices.push(i);
            v = maxShort;
        } else {
            v = v * 2 + vOffset;
        }
        vBuffer[i] = v;
        var height = CesiumMath.lerp(parentMinimumHeight, parentMaximumHeight, heightBuffer[i] / maxShort);
        if (height < minimumHeight) {
            minimumHeight = height;
        }
        if (height > maximumHeight) {
            maximumHeight = height;
        }
        heightBuffer[i] = height;
        cartographicScratch.longitude = CesiumMath.lerp(west, east, u / maxShort);
        cartographicScratch.latitude = CesiumMath.lerp(south, north, v / maxShort);
        cartographicScratch.height = height;
        ellipsoid.cartographicToCartesian(cartographicScratch, cartesian3Scratch);
        cartesianVertices.push(cartesian3Scratch.x);
        cartesianVertices.push(cartesian3Scratch.y);
        cartesianVertices.push(cartesian3Scratch.z);
    }
    var boundingSphere = BoundingSphere.fromVertices(cartesianVertices, Cartesian3.ZERO, 3, boundingSphereScratch);
    var occluder = new EllipsoidalOccluder(ellipsoid);
    var horizonOcclusionPoint = occluder.computeHorizonCullingPointFromVertices(boundingSphere.center, cartesianVertices, 3, boundingSphere.center, horizonOcclusionPointScratch);
    var heightRange = maximumHeight - minimumHeight;
    var vertices = new Uint16Array(uBuffer.length + vBuffer.length + heightBuffer.length);
    for (i = 0; i < uBuffer.length; ++i) {
        vertices[i] = uBuffer[i];
    }
    var start = uBuffer.length;
    for (i = 0; i < vBuffer.length; ++i) {
        vertices[start + i] = vBuffer[i];
    }
    start += vBuffer.length;
    for (i = 0; i < heightBuffer.length; ++i) {
        vertices[start + i] = maxShort * (heightBuffer[i] - minimumHeight) / heightRange;
    }
    var indicesTypedArray = IndexDatatype.createTypedArray(uBuffer.length, indices);
    var encodedNormals;
    if (hasVertexNormals) {
        var normalArray = new Uint8Array(normalBuffer);
        transferableObjects.push(vertices.buffer, indicesTypedArray.buffer, normalArray.buffer);
        encodedNormals = normalArray.buffer;
    } else {
        transferableObjects.push(vertices.buffer, indicesTypedArray.buffer);
    }
    return {
        vertices: vertices.buffer,
        encodedNormals: encodedNormals,
        indices: indicesTypedArray.buffer,
        minimumHeight: minimumHeight,
        maximumHeight: maximumHeight,
        westIndices: westIndices,
        southIndices: southIndices,
        eastIndices: eastIndices,
        northIndices: northIndices,
        boundingSphere: boundingSphere,
        horizonOcclusionPoint: horizonOcclusionPoint
    };
}
function Vertex() {
    this.vertexBuffer = undefined;
    this.index = undefined;
    this.first = undefined;
    this.second = undefined;
    this.ratio = undefined;
}
Vertex.prototype.clone = function (result) {
    if (!defined(result)) {
        result = new Vertex();
    }
    result.uBuffer = this.uBuffer;
    result.vBuffer = this.vBuffer;
    result.heightBuffer = this.heightBuffer;
    result.normalBuffer = this.normalBuffer;
    result.index = this.index;
    result.first = this.first;
    result.second = this.second;
    result.ratio = this.ratio;
    return result;
};
Vertex.prototype.initializeIndexed = function (uBuffer, vBuffer, heightBuffer, normalBuffer, index) {
    this.uBuffer = uBuffer;
    this.vBuffer = vBuffer;
    this.heightBuffer = heightBuffer;
    this.normalBuffer = normalBuffer;
    this.index = index;
    this.first = undefined;
    this.second = undefined;
    this.ratio = undefined;
};
Vertex.prototype.initializeInterpolated = function (first, second, ratio) {
    this.vertexBuffer = undefined;
    this.index = undefined;
    this.newIndex = undefined;
    this.first = first;
    this.second = second;
    this.ratio = ratio;
};
Vertex.prototype.initializeFromClipResult = function (clipResult, index, vertices) {
    var nextIndex = index + 1;
    if (clipResult[index] !== -1) {
        vertices[clipResult[index]].clone(this);
    } else {
        this.vertexBuffer = undefined;
        this.index = undefined;
        this.first = vertices[clipResult[nextIndex]];
        ++nextIndex;
        this.second = vertices[clipResult[nextIndex]];
        ++nextIndex;
        this.ratio = clipResult[nextIndex];
        ++nextIndex;
    }
    return nextIndex;
};
Vertex.prototype.getKey = function () {
    if (this.isIndexed()) {
        return this.index;
    }
    return JSON.stringify({
        first: this.first.getKey(),
        second: this.second.getKey(),
        ratio: this.ratio
    });
};
Vertex.prototype.isIndexed = function () {
    return defined(this.index);
};
Vertex.prototype.getH = function () {
    if (defined(this.index)) {
        return this.heightBuffer[this.index];
    }
    return CesiumMath.lerp(this.first.getH(), this.second.getH(), this.ratio);
};
Vertex.prototype.getU = function () {
    if (defined(this.index)) {
        return this.uBuffer[this.index];
    }
    return CesiumMath.lerp(this.first.getU(), this.second.getU(), this.ratio);
};
Vertex.prototype.getV = function () {
    if (defined(this.index)) {
        return this.vBuffer[this.index];
    }
    return CesiumMath.lerp(this.first.getV(), this.second.getV(), this.ratio);
};
var encodedScratch = new Cartesian2();
var depth = -1;
var cartesianScratch1 = [
        new Cartesian3(),
        new Cartesian3()
    ];
var cartesianScratch2 = [
        new Cartesian3(),
        new Cartesian3()
    ];
function lerpOctEncodedNormal(vertex, result) {
    ++depth;
    var first = cartesianScratch1[depth];
    var second = cartesianScratch2[depth];
    first = AttributeCompression.octDecode(vertex.first.getNormalX(), vertex.first.getNormalY(), first);
    second = AttributeCompression.octDecode(vertex.second.getNormalX(), vertex.second.getNormalY(), second);
    cartesian3Scratch = Cartesian3.lerp(first, second, vertex.ratio, cartesian3Scratch);
    Cartesian3.normalize(cartesian3Scratch, cartesian3Scratch);
    AttributeCompression.octEncode(cartesian3Scratch, result);
    --depth;
    return result;
}
Vertex.prototype.getNormalX = function () {
    if (defined(this.index)) {
        return this.normalBuffer[this.index * 2];
    }
    encodedScratch = lerpOctEncodedNormal(this, encodedScratch);
    return encodedScratch.x;
};
Vertex.prototype.getNormalY = function () {
    if (defined(this.index)) {
        return this.normalBuffer[this.index * 2 + 1];
    }
    encodedScratch = lerpOctEncodedNormal(this, encodedScratch);
    return encodedScratch.y;
};
var polygonVertices = [];
polygonVertices.push(new Vertex());
polygonVertices.push(new Vertex());
polygonVertices.push(new Vertex());
polygonVertices.push(new Vertex());
function addClippedPolygon(uBuffer, vBuffer, heightBuffer, normalBuffer, indices, vertexMap, clipped, triangleVertices, hasVertexNormals) {
    if (clipped.length === 0) {
        return;
    }
    var numVertices = 0;
    var clippedIndex = 0;
    while (clippedIndex < clipped.length) {
        clippedIndex = polygonVertices[numVertices++].initializeFromClipResult(clipped, clippedIndex, triangleVertices);
    }
    for (var i = 0; i < numVertices; ++i) {
        var polygonVertex = polygonVertices[i];
        if (!polygonVertex.isIndexed()) {
            var key = polygonVertex.getKey();
            if (defined(vertexMap[key])) {
                polygonVertex.newIndex = vertexMap[key];
            } else {
                var newIndex = uBuffer.length;
                uBuffer.push(polygonVertex.getU());
                vBuffer.push(polygonVertex.getV());
                heightBuffer.push(polygonVertex.getH());
                if (hasVertexNormals) {
                    normalBuffer.push(polygonVertex.getNormalX());
                    normalBuffer.push(polygonVertex.getNormalY());
                }
                polygonVertex.newIndex = newIndex;
                vertexMap[key] = newIndex;
            }
        } else {
            polygonVertex.newIndex = vertexMap[polygonVertex.index];
            polygonVertex.uBuffer = uBuffer;
            polygonVertex.vBuffer = vBuffer;
            polygonVertex.heightBuffer = heightBuffer;
            if (hasVertexNormals) {
                polygonVertex.normalBuffer = normalBuffer;
            }
        }
    }
    if (numVertices === 3) {
        indices.push(polygonVertices[0].newIndex);
        indices.push(polygonVertices[1].newIndex);
        indices.push(polygonVertices[2].newIndex);
    } else if (numVertices === 4) {
        indices.push(polygonVertices[0].newIndex);
        indices.push(polygonVertices[1].newIndex);
        indices.push(polygonVertices[2].newIndex);
        indices.push(polygonVertices[0].newIndex);
        indices.push(polygonVertices[2].newIndex);
        indices.push(polygonVertices[3].newIndex);
    }
}
module.exports = createTaskProcessorWorker(upsampleQuantizedTerrainMesh);
},{"../Core/AttributeCompression":94,"../Core/BoundingSphere":98,"../Core/Cartesian2":101,"../Core/Cartesian3":102,"../Core/Cartographic":104,"../Core/Ellipsoid":130,"../Core/EllipsoidalOccluder":136,"../Core/IndexDatatype":162,"../Core/Intersections2D":165,"../Core/Math":174,"../Core/defined":245,"./createTaskProcessorWorker":678}]},{},[91])


//# sourceMappingURL=ausglobe.js.map